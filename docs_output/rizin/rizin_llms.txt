# Document Index
- [Rizin Framework Overview](https://book.rizin.re/src/introduction/overview.html): This document provides an overview of the Rizin Framework, a comprehensive suite of tools for reverse engineering. It details various command-line utilities including rizin (disassembler, hex editor, debugger), rz-bin (executable parsing), rz-asm (assembler/disassembler), rz-hash (hashing), rz-diff (binary diffing), rz-find (pattern searching), rz-gg (code compilation), rz-run (program execution), and rz-ax (expression evaluator). The document includes examples for each tool's usage.
- [Testing the Rizin Plugin](https://book.rizin.re/src/plugins/testing.html): This document details how to test the 'mycpu' plugin for the Rizin framework, including verifying its loading and demonstrating its assembly and disassembly capabilities with sample code and commands. It shows how to use rz-asm and rizin to load the plugin, write random code, and display the disassembled output.
- [Debugging Plugins in Rizin Framework](https://book.rizin.re/src/plugins/debug.html): This document explains how to debug plugins in the Rizin framework by setting the R_DEBUG=yes environment variable and provides an example of the output, including plugin loading messages and potential errors like module version mismatches.
- [Python Plugins for Rizin Framework](https://book.rizin.re/src/plugins/python.html): This document provides a comprehensive guide on creating Python plugins for the Rizin Framework, covering both assembly and analysis plugins. It details the structure and required functions for each plugin type, with code examples for defining custom architectures and handling binary analysis. Additionally, it explains how to implement format plugins for Rizin, including necessary functions like `load`, `check_bytes`, and `info`, with a specific example for the OS/2 LE/LX format.
- [Writing Rizin Debugger Plugins](https://book.rizin.re/src/plugins/dev-other.html): This document is a guide to writing debugger plugins for the Rizin framework, focusing on adding support for GDB and various architectures. It includes code snippets, commit links for architectural implementations, and an example plugin for the z80 pseudo-architecture.
- [Implementing NES File Format Plugin for Rizin Framework](https://book.rizin.re/src/plugins/dev-bin.html): This document outlines the process of implementing a new file format plugin for the Rizin Framework, specifically focusing on the NES format. It includes the necessary Makefile configurations, C code for parsing and identifying NES files, and provides examples of other format implementations within the Rizin ecosystem.
- [Implementing a Rizin Analysis Plugin](https://book.rizin.re/src/plugins/dev-analysis.html): This document details the process of creating a custom analysis plugin for the Rizin framework, focusing on the structure of the analysis plugin, its key functions like opcode analysis and ESIL uplifting, and provides example C code and a Makefile. It also explains how to compile and integrate these plugins with Rizin for enhanced reverse engineering capabilities.
- [Implementing a Disassembly Plugin for Rizin](https://book.rizin.re/src/plugins/dev-asm.html): This document provides a guide on implementing a new disassembly plugin for the Rizin framework, detailing the process of creating a C file and a meson build file. It covers the structure of an RzAsm plugin, the necessary C code, and modifications required to integrate the plugin into the Rizin source tree, including updates to meson.build and rz_asm.h. The guide also references commits for a NIOS II CPU disassembly plugin as an example.
- [Rizin IO Plugins](https://book.rizin.re/src/plugins/ioplugins.html): This document explains the IO plugins in the Rizin framework, which handle all input and output operations for the tool. It details how these plugins allow Rizin to treat various data sources like files, network connections, and processes uniformly through URIs, offering examples such as debugging, remote sessions, and virtual buffers. The text also lists available IO plugins with their functionalities and protocols.
- [Rz Hash Tool](https://book.rizin.re/src/tools/rz-hash/rz-hash_tool.html): A summary for rz-hash_tool.html.
- [Intro](https://book.rizin.re/src/plugins/intro.html): A summary for intro.html.
- [Rz-hash: A Comprehensive Guide to Hashing and Encoding with Rizin](https://book.rizin.re/src/tools/rz-hash/intro.html): This document details the rz-hash tool, explaining its capabilities for computing checksums of files, disk devices, and strings using various algorithms and block sizes. It also covers its encoding/decoding features, integration with rz-bin for section checksums, and usage within a Rizin session via the 'ph' command. The document lists supported hashing algorithms and provides examples for each use case.
- [RzEgg Language Syntax and Features](https://book.rizin.re/src/tools/rz-gg/lang.html): This document details the syntax and features of the rz_egg language, a one-pass compiler used for creating standalone binaries, position-independent code, and patching binaries. It covers preprocessor directives like aliases, includes, and hashbangs, function definitions and types, syscalls, variable and array handling, tracing, pointers, virtual registers, math operations, return values, traps, inline assembly, labels, control flow, and comments.
- [Rz-gg: Reverse Engineering with the Rizin Framework](https://book.rizin.re/src/tools/rz-gg/rz-gg.html): This document describes rz-gg, a tool for creating relocatable code snippets for process injection and exploit development. It covers rz-gg's functionality, including compiling its own language or C code, supporting multiple architectures (x86, x86-64, ARM), and generating tiny binaries with various output formats like C, PE, ELF, Mach-O, raw, Python, and JavaScript.
- [Assembler in the Rizin Framework](https://book.rizin.re/src/tools/rz-asm/assemble.html): This document explains the assembly functionality within the Rizin framework, covering its command-line tool `rz-asm` and its integration into the Rizin environment via `pa`, `pad`, `wa`, and `wx` commands. It details supported assembly languages like x86, powerpc, and arm, and demonstrates assembling code snippets and files, including a practical example of creating self-stop shellcode for x86. The guide also touches upon visual assembly mode in Rizin.
- [Rizin Handbook: rz-asm Command-Line Tool Guide](https://book.rizin.re/src/tools/rz-asm/intro.html): This document details the `rz-asm` command-line tool, a component of the Rizin framework for reverse engineering. It provides a comprehensive list of command-line options for assembling, disassembling, and analyzing code across various architectures. The document also includes an extensive list of supported plugins for different architectures, indicating whether they support assembly, disassembly, or analysis, along with licensing information.
- [Binary Diffing](https://book.rizin.re/src/tools/rz-diff/binary_diffing.html): A summary for binary_diffing.html.
- [Credits](https://book.rizin.re/src/acknowledgments/credits.html): This document lists the authors and contributors to "The Rizin Handbook: A Guide to Reverse Engineering with the Rizin Framework", acknowledging their roles in reviewing, writing, and bug reporting for both the book and the Rizin project.
- [Rizin Reference Card](https://book.rizin.re/src/refcard/intro.html): This document is a reference card for the Rizin framework, detailing commands for reverse engineering tasks such as navigation, analysis, debugging, and searching within binaries. It covers essential commands for manipulating flags, functions, variables, and strings, as well as visual mode operations and expression variables.
- [Fire up the debugger â€“ The Rizin Handbook](https://book.rizin.re/src/crackmes/hackthebox/find-the-easy-pass/fire-up-the-debugger.html): This document guides users through debugging a program called EasyPass.exe using the Rizin Framework to find the correct password. It details setting breakpoints, running the program, monitoring memory registers like EAX and EDX, and stepping through code execution to identify the password "fortan!". The guide includes several screenshots illustrating the debugger interface and program flow.
- [Find the Validation Routine with Rizin Framework](https://book.rizin.re/src/crackmes/hackthebox/find-the-easy-pass/find-the-validation-routine.html): This document details the process of reverse engineering a program using the Rizin framework to find a validation routine. It guides the user through debugging, analyzing code sections, identifying strings like "Wrong Password!", and visualizing the program's flow using graph views to pinpoint the routine responsible for password validation and success/failure messages.
- [Identification of EasyPass.exe using Rizin](https://book.rizin.re/src/crackmes/hackthebox/find-the-easy-pass/identification.html): This document details the process of identifying an executable file, EasyPass.exe, using the rz-bin tool. It covers initial file identification, execution analysis, and string searching within the executable to locate messages like "Wrong Password!". The guide also highlights differences in string searching commands within the Rizin framework.
- [Bytecode Program for Rizin Framework VM](https://book.rizin.re/src/crackmes/avatao/01-reverse4/bytecode.html): This document outlines the functional specification for a virtual machine program, detailing requirements for return values, memory manipulation, instruction usage, and conditional logic. It provides specific guidance on using the 'J' instruction, including conditions for incrementing a counter (_sym.good_if_ne_zero_) and presents a sample bytecode program for achieving these requirements.
- [Instruction Set for Rizin VM](https://book.rizin.re/src/crackmes/avatao/01-reverse4/instructionset.html): This document details the instruction set for a virtual machine, explaining the function of each instruction and its arguments. It covers operations like memory pointer manipulation, arithmetic, conditional logic, and return values.
- [Vmloop](https://book.rizin.re/src/crackmes/avatao/01-reverse4/vmloop.html): A summary for vmloop.html.
- [Reverse Engineering with Rizin: Analyzing the Main Function](https://book.rizin.re/src/crackmes/avatao/01-reverse4/main.html): This document provides a step-by-step guide to reverse engineering using the Rizin framework. It focuses on analyzing the `main` function, demonstrating how to navigate the code, use visual modes, understand disassembly, and rename variables and functions. Key operations covered include seeking to addresses, analyzing functions, managing flags, declaring data, and interpreting program flow for reverse engineering tasks.
- [First Steps](https://book.rizin.re/src/crackmes/avatao/01-reverse4/first_steps.html): A summary for first_steps.html.
- [Rizin](https://book.rizin.re/src/crackmes/avatao/01-reverse4/rizin.html): A summary for rizin.html.
- [IOLI 0x09 â€“ Reverse Engineering with Rizin Framework](https://book.rizin.re/src/crackmes/ioli/ioli_0x09.html): This document details the reverse engineering process for the IOLI Crackme Level 0x09 using the Rizin Framework. It covers comparing binary versions, analyzing function differences, renaming functions, and using ESIL to resolve string addresses, concluding with examples.
- [The Rizin Handbook: A Guide to Reverse Engineering with the Rizin Framework - IOLI 0x08](https://book.rizin.re/src/crackmes/ioli/ioli_0x08.html): This document details the reverse engineering of the `crackme0x08` binary using the Rizin framework. It highlights the comparison between `crackme0x07` and `crackme0x08`, noting that `crackme0x08` restores symbol names stripped in the previous version. The solution involves using similar techniques as `crackme0x07`, including the use of an `exit` trampoline and identifying renamed functions and global variables within the Rizin environment.
- [The Rizin Handbook: A Guide to Reverse Engineering with the Rizin Framework - IOLI 0x07](https://book.rizin.re/src/crackmes/ioli/ioli_0x07.html): This document details the process of reverse engineering the IOLI Crackme Level 0x07 using the Rizin framework. It covers analyzing strings, disassembling code, identifying functions, and understanding the logic, including a parity check and the manipulation of a global variable. The document highlights the use of Rizin commands like `rz-bin`, `aa`, `pdg`, `afn`, `afr`, `axf`, and `axt` to achieve the analysis.
- [Ioli 0X06](https://book.rizin.re/src/crackmes/ioli/ioli_0x06.html): A summary for ioli_0x06.html.
- [The Rizin Handbook: IOLI 0x05 Crackme Guide](https://book.rizin.re/src/crackmes/ioli/ioli_0x05.html): This document details the sixth crackme challenge, focusing on reverse engineering a program using the Rizin framework. It analyzes functions like `main`, `check`, and `parell`, explaining how the program processes user input, sums digits, and performs parity checks to validate a password. The guide includes Rizin command outputs and successful password examples.
- [Reverse Engineering Crackme0x04 with Rizin Framework](https://book.rizin.re/src/crackmes/ioli/ioli_0x04.html): This document details the process of reverse engineering the 'crackme0x04' executable using the Rizin framework. It explains how the `check` function calculates a password by summing digits entered by the user, aiming for a total of 15. The guide demonstrates techniques like string extraction, function analysis, debugging, memory allocation, and breakpoint setting to understand and eventually bypass the password protection mechanism. It also shows how non-digit characters are ignored in the summation, allowing for various valid password inputs.
- [Rizin Handbook: Reverse Engineering Crackme 0x03](https://book.rizin.re/src/crackmes/ioli/ioli_0x03.html): This document details a reverse engineering challenge using the Rizin framework. It walks through analyzing a crackme executable, identifying its core logic, and using Rizin's features like command-line analysis, debugging, and emulation to understand and bypass its password protection mechanism. The process involves string analysis, decompilation, debugging to set breakpoints and manipulate program flow, and emulation to execute code snippets, ultimately revealing a simple character shift cipher used for decoding messages.
- [IOLI 0x02 â€“ Reverse Engineering with Rizin Framework](https://book.rizin.re/src/crackmes/ioli/ioli_0x02.html): This document details the process of reverse engineering the second crackme challenge (0x02) using the Rizin framework. It covers initial analysis with rz-bin, disassembly and decompilation within Rizin, and the steps to derive the correct password by analyzing the code's logic, ultimately revealing the password to be 338724.
- [Ioli 0X01](https://book.rizin.re/src/crackmes/ioli/ioli_0x01.html): A summary for ioli_0x01.html.
- [IOLI 0x00 â€“ The Rizin Handbook: A Guide to Reverse Engineering with the Rizin Framework](https://book.rizin.re/src/crackmes/ioli/ioli_0x00.html): This document provides a step-by-step guide to solving the IOLI Crackme Level 0x00 challenge using the Rizin Framework. It details how to extract strings from the binary using `rz-bin -z` to identify the password, ultimately revealing "250382" as the correct password.
- [Intro](https://book.rizin.re/src/tools/rz-diff/intro.html): A summary for intro.html.
- [Program Sections with Rizin Framework](https://book.rizin.re/src/tools/rz-bin/program_sections.html): This document details how to use the rz-bin command with the -S option to display detailed information about executable file sections, including their index, offset, size, alignment, type, and permissions. It also explains the -Sr option for flagging section start/end points and includes examples of command output.
- [Strings Extraction with rz-bin](https://book.rizin.re/src/tools/rz-bin/strings.html): This document explains how to use the -z and -zr options in the rz-bin command for extracting strings from ELF and PE files. It provides examples of command usage and output, demonstrating how to list strings, their properties, and how to generate rz-bin commands to create flags and mark byte ranges for these strings within a rz-bin session.
- [Listing Libraries with rz-bin -l](https://book.rizin.re/src/tools/rz-bin/libraries.html): This document explains how to list libraries used by a binary with the `rz-bin -l` command, comparing its output to the `ldd` command and highlighting that `rz-bin` only shows direct binary dependencies, not library dependencies.
- [Symbols (Exports) with Rizin Framework](https://book.rizin.re/src/tools/rz-bin/symbols.html): This document details how to use the rz-bin command-line tool to extract symbols (exports) from binary files, providing examples for both a human-readable list and a rizin script format.
- [Imports â€“ The Rizin Handbook](https://book.rizin.re/src/tools/rz-bin/imports.html): This document details how to use the rz-bin tool with the -i flag to list imported objects and their offsets in the PLT, which is useful for understanding external function calls within an executable.
- [File Properties Identification with Rizin Framework](https://book.rizin.re/src/tools/rz-bin/file_identification.html): This document explains how to use the 'rz-bin -I' command in the Rizin Framework to identify file properties such as architecture, endianness, OS, and more. It also details how to use the '-Ir' option to format this information for Rizin's main program.
- [Rz-bin â€” Show Properties of a Binary](https://book.rizin.re/src/tools/rz-bin/intro.html): The Rizin Handbook's `rz-bin` chapter details its functionality for inspecting binary file properties, including imports, sections, and headers. It supports various formats like ELF, PE, and Mach-O, and can extract information such as symbol imports/exports, library dependencies, strings, and entrypoint addresses. The content also lists numerous command-line options for customized analysis and provides environment variables for configuring `rz-bin`'s behavior.
- [rz-run Usage and Configuration](https://book.rizin.re/src/tools/rz-run/intro.html): rz-run is a tool for setting up execution environments in Rizin, allowing for redirection of stdin/stdout, environment variable manipulation, and other debugging configurations. It uses a simple key=value profile format, with important directives like 'program' and 'arg*' for specifying the binary and its arguments, and options for I/O redirection, environment management, and execution control.
- [Intro](https://book.rizin.re/src/tools/rz-find/intro.html): A summary for intro.html.
- [Intro](https://book.rizin.re/src/tools/rz-ax/intro.html): A summary for intro.html.
- [WinDBG Kernel-Mode Debugging with Rizin Framework](https://book.rizin.re/src/remote_access/windbg.html): This document provides a guide to using WinDBG for kernel-mode debugging with the Rizin Framework. It covers setting up KD via serial port and network connections in Rizin, and also details how to use Rizin's DbgEng backend for debugging various Windows scenarios, including dump files and remote debugging. The guide includes specific commands and configurations for different Windows versions and virtual machine setups.
- [Remote Debugging with Rizin and Gdbserver](https://book.rizin.re/src/remote_access/remote_gdb.html): This document explains how to use the Rizin framework for remote debugging with gdbserver. It covers connecting to a remote gdbserver, attaching to processes, handling symbols, adjusting packet sizes, and utilizing specific gdb IO commands within Rizin. It also introduces Rizin's built-in gdbserver implementation.
- [Remote Access Capabilities of Rizin Framework](https://book.rizin.re/src/remote_access/remoting_capabilities.html): This document outlines the remote access capabilities of the Rizin framework, detailing how to connect to and control Rizin instances over a network. It covers various commands for establishing connections, executing commands remotely, and redirecting output, including examples for setting up server processes and managing client connections.
- [Rizin Handbook: Reverse Engineering on macOS/iOS](https://book.rizin.re/src/debugger/apple.html): This document provides a guide to reverse engineering with the Rizin Framework on macOS and iOS. It details how to sign the Rizin binary to enable debugging capabilities and discusses solutions for common issues such as debugging on macOS over SSH, including modifying taskport permissions. It also addresses limitations like the inability to debug Apple-signed binaries due to System Integrity Protection (SIP) and offers workarounds.
- [Windows Messages in Rizin](https://book.rizin.re/src/debugger/windows_messages.html): This document explains how to use Rizin's `dbW` command to set breakpoints on Windows messages, allowing users to debug window message handlers by specifying message types and window class names or handles. It also covers using `dW` to list process windows and `dWi` to identify windows using a mouse cursor.
- [Reverse Debugging with Rizin Framework](https://book.rizin.re/src/debugger/revdebug.html): This document explains Rizin's reverse debugging capabilities, including saving and restoring program states for backward execution, managing recorded states with `dts` commands, and performing reverse debugging in ESIL mode. It also touches on exporting/importing states and using Rizin with gdb's remote protocol.
- [Rizin Heap Inspection Guide](https://book.rizin.re/src/debugger/heap.html): This document details the heap inspection capabilities within the Rizin framework. It explains how to use commands like `dmh`, `dmhg`, and `dmhd` to view heap structures, allocations, and bin information, supporting Glibc, Jemalloc, and Windows heaps.
- [Memory Maps](https://book.rizin.re/src/debugger/memory_maps.html): A summary for memory_maps.html.
- [Rizin Registers Guide](https://book.rizin.re/src/debugger/registers.html): This document explains how to use the 'dr' command in the Rizin Framework to view, get, and set register values, including general-purpose registers and hardware registers like DR0-DR7. It covers commands like 'dr', 'dro', 'drd', and demonstrates how to save and restore register states using file redirection.
- [Rizin Framework Migration Guide](https://book.rizin.re/src/debugger/migration.html): This document provides a comprehensive guide to migrating from IDA, GDB, or WinDBG to the Rizin framework for reverse engineering. It details various commands and functionalities within Rizin, offering equivalents for common debugging and analysis tasks found in other tools. The guide covers process attachment, debugging, scripting, code navigation, disassembly, and project management, including a comparative table of commands across different debuggers.
- [Rizin Debugger Overview](https://book.rizin.re/src/debugger/intro.html): This document details how Rizin's debugger functions as an IO plugin, enabling it to manage processes across various URI types and providing a consistent debugging experience across different architectures and operating systems through system calls and IO plugins. It also outlines the basic debugger commands and session restart options.
- [Rz-pipe: A Guide to Reverse Engineering with Rizin Framework](https://book.rizin.re/src/scripting/rz-pipe.html): This document outlines the rz-pipe module, a tool for interacting with Rizin instances through various methods including spawn pipes, HTTP queries, and TCP sockets. It details usage examples in Python, Haskell, OCaml, Rust, and Ruby, showing how to execute Rizin commands and retrieve data.
- [Macros and Aliases in Rizin Framework](https://book.rizin.re/src/scripting/macros.html): This document details the usage of macros and aliases in the Rizin Framework. It explains how to define, use, and manage macros for task automation, including those with arguments. It also covers the creation and management of aliases for simplifying and speeding up command execution, including chaining aliases together.
- [Loops in the Rizin Framework](https://book.rizin.re/src/scripting/loops.html): This document explains how to use loops in the Rizin Framework for automation. It covers looping over flags (e.g., function flags), lists of offsets, and instructions within basic blocks or functions using various syntaxes like `@@f:regex`, `@@=list`, and `@@i`.
- [Intro](https://book.rizin.re/src/scripting/intro.html): A summary for intro.html.
- [CPU and Platform Profiles in Rizin](https://book.rizin.re/src/analysis/cpu_platform_profiles.html): This document details how the Rizin framework uses CPU and platform profiles to manage the diversity of embedded systems. It explains that CPU profiles store CPU-specific values like RAM and ROM sizes, and IO registers, while platform profiles store information about specific boards and their peripherals. Both profile types are stored in SDB files and are loaded during analysis to simplify reverse engineering by adding flags and comments. The document also provides instructions on how to add new CPU and platform profiles to the framework.
- [Rizin Framework Graph Commands](https://book.rizin.re/src/analysis/graphs.html): This document provides a comprehensive overview of the graph commands available in the Rizin Framework. It details various graph types such as call graphs, control flow graphs, and reference graphs, along with their corresponding output formats including ASCII art, JSON, and Graphviz dot. The document also explains how to use these commands for data analysis and visualization in reverse engineering.
- [Rizin Signatures Guide](https://book.rizin.re/src/analysis/signatures.html): This document explains how to use Rizin's signature matching and creation features, including support for the HexRays FLIRT format. It details commands for applying, managing, and creating signatures, as well as configuration options for signature databases and file formats.
- [Symbols and Debugging Information in Rizin Framework](https://book.rizin.re/src/analysis/symbols.html): This document explains how Rizin, a reverse engineering framework, handles symbols, specifically debugging information like DWARF and PDB files. It details the configuration options for downloading and extracting PDB files from Microsoft's symbol server, including command-line options and internal Rizin commands. The document also covers the automated loading of DWARF information and provides examples of how symbol information is displayed within the Rizin environment.
- [Rizin Framework Emulation with ESIL](https://book.rizin.re/src/analysis/emulation.html): This document explains the emulation capabilities within the Rizin Framework, focusing on its ESIL (Emulated String Instruction Language) for dynamic analysis. It details how ESIL aids in overcoming static analysis limitations like path explosion and covers manual setup and usage of the ESIL VM, including stepping, tracing, and interacting with the VM. The document also discusses automatic integration of emulation into the analysis loop and various configuration options to customize ESIL behavior for memory and stack manipulation. It highlights that ESIL VM cannot emulate external or system calls, making it suitable for analyzing smaller code segments like deobfuscation or unpacking routines.
- [Syscall Analysis in Rizin](https://book.rizin.re/src/analysis/syscalls.html): This document explains how to use Rizin to detect and analyze system calls (syscalls). It covers using commands like `/ad`, `asl`, `/as`, `asm.emu`, `aae`, and `dcs*` to find, list, and trace syscalls. It also details how Rizin maps syscalls to numbers and names, facilitating reverse engineering tasks.
- [Virtual Tables in Rizin Framework](https://book.rizin.re/src/analysis/vtables.html): This document explains how to use Rizin's virtual table parsing features, covering commands for inspecting and recovering C++ virtual tables and RTTI information.
- [Calling Conventions](https://book.rizin.re/src/analysis/calling_conventions.html): A summary for calling_conventions.html.
- [Rizin Framework Type System Guide](https://book.rizin.re/src/analysis/types.html): This document provides a comprehensive guide to using Rizin's type system for reverse engineering. It covers defining, loading, printing, and linking C-style data types, including structs, unions, and enums. The guide also explains how to use Rizin commands like `t`, `td`, `to`, `ts`, `tp`, `aht`, and `te` with practical examples and code snippets.
- [Variables](https://book.rizin.re/src/analysis/variables.html): A summary for variables.html.
- [Code Analysis](https://book.rizin.re/src/analysis/code_analysis.html): A summary for code_analysis.html.
- [Rizin Framework Data and Code Analysis](https://book.rizin.re/src/analysis/intro.html): This document details the Rizin Framework's data and code analysis capabilities, focusing on the 'a' command family. It lists various subcommands for analyzing code, data, functions, opcodes, and managing analysis-related information like graphs and variables.
- [ESIL â€“ The Rizin Handbook: A Guide to Reverse Engineering with the Rizin Framework](https://book.rizin.re/src/disassembling/esil.html): This document is a handbook on using the Rizin framework for reverse engineering, specifically detailing the Evaluable Strings Intermediate Language (ESIL). It explains ESIL's Forth-like, stack-based approach to representing and emulating CPU opcodes with examples and a comprehensive list of ESIL commands and their operations. The guide also covers Rizin environment variables for enhancing the debugging and analysis experience with ESIL, such as `asm.emu`, `emu.str`, and `asm.esil`, and demonstrates how to use commands like `ae`, `aes`, `aeso`, `aesu`, and `ar` for evaluating and stepping through ESIL code.
- [RzIL: A Guide to Reverse Engineering with Rizin Framework](https://book.rizin.re/src/disassembling/rzil.html): This document provides a comprehensive guide to RzIL, the intermediate language used in the Rizin reverse engineering framework. It details RzIL's syntax, instruction representation using s-expressions, and its application in code analysis and emulation. The guide includes practical examples of using RzIL commands for disassembling, analyzing, and emulating code, particularly for PowerPC architecture. It also covers emulation control, register/memory access, and string printing via emulation.
- [Adding Metadata to Disassembly with Rizin](https://book.rizin.re/src/disassembling/adding_metadata.html): This document explains how to add metadata to disassembled binary files using the Rizin framework, covering comments, data types, and structural annotations through various commands like C, CC, Cs, and Cf, and also mentions visual mode shortcuts.
- [Disassembling with the Rizin Framework](https://book.rizin.re/src/disassembling/intro.html): This document explains the disassembly feature in the Rizin framework, detailing how to represent byte arrays using the 'p' command's print mode. It covers various commands like 'pd', 'pD', and 'pdp' for disassembling code, adjusting block sizes, and handling ROP chains. The guide also demonstrates how to customize disassembly output with options for pseudo-syntax, Intel, and AT&T syntax, and provides an overview of related commands for different disassembly needs.
- [Visual Panels in Rizin Framework](https://book.rizin.re/src/visual_mode/visual_panels.html): This document provides a comprehensive guide to Visual Panels in the Rizin Framework, detailing its split-screen functionality, command shortcuts for various panels (Symbols, Registers, Stack, etc.), and usage in debugging and reverse engineering. It covers basic operations, window mode, editing values, tab management, and saving custom layouts.
- [Visual Disassembly in Rizin Framework](https://book.rizin.re/src/visual_mode/visual_disassembly.html): This document provides a comprehensive guide to using the visual disassembly features of the Rizin Framework. It covers navigation, data definition and formatting, xref analysis, function argument display, commenting, searching, HUDs, and visual configuration for customizing the disassembly appearance and behavior.
- [Visual Mode in the Rzin Framework](https://book.rizin.re/src/visual_mode/intro.html): This document provides a comprehensive guide to the Visual Mode in the Rizin Framework, detailing its navigation features, different panel display options, and an extensive list of keyboard shortcuts for efficient use during reverse engineering tasks.
- [Dietline: Rizin Framework Command-Line Interface](https://book.rizin.re/src/basic_commands/dietline.html): This document details the features and usage of Dietline, the command-line editing and history navigation library used in the Rizin framework. It covers input capabilities, autocompletion, and configurable Emacs and Vi modes with their respective keybindings for editing, deleting, and history searching.
- [SDB - The Rizin Handbook](https://book.rizin.re/src/basic_commands/sdb.html): SDB, short for String DataBase, is a fast, string-based key-value database used within the Rizin Framework. It supports namespaces, atomic synchronization, and JSON/array introspection, serving as a powerful tool for managing data during reverse engineering tasks.
- [Comparing Bytes with Rizin's 'compare' Command](https://book.rizin.re/src/basic_commands/comparing_bytes.html): This document details the 'compare' command in the Rizin framework, explaining how to compare byte sequences, memory contents, and code. It covers various subcommands like `cx` for comparing with hex pairs, `cc` for comparing code sequences, and `cf` for comparing with files stored on disk. It also mentions the `rz-diff` utility for general diffing tasks.
- [Yank/Paste in Rizin Framework](https://book.rizin.re/src/basic_commands/yank_paste.html): This document explains the yank and paste functionality in the Rizin Framework using the 'y' command, detailing how to copy and paste memory portions, including visual mode operations and specific commands like `y`, `yy`, and `yt`.
- [Write](https://book.rizin.re/src/basic_commands/write.html): A summary for write.html.
- [Rizin Flags and Flagspaces Guide](https://book.rizin.re/src/basic_commands/flags.html): This document explains how to use flags and flagspaces in the Rizin framework for reverse engineering. It covers creating, deleting, renaming, and managing flags, including local flags and flag zones for navigation.
- [Print Modes](https://book.rizin.re/src/basic_commands/print_modes.html): A summary for print_modes.html.
- [Mapping Files in Rizin Framework](https://book.rizin.re/src/basic_commands/mapping_files.html): This document explains how to use the I/O subsystem in the Rizin Framework to map files into memory. It details commands like 'o' to open files, '-B' and '-m' flags for changing base addresses and mapping files, and 'ol' to list mapped files. The guide also covers unmapping files with 'o-' and viewing opened files with 'o='.
- [Rizin Sections and Mappings](https://book.rizin.re/src/basic_commands/sections.html): This document, "Sections â€“ The Rizin Handbook: A Guide to Reverse Engineering with the Rizin Framework," details how to view and manage sections and memory mappings within the Rizin reverse engineering framework. It covers commands like `iS` for displaying section information, `om` for creating new memory mappings, and `oml` for viewing mapped sections, along with their properties and how to delete them.
- [Block Size Management in Rizin Framework](https://book.rizin.re/src/basic_commands/block_size.html): This document explains how to use the 'b' command in the Rizin framework to manage block size, which determines the default byte processing amount for commands. It covers setting, increasing, decreasing, and querying block size using commands like `b`, `b+`, `b-`, and `bf`, with examples for disassembling functions and using special variables like $FB and $FS.
- [The Rizin Handbook: Seeking Commands](https://book.rizin.re/src/basic_commands/seeking.html): This document explains how to use the 'seek' command in the Rizin framework for reverse engineering. It covers moving to specific addresses, relative seeking, using expressions and registers for seeking, and managing seek history. The guide also includes examples with a simple C program compiled into an ELF executable.
- [Rizin Basic Commands Guide](https://book.rizin.re/src/basic_commands/intro.html): This document explains the basic command structure and usage in the Rizin framework, covering command formats, special characters like `!`, `@`, `>`, and `|`, and demonstrating their application with examples for seeking, searching, and data manipulation.
- [Rizin Run-Time Variables](https://book.rizin.re/src/configuration/run_time_variables.html): This document lists and describes the run-time variables for the Rizin framework, which can be used to modify its default behavior. It includes environment variables related to plugins, debugging, logging, and paths.
- [Compile-Time Variables in Rizin Framework](https://book.rizin.re/src/configuration/compile_time_variables.html): This document explains how to access compile-time variables in the Rizin framework by using the `rizin -H` command and lists various variables such as RZ_VERSION, RZ_PREFIX, and RZ_LIBDIR. It also demonstrates how to view a specific variable using the `rizin -H variable` command.
- [Initial Scripts in Rizin Framework](https://book.rizin.re/src/configuration/initial_scripts.html): This document details the various initial scripts used by the Rizin framework, including `rizinrc`, `binrc`, and file-specific scripts like `firmware.bin.rz`. It explains their loading locations, execution conditions, and provides examples for Linux, macOS, and Windows environments, covering customizations and debugging with `log.level=2`.
- [Evaluable Variables in Rizin Framework](https://book.rizin.re/src/configuration/evars.html): This document details 'evaluable variables' in the Rizin Framework, which are configuration variables affecting analysis, visuals, and assembly. It covers variables for assembly configuration such as setting the architecture, bits, byte display, CPU type, platform, flags, function size, lines, offsets, OS, and pseudo-syntax.
- [Colors and Themes in Rizin Framework](https://book.rizin.re/src/configuration/colors.html): This document explains how to configure color output and themes in the Rizin framework. It covers the `scr.color` option, which supports four values from no colors to truecolor, and how to set preferences in the `rizinrc` file. The guide also details commands like `ec`, `ecs`, and `eco` for managing color palettes and themes, including custom theme creation and randomization options. It notes that Rizin attempts to match colors to the console's theme and allows manual selection due to the lack of standardized terminal querying methods.
- [Rizin Configuration Guide](https://book.rizin.re/src/configuration/intro.html): This document explains how to configure the Rizin reverse engineering framework using the `rizinrc` file and command-line options. It details how to set various configuration variables, list available options, and use visual mode for easier customization.
- [Contributing to Rizin](https://book.rizin.re/src/first_steps/contributing.html): This document outlines how to contribute to the Rizin Book and the Rizin project itself. It details accepted contribution types, such as CTF writeups and documentation, and provides links to relevant repositories, code of conduct, and community chat servers. It also emphasizes the importance of obtaining permission for content creation.
- [Basic Rizin Debugger Session](https://book.rizin.re/src/first_steps/basic_debugger_session.html): This document provides a guide to basic debugger operations within the Rizin framework. It details how to initiate a debugging session, manage breakpoints and execution flow, and leverage Rizin's visual debugger mode for a more interactive experience. The guide also lists common debugger commands for tasks like stepping through code, inspecting registers, and manipulating memory maps.
- [Expressions in the Rizin Framework](https://book.rizin.re/src/first_steps/expressions.html): The Rizin Handbook chapter on Expressions details the use of the '%' command for evaluating mathematical and numerical expressions within the Rizin framework. It outlines supported arithmetic, binary, and boolean operations, various numerical formats, and the usage of internal variables and seek positions for complex expression building. The chapter also includes information on string manipulation, hash calculation, number conversions, and accessing register values.
- [Commandline Rizin](https://book.rizin.re/src/first_steps/commandline_rizin.html): A summary for commandline_rizin.html.
- [Shell Command-line Options](https://book.rizin.re/src/first_steps/commandline_options.html): This document details the various command-line options available for the Rizin framework. It covers basic usage, specific flags for file handling, debugging, analysis, and configuration, along with common usage patterns and examples for each option.
- [Rizin Framework Basic Usage Guide](https://book.rizin.re/src/first_steps/intro.html): This document provides a comprehensive guide to the Rizin framework, covering basic usage, command navigation, and file manipulation. It details commands for searching help, filtering output, navigating binary files with seek and print commands, and modifying files in write mode. The guide also introduces visual modes (`V` and `v`) for enhanced interaction and provides keybindings for navigation and editing within these modes.
- [Compiling Rizin for Android](https://book.rizin.re/src/introduction/compilation_android.html): Provides a step-by-step guide on how to cross-compile the Rizin reverse engineering framework for Android using Meson and Ninja. It details the necessary prerequisites, NDK setup, Meson cross-file configuration, compilation commands, and instructions for transferring the compiled files to an Android device.
- [Windows Compilation](https://book.rizin.re/src/introduction/windows_compilation.html): A summary for windows_compilation.html.
- [Compilation and Portability](https://book.rizin.re/src/introduction/compilation_portability.html): This document from The Rizin Handbook details the compilation and portability of the Rizin framework, noting its compatibility with various systems and architectures, including support for TinyCC. It specifies the platforms where the debugger layer is available and explains how to disable it if necessary. The document also mentions I/O plugins that depend on external debugging tools and provides information about using a Dockerfile for deployment.
