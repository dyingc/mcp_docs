# Document Index
- [angr Documentation](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest.md): This document provides a comprehensive guide to using angr, a powerful binary analysis framework. It covers installation, core concepts like symbolic execution and simulation managers, built-in and custom analyses, advanced topics such as optimization and specific platform support, and various examples and API references. angr also includes details on its supporting libraries like archinfo, pyvex, cle, and claripy, as well as its GUI, angr-management.
- [Introduction to angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/quickstart.html): This document provides an introduction to angr, a powerful binary analysis toolkit that utilizes dynamic symbolic execution and static analysis. It outlines the core challenges in binary analysis, explains how angr addresses them, and offers resources for support, academic citation, and further learning through papers and CTF examples.
- [Migration 7](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/appendix/migration-7.html): A summary for migration-7.html.
- [Migrating to angr 8](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/appendix/migration-8.html): This document details the migration process to angr version 8, highlighting key changes such as the transition from Python 2 to Python 3, API modifications in CLE memory and symbols, and various deprecations and name changes. It provides guidance on adapting existing scripts to the new Python 3 environment, including changes in string handling, built-in functions, and number operations, with specific examples for angr usage like state.solver.eval and memory operations.
- [Migrating to angr 9.1](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/appendix/migration-9.1.html): This document details the breaking changes in angr version 9.1, focusing on the refactoring of SimCC. Key changes include the deprecation of customizable SimCCs, mandatory SimType usage for typed data interactions, the introduction of the `buffer` parameter in PointerWrapper for array handling, and the renaming of `func_ty` to `prototype` for consistency.
- [angr Changelog](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/appendix/changelog.html): This document details the major changes and bug fixes in various versions of the angr binary analysis framework, spanning from version 7.8.6.16 to 9.1. It highlights significant refactoring, new features like a decompiler and improved CFG recovery, support for new architectures and languages (like ARM and Java), and transitions such as the move to Python 3. The changelog also notes the removal of deprecated features and backend support.
- [More Examples](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/appendix/more-examples.html): A summary for more-examples.html.
- [Angr State Options Guide](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/appendix/options.html): This document details the various state options available in the angr framework, categorizing them into modes, sets, and individual options, and explaining their impact on emulation and analysis.
- [Claripy Operations](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/appendix/ops.html): This document lists and describes various Claripy operations, categorized into Arithmetic and Logic, Bitvector Manipulation, and Extra Functionality, with examples for each operation.
- [Angr Cheatsheet](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/appendix/cheatsheet.html): This document provides a cheatsheet for the angr framework, covering general usage, state management, simulation, constraint solving with claripy, FFI, hooking, and debugging techniques. It includes code snippets for loading binaries, creating states and simulation managers, exploring execution paths, manipulating symbolic variables, and setting breakpoints.
- [Faq](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/faq.html): A summary for faq.html.
- [angr Examples Guide](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/examples.html): This document provides an overview of angr examples, categorized into Introduction, Reversing, Vulnerability Discovery, and Exploitation. It details various reverse engineering challenges and vulnerability discovery scenarios, showcasing angr's capabilities with links to scripts and binaries.
- [Analysis Writing](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/extending-angr/analysis_writing.html): A summary for analysis_writing.html.
- [Environment](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/extending-angr/environment.html): A summary for environment.html.
- [State Plugins in angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/extending-angr/state_plugins.html): This document explains how to create and use state plugins in the angr framework. It covers implementing the `copy` and `merge` methods, handling state initialization and lifecycle, and considerations for serialization and nested plugins.
- [Hooks and SimProcedures](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/extending-angr/simprocedures.html): This document provides a comprehensive guide to using Hooks and SimProcedures in angr for modifying program behavior. It covers basic usage with examples, implementation details, data types, and advanced control flow mechanisms like conditional exits and continuations for calling binary functions from SimProcedures.
- [Debug Variable Resolution in Angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/advanced-topics/debug_var.html): This document explains how to use angr's debug variable resolution feature, allowing users to inspect source-level variables within binary analysis. It covers setup, core functionalities like accessing variable memory and dereferencing pointers, and handling variable visibility across different scopes. Examples demonstrate retrieving variable values, including pointers and those within nested scopes.
- [Symbion: Interleaving Symbolic and Concrete Execution](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/advanced-topics/symbion.html): Symbion is a technique for interleaved symbolic and concrete execution in angr. It allows users to import a concrete state of a target program into angr, make parts of the state symbolic, perform symbolic analysis, and then resume concrete execution. This enables advanced runtime and interactive symbolic analyses backed by the actual program's execution. The tool provides a default GDB-based concrete target and discusses installation and customization options like SYMBION_SYNC_CLE and SYMBION_KEEP_STUBS_ON_SYNC.
- [Java Support in angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/advanced-topics/java_support.html): This document details angr's experimental support for symbolically executing Java code and Android apps, including those with mixed Java and native code. It covers installation requirements, the underlying Soot framework, and provides links to various examples and resources for Java and Android application analysis.
- [Concretization Strategies in angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/advanced-topics/concretization_strategies.html): This document explains angr's symbolic memory addressing, detailing how 'concretization strategies' manage symbolic memory accesses, particularly for writes. It outlines the default strategies and how to customize them for different behaviors, such as allowing a range of symbolic writes or selecting maximum solutions. The document also touches upon enabling symbolic writes globally and provides a template for writing custom strategies.
- [Claripy: The Solver Engine](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/advanced-topics/claripy.html): Claripy is angr's solver engine, providing a unified way to interact with concrete and symbolic expressions through ASTs, Frontends, and Backends. It supports various expression types like bitvectors (BV) and floating-point numbers (FP), and offers operations for manipulation and comparison, all managed by different Solver types such as Solver, SolverVSA, SolverReplacement, and SolverHybrid.
- [Working with Data and Conventions in angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/advanced-topics/structured_data.html): This document describes how to work with structured data in angr, a framework for symbolic execution. It covers accessing types, parsing C definitions, and interacting with memory using typed data. It also explains calling conventions and the Foreign Functions Interface (FFI) for symbolic execution through callables.
- [Intermediate Representation (VEX) in angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/advanced-topics/ir.html): This document provides an overview of angr's Intermediate Representation (IR), VEX, explaining its purpose in analyzing code across different architectures like MIPS, ARM, and x86. It details the components of VEX IR, including Expressions, Operations, Temporary variables, Statements, and Blocks, and illustrates how VEX abstracts architectural differences for registers, memory access, and side-effects. The document also includes examples of VEX IR translation and demonstrates how to use PyVEX within angr to interact with this IR.
- [File System](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/advanced-topics/file_system.html): A summary for file_system.html.
- [Angr Optimization Considerations](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/advanced-topics/speed.html): Provides an in-depth guide to optimizing the performance of the angr binary analysis framework. It covers general speed tips such as using PyPy, selectively loading mixins and shared libraries, and employing SimProcedures and SimInspect. The guide also details strategies for optimizing concrete or partially-concrete execution, including the use of the Unicorn engine, fast memory/registers, pre-concretizing input, and the "afterburner" technique for automatic concretization. Additionally, it addresses memory optimization by managing state references and using `state.history.trim()` to reduce memory footprint, particularly for analyses with long execution paths.
- [Whatâ€™s Up With Mixins, Anyway?](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/advanced-topics/mixins.html): This document explains the mixin design pattern and its application in the angr framework, detailing how multiple inheritance is used to create modular and reusable code for analysis engines and the VEX lifter. It covers the Method Resolution Order (MRO) and provides examples of mixins like ClaripyDataMixin and TrackActionsMixin.
- [Understanding the Execution Pipeline in angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/advanced-topics/pipeline.html): This document details the execution pipeline of the angr framework, explaining the roles of Simulation Managers, Exploration Techniques, SimState, and SimEngine in analyzing code. It covers functions like run(), step(), and successors(), and describes the default UberEngine with its various mixins for handling different execution scenarios like machine code, syscalls, and hooks.
- [Gotchas](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/advanced-topics/gotchas.html): A summary for gotchas.html.
- [angr Decompiler Analysis Passes](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/analyses/decompiler.html): Provides an overview of the angr decompiler, detailing the various analysis passes involved in decompiling code. It covers stages from control flow graph recovery and indirect branch resolution to simplifying AIL blocks and functions, and finally to code generation.
- [Backward Slicing with angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/analyses/backward_slice.html): This document explains backward slicing in angr, a tool used for debugging and program understanding. It details how to construct a backward slice using angr's BackwardSlice analysis, including required inputs like CFGs and optional inputs like CDGs and DDGs. The document also covers the members of the BackwardSlice object and provides usage examples.
- [Control-flow Graph Recovery in angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/analyses/cfg.html): This document details angr's Control-Flow Graph (CFG) recovery capabilities, differentiating between static (CFGFast) and dynamic (CFGEmulated) analyses. It explains how to generate and utilize CFGs, discusses handling shared libraries, and elaborates on the Function Manager object with its various properties and methods for analyzing function behavior, call sites, and references. The document also touches upon CFGFast's methodology for identifying function starts and handling function returns.
- [Be Creative: Advice for Using angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/core-concepts/be_creative.html): This document provides advice for using the angr binary analysis framework, emphasizing creativity and community support alongside its core emulating capabilities. It guides users to leverage angr's tools and abstractions to solve binary analysis problems effectively.
- [Analyses](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/core-concepts/analyses.html): This document provides an overview of angr's analyses, detailing built-in functionalities like CFGFast, CFGEmulated, VFG, DDG, BackwardSlice, and Identifier. It also explains how to write custom analyses and discusses the resilience of analyses, including error handling and a 'fail fast' option.
- [Symbolic Execution with angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/core-concepts/symbolic.html): This document explains symbolic execution, a program analysis technique that explores multiple execution paths simultaneously by treating inputs as symbolic variables rather than concrete values. It details how this method generates and solves constraints to uncover bugs and vulnerabilities, providing examples using the angr framework for binary analysis and test case generation.
- [Simulation and Instrumentation in angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/core-concepts/simulation.html): This document details angr's simulation and instrumentation capabilities, explaining its execution engines, the SimSuccessors object for categorizing states, and the breakpoint system for debugging and analysis. It covers various breakpoint event types and their associated attributes.
- [Simulation Managers](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/core-concepts/pathgroups.html): This document explains angr's SimulationManager, a tool for controlling symbolic execution. It details how to manage states, step through execution, handle branches, and utilize stashes like 'active', 'deadended', 'pruned', 'unconstrained', and 'unsat'. It also covers stash management techniques such as moving states between stashes and accessing individual states. The document introduces the `.explore()` method for targeted state searching, including 'find', 'avoid', and 'num_find' parameters, using a crackme example to illustrate its usage. The 'errored' list for handling execution errors is also discussed.
- [Machine State in angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/core-concepts/states.html): This document explains angr's machine state, including how to interact with memory and registers, perform basic execution using `state.step()`, and understand how symbolic execution handles multiple successor states. It also covers different state presets like blank_state, entry_state, full_init_state, and call_state, along with customization options for state constructors.
- [Symbolic Expressions and Constraint Solving with angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/core-concepts/solver.html): This document explains how to use angr for symbolic execution, focusing on symbolic expressions and constraint solving. It covers working with bitvectors (concrete and symbolic), performing arithmetic operations, understanding Abstract Syntax Trees (ASTs), and utilizing SMT solvers to determine variable values based on constraints. The guide includes practical examples of setting constraints and evaluating symbolic variables to find inputs for given outputs.
- [Loading Binaries in Angr with CLE](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/core-concepts/loading.html): This document provides a comprehensive guide on loading binary files in angr, a powerful framework for binary analysis. It details the CLE (CLE Loads Everything) component responsible for parsing binaries and their dependencies, explaining how to interact with the Loader object to access loaded binaries, their segments, sections, symbols, and relocations. The guide also covers methods for finding symbols by name or address, understanding symbol attributes like rebased_addr, linked_addr, and relative_addr, and differentiating between import and export symbols. Additionally, it touches upon relocations, which manage the linking of imports to exports.
- [Core Concepts of angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/core-concepts/toplevel.html): This document provides a comprehensive overview of angr's core concepts, including projects, basic properties, and the factory for creating objects like blocks and states. It details how to load binaries, interact with program states, and manage data using bitvectors. It also introduces essential components like CLE for binary loading and provides practical code examples for using angr in Python.
- [Help Wanted](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/getting-started/helpwanted.html): This document outlines the "Help Wanted" section for the angr documentation, detailing various areas where community contributions are needed. It covers improvements in documentation (API, GitBook, angr course), research re-implementations (Redundant State Detection, In-Vivo Multi-Path Analysis), development efforts (angr-management, IDA Plugins, new architectures, environment support), design problems (type annotation), and research challenges (semantic function identification/diffing, applying AFL's path selection to symbolic execution).
- [Developing and Reporting Bugs in angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/getting-started/developing.html): This document outlines the procedures for reporting bugs and contributing to the angr project. It details how to submit bug reports with reproducible test cases and provides guidelines for developers on coding style, documentation, unit testing, and using pre-commit hooks to maintain code quality.
- [Installing angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/getting-started/installing.html): This document provides instructions for installing the angr binary analysis framework using PyPI, source, or Docker. It also includes troubleshooting tips for common installation issues.
- [angr Documentation](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest.md): This document provides a comprehensive guide to the angr binary analysis framework, covering its core concepts, built-in analyses, advanced topics, and API, along with examples and troubleshooting tips. It also details the libraries that comprise angr, such as archinfo, pyvex, cle, and claripy.
- [Introduction to angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/quickstart.html): This document provides an introduction to angr, a powerful binary analysis toolkit capable of dynamic symbolic execution and static analyses. It outlines the challenges in binary analysis, explains angr's components for addressing them, and offers resources for support, citation, and further learning through papers and CTF challenges.
- [angr Documentation](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/_sources/index.rst.txt): This document provides a comprehensive guide to learning and using angr, a powerful platform for program analysis. It covers various aspects including an introduction to angr's libraries like archinfo, pyvex, pypcode, cle, and claripy, along with information on angr-management, core concepts, analyses, advanced topics, extensions, examples, FAQ, and API references.
- [Migration 7](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/appendix/migration-7.html): A summary for migration-7.html.
- [Migration 8](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/appendix/migration-8.html): A summary for migration-8.html.
- [Migrating to angr 9.1](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/appendix/migration-9.1.html): This document outlines the significant changes in angr 9.1, focusing on the refactoring of SimCC (Simulated Calling Conventions). Key updates include the mandatory use of SimTypes for typed data interactions, changes in how SimCCs are customized via SimCCUsercall, and the introduction of a `buffer` parameter for PointerWrapper to better handle array-like data. It also covers the renaming of `func_ty` to `prototype` for consistency and highlights that functions like `call_state`, `callable`, and `SimProcedure.call()` now require a prototype.
- [angr Changelog](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/appendix/changelog.html): This document details the changelog for the angr software, covering major versions and releases from 9.1 down to 7.8.6.16. It highlights significant changes, new features, bug fixes, and refactors, including improvements to CFG recovery, decompiler implementation, C++ support, and Python 3 transition.
- [More Examples](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/appendix/more-examples.html): A summary for more-examples.html.
- [Angr State Options and Modes](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/appendix/options.html): This document provides a comprehensive list of state options, modes, and sets available within the angr documentation. It details various configurations for symbolic execution, static analysis, and tracing, explaining their purpose and applicability. The options range from memory and register handling to performance optimizations and error resilience, categorizing them by their function and the contexts in which they are used.
- [Ops](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/appendix/ops.html): A summary for ops.html.
- [Cheatsheet](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/appendix/cheatsheet.html): A summary for cheatsheet.html.
- [Frequently Asked Questions about angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/faq.html): This document answers frequently asked questions about the angr software, covering topics such as its naming, stylization, troubleshooting symbolic execution, obtaining diagnostic information, performance considerations, bug finding strategies, the choice of VEX intermediate representation, ARM address indexing, object serialization, and reasons for unsupported floating-point operations.
- [angr Examples](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/examples.html): This document outlines various examples of using the angr tool for reverse engineering, vulnerability discovery, and exploitation assistance. It categorizes examples like Fauxware, little_engine, whitehat CTF crypto, wyvern, zwiebel, FlareOn challenge 5, 0ctf trace, license, and Crackme2000, detailing script authors, runtimes, and key concepts demonstrated.
- [Writing Analyses in angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/extending-angr/analysis_writing.html): This document explains how to write custom analyses in angr by subclassing the 'angr.Analysis' class. It covers registering new analyses, accessing the project, and implementing resilient analysis execution using a context manager that handles exceptions gracefully.
- [Extending the Environment Model in angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/extending-angr/environment.html): This document explains how to extend angr's environment model by implementing SimProcedures for dynamic library functions and system calls. It covers both in-tree and out-of-tree development approaches, detailing how to integrate custom procedures using SimLibraries, catalogues, and project-level hooks. The guide also delves into syscall handling, explaining the role of SimSyscallLibrary and SimUserland in managing syscall interfaces across different ABIs.
- [State Plugins](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/extending-angr/state_plugins.html): This document explains angr's state plugins, which are used to store data on a state in an object-oriented way. It covers how to create a basic plugin, the methods involved in the state lifecycle (copying, merging, and serialization), and how plugins can contain other plugins.
- [Hooks and SimProcedures in angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/extending-angr/simprocedures.html): This document explains how to use hooks and SimProcedures in angr, a framework for symbolic execution. It covers the basics of creating SimProcedures, handling arguments and return values, managing control flow within SimProcedures, and advanced topics like conditional exits and continuations for calling binary functions from SimProcedures.
- [Debug variable resolution in angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/advanced-topics/debug_var.html): This document explains how to use angr's feature for resolving source-level debug variables in binaries. It covers setup steps, including compiling with debug information and loading it in angr, and demonstrates how to access variable values and dereference pointers using `state.dvars`. The guide also explains how angr handles variables with the same name in different scopes, prioritizing the nearest one.
- [Symbion: Interleaving Symbolic and Concrete Execution](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/advanced-topics/symbion.html): Symbion is a technique for interleaving symbolic and concrete execution in the angr framework. It allows users to import a concrete program state into angr, make parts of it symbolic, perform symbolic analysis, and then resume concrete execution. This enables advanced interactive analyses by bridging external program execution with angr's symbolic capabilities. The tool provides a default GDB-based concrete target and discusses state options like SYMBION_SYNC_CLE for memory mapping and SYMBION_KEEP_STUBS_ON_SYNC for handling function hooking.
- [Java Support in angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/advanced-topics/java_support.html): Provides an overview of angr's experimental support for symbolically executing Java code and Android apps, including installation instructions and examples. It details the use of pysoot for Java bytecode analysis and its ability to handle mixed Java and native code execution, along with static analysis and string constraint solving.
- [Symbolic Memory Addressing Concretization Strategies](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/advanced-topics/concretization_strategies.html): This document explains angr's symbolic memory addressing, detailing how it concretizes symbolic addresses during memory writes, which can differ from symbolic reads. It outlines the default concretization strategies for writes, including a conditional strategy for annotated indices and a strategy that selects the maximum possible solution. The document also provides guidance on enabling symbolic writes for all indices by setting state options or manually inserting a SimConcretizationStrategyRange object, and briefly mentions the process of writing custom strategies.
- [Claripy Solver Engine Overview](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/advanced-topics/claripy.html): This document provides a comprehensive overview of angr's solver engine, Claripy, detailing its architecture including ASTs, Frontends, Backends, and Solvers. It explains how Claripy unifies the representation and evaluation of concrete and symbolic expressions using various backends like Z3 and VSA, and outlines the different types of ASTs (BitVector, Floating-Point, Boolean) with usage examples. The document also introduces the various Claripy solvers (Solver, SolverVSA, SolverReplacement, SolverHybrid) and common AST operations.
- [Working with Data and Conventions in angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/advanced-topics/structured_data.html): This document explains how to work with various data conventions in angr, including structured data types, memory access, and calling conventions. It details angr's SimTypes system for parsing and representing C types, accessing typed data from memory using the state.mem interface, and managing function calling conventions with SimCC for cleaner argument handling. The document also covers Callables as a FFI for symbolic execution, enabling the creation of symbolic functions and managing their arguments and return values.
- [Intermediate Representation (VEX) in angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/advanced-topics/ir.html): This document provides an in-depth explanation of angr's Intermediate Representation (IR), known as VEX. It details how VEX abstracts architectural differences in registers, memory access, and instruction side-effects to facilitate unified program analysis across various CPU architectures like x86, MIPS, and ARM. The document breaks down VEX's core components, including Expressions, Operations, Temporary variables, Statements, and Blocks, and illustrates their usage with examples of IR translation. It also introduces PyVEX, the Python library used by angr to interact with VEX, and provides practical examples of its application.
- [File System](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/advanced-topics/file_system.html): A summary for file_system.html.
- [Optimization considerations for angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/advanced-topics/speed.html): This document provides a comprehensive guide to optimizing the performance of the angr binary analysis framework. It covers general speed tips such as using PyPy, selectively using SimEngine mixins, managing shared libraries, and employing SimProcedures and SimInspect. It also details strategies for concrete or partially-concrete execution, including the use of the Unicorn engine, fast memory/registers, ahead-of-time input concretization, and the "afterburner" for threshold-based concretization. Memory optimization techniques, like managing state references and trimming state history, are also discussed.
- [Mixins in Python and angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/advanced-topics/mixins.html): This document provides a comprehensive explanation of the mixin design pattern in Python, detailing its implementation and benefits in software development. It further elaborates on the practical application of mixins within the angr framework, specifically in the context of SimEngine and VEX analysis, illustrating how they facilitate modularity and code reuse for enhanced functionality and instrumentation.
- [Understanding the Execution Pipeline](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/advanced-topics/pipeline.html): This document details the execution pipeline of the angr framework, explaining the roles of Simulation Managers, Exploration Techniques, SimState, and SimEngine. It covers how actions like `run()` and `step()` are processed, including the instrumentation capabilities of exploration techniques and the functioning of various engine mixins like `SimEngineSyscall` and `HeavyVEXMixin`.
- [Gotchas when using angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/advanced-topics/gotchas.html): This document outlines common issues ("gotchas") encountered when using the angr symbolic execution framework. It covers problems with SimProcedures (function summaries), unsupported system calls, the symbolic memory model, handling symbolic lengths in operations, and division by zero errors with the Z3 solver. The guide suggests workarounds such as disabling or replacing SimProcedures, implementing missing system calls, or adjusting memory concretization strategies.
- [Advanced Topics in angr Documentation](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/advanced-topics/index.html): This markdown file details advanced topics in the angr documentation, covering execution pipeline, mixins, optimization, file system interactions, intermediate representation, structured data, solver engine, symbolic memory addressing, Java support, Symbion, and debug variable resolution.
- [Angr Decompiler Analysis Passes](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/analyses/decompiler.html): This document outlines the analysis passes of the angr Decompiler, detailing the control flow graph recovery, indirect branch resolving, stack pointer analysis, IR lifting, AIL graph building, and various simplification passes including dead assignment elimination, peephole optimizations, and variable type inference. It also covers structure analysis and code generation.
- [Identifier](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/analyses/identifier.html): The angr Identifier analysis identifies common library functions in CGC binaries by prefiltering based on stack variable and argument information. It provides addresses and names of recognized functions, with examples of its usage in identifying functions like memcmp, memcpy, and malloc.
- [Backward Slicing with angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/analyses/backward_slice.html): This document explains backward slicing using the angr framework. It details the requirements for creating a backward slice, including control flow graphs (CFGs), and provides code examples for using the `BackwardSlice` analysis. The document also covers the members of the `BackwardSlice` object and discusses implementation details, limitations, and soundness.
- [Control-Flow Graph Recovery in angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/analyses/cfg.html): This document describes angr's Control-Flow Graph (CFG) recovery capabilities, detailing two methods: CFGFast for static analysis and CFGEmulated for dynamic analysis using symbolic execution. It explains how to generate, use, and interpret CFGs, including node and edge properties, and how to manage functions and their attributes within angr. The document also covers CFGFast's specific mechanisms for identifying function starts and handling function returns, as well as considerations for shared libraries.
- [Be Creative: Advice for Angr Usage](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/core-concepts/be_creative.html): This document provides advice for users of the angr binary analysis framework, emphasizing creativity and community support while covering fundamental components and advanced tuning for complex scenarios.
- [Symbolic Execution with angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/core-concepts/symbolic.html): Symbolic execution is a program analysis technique that explores multiple program paths by treating inputs as symbolic variables instead of concrete values. It allows for the discovery of bugs and vulnerabilities by analyzing constraints generated from symbolic expressions. The document provides an example of symbolic execution with the angr framework to find valid inputs that reach a specific function.
- [Analyses](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/core-concepts/analyses.html): This document provides an overview of angr's built-in analyses, including CFGFast, CFGEmulated, VFG, DDG, BackwardSlice, and Identifier. It also explains how to write resilient analyses that can handle errors or run in "fail fast" mode.
- [Simulation and Instrumentation in angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/core-concepts/simulation.html): This document details angr's simulation and instrumentation capabilities, covering its various execution engines (failure, syscall, hook, unicorn, VEX) and the SimSuccessors object which categorizes successor states based on execution conditions. It also explains how to set breakpoints on various events like memory access, register operations, and instruction translation, with examples of using callbacks or IPython for debugging.
- [Simulation Managers](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/core-concepts/pathgroups.html): This document explains angr's SimulationManager, a tool for controlling symbolic execution. It details how to manage multiple states using stashes, step through execution, and use methods like .run() and .explore() for program analysis. The document also covers stash management, different stash types (active, deadended, pruned, unconstrained, unsat), and handling execution errors.
- [Machine State in angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/core-concepts/states.html): This document provides a comprehensive guide to understanding and manipulating machine states within the angr framework. It covers the structure of SimState objects, including memory and register access, and demonstrates basic and advanced execution techniques using state.step(). The document also explains how symbolic execution handles branching conditions and introduces various state constructors like blank_state, entry_state, full_init_state, and call_state for different analysis scenarios.
- [Symbolic Expressions and Constraint Solving in angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/core-concepts/solver.html): This document explains angr's symbolic execution capabilities, focusing on how to work with symbolic variables and bitvectors. It details the creation of symbolic variables, performing arithmetic and logical operations on them to create Abstract Syntax Trees (ASTs), and how these ASTs are translated into constraints for SMT solvers. The document also covers symbolic booleans, constraint satisfaction, and using the solver to find concrete values that satisfy predefined conditions.
- [Loading Binaries with Angr's CLE](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/core-concepts/loading.html): This document details how to use angr's CLE (cle loads everything) component to load and dissect binary files. It covers accessing loaded objects, their properties like entry points and memory regions, and working with symbols and relocations, including import and export symbols.
- [Angr Core Concepts](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/core-concepts/toplevel.html): This document provides an overview of angr's core concepts, including projects, basic properties like architecture and entry point, and the loading process using CLE. It details how to work with basic blocks and simulated states, emphasizing the use of bitvectors for representing CPU data and interacting with registers and memory. The factory pattern for object creation and the `claripy` library for bitvector manipulation are also introduced.
- [Help Wanted in angr Development](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/getting-started/helpwanted.html): This document outlines various ways the community can contribute to the angr framework, including documentation improvements, research reimplementations, development tasks like GUI enhancements and adding new architectures, and tackling design and research challenges. It lists specific TODO items and GitHub issues tagged with "Help wanted" to guide potential contributors.
- [Angr Development and Bug Reporting Guidelines](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/getting-started/developing.html): This document outlines the process for reporting bugs in the angr framework, including steps for forking repositories, creating pull requests with test cases, and adhering to bug-fixing conventions. It also provides detailed guidelines for developing angr, covering pre-commit hooks, coding style (using black and PEP8), documentation standards (using Sphinx and ReStructured Text), and unit testing procedures with nosetests.
- [Installing angr](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/getting-started/installing.html): This document provides instructions for installing angr, a binary analysis framework. It covers installation via PyPI (recommended), from source, and using Docker. It also includes troubleshooting tips for common issues like missing attributes or attribute errors.
- [Api](https://raw.githubusercontent.com/dyingc/mcp_docs/master/docs_output/angr/en/latest/api.html): A summary for api.html.
