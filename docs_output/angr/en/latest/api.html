# API Reference - angr documentation

# API Reference¶

_class _angr.BP(_when ='before'_, _enabled =None_, _condition =None_, _action =None_, _** kwargs_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A breakpoint.

__init__(_when ='before'_, _enabled =None_, _condition =None_, _action =None_, _** kwargs_)¶
    

check(_state_ , _when_)¶
    

Checks state state to see if the breakpoint should fire.

Parameters:
    

  * **state** – The state.

  * **when** – Whether the check is happening before or after the event.

Returns:
    

A boolean representing whether the checkpoint should fire.

fire(_state_)¶
    

Trigger the breakpoint.

Parameters:
    

**state** – The state.

_class _angr.Analysis¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

This class represents an analysis on the program.

Variables:
    

  * **project** – The project for this analysis.

  * **kb** (_KnowledgeBase_) – The knowledgebase object.

  * **_progress_callback** – A callback function for receiving the progress of this analysis. It only takes one argument, which is a float number from 0.0 to 100.0 indicating the current progress.

  * **_show_progressbar** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If a progressbar should be shown during the analysis. It’s independent from _progress_callback.

  * **_progressbar** (_progress.Progress_) – The progress bar object.

project _: Project_¶
    

kb _: KnowledgeBase_¶
    

errors _: list[AnalysisLogEntry]__ = []_¶
    

named_errors _: defaultdict[str, list[AnalysisLogEntry]]__ = {}_¶
    

_exception _angr.AngrAnalysisError¶
    

Bases: `AngrError`

_exception _angr.AngrAnnotatedCFGError¶
    

Bases: `AngrError`

_exception _angr.AngrAssemblyError¶
    

Bases: `AngrError`

_exception _angr.AngrBackwardSlicingError¶
    

Bases: `AngrError`

_exception _angr.AngrBladeError¶
    

Bases: `AngrError`

_exception _angr.AngrBladeSimProcError¶
    

Bases: `AngrBladeError`

_exception _angr.AngrCFGError¶
    

Bases: `AngrError`

_exception _angr.AngrCallableError¶
    

Bases: `AngrSurveyorError`

_exception _angr.AngrCallableMultistateError¶
    

Bases: `AngrCallableError`

_exception _angr.AngrCorruptDBError¶
    

Bases: `AngrDBError`

_exception _angr.AngrDBError¶
    

Bases: `AngrError`

_exception _angr.AngrDDGError¶
    

Bases: `AngrAnalysisError`

_exception _angr.AngrDataGraphError¶
    

Bases: `AngrAnalysisError`

_exception _angr.AngrDecompilationError¶
    

Bases: `AngrError`

_exception _angr.AngrDelayJobNotice¶
    

Bases: `AngrForwardAnalysisError`

_exception _angr.AngrDirectorError¶
    

Bases: `AngrExplorationTechniqueError`

_exception _angr.AngrError¶
    

Bases: [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception "\(in Python v3.13\)")

_exception _angr.AngrExitError¶
    

Bases: `AngrError`

_exception _angr.AngrExplorationTechniqueError¶
    

Bases: `AngrError`

_exception _angr.AngrExplorerError¶
    

Bases: `AngrExplorationTechniqueError`

_exception _angr.AngrForwardAnalysisError¶
    

Bases: `AngrError`

_exception _angr.AngrIncompatibleDBError¶
    

Bases: `AngrDBError`

_exception _angr.AngrIncongruencyError¶
    

Bases: `AngrAnalysisError`

_exception _angr.AngrInvalidArgumentError¶
    

Bases: `AngrError`

_exception _angr.AngrJobMergingFailureNotice¶
    

Bases: `AngrForwardAnalysisError`

_exception _angr.AngrJobWideningFailureNotice¶
    

Bases: `AngrForwardAnalysisError`

_exception _angr.AngrLifterError¶
    

Bases: `AngrError`

_exception _angr.AngrLoopAnalysisError¶
    

Bases: `AngrAnalysisError`

_exception _angr.AngrMissingTypeError¶
    

Bases: `AngrTypeError`

_exception _angr.AngrNoPluginError¶
    

Bases: `AngrError`

_exception _angr.AngrPathError¶
    

Bases: `AngrError`

_exception _angr.AngrRuntimeError¶
    

Bases: [`RuntimeError`](https://docs.python.org/3/library/exceptions.html#RuntimeError "\(in Python v3.13\)")

_exception _angr.AngrSimOSError¶
    

Bases: `AngrError`

_exception _angr.AngrSkipJobNotice¶
    

Bases: `AngrForwardAnalysisError`

_exception _angr.AngrSurveyorError¶
    

Bases: `AngrError`

_exception _angr.AngrSyscallError¶
    

Bases: `AngrError`

_exception _angr.AngrTracerError¶
    

Bases: `AngrExplorationTechniqueError`

_exception _angr.AngrTypeError¶
    

Bases: `AngrError`, [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "\(in Python v3.13\)")

_exception _angr.AngrUnsupportedSyscallError¶
    

Bases: `AngrSyscallError`, `SimProcedureError`, `SimUnsupportedError`

_exception _angr.AngrVFGError¶
    

Bases: `AngrError`

_exception _angr.AngrVFGRestartAnalysisNotice¶
    

Bases: `AngrVFGError`

_exception _angr.AngrValueError¶
    

Bases: `AngrError`, [`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError "\(in Python v3.13\)")

_exception _angr.AngrVaultError¶
    

Bases: `AngrError`

_class _angr.Blade(_graph_ , _dst_run_ , _dst_stmt_idx_ , _direction ='backward'_, _project =None_, _cfg =None_, _ignore_sp =False_, _ignore_bp =False_, _ignored_regs =None_, _max_level =3_, _base_state =None_, _stop_at_calls =False_, _cross_insn_opt =False_, _max_predecessors =10_, _include_imarks =True_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Blade is a light-weight program slicer that works with networkx DiGraph containing CFGNodes. It is meant to be used in angr for small or on-the-fly analyses.

Parameters:
    

  * **graph** (_networkx.DiGraph_)

  * **dst_run** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **dst_stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **direction** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **ignore_sp** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **ignore_bp** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **max_level** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **stop_at_calls** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **max_predecessors** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **include_imarks** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_graph_ , _dst_run_ , _dst_stmt_idx_ , _direction ='backward'_, _project =None_, _cfg =None_, _ignore_sp =False_, _ignore_bp =False_, _ignored_regs =None_, _max_level =3_, _base_state =None_, _stop_at_calls =False_, _cross_insn_opt =False_, _max_predecessors =10_, _include_imarks =True_)¶
    

Parameters:
    

  * **graph** (`DiGraph`) – A graph representing the control flow graph. Note that it does not take angr.analyses.CFGEmulated or angr.analyses.CFGFast.

  * **dst_run** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – An address specifying the target SimRun.

  * **dst_stmt_idx** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The target statement index. -1 means executing until the last statement.

  * **direction** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – ‘backward’ or ‘forward’ slicing. Forward slicing is not yet supported.

  * **project** (_angr.Project_) – The project instance.

  * **cfg** (_angr.analyses.CFGBase_) – the CFG instance. It will be made mandatory later.

  * **ignore_sp** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether the stack pointer should be ignored in dependency tracking. Any dependency from/to stack pointers will be ignored if this options is True.

  * **ignore_bp** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether the base pointer should be ignored or not.

  * **max_level** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The maximum number of blocks that we trace back for.

  * **stop_at_calls** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Limit slicing within a single function. Do not proceed when encounters a call edge.

  * **include_imarks** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Should IMarks (instruction boundaries) be included in the slice.

  * **max_predecessors** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

Returns:
    

None

_property _slice¶
    

dbg_repr(_arch =None_)¶
    

_class _angr.Block(_addr_ , _project =None_, _arch =None_, _size =None_, _max_size =None_, _byte_string =None_, _thumb =False_, _backup_state =None_, _extra_stop_points =None_, _opt_level =None_, _num_inst =None_, _traceflags =0_, _strict_block_end =None_, _collect_data_refs =False_, _cross_insn_opt =True_, _load_from_ro_regions =False_, _const_prop =False_, _initial_regs =None_, _skip_stmts =False_)¶
    

Bases: `Serializable`

Represents a basic block in a binary or a program.

Parameters:
    

**arch** (_Arch_ _|__None_)

BLOCK_MAX_SIZE _ = 4096_¶
    

__init__(_addr_ , _project =None_, _arch =None_, _size =None_, _max_size =None_, _byte_string =None_, _thumb =False_, _backup_state =None_, _extra_stop_points =None_, _opt_level =None_, _num_inst =None_, _traceflags =0_, _strict_block_end =None_, _collect_data_refs =False_, _cross_insn_opt =True_, _load_from_ro_regions =False_, _const_prop =False_, _initial_regs =None_, _skip_stmts =False_)¶
    

Parameters:
    

**arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)") _|__None_)

arch¶
    

addr¶
    

thumb¶
    

size¶
    

pp(_** kwargs_)¶
    

set_initial_regs()¶
    

_static _reset_initial_regs()¶
    

_property _vex _: [IRSB](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.block.IRSB "\(in pyvex\)") | IRSB_¶
    

_property _vex_nostmt¶
    

_property _disassembly _: DisassemblerBlock_¶
    

Provide a disassembly object using whatever disassembler is available

_property _capstone _: CapstoneBlock_¶
    

_property _codenode¶
    

_property _bytes _: [bytes](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

_property _instructions _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_property _instruction_addrs¶
    

serialize_to_cmessage()¶
    

Serialize the class object and returns a protobuf cmessage object.

Returns:
    

A protobuf cmessage object.

Return type:
    

protobuf.cmessage

_classmethod _parse_from_cmessage(_cmsg_)¶
    

Parse a protobuf cmessage and create a class object.

Parameters:
    

**cmsg** – The probobuf cmessage object.

Returns:
    

A unserialized class object.

Return type:
    

cls

_class _angr.Emulator(_engine_ , _init_state_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Emulator is a utility that adapts an angr ConcreteEngine to a more user-friendly interface for concrete execution. It only supports concrete execution and requires a ConcreteEngine.

Saftey: This class is not thread-safe. It should only be used in a single-threaded context. It can be safely shared between multiple threads, provided that only one thread is using it at a time.

Parameters:
    

  * **engine** (_ConcreteEngine_)

  * **init_state** (_HeavyConcreteState_)

__init__(_engine_ , _init_state_)¶
    

Parameters:
    

  * **engine** (`ConcreteEngine`) – The ConcreteEngine to use for emulation.

  * **init_state** (`SimState`[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – The initial state to use for emulation.

_property _state _: SimState[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]_¶
    

The current state of the emulator.

_property _breakpoints _: [set](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]_¶
    

The set of currently set breakpoints.

add_breakpoint(_addr_)¶
    

Add a breakpoint at the given address.

Parameters:
    

**addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address to set the breakpoint at.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

remove_breakpoint(_addr_)¶
    

Remove a breakpoint at the given address, if present.

Parameters:
    

**addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address to remove the breakpoint from.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

run(_num_inst =None_)¶
    

Execute the emulator.

Return type:
    

`EmulatorStopReason`

Parameters:
    

**num_inst** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

_class _angr.EmulatorStopReason(_value_)¶
    

Bases: [`Enum`](https://docs.python.org/3/library/enum.html#enum.Enum "\(in Python v3.13\)")

Enum representing the reason for stopping the emulator.

INSTRUCTION_LIMIT _ = 'instruction_limit'_¶
    

BREAKPOINT _ = 'breakpoint'_¶
    

NO_SUCCESSORS _ = 'no_successors'_¶
    

MEMORY_ERROR _ = 'memory_error'_¶
    

FAILURE _ = 'failure'_¶
    

EXIT _ = 'exit'_¶
    

_class _angr.ExplorationTechnique¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

An ExplorationTechnique is a set of hooks for a simulation manager that assists in the implementation of new techniques in symbolic exploration.

Any number of these methods may be overridden by a subclass. To use an exploration technique, call `simgr.use_technique` with an _instance_ of the technique.

__init__()¶
    

setup(_simgr_)¶
    

Perform any initialization on this manager you might need to do.

Parameters:
    

**simgr** (_angr.SimulationManager_) – The simulation manager to which you have just been added

step(_simgr_ , _stash ='active'_, _** kwargs_)¶
    

Hook the process of stepping a stash forward. Should call `simgr.step(stash, **kwargs)` in order to do the actual processing.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

filter(_simgr_ , _state_ , _** kwargs_)¶
    

Perform filtering on which stash a state should be inserted into.

If the state should be filtered, return the name of the stash to move the state to. If you want to modify the state before filtering it, return a tuple of the stash to move the state to and the modified state. To defer to the original categorization procedure, return the result of `simgr.filter(state, **kwargs)`

If the user provided a `filter_func` in their step or run command, it will appear here.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

selector(_simgr_ , _state_ , _** kwargs_)¶
    

Determine if a state should participate in the current round of stepping. Return True if the state should be stepped, and False if the state should not be stepped. To defer to the original selection procedure, return the result of `simgr.selector(state, **kwargs)`.

If the user provided a `selector_func` in their step or run command, it will appear here.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

step_state(_simgr_ , _state_ , _** kwargs_)¶
    

Determine the categorization of state successors into stashes. The result should be a dict mapping stash names to the list of successor states that fall into that stash, or None as a stash name to use the original stash name.

If you would like to directly work with a SimSuccessors object, you can obtain it with `simgr.successors(state, **kwargs)`. This is not recommended, as it denies other hooks the opportunity to look at the successors. Therefore, the usual technique is to call `simgr.step_state(state, **kwargs)` and then mutate the returned dict before returning it yourself.

..note:: This takes precedence over the filter hook - filter is only applied to states returned from here in the None stash.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

successors(_simgr_ , _state_ , _** kwargs_)¶
    

Perform the process of stepping a state forward, returning a SimSuccessors object.

To defer to the original succession procedure, return the result of `simgr.successors(state, **kwargs)`. Be careful about not calling this method (e.g. calling `project.factory.successors` manually) as it denies other hooks the opportunity to instrument the step. Instead, you can mutate the kwargs for the step before calling the original, and mutate the result before returning it yourself.

If the user provided a `successor_func` in their step or run command, it will appear here.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

complete(_simgr_)¶
    

Return whether or not this manager has reached a “completed” state, i.e. `SimulationManager.run()` should halt.

This is the one hook which is _not_ subject to the nesting rules of hooks. You should _not_ call `simgr.complete`, you should make your own decision and return True or False. Each of the techniques’ completion checkers will be called and the final result will be compted with `simgr.completion_mode`.

Parameters:
    

**simgr** (_angr.SimulationManager_)

_class _angr.KnowledgeBase(_project_ , _obj =None_, _name =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Represents a “model” of knowledge about an artifact.

Contains things like a CFG, data references, etc.

functions _: `FunctionManager`_¶
    

variables _: `VariableManager`_¶
    

defs _: `KeyDefinitionManager`_¶
    

cfgs _: `CFGManager`_¶
    

types _: `TypesStore`_¶
    

propagations _: `PropagationManager`_¶
    

xrefs _: `XRefManager`_¶
    

decompilations _: `StructuredCodeManager`_¶
    

__init__(_project_ , _obj =None_, _name =None_)¶
    

_property _callgraph¶
    

_property _unresolved_indirect_jumps¶
    

_property _resolved_indirect_jumps¶
    

has_plugin(_name_)¶
    

get_plugin(_name_)¶
    

register_plugin(_name_ , _plugin_)¶
    

release_plugin(_name_)¶
    

K _ = ~K_¶
    

get_knowledge(_requested_plugin_cls_)¶
    

Type inference safe method to request a knowledge base plugin Explicitly passing the type of the requested plugin achieves two things: 1\. Every location using this plugin can be easily found with an IDE by searching explicit references to the type 2\. Basic type inference can deduce the result type and properly type check usages of it

If there isn’t already an instance of this class None will be returned to make it clear to the caller that there is no existing knowledge of this type yet. The code that initially creates this knowledge should use the register_plugin method to register the initial knowledge state :type requested_plugin_cls: type[K] :param requested_plugin_cls: :rtype: K | None :return: Instance of the requested plugin class or null if it is not a known plugin

Parameters:
    

**requested_plugin_cls** ([_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__K_ _]_)

Return type:
    

K | None

request_knowledge(_requested_plugin_cls_)¶
    

Return type:
    

K

Parameters:
    

**requested_plugin_cls** ([_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__K_ _]_)

_class _angr.PTChunk(_base_ , _sim_state_ , _heap =None_)¶
    

Bases: `Chunk`

A chunk, inspired by the implementation of chunks in ptmalloc. Provides a representation of a chunk via a view into the memory plugin. For the chunk definitions and docs that this was loosely based off of, see glibc malloc/malloc.c, line 1033, as of commit 5a580643111ef6081be7b4c7bd1997a5447c903f. Alternatively, take the following link. <https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=67cdfd0ad2f003964cd0f7dfe3bcd85ca98528a7;hb=5a580643111ef6081be7b4c7bd1997a5447c903f#l1033>

Variables:
    

  * **base** – the location of the base of the chunk in memory

  * **state** – the program state that the chunk is resident in

  * **heap** – the heap plugin that the chunk is managed by

__init__(_base_ , _sim_state_ , _heap =None_)¶
    

get_size()¶
    

Returns the actual size of a chunk (as opposed to the entire size field, which may include some flags).

get_data_size()¶
    

Returns the size of the data portion of a chunk.

set_size(_size_ , _is_free =None_)¶
    

Use this to set the size on a chunk. When the chunk is new (such as when a free chunk is shrunk to form an allocated chunk and a remainder free chunk) it is recommended that the is_free hint be used since setting the size depends on the chunk’s freeness, and vice versa.

Parameters:
    

  * **size** – size of the chunk

  * **is_free** – boolean indicating the chunk’s freeness

set_prev_freeness(_is_free_)¶
    

Sets (or unsets) the flag controlling whether the previous chunk is free.

Parameters:
    

**is_free** – if True, sets the previous chunk to be free; if False, sets it to be allocated

is_prev_free()¶
    

Returns a concrete state of the flag indicating whether the previous chunk is free or not. Issues a warning if that flag is symbolic and has multiple solutions, and then assumes that the previous chunk is free.

Returns:
    

True if the previous chunk is free; False otherwise

prev_size()¶
    

Returns the size of the previous chunk, masking off what would be the flag bits if it were in the actual size field. Performs NO CHECKING to determine whether the previous chunk size is valid (for example, when the previous chunk is not free, its size cannot be determined).

is_free()¶
    

Returns a concrete determination as to whether the chunk is free.

data_ptr()¶
    

Returns the address of the payload of the chunk.

next_chunk()¶
    

Returns the chunk immediately following (and adjacent to) this one, if it exists.

Returns:
    

The following chunk, or None if applicable

prev_chunk()¶
    

Returns the chunk immediately prior (and adjacent) to this one, if that chunk is free. If the prior chunk is not free, then its base cannot be located and this method raises an error.

Returns:
    

If possible, the previous chunk; otherwise, raises an error

fwd_chunk()¶
    

Returns the chunk following this chunk in the list of free chunks. If this chunk is not free, then it resides in no such list and this method raises an error.

Returns:
    

If possible, the forward chunk; otherwise, raises an error

set_fwd_chunk(_fwd_)¶
    

Sets the chunk following this chunk in the list of free chunks.

Parameters:
    

**fwd** – the chunk to follow this chunk in the list of free chunks

bck_chunk()¶
    

Returns the chunk backward from this chunk in the list of free chunks. If this chunk is not free, then it resides in no such list and this method raises an error.

Returns:
    

If possible, the backward chunk; otherwise, raises an error

set_bck_chunk(_bck_)¶
    

Sets the chunk backward from this chunk in the list of free chunks.

Parameters:
    

**bck** – the chunk to precede this chunk in the list of free chunks

_exception _angr.PathUnreachableError¶
    

Bases: `AngrPathError`

_class _angr.PointerWrapper(_value_ , _buffer =False_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_value_ , _buffer =False_)¶
    

_class _angr.Project(_thing_ , _default_analysis_mode =None_, _ignore_functions =None_, _use_sim_procedures =True_, _exclude_sim_procedures_func =None_, _exclude_sim_procedures_list =()_, _arch =None_, _simos =None_, _engine =None_, _load_options =None_, _translation_cache =True_, _selfmodifying_code =False_, _support_selfmodifying_code =None_, _store_function =None_, _load_function =None_, _analyses_preset =None_, _concrete_target =None_, _eager_ifunc_resolution =None_, _** kwargs_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

This is the main class of the angr module. It is meant to contain a set of binaries and the relationships between them, and perform analyses on them.

Parameters:
    

  * **thing** – The path to the main executable object to analyze, or a CLE Loader object.

  * **arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)"))

  * **load_options** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__Any_ _]__|__None_)

  * **selfmodifying_code** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **support_selfmodifying_code** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

The following parameters are optional.

Parameters:
    

  * **default_analysis_mode** – The mode of analysis to use by default. Defaults to ‘symbolic’.

  * **ignore_functions** – A list of function names that, when imported from shared libraries, should never be stepped into in analysis (calls will return an unconstrained value).

  * **use_sim_procedures** – Whether to replace resolved dependencies for which simprocedures are available with said simprocedures.

  * **exclude_sim_procedures_func** – A function that, when passed a function name, returns whether or not to wrap it with a simprocedure.

  * **exclude_sim_procedures_list** – A list of functions to _not_ wrap with simprocedures.

  * **arch** – The target architecture (auto-detected otherwise).

  * **simos** – a SimOS class to use for this project.

  * **engine** – The SimEngine class to use for this project.

  * **translation_cache** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If True, cache translated basic blocks rather than re-translating them.

  * **selfmodifying_code** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether we aggressively support self-modifying code. When enabled, emulation will try to read code from the current state instead of the original memory, regardless of the current memory protections.

  * **store_function** – A function that defines how the Project should be stored. Default to pickling.

  * **load_function** – A function that defines how the Project should be loaded. Default to unpickling.

  * **analyses_preset** (_angr.misc.PluginPreset_) – The plugin preset for the analyses provider (i.e. Analyses instance).

  * **load_options** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__Any_ _]__|__None_)

  * **support_selfmodifying_code** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

Any additional keyword arguments passed will be passed onto `cle.Loader`.

Variables:
    

  * **analyses** – The available analyses.

  * **entry** – The program entrypoint.

  * **factory** – Provides access to important analysis elements such as path groups and symbolic execution results.

  * **filename** – The filename of the executable.

  * **loader** – The program loader.

  * **storage** – Dictionary of things that should be loaded/stored with the Project.

Parameters:
    

  * **arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)"))

  * **load_options** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__Any_ _]__|__None_)

  * **selfmodifying_code** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **support_selfmodifying_code** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

__init__(_thing_ , _default_analysis_mode =None_, _ignore_functions =None_, _use_sim_procedures =True_, _exclude_sim_procedures_func =None_, _exclude_sim_procedures_list =()_, _arch =None_, _simos =None_, _engine =None_, _load_options =None_, _translation_cache =True_, _selfmodifying_code =False_, _support_selfmodifying_code =None_, _store_function =None_, _load_function =None_, _analyses_preset =None_, _concrete_target =None_, _eager_ifunc_resolution =None_, _** kwargs_)¶
    

Parameters:
    

  * **load_options** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]__|__None_)

  * **selfmodifying_code** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **support_selfmodifying_code** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

arch _: [`Arch`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)")_¶
    

_property _kb¶
    

get_kb(_name_)¶
    

_property _analyses _: AnalysesHubWithDefault_¶
    

hook(_addr_ , _hook =None_, _length =0_, _kwargs =None_, _replace =False_)¶
    

Hook a section of code with a custom function. This is used internally to provide symbolic summaries of library functions, and can be used to instrument execution or to modify control flow.

When hook is not specified, it returns a function decorator that allows easy hooking. Usage:
    
    
    # Assuming proj is an instance of angr.Project, we will add a custom hook at the entry
    # point of the project.
    @proj.hook(proj.entry)
    def my_hook(state):
        print("Welcome to execution!")
    

Parameters:
    

  * **addr** – The address to hook.

  * **hook** – A `angr.project.Hook` describing a procedure to run at the given address. You may also pass in a SimProcedure class or a function directly and it will be wrapped in a Hook object for you.

  * **length** – If you provide a function for the hook, this is the number of bytes that will be skipped by executing the hook by default.

  * **kwargs** – If you provide a SimProcedure for the hook, these are the keyword arguments that will be passed to the procedure’s run method eventually.

  * **replace** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")) – Control the behavior on finding that the address is already hooked. If true, silently replace the hook. If false (default), warn and do not replace the hook. If none, warn and replace the hook.

is_hooked(_addr_)¶
    

Returns True if addr is hooked.

Parameters:
    

**addr** – An address.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

True if addr is hooked, False otherwise.

hooked_by(_addr_)¶
    

Returns the current hook for addr.

Parameters:
    

**addr** – An address.

Return type:
    

`SimProcedure` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

None if the address is not hooked.

unhook(_addr_)¶
    

Remove a hook.

Parameters:
    

**addr** – The address of the hook.

hook_symbol(_symbol_name_ , _simproc_ , _kwargs =None_, _replace =None_)¶
    

Resolve a dependency in a binary. Looks up the address of the given symbol, and then hooks that address. If the symbol was not available in the loaded libraries, this address may be provided by the CLE externs object.

Additionally, if instead of a symbol name you provide an address, some secret functionality will kick in and you will probably just hook that address, UNLESS you’re on powerpc64 ABIv1 or some yet-unknown scary ABI that has its function pointers point to something other than the actual functions, in which case it’ll do the right thing.

Parameters:
    

  * **symbol_name** – The name of the dependency to resolve.

  * **simproc** – The SimProcedure instance (or function) with which to hook the symbol

  * **kwargs** – If you provide a SimProcedure for the hook, these are the keyword arguments that will be passed to the procedure’s run method eventually.

  * **replace** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")]) – Control the behavior on finding that the address is already hooked. If true, silently replace the hook. If false, warn and do not replace the hook. If none (default), warn and replace the hook.

Returns:
    

The address of the new symbol.

Return type:
    

[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

symbol_hooked_by(_symbol_name_)¶
    

Return the SimProcedure, if it exists, for the given symbol name.

Parameters:
    

**symbol_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of the symbol.

Return type:
    

`SimProcedure` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

None if the address is not hooked.

is_symbol_hooked(_symbol_name_)¶
    

Check if a symbol is already hooked.

Parameters:
    

**symbol_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of the symbol.

Returns:
    

True if the symbol can be resolved and is hooked, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

unhook_symbol(_symbol_name_)¶
    

Remove the hook on a symbol. This function will fail if the symbol is provided by the extern object, as that would result in a state where analysis would be unable to cope with a call to this symbol.

rehook_symbol(_new_address_ , _symbol_name_ , _stubs_on_sync_)¶
    

Move the hook for a symbol to a specific address :type new_address: :param new_address: the new address that will trigger the SimProc execution :type symbol_name: :param symbol_name: the name of the symbol (f.i. strcmp ) :return: None

execute(_* args_, _** kwargs_)¶
    

This function is a symbolic execution helper in the simple style supported by triton and manticore. It designed to be run after setting up hooks (see Project.hook), in which the symbolic state can be checked.

This function can be run in three different ways:

>   * When run with no parameters, this function begins symbolic execution from the entrypoint.
> 
>   * It can also be run with a “state” parameter specifying a SimState to begin symbolic execution from.
> 
>   * Finally, it can accept any arbitrary keyword arguments, which are all passed to project.factory.full_init_state.
> 
> 

If symbolic execution finishes, this function returns the resulting simulation manager.

terminate_execution()¶
    

Terminates a symbolic execution that was started with Project.execute().

_class _angr.Server(_project_ , _spill_yard =None_, _db =None_, _max_workers =None_, _max_states =10_, _staging_max =10_, _bucketizer =True_, _recursion_limit =1000_, _worker_exit_callback =None_, _techniques =None_, _add_options =None_, _remove_options =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Server implements the analysis server with a series of control interfaces exposed.

Variables:
    

  * **project** – An instance of angr.Project.

  * **spill_yard** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – A directory to store spilled states.

  * **db** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Path of the database that stores information about spilled states.

  * **max_workers** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Maximum number of workers. Each worker starts a new process.

  * **max_states** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Maximum number of active states for each worker.

  * **staging_max** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Maximum number of inactive states that are kept into memory before spilled onto the disk and potentially be picked up by another worker.

  * **bucketizer** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Use the Bucketizer exploration strategy.

  * **_worker_exit_callback** – A method that will be called upon the exit of each worker.

__init__(_project_ , _spill_yard =None_, _db =None_, _max_workers =None_, _max_states =10_, _staging_max =10_, _bucketizer =True_, _recursion_limit =1000_, _worker_exit_callback =None_, _techniques =None_, _add_options =None_, _remove_options =None_)¶
    

inc_active_workers()¶
    

dec_active_workers()¶
    

stop()¶
    

_property _active_workers¶
    

_property _stopped¶
    

on_worker_exit(_worker_id_ , _stashes_)¶
    

run()¶
    

_exception _angr.SimAbstractMemoryError¶
    

Bases: `SimMemoryError`

_exception _angr.SimActionError¶
    

Bases: `SimError`

_class _angr.SimCC(_arch_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A calling convention allows you to extract from a state the data passed from function to function by calls and returns. Most of the methods provided by SimCC that operate on a state assume that the program is just after a call but just before stack frame allocation, though this may be overridden with the stack_base parameter to each individual method.

This is the base class for all calling conventions.

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

__init__(_arch_)¶
    

Parameters:
    

**arch** ([`Arch`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)")) – The Archinfo arch for this CC

ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = []_¶
    

FP_ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = []_¶
    

STACKARG_SP_BUFF _ = 0_¶
    

STACKARG_SP_DIFF _ = 0_¶
    

CALLER_SAVED_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = []_¶
    

RETURN_ADDR _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

OVERFLOW_RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

FP_RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

ARCH _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[[`Arch`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)")] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

EXTRA_ARCHES _: [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[[`Arch`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)")], [`...`](https://docs.python.org/3/library/constants.html#Ellipsis "\(in Python v3.13\)")]__ = ()_¶
    

CALLEE_CLEANUP _ = False_¶
    

STACK_ALIGNMENT _ = 1_¶
    

_property _int_args¶
    

Iterate through all the possible arg positions that can only be used to store integer or pointer values.

Returns an iterator of SimFunctionArguments

_property _memory_args¶
    

Iterate through all the possible arg positions that can be used to store any kind of argument.

Returns an iterator of SimFunctionArguments

_property _fp_args¶
    

Iterate through all the possible arg positions that can only be used to store floating point values.

Returns an iterator of SimFunctionArguments

is_fp_arg(_arg_)¶
    

This should take a SimFunctionArgument instance and return whether or not that argument is a floating-point argument.

Returns True for MUST be a floating point arg,
    

False for MUST NOT be a floating point arg, None for when it can be either.

_class _ArgSession(_cc_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A class to keep track of the state accumulated in laying parameters out into memory

both_iter¶
    

cc¶
    

fp_iter¶
    

int_iter¶
    

__init__(_cc_)¶
    

getstate()¶
    

setstate(_state_)¶
    

arg_session(_ret_ty_)¶
    

Return an arg session.

A session provides the control interface necessary to describe how integral and floating-point arguments are laid out into memory. The default behavior is that there are a finite list of int-only and fp-only argument slots, and an infinite number of generic slots, and when an argument of a given type is requested, the most slot available is used. If you need different behavior, subclass ArgSession.

You need to provide the return type of the function in order to kick off an arg layout session.

Parameters:
    

**ret_ty** (_SimType_ _|__None_)

return_in_implicit_outparam(_ty_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

stack_space(_args_)¶
    

Parameters:
    

**args** – A list of SimFunctionArguments

Returns:
    

The number of bytes that should be allocated on the stack to store all these args, NOT INCLUDING the return address.

return_val(_ty_ , _perspective_returned =False_)¶
    

The location the return value is stored, based on its type.

_property _return_addr¶
    

The location the return address is stored.

next_arg(_session_ , _arg_type_)¶
    

Parameters:
    

  * **session** (_ArgSession_)

  * **arg_type** (_SimType_)

_static _is_fp_value(_val_)¶
    

_static _guess_prototype(_args_ , _prototype =None_)¶
    

Come up with a plausible SimTypeFunction for the given args (as would be passed to e.g. setup_callsite).

You can pass a variadic function prototype in the base_type parameter and all its arguments will be used, only guessing types for the variadic arguments.

arg_locs(_prototype_)¶
    

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`SimFunctionArgument`]

get_args(_state_ , _prototype_ , _stack_base =None_)¶
    

set_return_val(_state_ , _val_ , _ty_ , _stack_base =None_, _perspective_returned =False_)¶
    

setup_callsite(_state_ , _ret_addr_ , _args_ , _prototype_ , _stack_base =None_, _alloc_base =None_, _grow_like_stack =True_)¶
    

This function performs the actions of the caller getting ready to jump into a function.

Parameters:
    

  * **state** – The SimState to operate on

  * **ret_addr** – The address to return to when the called function finishes

  * **args** – The list of arguments that that the called function will see

  * **prototype** – The signature of the call you’re making. Should include variadic args concretely.

  * **stack_base** – An optional pointer to use as the top of the stack, circa the function entry point

  * **alloc_base** – An optional pointer to use as the place to put excess argument data

  * **grow_like_stack** – When allocating data at alloc_base, whether to allocate at decreasing addresses

The idea here is that you can provide almost any kind of python type in args and it’ll be translated to a binary format to be placed into simulated memory. Lists (representing arrays) must be entirely elements of the same type and size, while tuples (representing structs) can be elements of any type and size. If you’d like there to be a pointer to a given value, wrap the value in a PointerWrapper.

If stack_base is not provided, the current stack pointer will be used, and it will be updated. If alloc_base is not provided, the stack base will be used and grow_like_stack will implicitly be True.

grow_like_stack controls the behavior of allocating data at alloc_base. When data from args needs to be wrapped in a pointer, the pointer needs to point somewhere, so that data is dumped into memory at alloc_base. If you set alloc_base to point to somewhere other than the stack, set grow_like_stack to False so that sequential allocations happen at increasing addresses.

teardown_callsite(_state_ , _return_val =None_, _prototype =None_, _force_callee_cleanup =False_)¶
    

This function performs the actions of the callee as it’s getting ready to return. It returns the address to return to.

Parameters:
    

  * **state** – The state to mutate

  * **return_val** – The value to return

  * **prototype** – The prototype of the given function

  * **force_callee_cleanup** – If we should clean up the stack allocation for the arguments even if it’s not the callee’s job to do so

TODO: support the stack_base parameter from setup_callsite…? Does that make sense in this context? Maybe it could make sense by saying that you pass it in as something like the “saved base pointer” value?

_static _find_cc(_arch_ , _args_ , _sp_delta_ , _platform ='Linux'_)¶
    

Pinpoint the best-fit calling convention and return the corresponding SimCC instance, or None if no fit is found.

Parameters:
    

  * **arch** ([`Arch`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)")) – An ArchX instance. Can be obtained from archinfo.

  * **args** ([`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`SimRegArg` | `SimStackArg`]) – A list of arguments. It may be updated by the first matched calling convention to remove non-argument arguments.

  * **sp_delta** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The change of stack pointer before and after the call is made.

  * **platform** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

Return type:
    

`SimCC` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

A calling convention instance, or None if none of the SimCC subclasses seems to fit the arguments provided.

_classmethod _arches()¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[[`Arch`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)")], [`...`](https://docs.python.org/3/library/constants.html#Ellipsis "\(in Python v3.13\)")]

get_arg_info(_state_ , _prototype_)¶
    

This is just a simple wrapper that collects the information from various locations prototype is as passed to self.arg_locs and self.get_args :param angr.SimState state: The state to evaluate and extract the values from :return: A list of tuples, where the nth tuple is (type, name, location, value) of the nth argument

_exception _angr.SimCCError¶
    

Bases: `SimError`

_exception _angr.SimCCallError¶
    

Bases: `SimExpressionError`

_exception _angr.SimConcreteBreakpointError¶
    

Bases: `AngrError`

_exception _angr.SimConcreteMemoryError¶
    

Bases: `AngrError`

_exception _angr.SimConcreteRegisterError¶
    

Bases: `AngrError`

_exception _angr.SimEmptyCallStackError¶
    

Bases: `SimError`

_exception _angr.SimEngineError¶
    

Bases: `SimError`

_exception _angr.SimError¶
    

Bases: [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception "\(in Python v3.13\)")

bbl_addr _ = None_¶
    

stmt_idx _ = None_¶
    

ins_addr _ = None_¶
    

executed_instruction_count _ = None_¶
    

guard _ = None_¶
    

record_state(_state_)¶
    

_exception _angr.SimEventError¶
    

Bases: `SimStateError`

_exception _angr.SimException¶
    

Bases: `SimError`

_exception _angr.SimExpressionError¶
    

Bases: `SimError`

_exception _angr.SimFastMemoryError¶
    

Bases: `SimMemoryError`

_exception _angr.SimFastPathError¶
    

Bases: `SimEngineError`

_class _angr.SimFile(_name =None_, _content =None_, _size =None_, _has_end =None_, _seekable =True_, _writable =True_, _ident =None_, _concrete =None_, _** kwargs_)¶
    

Bases: `SimFileBase`, `DefaultMemory`

The normal SimFile is meant to model files on disk. It subclasses SimSymbolicMemory so loads and stores to/from it are very simple.

Parameters:
    

  * **name** – The name of the file

  * **content** – Optional initial content for the file as a string or bitvector

  * **size** – Optional size of the file. If content is not specified, it defaults to zero

  * **has_end** – Whether the size boundary is treated as the end of the file or a frontier at which new content will be generated. If unspecified, will pick its value based on options.FILES_HAVE_EOF. Another caveat is that if the size is also unspecified this value will default to False.

  * **seekable** – Optional bool indicating whether seek operations on this file should succeed, default True.

  * **writable** – Whether writing to this file is allowed

  * **concrete** – Whether or not this file contains mostly concrete data. Will be used by some SimProcedures to choose how to handle variable-length operations like fgets.

Variables:
    

**has_end** – Whether this file has an EOF

__init__(_name =None_, _content =None_, _size =None_, _has_end =None_, _seekable =True_, _writable =True_, _ident =None_, _concrete =None_, _** kwargs_)¶
    

_property _category¶
    

reg, mem, or file.

Type:
    

Return the category of this SimMemory instance. It can be one of the three following categories

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

_property _size¶
    

The number of data bytes stored by the file at present. May be a symbolic value.

concretize(_** kwargs_)¶
    

Return a concretization of the contents of the file, as a flat bytestring.

read(_pos_ , _size_ , _** kwargs_)¶
    

Read some data from the file.

Parameters:
    

  * **pos** – The offset in the file to read from.

  * **size** – The size to read. May be symbolic.

Returns:
    

A tuple of the data read (a bitvector of the length that is the maximum length of the read), the actual size of the read, and the new file position pointer.

write(_pos_ , _data_ , _size =None_, _events =True_, _** kwargs_)¶
    

Write some data to the file.

Parameters:
    

  * **pos** – The offset in the file to write to. May be ignored if the file is a stream or device.

  * **data** – The data to write as a bitvector

  * **size** – The optional size of the data to write. If not provided will default to the length of the data. Must be constrained to less than or equal to the size of the data.

Returns:
    

The new file position pointer.

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(___)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.SimFileBase(_name =None_, _writable =True_, _ident =None_, _concrete =False_, _file_exists =True_, _** kwargs_)¶
    

Bases: `SimStatePlugin`

SimFiles are the storage mechanisms used by SimFileDescriptors.

Different types of SimFiles can have drastically different interfaces, and as a result there’s not much that can be specified on this base class. All the read and write methods take a `pos` argument, which may have different semantics per-class. `0` will always be a valid position to use, though, and the next position you should use is part of the return tuple.

Some simfiles are “streams”, meaning that the position that reads come from is determined not by the position you pass in (it will in fact be ignored), but by an internal variable. This is stored as `.pos` if you care to read it. Don’t write to it. The same lack-of-semantics applies to this field as well.

Variables:
    

  * **name** – The name of the file. Purely for cosmetic purposes

  * **ident** – The identifier of the file, typically autogenerated from the name and a nonce. Purely for cosmetic purposes, but does appear in symbolic values autogenerated in the file.

  * **seekable** – Bool indicating whether seek operations on this file should succeed. If this is True, then `pos` must be a number of bytes from the start of the file.

  * **writable** – Bool indicating whether writing to this file is allowed.

  * **pos** – If the file is a stream, this will be the current position. Otherwise, None.

  * **concrete** – Whether or not this file contains mostly concrete data. Will be used by some SimProcedures to choose how to handle variable-length operations like fgets.

  * **file_exists** – Set to False, if file does not exists, set to a claripy Bool if unknown, default True.

seekable _ = False_¶
    

pos _ = None_¶
    

__init__(_name =None_, _writable =True_, _ident =None_, _concrete =False_, _file_exists =True_, _** kwargs_)¶
    

_static _make_ident(_name_)¶
    

concretize(_** kwargs_)¶
    

Return a concretization of the contents of the file. The type of the return value of this method will vary depending on which kind of SimFile you’re using.

read(_pos_ , _size_ , _** kwargs_)¶
    

Read some data from the file.

Parameters:
    

  * **pos** – The offset in the file to read from.

  * **size** – The size to read. May be symbolic.

Returns:
    

A tuple of the data read (a bitvector of the length that is the maximum length of the read), the actual size of the read, and the new file position pointer.

write(_pos_ , _data_ , _size =None_, _** kwargs_)¶
    

Write some data to the file.

Parameters:
    

  * **pos** – The offset in the file to write to. May be ignored if the file is a stream or device.

  * **data** – The data to write as a bitvector

  * **size** – The optional size of the data to write. If not provided will default to the length of the data. Must be constrained to less than or equal to the size of the data.

Returns:
    

The new file position pointer.

_property _size¶
    

The number of data bytes stored by the file at present. May be a symbolic value.

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

_class _angr.SimFileDescriptor(_simfile_ , _flags =0_)¶
    

Bases: `SimFileDescriptorBase`

A simple file descriptor forwarding reads and writes to a SimFile. Contains information about the current opened state of the file, such as the flags or (if relevant) the current position.

Variables:
    

  * **file** – The SimFile described to by this descriptor

  * **flags** – The mode that the file descriptor was opened with, a bitfield of flags

__init__(_simfile_ , _flags =0_)¶
    

read_data(_size_ , _** kwargs_)¶
    

Reads some data from the file, returning the data.

Parameters:
    

**size** – The requested length of the read

Returns:
    

A tuple of the data read and the real length of the read

write_data(_data_ , _size =None_, _** kwargs_)¶
    

Write some data, provided as an argument into the file.

Parameters:
    

  * **data** – A bitvector to write into the file

  * **size** – The requested size of the write (may be symbolic)

Returns:
    

The real length of the write

seek(_offset_ , _whence ='start'_)¶
    

Seek the file descriptor to a different position in the file.

Parameters:
    

  * **offset** – The offset to seek to, interpreted according to whence

  * **whence** – What the offset is relative to; one of the strings “start”, “current”, or “end”

Returns:
    

A symbolic boolean describing whether the seek succeeded or not

eof()¶
    

Return the EOF status. May be a symbolic boolean.

tell()¶
    

Return the current position, or None if the concept doesn’t make sense for the given file.

size()¶
    

Return the size of the data stored in the file in bytes, or None if the concept doesn’t make sense for the given file.

concretize(_** kwargs_)¶
    

Return a concretization of the underlying file. Returns whatever format is preferred by the file.

_property _file_exists¶
    

This should be True in most cases. Only if we opened an fd of unknown existence, ALL_FILES_EXIST is False and ANY_FILE_MIGHT_EXIST is True, this is a symbolic boolean.

_property _read_storage¶
    

Return the SimFile backing reads from this fd

_property _write_storage¶
    

Return the SimFile backing writes to this fd

_property _read_pos¶
    

Return the current position of the read file pointer.

If the underlying read file is a stream, this will return the position of the stream. Otherwise, will return the position of the file descriptor in the file.

_property _write_pos¶
    

Return the current position of the read file pointer.

If the underlying read file is a stream, this will return the position of the stream. Otherwise, will return the position of the file descriptor in the file.

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(___)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.SimFileDescriptorDuplex(_read_file_ , _write_file_)¶
    

Bases: `SimFileDescriptorBase`

A file descriptor that refers to two file storage mechanisms, one to read from and one to write to. As a result, operations like seek, eof, etc no longer make sense.

Parameters:
    

  * **read_file** – The SimFile to read from

  * **write_file** – The SimFile to write to

__init__(_read_file_ , _write_file_)¶
    

read_data(_size_ , _** kwargs_)¶
    

Reads some data from the file, returning the data.

Parameters:
    

**size** – The requested length of the read

Returns:
    

A tuple of the data read and the real length of the read

write_data(_data_ , _size =None_, _** kwargs_)¶
    

Write some data, provided as an argument into the file.

Parameters:
    

  * **data** – A bitvector to write into the file

  * **size** – The requested size of the write (may be symbolic)

Returns:
    

The real length of the write

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

eof()¶
    

Return the EOF status. May be a symbolic boolean.

tell()¶
    

Return the current position, or None if the concept doesn’t make sense for the given file.

seek(_offset_ , _whence ='start'_)¶
    

Seek the file descriptor to a different position in the file.

Parameters:
    

  * **offset** – The offset to seek to, interpreted according to whence

  * **whence** – What the offset is relative to; one of the strings “start”, “current”, or “end”

Returns:
    

A symbolic boolean describing whether the seek succeeded or not

size()¶
    

Return the size of the data stored in the file in bytes, or None if the concept doesn’t make sense for the given file.

concretize(_** kwargs_)¶
    

Return a concretization of the underlying files, as a tuple of (read file, write file).

_property _read_storage¶
    

Return the SimFile backing reads from this fd

_property _write_storage¶
    

Return the SimFile backing writes to this fd

_property _read_pos¶
    

Return the current position of the read file pointer.

If the underlying read file is a stream, this will return the position of the stream. Otherwise, will return the position of the file descriptor in the file.

_property _write_pos¶
    

Return the current position of the read file pointer.

If the underlying read file is a stream, this will return the position of the stream. Otherwise, will return the position of the file descriptor in the file.

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(___)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_exception _angr.SimFileError¶
    

Bases: `SimMemoryError`, `SimFilesystemError`

_class _angr.SimFileStream(_name =None_, _content =None_, _pos =0_, _** kwargs_)¶
    

Bases: `SimFile`

A specialized SimFile that uses a flat memory backing, but functions as a stream, tracking its position internally.

The pos argument to the read and write methods will be ignored, and will return None. Instead, there is an attribute `pos` on the file itself, which will give you what you want.

Parameters:
    

  * **name** – The name of the file, for cosmetic purposes

  * **pos** – The initial position of the file, default zero

  * **kwargs** – Any other keyword arguments will go on to the SimFile constructor.

Variables:
    

**pos** – The current position in the file.

__init__(_name =None_, _content =None_, _pos =0_, _** kwargs_)¶
    

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

read(_pos_ , _size_ , _** kwargs_)¶
    

Read some data from the file.

Parameters:
    

  * **pos** – The offset in the file to read from.

  * **size** – The size to read. May be symbolic.

Returns:
    

A tuple of the data read (a bitvector of the length that is the maximum length of the read), the actual size of the read, and the new file position pointer.

write(___ , _data_ , _size =None_, _** kwargs_)¶
    

Write some data to the file.

Parameters:
    

  * **pos** – The offset in the file to write to. May be ignored if the file is a stream or device.

  * **data** – The data to write as a bitvector

  * **size** – The optional size of the data to write. If not provided will default to the length of the data. Must be constrained to less than or equal to the size of the data.

Returns:
    

The new file position pointer.

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_exception _angr.SimFilesystemError¶
    

Bases: `SimError`

_class _angr.SimHeapBrk(_heap_base =None_, _heap_size =None_)¶
    

Bases: `SimHeapBase`

SimHeapBrk represents a trivial heap implementation based on the Unix brk system call. This type of heap stores virtually no metadata, so it is up to the user to determine when it is safe to release memory. This also means that it does not properly support standard heap operations like realloc.

This heap implementation is a holdover from before any more proper implementations were modelled. At the time, various libc (or win32) SimProcedures handled the heap in the same way that this plugin does now. To make future heap implementations plug-and-playable, they should implement the necessary logic themselves, and dependent SimProcedures should invoke a method by the same name as theirs (prepended with an underscore) upon the heap plugin. Depending on the heap implementation, if the method is not supported, an error should be raised.

Out of consideration for the original way the heap was handled, this plugin implements functionality for all relevant SimProcedures (even those that would not normally be supported together in a single heap implementation).

Variables:
    

**heap_location** – the address of the top of the heap, bounding the allocations made starting from heap_base

__init__(_heap_base =None_, _heap_size =None_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

allocate(_sim_size_)¶
    

The actual allocation primitive for this heap implementation. Increases the position of the break to allocate space. Has no guards against the heap growing too large.

Parameters:
    

**sim_size** – a size specifying how much to increase the break pointer by

Returns:
    

a pointer to the previous break position, above which there is now allocated space

release(_sim_size_)¶
    

The memory release primitive for this heap implementation. Decreases the position of the break to deallocate space. Guards against releasing beyond the initial heap base.

Parameters:
    

**sim_size** – a size specifying how much to decrease the break pointer by (may be symbolic or not)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_exception _angr.SimHeapError¶
    

Bases: `SimStateError`

_class _angr.SimHeapPTMalloc(_heap_base =None_, _heap_size =None_)¶
    

Bases: `SimHeapFreelist`

A freelist-style heap implementation inspired by ptmalloc. The chunks used by this heap contain heap metadata in addition to user data. While the real-world ptmalloc is implemented using multiple lists of free chunks (corresponding to their different sizes), this more basic model uses a single list of chunks and searches for free chunks using a first-fit algorithm.

**NOTE:** The plugin must be registered using `register_plugin` with name `heap` in order to function properly.

Variables:
    

  * **heap_base** – the address of the base of the heap in memory

  * **heap_size** – the total size of the main memory region managed by the heap in memory

  * **mmap_base** – the address of the region from which large mmap allocations will be made

  * **free_head_chunk** – the head of the linked list of free chunks in the heap

__init__(_heap_base =None_, _heap_size =None_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

chunks()¶
    

Returns an iterator over all the chunks in the heap.

allocated_chunks()¶
    

Returns an iterator over all the allocated chunks in the heap.

free_chunks()¶
    

Returns an iterator over all the free chunks in the heap.

chunk_from_mem(_ptr_)¶
    

Given a pointer to a user payload, return the base of the chunk associated with that payload (i.e. the chunk pointer). Returns None if ptr is null.

Parameters:
    

**ptr** – a pointer to the base of a user payload in the heap

Returns:
    

a pointer to the base of the associated heap chunk, or None if ptr is null

malloc(_sim_size_)¶
    

A somewhat faithful implementation of libc malloc.

Parameters:
    

**sim_size** – the amount of memory (in bytes) to be allocated

Returns:
    

the address of the allocation, or a NULL pointer if the allocation failed

free(_ptr_)¶
    

A somewhat faithful implementation of libc free.

Parameters:
    

**ptr** – the location in memory to be freed

calloc(_sim_nmemb_ , _sim_size_)¶
    

A somewhat faithful implementation of libc calloc.

Parameters:
    

  * **sim_nmemb** – the number of elements to allocated

  * **sim_size** – the size of each element (in bytes)

Returns:
    

the address of the allocation, or a NULL pointer if the allocation failed

realloc(_ptr_ , _size_)¶
    

A somewhat faithful implementation of libc realloc.

Parameters:
    

  * **ptr** – the location in memory to be reallocated

  * **size** – the new size desired for the allocation

Returns:
    

the address of the allocation, or a NULL pointer if the allocation was freed or if no new allocation was made

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

init_state()¶
    

Use this function to perform any initialization on the state at plugin-add time

_class _angr.SimHostFilesystem(_host_path =None_, _** kwargs_)¶
    

Bases: `SimConcreteFilesystem`

Simulated mount that makes some piece from the host filesystem available to the guest.

Parameters:
    

  * **host_path** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The path on the host to mount

  * **pathsep** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The host path separator character, default os.path.sep

__init__(_host_path =None_, _** kwargs_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

_exception _angr.SimIRSBError¶
    

Bases: `SimEngineError`

_exception _angr.SimIRSBNoDecodeError¶
    

Bases: `SimIRSBError`

_exception _angr.SimMemoryAddressError¶
    

Bases: `SimMemoryError`

_exception _angr.SimMemoryError¶
    

Bases: `SimStateError`

_exception _angr.SimMemoryLimitError¶
    

Bases: `SimMemoryError`

_exception _angr.SimMemoryMissingError(_missing_addr_ , _missing_size_ , _* args_)¶
    

Bases: `SimMemoryError`

__init__(_missing_addr_ , _missing_size_ , _* args_)¶
    

_exception _angr.SimMergeError¶
    

Bases: `SimStateError`

_exception _angr.SimMissingTempError¶
    

Bases: `SimValueError`, [`IndexError`](https://docs.python.org/3/library/exceptions.html#IndexError "\(in Python v3.13\)")

_class _angr.SimMount¶
    

Bases: `SimStatePlugin`

This is the base class for “mount points” in angr’s simulated filesystem. Subclass this class and give it to the filesystem to intercept all file creations and opens below the mountpoint. Since this a SimStatePlugin you may also want to implement set_state, copy, merge, etc.

get(_path_elements_)¶
    

Implement this function to instrument file lookups.

Parameters:
    

**path_elements** – A list of path elements traversing from the mountpoint to the file

Returns:
    

A SimFile, or None

insert(_path_elements_ , _simfile_)¶
    

Implement this function to instrument file creation.

Parameters:
    

  * **path_elements** – A list of path elements traversing from the mountpoint to the file

  * **simfile** – The file to insert

Returns:
    

A bool indicating whether the insert occurred

delete(_path_elements_)¶
    

Implement this function to instrument file deletion.

Parameters:
    

**path_elements** – A list of path elements traversing from the mountpoint to the file

Returns:
    

A bool indicating whether the delete occurred

lookup(_sim_file_)¶
    

Look up the path of a SimFile in the mountpoint

Parameters:
    

**sim_file** – A SimFile object needs to be looked up

Returns:
    

A string representing the path of the file in the mountpoint Or None if the SimFile does not exist in the mountpoint

_class _angr.SimOS(_project_ , _name =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A class describing OS/arch-level configuration.

Parameters:
    

  * **project** (_angr.Project_)

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

__init__(_project_ , _name =None_)¶
    

Parameters:
    

  * **project** (_Project_)

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

name _: [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

configure_project()¶
    

Configure the project to set up global settings (like SimProcedures).

state_blank(_addr =None_, _initial_prefix =None_, _brk =None_, _stack_end =None_, _stack_size =8388608_, _stdin =None_, _thread_idx =None_, _permissions_backer =None_, _** kwargs_)¶
    

Initialize a blank state.

All parameters are optional.

Parameters:
    

  * **addr** – The execution start address.

  * **initial_prefix**

  * **stack_end** – The end of the stack (i.e., the byte after the last valid stack address).

  * **stack_size** – The number of bytes to allocate for stack space

  * **brk** – The address of the process’ break.

Returns:
    

The initialized SimState.

Any additional arguments will be passed to the SimState constructor

state_entry(_** kwargs_)¶
    

state_full_init(_** kwargs_)¶
    

state_call(_addr_ , _* args_, _** kwargs_)¶
    

prepare_call_state(_calling_state_ , _initial_state =None_, _preserve_registers =()_, _preserve_memory =()_)¶
    

This function prepares a state that is executing a call instruction. If given an initial_state, it copies over all of the critical registers to it from the calling_state. Otherwise, it prepares the calling_state for action.

This is mostly used to create minimalistic for CFG generation. Some ABIs, such as MIPS PIE and x86 PIE, require certain information to be maintained in certain registers. For example, for PIE MIPS, this function transfer t9, gp, and ra to the new state.

prepare_function_symbol(_symbol_name_ , _basic_addr =None_)¶
    

Prepare the address space with the data necessary to perform relocations pointing to the given symbol

Returns a 2-tuple. The first item is the address of the function code, the second is the address of the relocation target.

handle_exception(_successors_ , _engine_ , _exception_)¶
    

Perform exception handling. This method will be called when, during execution, a SimException is thrown. Currently, this can only indicate a segfault, but in the future it could indicate any unexpected exceptional behavior that can’t be handled by ordinary control flow.

The method may mutate the provided SimSuccessors object in any way it likes, or re-raise the exception.

Parameters:
    

  * **successors** – The SimSuccessors object currently being executed on

  * **engine** – The engine that was processing this step

  * **exception** – The actual exception object

syscall(_state_ , _allow_unsupported =True_)¶
    

Return type:
    

`SimProcedure` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **state** (_SimState_)

  * **allow_unsupported** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

syscall_abi(_state_)¶
    

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**state** (_SimState_)

syscall_cc(_state_)¶
    

Return type:
    

`SimCCSyscall` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**state** (_SimState_)

is_syscall_addr(_addr_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

syscall_from_addr(_addr_ , _allow_unsupported =True_)¶
    

Return type:
    

`SimProcedure` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

syscall_from_number(_number_ , _allow_unsupported =True_, _abi =None_)¶
    

Return type:
    

`SimProcedure` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

setup_gdt(_state_ , _gdt_)¶
    

Write the GlobalDescriptorTable object in the current state memory

Parameters:
    

  * **state** – state in which to write the GDT

  * **gdt** – GlobalDescriptorTable object

Returns:
    

generate_gdt(_fs_ , _gs_ , _fs_size =4294967295_, _gs_size =4294967295_)¶
    

Generate a GlobalDescriptorTable object and populate it using the value of the gs and fs register

Parameters:
    

  * **fs** – value of the fs segment register

  * **gs** – value of the gs segment register

  * **fs_size** – size of the fs segment register

  * **gs_size** – size of the gs segment register

Returns:
    

gdt a GlobalDescriptorTable object

_exception _angr.SimOperationError¶
    

Bases: `SimError`

_class _angr.SimPackets(_name_ , _write_mode =None_, _content =None_, _writable =True_, _ident =None_, _** kwargs_)¶
    

Bases: `SimFileBase`

The SimPackets is meant to model inputs whose content is delivered a series of asynchronous chunks. The data is stored as a list of read or write results. For symbolic sizes, state.libc.max_packet_size will be respected. If the SHORT_READS option is enabled, reads will return a symbolic size constrained to be less than or equal to the requested size.

A SimPackets cannot be used for both reading and writing - for socket objects that can be both read and written to you should use a file descriptor to multiplex the read and write operations into two separate file storage mechanisms.

Parameters:
    

  * **name** – The name of the file, for cosmetic purposes

  * **write_mode** – Whether this file is opened in read or write mode. If this is unspecified it will be autodetected.

  * **content** – Some initial content to use for the file. Can be a list of bytestrings or a list of tuples of content ASTs and size ASTs.

Variables:
    

  * **write_mode** – See the eponymous parameter

  * **content** – A list of packets, as tuples of content ASTs and size ASTs.

__init__(_name_ , _write_mode =None_, _content =None_, _writable =True_, _ident =None_, _** kwargs_)¶
    

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

_property _size¶
    

The number of data bytes stored by the file at present. May be a symbolic value.

concretize(_** kwargs_)¶
    

Returns a list of the packets read or written as bytestrings.

read(_pos_ , _size_ , _** kwargs_)¶
    

Read a packet from the stream.

Parameters:
    

  * **pos** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The packet number to read from the sequence of the stream. May be None to append to the stream.

  * **size** – The size to read. May be symbolic.

  * **short_reads** – Whether to replace the size with a symbolic value constrained to less than or equal to the original size. If unspecified, will be chosen based on the state option.

Returns:
    

A tuple of the data read (a bitvector of the length that is the maximum length of the read) and the actual size of the read.

write(_pos_ , _data_ , _size =None_, _events =True_, _** kwargs_)¶
    

Write a packet to the stream.

Parameters:
    

  * **pos** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The packet number to write in the sequence of the stream. May be None to append to the stream.

  * **data** – The data to write, as a string or bitvector.

  * **size** – The optional size to write. May be symbolic; must be constrained to at most the size of data.

Returns:
    

The next packet to use after this

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(___)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.SimPacketsStream(_name_ , _pos =0_, _** kwargs_)¶
    

Bases: `SimPackets`

A specialized SimPackets that tracks its position internally.

The pos argument to the read and write methods will be ignored, and will return None. Instead, there is an attribute `pos` on the file itself, which will give you what you want.

Parameters:
    

  * **name** – The name of the file, for cosmetic purposes

  * **pos** – The initial position of the file, default zero

  * **kwargs** – Any other keyword arguments will go on to the SimPackets constructor.

Variables:
    

**pos** – The current position in the file.

__init__(_name_ , _pos =0_, _** kwargs_)¶
    

read(_pos_ , _size_ , _** kwargs_)¶
    

Read a packet from the stream.

Parameters:
    

  * **pos** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The packet number to read from the sequence of the stream. May be None to append to the stream.

  * **size** – The size to read. May be symbolic.

  * **short_reads** – Whether to replace the size with a symbolic value constrained to less than or equal to the original size. If unspecified, will be chosen based on the state option.

Returns:
    

A tuple of the data read (a bitvector of the length that is the maximum length of the read) and the actual size of the read.

write(___ , _data_ , _size =None_, _** kwargs_)¶
    

Write a packet to the stream.

Parameters:
    

  * **pos** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The packet number to write in the sequence of the stream. May be None to append to the stream.

  * **data** – The data to write, as a string or bitvector.

  * **size** – The optional size to write. May be symbolic; must be constrained to at most the size of data.

Returns:
    

The next packet to use after this

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_exception _angr.SimPosixError¶
    

Bases: `SimStateError`

_class _angr.SimProcedure(_project =None_, _cc =None_, _prototype =None_, _symbolic_return =None_, _returns =None_, _is_syscall =False_, _is_stub =False_, _num_args =None_, _display_name =None_, _library_name =None_, _is_function =None_, _** kwargs_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A SimProcedure is a wonderful object which describes a procedure to run on a state.

You may subclass SimProcedure and override `run()`, replacing it with mutating `self.state` however you like, and then either returning a value or jumping away somehow.

A detailed discussion of programming SimProcedures may be found at <https://docs.angr.io/extending-angr/simprocedures>

Parameters:
    

**arch** – The architecture to use for this procedure

The following parameters are optional:

Parameters:
    

  * **symbolic_return** – Whether the procedure’s return value should be stubbed into a single symbolic variable constratined to the real return value

  * **returns** – Whether the procedure should return to its caller afterwards

  * **is_syscall** – Whether this procedure is a syscall

  * **num_args** – The number of arguments this procedure should extract

  * **display_name** – The name to use when displaying this procedure

  * **library_name** – The name of the library from which the function we’re emulating comes

  * **cc** – The SimCC to use for this procedure

  * **sim_kwargs** – Additional keyword arguments to be passed to run()

  * **is_function** – Whether this procedure emulates a function

The following class variables should be set if necessary when implementing a new SimProcedure:

Variables:
    

  * **NO_RET** – Set this to true if control flow will never return from this function

  * **DYNAMIC_RET** – Set this to true if whether the control flow returns from this function or not depends on the context (e.g., libc’s error() call). Must implement dynamic_returns() method.

  * **ADDS_EXITS** – Set this to true if you do any control flow other than returning

  * **IS_FUNCTION** – Does this procedure simulate a function? True by default

  * **ARGS_MISMATCH** – Does this procedure have a different list of arguments than what is provided in the function specification? This may happen when we manually extract arguments in the run() method of a SimProcedure. False by default.

  * **local_vars** – If you use `self.call()`, set this to a list of all the local variable names in your class. They will be restored on return.

The following instance variables are available when working with simprocedures from the inside or the outside:

Variables:
    

  * **project** – The associated angr project

  * **arch** – The associated architecture

  * **addr** – The linear address at which the procedure is executing

  * **cc** – The calling convention in use for engaging with the ABI

  * **canonical** – The canonical version of this SimProcedure. Procedures are deepcopied for many reasons, including to be able to store state related to a specific run and to be able to hook continuations.

  * **kwargs** – Any extra keyword arguments used to construct the procedure; will be passed to `run`

  * **display_name** – See the eponymous parameter

  * **library_name** – See the eponymous parameter

  * **abi** – If this is a syscall simprocedure, which ABI are we using to map the syscall numbers?

  * **symbolic_return** – See the eponymous parameter

  * **syscall_number** – If this procedure is a syscall, the number will be populated here.

  * **returns** – See eponymous parameter and NO_RET cvar

  * **is_syscall** – See eponymous parameter

  * **is_function** – See eponymous parameter and cvar

  * **is_stub** – See eponymous parameter

  * **is_continuation** – Whether this procedure is the original or a continuation resulting from `self.call()`

  * **continuations** – A mapping from name to each known continuation

  * **run_func** – The name of the function implementing the procedure. “run” by default, but different in continuations.

  * **num_args** – The number of arguments to the procedure. If not provided in the parameter, extracted from the definition of `self.run`

The following instance variables are only used in a copy of the procedure that is actually executing on a state:

Variables:
    

  * **state** – The SimState we should be mutating to perform the procedure

  * **successors** – The SimSuccessors associated with the current step

  * **arguments** – The function arguments, deserialized from the state

  * **arg_session** – The ArgSession that was used to parse arguments out of the state, in case you need it for varargs

  * **use_state_arguments** – Whether we’re using arguments extracted from the state or manually provided

  * **ret_to** – The current return address

  * **ret_expr** – The computed return value

  * **call_ret_expr** – The return value from having used `self.call()`

  * **inhibit_autoret** – Whether we should avoid automatically adding an exit for returning once the run function ends

  * **arg_session** – The ArgSession object that was used to extract the runtime argument values. Useful for if you want to extract variadic args.

__init__(_project =None_, _cc =None_, _prototype =None_, _symbolic_return =None_, _returns =None_, _is_syscall =False_, _is_stub =False_, _num_args =None_, _display_name =None_, _library_name =None_, _is_function =None_, _** kwargs_)¶
    

state _: `SimState`_¶
    

execute(_state_ , _successors =None_, _arguments =None_, _ret_to =None_)¶
    

Call this method with a SimState and a SimSuccessors to execute the procedure.

Alternately, successors may be none if this is an inline call. In that case, you should provide arguments to the function.

make_continuation(_name_)¶
    

NO_RET _ = False_¶
    

DYNAMIC_RET _ = False_¶
    

ADDS_EXITS _ = False_¶
    

IS_FUNCTION _ = True_¶
    

ARGS_MISMATCH _ = False_¶
    

ALT_NAMES _ = None_¶
    

local_vars _: [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"), [`...`](https://docs.python.org/3/library/constants.html#Ellipsis "\(in Python v3.13\)")]__ = ()_¶
    

run(_* args_, _** kwargs_)¶
    

Implement the actual procedure here!

Return type:
    

[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")

static_exits(_blocks_ , _** kwargs_)¶
    

Get new exits by performing static analysis and heuristics. This is a fast and best-effort approach to get new exits for scenarios where states are not available (e.g. when building a fast CFG).

Parameters:
    

**blocks** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – Blocks that are executed before reaching this SimProcedure.

Returns:
    

A list of dicts. Each dict should contain the following entries: ‘address’, ‘jumpkind’, and ‘namehint’.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

dynamic_returns(_blocks_ , _** kwargs_)¶
    

Determines if a call to this function returns or not by performing static analysis and heuristics.

Parameters:
    

**blocks** – Blocks that are executed before reaching this SimProcedure.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

True if the call returns, False otherwise.

_property _should_add_successors¶
    

set_args(_args_)¶
    

va_arg(_ty_ , _index =None_)¶
    

inline_call(_procedure_ , _* arguments_, _** kwargs_)¶
    

Call another SimProcedure in-line to retrieve its return value. Returns an instance of the procedure with the ret_expr property set.

Parameters:
    

  * **procedure** – The class of the procedure to execute

  * **arguments** – Any additional positional args will be used as arguments to the procedure call

  * **sim_kwargs** – Any additional keyword args will be passed as sim_kwargs to the procedure constructor

fix_prototype_returnty(_ret_size_)¶
    

ret(_expr =None_)¶
    

Add an exit representing a return from this function. If this is not an inline call, grab a return address from the state and jump to it. If this is not an inline call, set a return expression with the calling convention.

call(_addr_ , _args_ , _continue_at_ , _cc =None_, _prototype =None_, _jumpkind ='Ijk_Call'_)¶
    

Add an exit representing calling another function via pointer.

Parameters:
    

  * **addr** – The address of the function to call

  * **args** – The list of arguments to call the function with

  * **continue_at** – Later, when the called function returns, execution of the current procedure will continue in the named method.

  * **cc** – Optional: use this calling convention for calling the new function. Default is to use the current convention.

  * **prototype** – Optional: The prototype to use for the call. Will default to all-ints.

jump(_addr_ , _jumpkind ='Ijk_Boring'_)¶
    

Add an exit representing jumping to an address.

exit(_exit_code_)¶
    

Add an exit representing terminating the program.

ty_ptr(_ty_)¶
    

_property _is_java¶
    

_property _argument_types¶
    

_property _return_type¶
    

_exception _angr.SimProcedureArgumentError¶
    

Bases: `SimProcedureError`

_exception _angr.SimProcedureError¶
    

Bases: `SimEngineError`

_exception _angr.SimRegionMapError¶
    

Bases: `SimMemoryError`

_exception _angr.SimReliftException(_state_)¶
    

Bases: `SimEngineError`

__init__(_state_)¶
    

angr.SimSegfaultError¶
    

alias of `SimSegfaultException`

_exception _angr.SimSegfaultException(_addr_ , _reason_ , _original_addr =None_)¶
    

Bases: `SimException`, `SimMemoryError`

__init__(_addr_ , _reason_ , _original_addr =None_)¶
    

_exception _angr.SimShadowStackError¶
    

Bases: `SimProcedureError`

_exception _angr.SimSlicerError¶
    

Bases: `SimError`

_exception _angr.SimSolverError¶
    

Bases: `SimError`

_exception _angr.SimSolverModeError¶
    

Bases: `SimSolverError`

_exception _angr.SimSolverOptionError¶
    

Bases: `SimSolverError`

_class _angr.SimState(_project =None_, _arch =None_, _plugins =None_, _mode =None_, _options =None_, _add_options =None_, _remove_options =None_, _special_memory_filler =None_, _os_name =None_, _plugin_preset ='default'_, _cle_memory_backer =None_, _dict_memory_backer =None_, _permissions_map =None_, _default_permissions =3_, _stack_perms =None_, _stack_end =None_, _stack_size =None_, _regioned_memory_cls =None_, _** kwargs_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`IPTypeConc`, `IPTypeSym`], `PluginHub`[`SimStatePlugin`]

The SimState represents the state of a program, including its memory, registers, and so forth.

Parameters:
    

  * **project** (_angr.Project_) – The project instance.

  * **arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)") _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The architecture of the state.

  * **plugins** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__SimStatePlugin_ _]__|__None_)

  * **mode** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **options** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|_[_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__SimStateOptions_ _|__None_)

  * **add_options** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **remove_options** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **special_memory_filler** (_Callable_ _[__[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__SimState_ _]__,__Any_ _]__|__None_)

  * **os_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **plugin_preset** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **cle_memory_backer** (_Clemory_ _|__None_)

  * **dict_memory_backer** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") _]__|__None_)

  * **permissions_map** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **default_permissions** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **stack_perms** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **stack_end** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **stack_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

Variables:
    

  * **regs** – A convenient view of the state’s registers, where each register is a property

  * **mem** – A convenient view of the state’s memory, a `angr.state_plugins.view.SimMemView`

  * **registers** – The state’s register file as a flat memory region

  * **memory** – The state’s memory as a flat memory region

  * **solver** – The symbolic solver and variable manager for this state

  * **inspect** – The breakpoint manager, a `angr.state_plugins.inspect.SimInspector`

  * **log** – Information about the state’s history

  * **scratch** – Information about the current execution step

  * **posix** – MISNOMER: information about the operating system or environment model

  * **fs** – The current state of the simulated filesystem

  * **libc** – Information about the standard library we are emulating

  * **cgc** – Information about the cgc environment

  * **uc_manager** – Control of under-constrained symbolic execution

  * **unicorn** – Control of the Unicorn Engine

solver _: SimSolver_¶
    

posix _: SimSystemPosix_¶
    

registers _: DefaultMemory_¶
    

regs _: SimRegNameView_¶
    

memory _: DefaultMemory_¶
    

callstack _: CallStack_¶
    

mem _: SimMemView_¶
    

history _: SimStateHistory_¶
    

inspect _: SimInspector_¶
    

jni_references _: SimStateJNIReferences_¶
    

scratch _: SimStateScratch_¶
    

__init__(_project =None_, _arch =None_, _plugins =None_, _mode =None_, _options =None_, _add_options =None_, _remove_options =None_, _special_memory_filler =None_, _os_name =None_, _plugin_preset ='default'_, _cle_memory_backer =None_, _dict_memory_backer =None_, _permissions_map =None_, _default_permissions =3_, _stack_perms =None_, _stack_end =None_, _stack_size =None_, _regioned_memory_cls =None_, _** kwargs_)¶
    

Parameters:
    

  * **project** (_Project_ _|__None_)

  * **arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)") _|__None_)

  * **plugins** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__SimStatePlugin_ _]__|__None_)

  * **mode** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **options** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|_[_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__SimStateOptions_ _|__None_)

  * **add_options** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **remove_options** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **special_memory_filler** ([_Callable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)") _[__[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__SimState_ _]__,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]__|__None_)

  * **os_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **plugin_preset** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **cle_memory_backer** ([_Clemory_](https://docs.angr.io/projects/cle/en/latest/api/utils.html#cle.memory.Clemory "\(in cle\)") _|__None_)

  * **dict_memory_backer** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") _]__|__None_)

  * **permissions_map** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **default_permissions** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **stack_perms** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **stack_end** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **stack_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

_property _plugins¶
    

_property _ip¶
    

Get the instruction pointer expression, trigger SimInspect breakpoints, and generate SimActions. Use `_ip` to not trigger breakpoints or generate actions.

Returns:
    

an expression

_property _addr _: IPTypeConc_¶
    

Get the concrete address of the instruction pointer, without triggering SimInspect breakpoints or generating SimActions. An integer is returned, or an exception is raised if the instruction pointer is symbolic.

Returns:
    

an int

_property _arch _: [Arch](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)")_¶
    

T _ = ~T_¶
    

get_plugin(_name_)¶
    

Get the plugin named `name`. If no such plugin is currently active, try to activate a new one using the current preset.

has_plugin(_name_)¶
    

Return whether or not a plugin with the name `name` is currently active.

register_plugin(_name_ , _plugin_ , _inhibit_init =False_)¶
    

Add a new plugin `plugin` with name `name` to the active plugins.

_property _javavm_memory¶
    

In case of an JavaVM with JNI support, a state can store the memory plugin twice; one for the native and one for the java view of the state.

Returns:
    

The JavaVM view of the memory plugin.

_property _javavm_registers¶
    

In case of an JavaVM with JNI support, a state can store the registers plugin twice; one for the native and one for the java view of the state.

Returns:
    

The JavaVM view of the registers plugin.

simplify(_* args_)¶
    

Simplify this state’s constraints.

add_constraints(_* constraints_)¶
    

Add some constraints to the state.

You may pass in any number of symbolic booleans as variadic positional arguments.

satisfiable(_** kwargs_)¶
    

Whether the state’s constraints are satisfiable

downsize()¶
    

Clean up after the solver engine. Calling this when a state no longer needs to be solved on will reduce memory usage.

step(_** kwargs_)¶
    

Perform a step of symbolic execution using this state. Any arguments to AngrObjectFactory.successors can be passed to this.

Returns:
    

A SimSuccessors object categorizing the results of the step.

block(_* args_, _** kwargs_)¶
    

Represent the basic block at this state’s instruction pointer. Any arguments to AngrObjectFactory.block can ba passed to this.

Returns:
    

A Block object describing the basic block of code at this point.

copy()¶
    

Returns a copy of the state.

merge(_* others_, _** kwargs_)¶
    

Merges this state with the other states. Returns the merging result, merged state, and the merge flag.

Parameters:
    

  * **states** – the states to merge

  * **merge_conditions** – a tuple of the conditions under which each state holds

  * **common_ancestor** – a state that represents the common history between the states being merged. Usually it is only available when EFFICIENT_STATE_MERGING is enabled, otherwise weak-refed states might be dropped from state history instances.

  * **plugin_whitelist** – a list of plugin names that will be merged. If this option is given and is not None, any plugin that is not inside this list will not be merged, and will be created as a fresh instance in the new state.

  * **common_ancestor_history** – a SimStateHistory instance that represents the common history between the states being merged. This is to allow optimal state merging when EFFICIENT_STATE_MERGING is disabled.

Returns:
    

(merged state, merge flag, a bool indicating if any merging occurred)

widen(_* others_)¶
    

Perform a widening between self and other states :type others: :param others: :return:

reg_concrete(_* args_, _** kwargs_)¶
    

Returns the contents of a register but, if that register is symbolic, raises a SimValueError.

mem_concrete(_* args_, _** kwargs_)¶
    

Returns the contents of a memory but, if the contents are symbolic, raises a SimValueError.

stack_push(_thing_)¶
    

Push ‘thing’ to the stack, writing the thing to memory and adjusting the stack pointer.

stack_pop()¶
    

Pops from the stack and returns the popped thing. The length will be the architecture word size.

stack_read(_offset_ , _length_ , _bp =False_)¶
    

Reads length bytes, at an offset into the stack.

Parameters:
    

  * **offset** – The offset from the stack pointer.

  * **length** – The number of bytes to read.

  * **bp** – If True, offset from the BP instead of the SP. Default: False.

make_concrete_int(_expr_)¶
    

prepare_callsite(_retval_ , _args_ , _cc ='wtf'_)¶
    

dbg_print_stack(_depth =None_, _sp =None_)¶
    

Only used for debugging purposes. Return the current stack info in formatted string. If depth is None, the current stack frame (from sp to bp) will be printed out.

set_mode(_mode_)¶
    

_property _thumb¶
    

_property _with_condition¶
    

_exception _angr.SimStateError¶
    

Bases: `SimError`

_exception _angr.SimStateOptionsError¶
    

Bases: `SimError`

_class _angr.SimStatePlugin¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

This is a base class for SimState plugins. A SimState plugin will be copied along with the state when the state is branched. They are intended to be used for things such as tracking open files, tracking heap details, and providing storage and persistence for SimProcedures.

STRONGREF_STATE _ = False_¶
    

__init__()¶
    

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

set_strongref_state(_state_)¶
    

copy(__memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

_static _memo(_f_)¶
    

A decorator function you should apply to `copy`

Return type:
    

`_CopyFunc`[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)]

Parameters:
    

**f** ([_Callable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)") _[__[__T_ _,_[_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]__]__,__S_co_ _]_)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_classmethod _register_default(_name_ , _xtr =None_)¶
    

init_state()¶
    

Use this function to perform any initialization on the state at plugin-add time

_exception _angr.SimStatementError¶
    

Bases: `SimError`

_exception _angr.SimSymbolicFilesystemError¶
    

Bases: `SimFilesystemError`

_exception _angr.SimTranslationError¶
    

Bases: `SimEngineError`

_exception _angr.SimUCManagerAllocationError¶
    

Bases: `SimUCManagerError`

_exception _angr.SimUCManagerError¶
    

Bases: `SimError`

_exception _angr.SimUnicornError¶
    

Bases: `SimError`

_exception _angr.SimUnicornSymbolic¶
    

Bases: `SimError`

_exception _angr.SimUnicornUnsupport¶
    

Bases: `SimError`

_exception _angr.SimUninitializedAccessError(_expr_type_ , _expr_)¶
    

Bases: `SimExpressionError`

__init__(_expr_type_ , _expr_)¶
    

_exception _angr.SimUnsatError¶
    

Bases: `SimValueError`

_exception _angr.SimUnsupportedError¶
    

Bases: `SimError`

_exception _angr.SimValueError¶
    

Bases: `SimSolverError`

_exception _angr.SimZeroDivisionException¶
    

Bases: `SimException`, `SimOperationError`

_class _angr.SimulationManager(_project_ , _active_states=None_ , _stashes=None_ , _hierarchy=None_ , _resilience=None_ , _save_unsat=False_ , _auto_drop=None_ , _errored=None_ , _completion_mode= <built-in function any>_, _techniques=None_ , _suggestions=True_ , _**kwargs_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

The Simulation Manager is the future future.

Simulation managers allow you to wrangle multiple states in a slick way. States are organized into “stashes”, which you can step forward, filter, merge, and move around as you wish. This allows you to, for example, step two different stashes of states at different rates, then merge them together.

Stashes can be accessed as attributes (i.e. .active). A mulpyplexed stash can be retrieved by prepending the name with mp_, e.g. .mp_active. A single state from the stash can be retrieved by prepending the name with one_, e.g. .one_active.

Note that you shouldn’t usually be constructing SimulationManagers directly - there is a convenient shortcut for creating them in `Project.factory`: see `angr.factory.AngrObjectFactory`.

The most important methods you should look at are `step`, `explore`, and `use_technique`.

Parameters:
    

  * **project** (_angr.project.Project_) – A Project instance.

  * **stashes** – A dictionary to use as the stash store.

  * **active_states** – Active states to seed the “active” stash with.

  * **hierarchy** – A StateHierarchy object to use to track the relationships between states.

  * **resilience** – A set of errors to catch during stepping to put a state in the `errore` list. You may also provide the values False, None (default), or True to catch, respectively, no errors, all angr-specific errors, and a set of many common errors.

  * **save_unsat** – Set to True in order to introduce unsatisfiable states into the `unsat` stash instead of discarding them immediately.

  * **auto_drop** – A set of stash names which should be treated as garbage chutes.

  * **completion_mode** – A function describing how multiple exploration techniques with the `complete` hook set will interact. By default, the builtin function `any`.

  * **techniques** – A list of techniques that should be pre-set to use with this manager.

  * **suggestions** – Whether to automatically install the Suggestions exploration technique. Default True.

Variables:
    

  * **errored** – Not a stash, but a list of ErrorRecords. Whenever a step raises an exception that we catch, the state and some information about the error are placed in this list. You can adjust the list of caught exceptions with the resilience parameter.

  * **stashes** – All the stashes on this instance, as a dictionary.

  * **completion_mode** – A function describing how multiple exploration techniques with the `complete` hook set will interact. By default, the builtin function `any`.

ALL _ = '_ALL'_¶
    

DROP _ = '_DROP'_¶
    

__init__(_project_ , _active_states=None_ , _stashes=None_ , _hierarchy=None_ , _resilience=None_ , _save_unsat=False_ , _auto_drop=None_ , _errored=None_ , _completion_mode= <built-in function any>_, _techniques=None_ , _suggestions=True_ , _**kwargs_)¶
    

active _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`SimState`]_¶
    

stashed _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`SimState`]_¶
    

pruned _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`SimState`]_¶
    

unsat _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`SimState`]_¶
    

deadended _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`SimState`]_¶
    

unconstrained _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`SimState`]_¶
    

found _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`SimState`]_¶
    

one_active _: `SimState`_¶
    

one_stashed _: `SimState`_¶
    

one_pruned _: `SimState`_¶
    

one_unsat _: `SimState`_¶
    

one_deadended _: `SimState`_¶
    

one_unconstrained _: `SimState`_¶
    

one_found _: `SimState`_¶
    

_property _errored _: [list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[ErrorRecord]_¶
    

_property _stashes _: [defaultdict](https://docs.python.org/3/library/collections.html#collections.defaultdict "\(in Python v3.13\)")[[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"), [list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[SimState]]_¶
    

mulpyplex(_* stashes_)¶
    

Mulpyplex across several stashes.

Parameters:
    

**stashes** – the stashes to mulpyplex

Returns:
    

a mulpyplexed list of states from the stashes in question, in the specified order

copy(_deep =False_)¶
    

Make a copy of this simulation manager. Pass `deep=True` to copy all the states in it as well.

If the current callstack includes hooked methods, the already-called methods will not be included in the copy.

use_technique(_tech_)¶
    

Use an exploration technique with this SimulationManager.

Techniques can be found in `angr.exploration_techniques`.

Parameters:
    

**tech** (_ExplorationTechnique_) – An ExplorationTechnique object that contains code to modify this SimulationManager’s behavior.

Returns:
    

The technique that was added, for convenience

remove_technique(_tech_)¶
    

Remove an exploration technique from a list of active techniques.

Parameters:
    

**tech** (_ExplorationTechnique_) – An ExplorationTechnique object.

explore(_stash ='active'_, _n =None_, _find =None_, _avoid =None_, _find_stash ='found'_, _avoid_stash ='avoid'_, _cfg =None_, _num_find =1_, _avoid_priority =False_, _** kwargs_)¶
    

Tick stash “stash” forward (up to “n” times or until “num_find” states are found), looking for condition “find”, avoiding condition “avoid”. Stores found states into “find_stash’ and avoided states into “avoid_stash”.

The “find” and “avoid” parameters may be any of:

  * An address to find

  * A set or list of addresses to find

  * A function that takes a state and returns whether or not it matches.

If an angr CFG is passed in as the “cfg” parameter and “find” is either a number or a list or a set, then any states which cannot possibly reach a success state without going through a failure state will be preemptively avoided.

run(_stash ='active'_, _n =None_, _until =None_, _** kwargs_)¶
    

Run until the SimulationManager has reached a completed state, according to the current exploration techniques. If no exploration techniques that define a completion state are being used, run until there is nothing left to run.

Parameters:
    

  * **stash** – Operate on this stash

  * **n** – Step at most this many times

  * **until** – If provided, should be a function that takes a SimulationManager and returns True or False. Stepping will terminate when it is True.

Returns:
    

The simulation manager, for chaining.

Return type:
    

SimulationManager

complete()¶
    

Returns whether or not this manager has reached a “completed” state.

step(_stash ='active'_, _target_stash =None_, _n =None_, _selector_func =None_, _step_func =None_, _error_list =None_, _successor_func =None_, _until =None_, _filter_func =None_, _** run_args_)¶
    

Step a stash of states forward and categorize the successors appropriately.

The parameters to this function allow you to control everything about the stepping and categorization process.

Parameters:
    

  * **stash** – The name of the stash to step (default: ‘active’)

  * **target_stash** – The name of the stash to put the results in (default: same as `stash`)

  * **error_list** – The list to put ErrorRecord objects in (default: `self.errored`)

  * **selector_func** – If provided, should be a function that takes a state and returns a boolean. If True, the state will be stepped. Otherwise, it will be kept as-is.

  * **step_func** – If provided, should be a function that takes a SimulationManager and returns a SimulationManager. Will be called with the SimulationManager at every step. Note that this function should not actually perform any stepping - it is meant to be a maintenance function called after each step.

  * **successor_func** – If provided, should be a function that takes a state and return its successors. Otherwise, project.factory.successors will be used.

  * **filter_func** – If provided, should be a function that takes a state and return the name of the stash, to which the state should be moved.

  * **until** – (DEPRECATED) If provided, should be a function that takes a SimulationManager and returns True or False. Stepping will terminate when it is True.

  * **n** – (DEPRECATED) The number of times to step (default: 1 if “until” is not provided)

Additionally, you can pass in any of the following keyword args for project.factory.successors:

Parameters:
    

  * **jumpkind** – The jumpkind of the previous exit

  * **addr** – An address to execute at instead of the state’s ip.

  * **stmt_whitelist** – A list of stmt indexes to which to confine execution.

  * **last_stmt** – A statement index at which to stop execution.

  * **thumb** – Whether the block should be lifted in ARM’s THUMB mode.

  * **backup_state** – A state to read bytes from instead of using project memory.

  * **opt_level** – The VEX optimization level to use.

  * **insn_bytes** – A string of bytes to use for the block instead of the project.

  * **size** – The maximum size of the block, in bytes.

  * **num_inst** – The maximum number of instructions.

  * **traceflags** – traceflags to be passed to VEX. Default: 0

Returns:
    

The simulation manager, for chaining.

Return type:
    

SimulationManager

step_state(_state_ , _successor_func =None_, _error_list =None_, _** run_args_)¶
    

Don’t use this function manually - it is meant to interface with exploration techniques.

filter(_state_ , _filter_func =None_)¶
    

Don’t use this function manually - it is meant to interface with exploration techniques.

selector(_state_ , _selector_func =None_)¶
    

Don’t use this function manually - it is meant to interface with exploration techniques.

successors(_state_ , _successor_func =None_, _** run_args_)¶
    

Don’t use this function manually - it is meant to interface with exploration techniques.

prune(_filter_func =None_, _from_stash ='active'_, _to_stash ='pruned'_)¶
    

Prune unsatisfiable states from a stash.

This function will move all unsatisfiable states in the given stash into a different stash.

Parameters:
    

  * **filter_func** – Only prune states that match this filter.

  * **from_stash** – Prune states from this stash. (default: ‘active’)

  * **to_stash** – Put pruned states in this stash. (default: ‘pruned’)

Returns:
    

The simulation manager, for chaining.

Return type:
    

SimulationManager

populate(_stash_ , _states_)¶
    

Populate a stash with a collection of states.

Parameters:
    

  * **stash** – A stash to populate.

  * **states** – A list of states with which to populate the stash.

absorb(_simgr_)¶
    

Collect all the states from `simgr` and put them in their corresponding stashes in this manager. This will not modify `simgr`.

move(_from_stash_ , _to_stash_ , _filter_func =None_)¶
    

Move states from one stash to another.

Parameters:
    

  * **from_stash** – Take matching states from this stash.

  * **to_stash** – Put matching states into this stash.

  * **filter_func** – Stash states that match this filter. Should be a function that takes a state and returns True or False. (default: stash all states)

Returns:
    

The simulation manager, for chaining.

Return type:
    

SimulationManager

stash(_filter_func =None_, _from_stash ='active'_, _to_stash ='stashed'_)¶
    

Stash some states. This is an alias for move(), with defaults for the stashes.

Parameters:
    

  * **filter_func** – Stash states that match this filter. Should be a function that takes a state and returns True or False. (default: stash all states)

  * **from_stash** – Take matching states from this stash. (default: ‘active’)

  * **to_stash** – Put matching states into this stash. (default: ‘stashed’)

Returns:
    

The simulation manager, for chaining.

Return type:
    

SimulationManager

unstash(_filter_func =None_, _to_stash ='active'_, _from_stash ='stashed'_)¶
    

Unstash some states. This is an alias for move(), with defaults for the stashes.

Parameters:
    

  * **filter_func** – Unstash states that match this filter. Should be a function that takes a state and returns True or False. (default: unstash all states)

  * **from_stash** – take matching states from this stash. (default: ‘stashed’)

  * **to_stash** – put matching states into this stash. (default: ‘active’)

Returns:
    

The simulation manager, for chaining.

Return type:
    

SimulationManager

drop(_filter_func =None_, _stash ='active'_)¶
    

Drops states from a stash. This is an alias for move(), with defaults for the stashes.

Parameters:
    

  * **filter_func** – Drop states that match this filter. Should be a function that takes a state and returns True or False. (default: drop all states)

  * **stash** – Drop matching states from this stash. (default: ‘active’)

Returns:
    

The simulation manager, for chaining.

Return type:
    

SimulationManager

apply(_state_func =None_, _stash_func =None_, _stash ='active'_, _to_stash =None_)¶
    

Applies a given function to a given stash.

Parameters:
    

  * **state_func** – A function to apply to every state. Should take a state and return a state. The returned state will take the place of the old state. If the function _doesn’t_ return a state, the old state will be used. If the function returns a list of states, they will replace the original states.

  * **stash_func** – A function to apply to the whole stash. Should take a list of states and return a list of states. The resulting list will replace the stash. If both state_func and stash_func are provided state_func is applied first, then stash_func is applied on the results.

  * **stash** – A stash to work with.

  * **to_stash** – If specified, this stash will be used to store the resulting states instead.

Returns:
    

The simulation manager, for chaining.

Return type:
    

SimulationManager

split(_stash_splitter =None_, _stash_ranker =None_, _state_ranker =None_, _limit =8_, _from_stash ='active'_, _to_stash ='stashed'_)¶
    

Split a stash of states into two stashes depending on the specified options.

The stash from_stash will be split into two stashes depending on the other options passed in. If to_stash is provided, the second stash will be written there.

stash_splitter overrides stash_ranker, which in turn overrides state_ranker. If no functions are provided, the states are simply split according to the limit.

The sort done with state_ranker is ascending.

Parameters:
    

  * **stash_splitter** – A function that should take a list of states and return a tuple of two lists (the two resulting stashes).

  * **stash_ranker** – A function that should take a list of states and return a sorted list of states. This list will then be split according to “limit”.

  * **state_ranker** – An alternative to stash_splitter. States will be sorted with outputs of this function, which are to be used as a key. The first “limit” of them will be kept, the rest split off.

  * **limit** – For use with state_ranker. The number of states to keep. Default: 8

  * **from_stash** – The stash to split (default: ‘active’)

  * **to_stash** – The stash to write to (default: ‘stashed’)

Returns:
    

The simulation manager, for chaining.

Return type:
    

SimulationManager

merge(_merge_func =None_, _merge_key =None_, _stash ='active'_, _prune =True_)¶
    

Merge the states in a given stash.

Parameters:
    

  * **stash** – The stash (default: ‘active’)

  * **merge_func** – If provided, instead of using state.merge, call this function with the states as the argument. Should return the merged state.

  * **merge_key** – If provided, should be a function that takes a state and returns a key that will compare equal for all states that are allowed to be merged together, as a first approximation. By default: uses PC, callstack, and open file descriptors.

  * **prune** – Whether to prune the stash prior to merging it

Returns:
    

The simulation manager, for chaining.

Return type:
    

SimulationManager

_exception _angr.SimulationManagerError¶
    

Bases: `AngrError`

_class _angr.StateHierarchy¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

The state hierarchy holds weak references to SimStateHistory objects in a directed acyclic graph. It is useful for queries about a state’s ancestry, notably “what is the best ancestor state for a merge among these states” and “what is the most recent unsatisfiable state while using LAZY_SOLVES”

__init__()¶
    

get_ref(_obj_)¶
    

dead_ref(_ref_)¶
    

defer_cleanup()¶
    

add_state(_s_)¶
    

add_history(_h_)¶
    

simplify()¶
    

full_simplify()¶
    

lineage(_h_)¶
    

Returns the lineage of histories leading up to h.

all_successors(_h_)¶
    

history_successors(_h_)¶
    

history_predecessors(_h_)¶
    

history_contains(_h_)¶
    

unreachable_state(_state_)¶
    

unreachable_history(_h_)¶
    

most_mergeable(_states_)¶
    

Find the “most mergeable” set of states from those provided.

Parameters:
    

**states** – a list of states

Returns:
    

a tuple of: (list of states to merge, those states’ common history, list of states to not merge yet)

_exception _angr.TracerEnvironmentError¶
    

Bases: `AngrError`

_exception _angr.UnsupportedCCallError¶
    

Bases: `SimCCallError`, `SimUnsupportedError`

_exception _angr.UnsupportedDirtyError¶
    

Bases: `UnsupportedIRStmtError`, `SimUnsupportedError`

_exception _angr.UnsupportedIRExprError¶
    

Bases: `SimExpressionError`, `SimUnsupportedError`

_exception _angr.UnsupportedIROpError¶
    

Bases: `SimOperationError`, `SimUnsupportedError`

_exception _angr.UnsupportedIRStmtError¶
    

Bases: `SimStatementError`, `SimUnsupportedError`

_exception _angr.UnsupportedNodeTypeError¶
    

Bases: `AngrError`, [`NotImplementedError`](https://docs.python.org/3/library/exceptions.html#NotImplementedError "\(in Python v3.13\)")

angr.UnsupportedSyscallError¶
    

alias of `AngrUnsupportedSyscallError`

angr.default_cc(_arch_ , _platform ='Linux'_, _language =None_, _syscall =False_, _default =None_)¶
    

Return the default calling convention for a given architecture, platform, and language combination.

Parameters:
    

  * **arch** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The architecture name.

  * **platform** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")) – The platform name (e.g., “Linux” or “Win32”).

  * **language** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]) – The programming language name (e.g., “go”).

  * **syscall** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Return syscall convention (True), or normal calling convention (False, default).

  * **default** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`SimCC`]]) – The default calling convention to return if nothing fits.

Return type:
    

[`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`SimCC`] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

A default calling convention class if we can find one for the architecture, platform, and language combination, or the default if nothing fits.

angr.load_shellcode(_shellcode_ , _arch_ , _start_offset =0_, _load_address =0_, _thumb =False_, _** kwargs_)¶
    

Load a new project based on a snippet of assembly or bytecode.

Parameters:
    

  * **shellcode** ([`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") | [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The data to load, as either a bytestring of instructions or a string of assembly text

  * **arch** – The name of the arch to use, or an archinfo class

  * **start_offset** – The offset into the data to start analysis (default 0)

  * **load_address** – The address to place the data in memory (default 0)

  * **thumb** – Whether this is ARM Thumb shellcode

angr.register_analysis(_cls_ , _name_)¶
    

## Project¶

angr.project.load_shellcode(_shellcode_ , _arch_ , _start_offset =0_, _load_address =0_, _thumb =False_, _** kwargs_)¶
    

Load a new project based on a snippet of assembly or bytecode.

Parameters:
    

  * **shellcode** ([`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") | [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The data to load, as either a bytestring of instructions or a string of assembly text

  * **arch** – The name of the arch to use, or an archinfo class

  * **start_offset** – The offset into the data to start analysis (default 0)

  * **load_address** – The address to place the data in memory (default 0)

  * **thumb** – Whether this is ARM Thumb shellcode

_class _angr.project.Project(_thing_ , _default_analysis_mode =None_, _ignore_functions =None_, _use_sim_procedures =True_, _exclude_sim_procedures_func =None_, _exclude_sim_procedures_list =()_, _arch =None_, _simos =None_, _engine =None_, _load_options =None_, _translation_cache =True_, _selfmodifying_code =False_, _support_selfmodifying_code =None_, _store_function =None_, _load_function =None_, _analyses_preset =None_, _concrete_target =None_, _eager_ifunc_resolution =None_, _** kwargs_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

This is the main class of the angr module. It is meant to contain a set of binaries and the relationships between them, and perform analyses on them.

Parameters:
    

  * **thing** – The path to the main executable object to analyze, or a CLE Loader object.

  * **arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)"))

  * **load_options** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__Any_ _]__|__None_)

  * **selfmodifying_code** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **support_selfmodifying_code** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

The following parameters are optional.

Parameters:
    

  * **default_analysis_mode** – The mode of analysis to use by default. Defaults to ‘symbolic’.

  * **ignore_functions** – A list of function names that, when imported from shared libraries, should never be stepped into in analysis (calls will return an unconstrained value).

  * **use_sim_procedures** – Whether to replace resolved dependencies for which simprocedures are available with said simprocedures.

  * **exclude_sim_procedures_func** – A function that, when passed a function name, returns whether or not to wrap it with a simprocedure.

  * **exclude_sim_procedures_list** – A list of functions to _not_ wrap with simprocedures.

  * **arch** – The target architecture (auto-detected otherwise).

  * **simos** – a SimOS class to use for this project.

  * **engine** – The SimEngine class to use for this project.

  * **translation_cache** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If True, cache translated basic blocks rather than re-translating them.

  * **selfmodifying_code** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether we aggressively support self-modifying code. When enabled, emulation will try to read code from the current state instead of the original memory, regardless of the current memory protections.

  * **store_function** – A function that defines how the Project should be stored. Default to pickling.

  * **load_function** – A function that defines how the Project should be loaded. Default to unpickling.

  * **analyses_preset** (_angr.misc.PluginPreset_) – The plugin preset for the analyses provider (i.e. Analyses instance).

  * **load_options** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__Any_ _]__|__None_)

  * **support_selfmodifying_code** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

Any additional keyword arguments passed will be passed onto `cle.Loader`.

Variables:
    

  * **analyses** – The available analyses.

  * **entry** – The program entrypoint.

  * **factory** – Provides access to important analysis elements such as path groups and symbolic execution results.

  * **filename** – The filename of the executable.

  * **loader** – The program loader.

  * **storage** – Dictionary of things that should be loaded/stored with the Project.

Parameters:
    

  * **arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)"))

  * **load_options** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__Any_ _]__|__None_)

  * **selfmodifying_code** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **support_selfmodifying_code** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

__init__(_thing_ , _default_analysis_mode =None_, _ignore_functions =None_, _use_sim_procedures =True_, _exclude_sim_procedures_func =None_, _exclude_sim_procedures_list =()_, _arch =None_, _simos =None_, _engine =None_, _load_options =None_, _translation_cache =True_, _selfmodifying_code =False_, _support_selfmodifying_code =None_, _store_function =None_, _load_function =None_, _analyses_preset =None_, _concrete_target =None_, _eager_ifunc_resolution =None_, _** kwargs_)¶
    

Parameters:
    

  * **load_options** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]__|__None_)

  * **selfmodifying_code** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **support_selfmodifying_code** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

arch _: [`Arch`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)")_¶
    

_property _kb¶
    

get_kb(_name_)¶
    

_property _analyses _: AnalysesHubWithDefault_¶
    

hook(_addr_ , _hook =None_, _length =0_, _kwargs =None_, _replace =False_)¶
    

Hook a section of code with a custom function. This is used internally to provide symbolic summaries of library functions, and can be used to instrument execution or to modify control flow.

When hook is not specified, it returns a function decorator that allows easy hooking. Usage:
    
    
    # Assuming proj is an instance of angr.Project, we will add a custom hook at the entry
    # point of the project.
    @proj.hook(proj.entry)
    def my_hook(state):
        print("Welcome to execution!")
    

Parameters:
    

  * **addr** – The address to hook.

  * **hook** – A `angr.project.Hook` describing a procedure to run at the given address. You may also pass in a SimProcedure class or a function directly and it will be wrapped in a Hook object for you.

  * **length** – If you provide a function for the hook, this is the number of bytes that will be skipped by executing the hook by default.

  * **kwargs** – If you provide a SimProcedure for the hook, these are the keyword arguments that will be passed to the procedure’s run method eventually.

  * **replace** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")) – Control the behavior on finding that the address is already hooked. If true, silently replace the hook. If false (default), warn and do not replace the hook. If none, warn and replace the hook.

is_hooked(_addr_)¶
    

Returns True if addr is hooked.

Parameters:
    

**addr** – An address.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

True if addr is hooked, False otherwise.

hooked_by(_addr_)¶
    

Returns the current hook for addr.

Parameters:
    

**addr** – An address.

Return type:
    

`SimProcedure` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

None if the address is not hooked.

unhook(_addr_)¶
    

Remove a hook.

Parameters:
    

**addr** – The address of the hook.

hook_symbol(_symbol_name_ , _simproc_ , _kwargs =None_, _replace =None_)¶
    

Resolve a dependency in a binary. Looks up the address of the given symbol, and then hooks that address. If the symbol was not available in the loaded libraries, this address may be provided by the CLE externs object.

Additionally, if instead of a symbol name you provide an address, some secret functionality will kick in and you will probably just hook that address, UNLESS you’re on powerpc64 ABIv1 or some yet-unknown scary ABI that has its function pointers point to something other than the actual functions, in which case it’ll do the right thing.

Parameters:
    

  * **symbol_name** – The name of the dependency to resolve.

  * **simproc** – The SimProcedure instance (or function) with which to hook the symbol

  * **kwargs** – If you provide a SimProcedure for the hook, these are the keyword arguments that will be passed to the procedure’s run method eventually.

  * **replace** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")]) – Control the behavior on finding that the address is already hooked. If true, silently replace the hook. If false, warn and do not replace the hook. If none (default), warn and replace the hook.

Returns:
    

The address of the new symbol.

Return type:
    

[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

symbol_hooked_by(_symbol_name_)¶
    

Return the SimProcedure, if it exists, for the given symbol name.

Parameters:
    

**symbol_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of the symbol.

Return type:
    

`SimProcedure` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

None if the address is not hooked.

is_symbol_hooked(_symbol_name_)¶
    

Check if a symbol is already hooked.

Parameters:
    

**symbol_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of the symbol.

Returns:
    

True if the symbol can be resolved and is hooked, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

unhook_symbol(_symbol_name_)¶
    

Remove the hook on a symbol. This function will fail if the symbol is provided by the extern object, as that would result in a state where analysis would be unable to cope with a call to this symbol.

rehook_symbol(_new_address_ , _symbol_name_ , _stubs_on_sync_)¶
    

Move the hook for a symbol to a specific address :type new_address: :param new_address: the new address that will trigger the SimProc execution :type symbol_name: :param symbol_name: the name of the symbol (f.i. strcmp ) :return: None

execute(_* args_, _** kwargs_)¶
    

This function is a symbolic execution helper in the simple style supported by triton and manticore. It designed to be run after setting up hooks (see Project.hook), in which the symbolic state can be checked.

This function can be run in three different ways:

>   * When run with no parameters, this function begins symbolic execution from the entrypoint.
> 
>   * It can also be run with a “state” parameter specifying a SimState to begin symbolic execution from.
> 
>   * Finally, it can accept any arbitrary keyword arguments, which are all passed to project.factory.full_init_state.
> 
> 

If symbolic execution finishes, this function returns the resulting simulation manager.

terminate_execution()¶
    

Terminates a symbolic execution that was started with Project.execute().

_class _angr.factory.AngrObjectFactory(_project_ , _default_engine =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

This factory provides access to important analysis elements.

Parameters:
    

**default_engine** ([_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__SimEngine_ _]__|__None_)

__init__(_project_ , _default_engine =None_)¶
    

Parameters:
    

**default_engine** ([_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__SimEngine_ _]__|__None_)

default_engine_factory _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`SimEngine`]_¶
    

project _: `Project`_¶
    

procedure_engine _: `ProcedureEngine`_¶
    

_property _default_engine¶
    

snippet(_addr_ , _jumpkind =None_, _** block_opts_)¶
    

successors(_* args_, _engine =None_, _** kwargs_)¶
    

Perform execution using an engine. Generally, return a SimSuccessors object classifying the results of the run.

Parameters:
    

  * **state** – The state to analyze

  * **engine** – The engine to use. If not provided, will use the project default.

  * **addr** – optional, an address to execute at instead of the state’s ip

  * **jumpkind** – optional, the jumpkind of the previous exit

  * **inline** – This is an inline execution. Do not bother copying the state.

Additional keyword arguments will be passed directly into each engine’s process method.

blank_state(_** kwargs_)¶
    

Returns a mostly-uninitialized state object. All parameters are optional.

Parameters:
    

  * **addr** – The address the state should start at instead of the entry point.

  * **initial_prefix** – If this is provided, all symbolic registers will hold symbolic values with names prefixed by this string.

  * **fs** – A dictionary of file names with associated preset SimFile objects.

  * **concrete_fs** – bool describing whether the host filesystem should be consulted when opening files.

  * **chroot** – A path to use as a fake root directory, Behaves similarly to a real chroot. Used only when concrete_fs is set to True.

  * **kwargs** – Any additional keyword args will be passed to the SimState constructor.

Returns:
    

The blank state.

Return type:
    

SimState

entry_state(_** kwargs_)¶
    

Returns a state object representing the program at its entry point. All parameters are optional.

Parameters:
    

  * **addr** – The address the state should start at instead of the entry point.

  * **initial_prefix** – If this is provided, all symbolic registers will hold symbolic values with names prefixed by this string.

  * **fs** – a dictionary of file names with associated preset SimFile objects.

  * **concrete_fs** – boolean describing whether the host filesystem should be consulted when opening files.

  * **chroot** – a path to use as a fake root directory, behaves similar to a real chroot. used only when concrete_fs is set to True.

  * **argc** – a custom value to use for the program’s argc. May be either an int or a bitvector. If not provided, defaults to the length of args.

  * **args** – a list of values to use as the program’s argv. May be mixed strings and bitvectors.

  * **env** – a dictionary to use as the environment for the program. Both keys and values may be mixed strings and bitvectors.

Returns:
    

The entry state.

Return type:
    

SimState

full_init_state(_** kwargs_)¶
    

Very much like `entry_state()`, except that instead of starting execution at the program entry point, execution begins at a special SimProcedure that plays the role of the dynamic loader, calling each of the initializer functions that should be called before execution reaches the entry point.

It can take any of the arguments that can be provided to `entry_state`, except for `addr`.

call_state(_addr_ , _* args_, _** kwargs_)¶
    

Returns a state object initialized to the start of a given function, as if it were called with given parameters.

Parameters:
    

  * **addr** – The address the state should start at instead of the entry point.

  * **args** – Any additional positional arguments will be used as arguments to the function call.

The following parameters are optional.

Parameters:
    

  * **base_state** – Use this SimState as the base for the new state instead of a blank state.

  * **cc** – Optionally provide a SimCC object to use a specific calling convention.

  * **ret_addr** – Use this address as the function’s return target.

  * **stack_base** – An optional pointer to use as the top of the stack, circa the function entry point

  * **alloc_base** – An optional pointer to use as the place to put excess argument data

  * **grow_like_stack** – When allocating data at alloc_base, whether to allocate at decreasing addresses

  * **toc** – The address of the table of contents for ppc64

  * **initial_prefix** – If this is provided, all symbolic registers will hold symbolic values with names prefixed by this string.

  * **fs** – A dictionary of file names with associated preset SimFile objects.

  * **concrete_fs** – bool describing whether the host filesystem should be consulted when opening files.

  * **chroot** – A path to use as a fake root directory, Behaves similarly to a real chroot. Used only when concrete_fs is set to True.

  * **kwargs** – Any additional keyword args will be passed to the SimState constructor.

Returns:
    

The state at the beginning of the function.

Return type:
    

SimState

The idea here is that you can provide almost any kind of python type in args and it’ll be translated to a binary format to be placed into simulated memory. Lists (representing arrays) must be entirely elements of the same type and size, while tuples (representing structs) can be elements of any type and size. If you’d like there to be a pointer to a given value, wrap the value in a SimCC.PointerWrapper. Any value that can’t fit in a register will be automatically put in a PointerWrapper.

If stack_base is not provided, the current stack pointer will be used, and it will be updated. If alloc_base is not provided, the current stack pointer will be used, and it will be updated. You might not like the results if you provide stack_base but not alloc_base.

grow_like_stack controls the behavior of allocating data at alloc_base. When data from args needs to be wrapped in a pointer, the pointer needs to point somewhere, so that data is dumped into memory at alloc_base. If you set alloc_base to point to somewhere other than the stack, set grow_like_stack to False so that sequential allocations happen at increasing addresses.

simulation_manager(_thing =None_, _** kwargs_)¶
    

Constructs a new simulation manager.

Parameters:
    

  * **thing** ([`Union`](https://docs.python.org/3/library/typing.html#typing.Union "\(in Python v3.13\)")[[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`SimState`], `SimState`, [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")]) – What to put in the new SimulationManager’s active stash (either a SimState or a list of SimStates).

  * **kwargs** – Any additional keyword arguments will be passed to the SimulationManager constructor

Returns:
    

The new SimulationManager

Return type:
    

angr.sim_manager.SimulationManager

Many different types can be passed to this method:

  * If nothing is passed in, the SimulationManager is seeded with a state initialized for the program entry point, i.e. `entry_state()`.

  * If a `SimState` is passed in, the SimulationManager is seeded with that state.

  * If a list is passed in, the list must contain only SimStates and the whole list will be used to seed the SimulationManager.

simgr(_* args_, _** kwargs_)¶
    

Alias for simulation_manager to save our poor fingers

callable(_addr_ , _prototype =None_, _concrete_only =False_, _perform_merge =True_, _base_state =None_, _toc =None_, _cc =None_, _add_options =None_, _remove_options =None_, _step_limit =None_)¶
    

A Callable is a representation of a function in the binary that can be interacted with like a native python function.

Parameters:
    

  * **addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | `Function`) – The address of the function to use. If you pass in the function object, we will take its addr.

  * **prototype** – The prototype of the call to use, as a string or a SimTypeFunction

  * **concrete_only** – Throw an exception if the execution splits into multiple states

  * **perform_merge** – Merge all result states into one at the end (only relevant if concrete_only=False)

  * **base_state** – The state from which to do these runs

  * **toc** – The address of the table of contents for ppc64

  * **cc** – The SimCC to use for a calling convention

  * **step_limit** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – The maximum number of blocks that Callable will execute before pruning the path.

Returns:
    

A Callable object that can be used as a interface for executing guest code like a python function.

Return type:
    

angr.callable.Callable

cc()¶
    

Return a SimCC (calling convention) parameterized for this project.

Relevant subclasses of SimFunctionArgument are SimRegArg and SimStackArg, and shortcuts to them can be found on this cc object.

For stack arguments, offsets are relative to the stack pointer on function entry.

function_prototype()¶
    

Return a default function prototype parameterized for this project and SimOS.

block(_addr_ , _size =None_, _max_size =None_, _byte_string =None_, _thumb =False_, _backup_state =None_, _extra_stop_points =None_, _opt_level =None_, _num_inst =None_, _traceflags =0_, _insn_bytes =None_, _strict_block_end =None_, _collect_data_refs =False_, _cross_insn_opt =True_, _load_from_ro_regions =False_, _const_prop =False_, _initial_regs =None_, _skip_stmts =False_)¶
    

fresh_block(_addr_ , _size_ , _backup_state =None_)¶
    

_class _angr.block.DisassemblerBlock(_addr_ , _insns_ , _thumb_ , _arch_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Helper class to represent a block of disassembled target architecture instructions

__init__(_addr_ , _insns_ , _thumb_ , _arch_)¶
    

addr¶
    

insns¶
    

thumb¶
    

arch¶
    

pp()¶
    

_class _angr.block.DisassemblerInsn¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Helper class to represent a disassembled target architecture instruction

_property _size _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_property _address _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_property _mnemonic _: [str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")_¶
    

_property _op_str _: [str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")_¶
    

_class _angr.block.CapstoneBlock(_addr_ , _insns_ , _thumb_ , _arch_)¶
    

Bases: `DisassemblerBlock`

Deep copy of the capstone blocks, which have serious issues with having extended lifespans outside of capstone itself

_class _angr.block.CapstoneInsn(_capstone_insn_)¶
    

Bases: `DisassemblerInsn`

Represents a capstone instruction.

__init__(_capstone_insn_)¶
    

insn¶
    

_property _size _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_property _address _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_property _mnemonic _: [str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")_¶
    

_property _op_str _: [str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")_¶
    

_class _angr.block.Block(_addr_ , _project =None_, _arch =None_, _size =None_, _max_size =None_, _byte_string =None_, _thumb =False_, _backup_state =None_, _extra_stop_points =None_, _opt_level =None_, _num_inst =None_, _traceflags =0_, _strict_block_end =None_, _collect_data_refs =False_, _cross_insn_opt =True_, _load_from_ro_regions =False_, _const_prop =False_, _initial_regs =None_, _skip_stmts =False_)¶
    

Bases: `Serializable`

Represents a basic block in a binary or a program.

Parameters:
    

**arch** (_Arch_ _|__None_)

BLOCK_MAX_SIZE _ = 4096_¶
    

__init__(_addr_ , _project =None_, _arch =None_, _size =None_, _max_size =None_, _byte_string =None_, _thumb =False_, _backup_state =None_, _extra_stop_points =None_, _opt_level =None_, _num_inst =None_, _traceflags =0_, _strict_block_end =None_, _collect_data_refs =False_, _cross_insn_opt =True_, _load_from_ro_regions =False_, _const_prop =False_, _initial_regs =None_, _skip_stmts =False_)¶
    

Parameters:
    

**arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)") _|__None_)

arch¶
    

addr¶
    

thumb¶
    

size¶
    

pp(_** kwargs_)¶
    

set_initial_regs()¶
    

_static _reset_initial_regs()¶
    

_property _vex _: [IRSB](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.block.IRSB "\(in pyvex\)") | IRSB_¶
    

_property _vex_nostmt¶
    

_property _disassembly _: DisassemblerBlock_¶
    

Provide a disassembly object using whatever disassembler is available

_property _capstone _: CapstoneBlock_¶
    

_property _codenode¶
    

_property _bytes _: [bytes](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

_property _instructions _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_property _instruction_addrs¶
    

serialize_to_cmessage()¶
    

Serialize the class object and returns a protobuf cmessage object.

Returns:
    

A protobuf cmessage object.

Return type:
    

protobuf.cmessage

_classmethod _parse_from_cmessage(_cmsg_)¶
    

Parse a protobuf cmessage and create a class object.

Parameters:
    

**cmsg** – The probobuf cmessage object.

Returns:
    

A unserialized class object.

Return type:
    

cls

_class _angr.block.SootBlock(_addr_ , _*_ , _project_ , _arch_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Represents a Soot IR basic block.

Parameters:
    

  * **project** (_Project_)

  * **arch** (_Arch_)

__init__(_addr_ , _*_ , _project_ , _arch_)¶
    

Parameters:
    

  * **project** (_Project_)

  * **arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)"))

_property _soot¶
    

_property _size¶
    

_property _codenode¶
    

## Plugin Ecosystem¶

_class _angr.misc.plugins.PluginHub¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`P`]

A plugin hub is an object which contains many plugins, as well as the notion of a “preset”, or a backer that can provide default implementations of plugins which cater to a certain circumstance.

Objects in angr like the SimState, the Analyses hub, the SimEngine selector, etc all use this model to unify their mechanisms for automatically collecting and selecting components to use. If you’re familiar with design patterns this is a configurable Strategy Pattern.

Each PluginHub subclass should have a corresponding Plugin subclass, and perhaps a PluginPreset subclass if it wants its presets to be able to specify anything more interesting than a list of defaults.

__init__()¶
    

_classmethod _register_default(_name_ , _plugin_cls_ , _preset ='default'_)¶
    

_classmethod _register_preset(_name_ , _preset_)¶
    

Register a preset instance with the class of the hub it corresponds to. This allows individual plugin objects to automatically register themselves with a preset by using a classmethod of their own with only the name of the preset to register with.

_property _plugin_preset¶
    

Get the current active plugin preset

_property _has_plugin_preset _: [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

Check whether or not there is a plugin preset in use on this hub right now

use_plugin_preset(_preset_)¶
    

Apply a preset to the hub. If there was a previously active preset, discard it.

Preset can be either the string name of a preset or a PluginPreset instance.

discard_plugin_preset()¶
    

Discard the current active preset. Will release any active plugins that could have come from the old preset.

get_plugin(_name_)¶
    

Get the plugin named `name`. If no such plugin is currently active, try to activate a new one using the current preset.

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`P`)

Parameters:
    

**name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

has_plugin(_name_)¶
    

Return whether or not a plugin with the name `name` is currently active.

register_plugin(_name_ , _plugin_)¶
    

Add a new plugin `plugin` with name `name` to the active plugins.

Parameters:
    

**name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

release_plugin(_name_)¶
    

Deactivate and remove the plugin with name `name`.

_class _angr.misc.plugins.PluginPreset¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A plugin preset object contains a mapping from name to a plugin class. A preset can be active on a hub, which will cause it to handle requests for plugins which are not already present on the hub.

Unlike Plugins and PluginHubs, instances of PluginPresets are defined on the module level for individual presets. You should register the preset instance with a hub to allow plugins to easily add themselves to the preset without an explicit reference to the preset itself.

__init__()¶
    

activate(_hub_)¶
    

This method is called when the preset becomes active on a hub.

deactivate(_hub_)¶
    

This method is called when the preset is discarded from the hub.

add_default_plugin(_name_ , _plugin_cls_)¶
    

Add a plugin to the preset.

list_default_plugins()¶
    

Return a list of the names of available default plugins.

request_plugin(_name_)¶
    

Return the plugin class which is registered under the name `name`, or raise NoPlugin if the name isn’t available.

Return type:
    

[`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`P`)]

Parameters:
    

**name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

copy()¶
    

Return a copy of self.

_class _angr.misc.plugins.PluginVendor¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`P`], `PluginHub`[`P`]

A specialized hub which serves only as a plugin vendor, never having any “active” plugins. It will directly return the plugins provided by the preset instead of instantiating them.

release_plugin(_name_)¶
    

Deactivate and remove the plugin with name `name`.

register_plugin(_name_ , _plugin_)¶
    

Add a new plugin `plugin` with name `name` to the active plugins.

_class _angr.misc.plugins.VendorPreset¶
    

Bases: `PluginPreset`

A specialized preset class for use with the PluginVendor.

## Program State¶

angr.sim_state.arch_overridable(_f_)¶
    

_class _angr.sim_state.SimState(_project =None_, _arch =None_, _plugins =None_, _mode =None_, _options =None_, _add_options =None_, _remove_options =None_, _special_memory_filler =None_, _os_name =None_, _plugin_preset ='default'_, _cle_memory_backer =None_, _dict_memory_backer =None_, _permissions_map =None_, _default_permissions =3_, _stack_perms =None_, _stack_end =None_, _stack_size =None_, _regioned_memory_cls =None_, _** kwargs_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`IPTypeConc`, `IPTypeSym`], `PluginHub`[`SimStatePlugin`]

The SimState represents the state of a program, including its memory, registers, and so forth.

Parameters:
    

  * **project** (_angr.Project_) – The project instance.

  * **arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)") _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The architecture of the state.

  * **plugins** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__SimStatePlugin_ _]__|__None_)

  * **mode** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **options** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|_[_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__SimStateOptions_ _|__None_)

  * **add_options** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **remove_options** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **special_memory_filler** (_Callable_ _[__[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__SimState_ _]__,__Any_ _]__|__None_)

  * **os_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **plugin_preset** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **cle_memory_backer** (_Clemory_ _|__None_)

  * **dict_memory_backer** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") _]__|__None_)

  * **permissions_map** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **default_permissions** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **stack_perms** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **stack_end** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **stack_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

Variables:
    

  * **regs** – A convenient view of the state’s registers, where each register is a property

  * **mem** – A convenient view of the state’s memory, a `angr.state_plugins.view.SimMemView`

  * **registers** – The state’s register file as a flat memory region

  * **memory** – The state’s memory as a flat memory region

  * **solver** – The symbolic solver and variable manager for this state

  * **inspect** – The breakpoint manager, a `angr.state_plugins.inspect.SimInspector`

  * **log** – Information about the state’s history

  * **scratch** – Information about the current execution step

  * **posix** – MISNOMER: information about the operating system or environment model

  * **fs** – The current state of the simulated filesystem

  * **libc** – Information about the standard library we are emulating

  * **cgc** – Information about the cgc environment

  * **uc_manager** – Control of under-constrained symbolic execution

  * **unicorn** – Control of the Unicorn Engine

solver _: SimSolver_¶
    

posix _: SimSystemPosix_¶
    

registers _: DefaultMemory_¶
    

regs _: SimRegNameView_¶
    

memory _: DefaultMemory_¶
    

callstack _: CallStack_¶
    

mem _: SimMemView_¶
    

history _: SimStateHistory_¶
    

inspect _: SimInspector_¶
    

jni_references _: SimStateJNIReferences_¶
    

scratch _: SimStateScratch_¶
    

__init__(_project =None_, _arch =None_, _plugins =None_, _mode =None_, _options =None_, _add_options =None_, _remove_options =None_, _special_memory_filler =None_, _os_name =None_, _plugin_preset ='default'_, _cle_memory_backer =None_, _dict_memory_backer =None_, _permissions_map =None_, _default_permissions =3_, _stack_perms =None_, _stack_end =None_, _stack_size =None_, _regioned_memory_cls =None_, _** kwargs_)¶
    

Parameters:
    

  * **project** (_Project_ _|__None_)

  * **arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)") _|__None_)

  * **plugins** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__SimStatePlugin_ _]__|__None_)

  * **mode** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **options** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|_[_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__SimStateOptions_ _|__None_)

  * **add_options** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **remove_options** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **special_memory_filler** ([_Callable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)") _[__[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__SimState_ _]__,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]__|__None_)

  * **os_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **plugin_preset** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **cle_memory_backer** ([_Clemory_](https://docs.angr.io/projects/cle/en/latest/api/utils.html#cle.memory.Clemory "\(in cle\)") _|__None_)

  * **dict_memory_backer** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") _]__|__None_)

  * **permissions_map** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **default_permissions** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **stack_perms** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **stack_end** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **stack_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

_property _plugins¶
    

_property _ip¶
    

Get the instruction pointer expression, trigger SimInspect breakpoints, and generate SimActions. Use `_ip` to not trigger breakpoints or generate actions.

Returns:
    

an expression

_property _addr _: IPTypeConc_¶
    

Get the concrete address of the instruction pointer, without triggering SimInspect breakpoints or generating SimActions. An integer is returned, or an exception is raised if the instruction pointer is symbolic.

Returns:
    

an int

_property _arch _: [Arch](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)")_¶
    

T _ = ~T_¶
    

get_plugin(_name_)¶
    

Get the plugin named `name`. If no such plugin is currently active, try to activate a new one using the current preset.

has_plugin(_name_)¶
    

Return whether or not a plugin with the name `name` is currently active.

register_plugin(_name_ , _plugin_ , _inhibit_init =False_)¶
    

Add a new plugin `plugin` with name `name` to the active plugins.

_property _javavm_memory¶
    

In case of an JavaVM with JNI support, a state can store the memory plugin twice; one for the native and one for the java view of the state.

Returns:
    

The JavaVM view of the memory plugin.

_property _javavm_registers¶
    

In case of an JavaVM with JNI support, a state can store the registers plugin twice; one for the native and one for the java view of the state.

Returns:
    

The JavaVM view of the registers plugin.

simplify(_* args_)¶
    

Simplify this state’s constraints.

add_constraints(_* constraints_)¶
    

Add some constraints to the state.

You may pass in any number of symbolic booleans as variadic positional arguments.

satisfiable(_** kwargs_)¶
    

Whether the state’s constraints are satisfiable

downsize()¶
    

Clean up after the solver engine. Calling this when a state no longer needs to be solved on will reduce memory usage.

step(_** kwargs_)¶
    

Perform a step of symbolic execution using this state. Any arguments to AngrObjectFactory.successors can be passed to this.

Returns:
    

A SimSuccessors object categorizing the results of the step.

block(_* args_, _** kwargs_)¶
    

Represent the basic block at this state’s instruction pointer. Any arguments to AngrObjectFactory.block can ba passed to this.

Returns:
    

A Block object describing the basic block of code at this point.

copy()¶
    

Returns a copy of the state.

merge(_* others_, _** kwargs_)¶
    

Merges this state with the other states. Returns the merging result, merged state, and the merge flag.

Parameters:
    

  * **states** – the states to merge

  * **merge_conditions** – a tuple of the conditions under which each state holds

  * **common_ancestor** – a state that represents the common history between the states being merged. Usually it is only available when EFFICIENT_STATE_MERGING is enabled, otherwise weak-refed states might be dropped from state history instances.

  * **plugin_whitelist** – a list of plugin names that will be merged. If this option is given and is not None, any plugin that is not inside this list will not be merged, and will be created as a fresh instance in the new state.

  * **common_ancestor_history** – a SimStateHistory instance that represents the common history between the states being merged. This is to allow optimal state merging when EFFICIENT_STATE_MERGING is disabled.

Returns:
    

(merged state, merge flag, a bool indicating if any merging occurred)

widen(_* others_)¶
    

Perform a widening between self and other states :type others: :param others: :return:

reg_concrete(_* args_, _** kwargs_)¶
    

Returns the contents of a register but, if that register is symbolic, raises a SimValueError.

mem_concrete(_* args_, _** kwargs_)¶
    

Returns the contents of a memory but, if the contents are symbolic, raises a SimValueError.

stack_push(_thing_)¶
    

Push ‘thing’ to the stack, writing the thing to memory and adjusting the stack pointer.

stack_pop()¶
    

Pops from the stack and returns the popped thing. The length will be the architecture word size.

stack_read(_offset_ , _length_ , _bp =False_)¶
    

Reads length bytes, at an offset into the stack.

Parameters:
    

  * **offset** – The offset from the stack pointer.

  * **length** – The number of bytes to read.

  * **bp** – If True, offset from the BP instead of the SP. Default: False.

make_concrete_int(_expr_)¶
    

prepare_callsite(_retval_ , _args_ , _cc ='wtf'_)¶
    

dbg_print_stack(_depth =None_, _sp =None_)¶
    

Only used for debugging purposes. Return the current stack info in formatted string. If depth is None, the current stack frame (from sp to bp) will be printed out.

set_mode(_mode_)¶
    

_property _thumb¶
    

_property _with_condition¶
    

_class _angr.sim_state_options.StateOption(_name_ , _types_ , _default ='_NO_DEFAULT_VALUE'_, _description =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Describes a state option.

__init__(_name_ , _types_ , _default ='_NO_DEFAULT_VALUE'_, _description =None_)¶
    

name¶
    

types¶
    

default¶
    

description¶
    

_property _has_default_value¶
    

one_type()¶
    

_class _angr.sim_state_options.SimStateOptions(_thing_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A per-state manager of state options. An option can be either a key-valued entry or a Boolean switch (which can be seen as a key-valued entry whose value can only be either True or False).

OPTIONS _ = {'ABSTRACT_MEMORY': <O ABSTRACT_MEMORY[bool]>, 'ABSTRACT_SOLVER': <O ABSTRACT_SOLVER[bool]>, 'ACTION_DEPS': <O ACTION_DEPS[bool]>, 'ADD_AUTO_REFS': <O ADD_AUTO_REFS[bool]>, 'ALLOW_SEND_FAILURES': <O ALLOW_SEND_FAILURES[bool]>, 'ALL_FILES_EXIST': <O ALL_FILES_EXIST[bool]>, 'ANY_FILE_MIGHT_EXIST': <O ANY_FILE_MIGHT_EXIST[bool]>, 'APPROXIMATE_FIRST': <O APPROXIMATE_FIRST[bool]>, 'APPROXIMATE_GUARDS': <O APPROXIMATE_GUARDS[bool]>, 'APPROXIMATE_MEMORY_INDICES': <O APPROXIMATE_MEMORY_INDICES[bool]>, 'APPROXIMATE_MEMORY_SIZES': <O APPROXIMATE_MEMORY_SIZES[bool]>, 'APPROXIMATE_SATISFIABILITY': <O APPROXIMATE_SATISFIABILITY[bool]>, 'AST_DEPS': <O AST_DEPS[bool]>, 'AUTO_REFS': <O AUTO_REFS[bool]>, 'AVOID_MULTIVALUED_READS': <O AVOID_MULTIVALUED_READS[bool]>, 'AVOID_MULTIVALUED_WRITES': <O AVOID_MULTIVALUED_WRITES[bool]>, 'BEST_EFFORT_MEMORY_STORING': <O BEST_EFFORT_MEMORY_STORING[bool]>, 'BYPASS_ERRORED_IRCCALL': <O BYPASS_ERRORED_IRCCALL[bool]>, 'BYPASS_ERRORED_IROP': <O BYPASS_ERRORED_IROP[bool]>, 'BYPASS_ERRORED_IRSTMT': <O BYPASS_ERRORED_IRSTMT[bool]>, 'BYPASS_UNSUPPORTED_IRCCALL': <O BYPASS_UNSUPPORTED_IRCCALL[bool]>, 'BYPASS_UNSUPPORTED_IRDIRTY': <O BYPASS_UNSUPPORTED_IRDIRTY[bool]>, 'BYPASS_UNSUPPORTED_IREXPR': <O BYPASS_UNSUPPORTED_IREXPR[bool]>, 'BYPASS_UNSUPPORTED_IROP': <O BYPASS_UNSUPPORTED_IROP[bool]>, 'BYPASS_UNSUPPORTED_IRSTMT': <O BYPASS_UNSUPPORTED_IRSTMT[bool]>, 'BYPASS_UNSUPPORTED_SYSCALL': <O BYPASS_UNSUPPORTED_SYSCALL[bool]>, 'BYPASS_VERITESTING_EXCEPTIONS': <O BYPASS_VERITESTING_EXCEPTIONS[bool]>, 'CACHELESS_SOLVER': <O CACHELESS_SOLVER[bool]>, 'CALLLESS': <O CALLLESS[bool]>, 'CGC_ENFORCE_FD': <O CGC_ENFORCE_FD[bool]>, 'CGC_NON_BLOCKING_FDS': <O CGC_NON_BLOCKING_FDS[bool]>, 'CGC_NO_SYMBOLIC_RECEIVE_LENGTH': <O CGC_NO_SYMBOLIC_RECEIVE_LENGTH[bool]>, 'COMPOSITE_SOLVER': <O COMPOSITE_SOLVER[bool]>, 'CONCRETIZE': <O CONCRETIZE[bool]>, 'CONCRETIZE_SYMBOLIC_FILE_READ_SIZES': <O CONCRETIZE_SYMBOLIC_FILE_READ_SIZES[bool]>, 'CONCRETIZE_SYMBOLIC_WRITE_SIZES': <O CONCRETIZE_SYMBOLIC_WRITE_SIZES[bool]>, 'CONSERVATIVE_READ_STRATEGY': <O CONSERVATIVE_READ_STRATEGY[bool]>, 'CONSERVATIVE_WRITE_STRATEGY': <O CONSERVATIVE_WRITE_STRATEGY[bool]>, 'CONSTRAINT_TRACKING_IN_SOLVER': <O CONSTRAINT_TRACKING_IN_SOLVER[bool]>, 'COPY_STATES': <O COPY_STATES[bool]>, 'CPUID_SYMBOLIC': <O CPUID_SYMBOLIC[bool]>, 'DOWNSIZE_Z3': <O DOWNSIZE_Z3[bool]>, 'DO_CCALLS': <O DO_CCALLS[bool]>, 'DO_RET_EMULATION': <O DO_RET_EMULATION[bool]>, 'EFFICIENT_STATE_MERGING': <O EFFICIENT_STATE_MERGING[bool]>, 'ENABLE_NX': <O ENABLE_NX[bool]>, 'EXCEPTION_HANDLING': <O EXCEPTION_HANDLING[bool]>, 'EXTENDED_IROP_SUPPORT': <O EXTENDED_IROP_SUPPORT[bool]>, 'FAST_MEMORY': <O FAST_MEMORY[bool]>, 'FAST_REGISTERS': <O FAST_REGISTERS[bool]>, 'FILES_HAVE_EOF': <O FILES_HAVE_EOF[bool]>, 'HYBRID_SOLVER': <O HYBRID_SOLVER[bool]>, 'JAVA_IDENTIFY_GETTER_SETTER': <O JAVA_IDENTIFY_GETTER_SETTER[bool]>, 'JAVA_TRACK_ATTRIBUTES': <O JAVA_TRACK_ATTRIBUTES[bool]>, 'KEEP_IP_SYMBOLIC': <O KEEP_IP_SYMBOLIC[bool]>, 'LAZY_SOLVES': <O LAZY_SOLVES[bool]>, 'MEMORY_CHUNK_INDIVIDUAL_READS': <O MEMORY_CHUNK_INDIVIDUAL_READS[bool]>, 'MEMORY_FIND_STRICT_SIZE_LIMIT': <O MEMORY_FIND_STRICT_SIZE_LIMIT[bool]>, 'MEMORY_SYMBOLIC_BYTES_MAP': <O MEMORY_SYMBOLIC_BYTES_MAP[bool]>, 'NO_CROSS_INSN_OPT': <O NO_CROSS_INSN_OPT[bool]>, 'NO_IP_CONCRETIZATION': <O NO_IP_CONCRETIZATION[bool]>, 'NO_SYMBOLIC_JUMP_RESOLUTION': <O NO_SYMBOLIC_JUMP_RESOLUTION[bool]>, 'NO_SYMBOLIC_SYSCALL_RESOLUTION': <O NO_SYMBOLIC_SYSCALL_RESOLUTION[bool]>, 'OPTIMIZE_IR': <O OPTIMIZE_IR[bool]>, 'PRODUCE_ZERODIV_SUCCESSORS': <O PRODUCE_ZERODIV_SUCCESSORS[bool]>, 'REGION_MAPPING': <O REGION_MAPPING[bool]>, 'REPLACEMENT_SOLVER': <O REPLACEMENT_SOLVER[bool]>, 'REVERSE_MEMORY_HASH_MAP': <O REVERSE_MEMORY_HASH_MAP[bool]>, 'REVERSE_MEMORY_NAME_MAP': <O REVERSE_MEMORY_NAME_MAP[bool]>, 'SHORT_READS': <O SHORT_READS[bool]>, 'SIMPLIFY_CONSTRAINTS': <O SIMPLIFY_CONSTRAINTS[bool]>, 'SIMPLIFY_EXIT_GUARD': <O SIMPLIFY_EXIT_GUARD[bool]>, 'SIMPLIFY_EXIT_STATE': <O SIMPLIFY_EXIT_STATE[bool]>, 'SIMPLIFY_EXIT_TARGET': <O SIMPLIFY_EXIT_TARGET[bool]>, 'SIMPLIFY_EXPRS': <O SIMPLIFY_EXPRS[bool]>, 'SIMPLIFY_MEMORY_READS': <O SIMPLIFY_MEMORY_READS[bool]>, 'SIMPLIFY_MEMORY_WRITES': <O SIMPLIFY_MEMORY_WRITES[bool]>, 'SIMPLIFY_MERGED_CONSTRAINTS': <O SIMPLIFY_MERGED_CONSTRAINTS[bool]>, 'SIMPLIFY_REGISTER_READS': <O SIMPLIFY_REGISTER_READS[bool]>, 'SIMPLIFY_REGISTER_WRITES': <O SIMPLIFY_REGISTER_WRITES[bool]>, 'SIMPLIFY_RETS': <O SIMPLIFY_RETS[bool]>, 'SPECIAL_MEMORY_FILL': <O SPECIAL_MEMORY_FILL[bool]>, 'STRICT_PAGE_ACCESS': <O STRICT_PAGE_ACCESS[bool]>, 'SUPER_FASTPATH': <O SUPER_FASTPATH[bool]>, 'SUPPORT_FLOATING_POINT': <O SUPPORT_FLOATING_POINT[bool]>, 'SYMBION_KEEP_STUBS_ON_SYNC': <O SYMBION_KEEP_STUBS_ON_SYNC[bool]>, 'SYMBION_SYNC_CLE': <O SYMBION_SYNC_CLE[bool]>, 'SYMBOLIC': <O SYMBOLIC[bool]>, 'SYMBOLIC_INITIAL_VALUES': <O SYMBOLIC_INITIAL_VALUES[bool]>, 'SYMBOLIC_MEMORY_NO_SINGLEVALUE_OPTIMIZATIONS': <O SYMBOLIC_MEMORY_NO_SINGLEVALUE_OPTIMIZATIONS[bool]>, 'SYMBOLIC_TEMPS': <O SYMBOLIC_TEMPS[bool]>, 'SYMBOLIC_WRITE_ADDRESSES': <O SYMBOLIC_WRITE_ADDRESSES[bool]>, 'SYMBOL_FILL_UNCONSTRAINED_MEMORY': <O SYMBOL_FILL_UNCONSTRAINED_MEMORY[bool]>, 'SYMBOL_FILL_UNCONSTRAINED_REGISTERS': <O SYMBOL_FILL_UNCONSTRAINED_REGISTERS[bool]>, 'SYNC_CLE_BACKEND_CONCRETE': <O SYNC_CLE_BACKEND_CONCRETE[bool]>, 'TRACK_ACTION_HISTORY': <O TRACK_ACTION_HISTORY[bool]>, 'TRACK_CONSTRAINTS': <O TRACK_CONSTRAINTS[bool]>, 'TRACK_CONSTRAINT_ACTIONS': <O TRACK_CONSTRAINT_ACTIONS[bool]>, 'TRACK_JMP_ACTIONS': <O TRACK_JMP_ACTIONS[bool]>, 'TRACK_MEMORY_ACTIONS': <O TRACK_MEMORY_ACTIONS[bool]>, 'TRACK_MEMORY_MAPPING': <O TRACK_MEMORY_MAPPING[bool]>, 'TRACK_OP_ACTIONS': <O TRACK_OP_ACTIONS[bool]>, 'TRACK_REGISTER_ACTIONS': <O TRACK_REGISTER_ACTIONS[bool]>, 'TRACK_SOLVER_VARIABLES': <O TRACK_SOLVER_VARIABLES[bool]>, 'TRACK_TMP_ACTIONS': <O TRACK_TMP_ACTIONS[bool]>, 'TRUE_RET_EMULATION_GUARD': <O TRUE_RET_EMULATION_GUARD[bool]>, 'UNDER_CONSTRAINED_SYMEXEC': <O UNDER_CONSTRAINED_SYMEXEC[bool]>, 'UNICORN': <O UNICORN[bool]>, 'UNICORN_AGGRESSIVE_CONCRETIZATION': <O UNICORN_AGGRESSIVE_CONCRETIZATION[bool]>, 'UNICORN_HANDLE_CGC_RANDOM_SYSCALL': <O UNICORN_HANDLE_CGC_RANDOM_SYSCALL[bool]>, 'UNICORN_HANDLE_CGC_RECEIVE_SYSCALL': <O UNICORN_HANDLE_CGC_RECEIVE_SYSCALL[bool]>, 'UNICORN_HANDLE_CGC_TRANSMIT_SYSCALL': <O UNICORN_HANDLE_CGC_TRANSMIT_SYSCALL[bool]>, 'UNICORN_HANDLE_SYMBOLIC_ADDRESSES': <O UNICORN_HANDLE_SYMBOLIC_ADDRESSES[bool]>, 'UNICORN_HANDLE_SYMBOLIC_CONDITIONS': <O UNICORN_HANDLE_SYMBOLIC_CONDITIONS[bool]>, 'UNICORN_HANDLE_SYMBOLIC_SYSCALLS': <O UNICORN_HANDLE_SYMBOLIC_SYSCALLS[bool]>, 'UNICORN_SYM_REGS_SUPPORT': <O UNICORN_SYM_REGS_SUPPORT[bool]>, 'UNICORN_THRESHOLD_CONCRETIZATION': <O UNICORN_THRESHOLD_CONCRETIZATION[bool]>, 'UNICORN_TRACK_BBL_ADDRS': <O UNICORN_TRACK_BBL_ADDRS[bool]>, 'UNICORN_TRACK_STACK_POINTERS': <O UNICORN_TRACK_STACK_POINTERS[bool]>, 'UNICORN_ZEROPAGE_GUARD': <O UNICORN_ZEROPAGE_GUARD[bool]>, 'UNINITIALIZED_ACCESS_AWARENESS': <O UNINITIALIZED_ACCESS_AWARENESS[bool]>, 'UNSUPPORTED_BYPASS_ZERO_DEFAULT': <O UNSUPPORTED_BYPASS_ZERO_DEFAULT[bool]>, 'UNSUPPORTED_FORCE_CONCRETIZE': <O UNSUPPORTED_FORCE_CONCRETIZE[bool]>, 'USE_SIMPLIFIED_CCALLS': <O USE_SIMPLIFIED_CCALLS[bool]>, 'USE_SYSTEM_TIMES': <O USE_SYSTEM_TIMES[bool]>, 'VALIDATE_APPROXIMATIONS': <O VALIDATE_APPROXIMATIONS[bool]>, 'ZERO_FILL_UNCONSTRAINED_MEMORY': <O ZERO_FILL_UNCONSTRAINED_MEMORY[bool]>, 'ZERO_FILL_UNCONSTRAINED_REGISTERS': <O ZERO_FILL_UNCONSTRAINED_REGISTERS[bool]>, 'jumptable_symbolic_ip_max_targets': <O jumptable_symbolic_ip_max_targets[int]: The maximum number of concrete addresses a symbolic instruction pointer can be concretized to if it is part of a jump table.>, 'symbolic_ip_max_targets': <O symbolic_ip_max_targets[int]: The maximum number of concrete addresses a symbolic instruction pointer can be concretized to.>}_¶
    

__init__(_thing_)¶
    

Parameters:
    

**thing** – Either a set of Boolean switches to enable, or an existing SimStateOptions instance.

add(_boolean_switch_)¶
    

[COMPATIBILITY] Enable a Boolean switch.

Parameters:
    

**boolean_switch** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of the Boolean switch.

Returns:
    

None

update(_boolean_switches_)¶
    

[COMPATIBILITY] In order to be compatible with the old interface, you can enable a collection of Boolean switches at the same time by doing the following:
    
    
    >>> state.options.update({sim_options.SYMBOLIC, sim_options.ABSTRACT_MEMORY})
    

or
    
    
    >>> state.options.update(sim_options.unicorn)
    

Parameters:
    

**boolean_switches** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")) – A collection of Boolean switches to enable.

Returns:
    

None

remove(_name_)¶
    

Drop a state option if it exists, or raise a KeyError if the state option is not set.

[COMPATIBILITY] Remove a Boolean switch.

Parameters:
    

**name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of the state option.

Returns:
    

NNone

discard(_name_)¶
    

Drop a state option if it exists, or silently return if the state option is not set.

[COMPATIBILITY] Disable a Boolean switch.

Parameters:
    

**name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of the Boolean switch.

Returns:
    

None

difference(_boolean_switches_)¶
    

[COMPATIBILITY] Make a copy of the current instance, and then discard all options that are in boolean_switches.

Parameters:
    

**boolean_switches** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")) – A collection of Boolean switches to disable.

Returns:
    

A new SimStateOptions instance.

copy()¶
    

Get a copy of the current SimStateOptions instance.

Returns:
    

A new SimStateOptions instance.

Return type:
    

SimStateOptions

tally(_exclude_false =True_, _description =False_)¶
    

Return a string representation of all state options.

Parameters:
    

  * **exclude_false** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether to exclude Boolean switches that are disabled.

  * **description** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether to display the description of each option.

Returns:
    

A string representation.

Return type:
    

[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

_classmethod _register_option(_name_ , _types_ , _default =None_, _description =None_)¶
    

Register a state option.

Parameters:
    

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of the state option.

  * **types** – A collection of allowed types of this state option.

  * **default** – The default value of this state option.

  * **description** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The description of this state option.

Returns:
    

None

_classmethod _register_bool_option(_name_ , _description =None_)¶
    

Register a Boolean switch as state option. This is equivalent to cls.register_option(name, set([bool]), description=description)

Parameters:
    

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of the state option.

  * **description** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The description of this state option.

Returns:
    

None

_class _angr.state_plugins.GDB(_omit_fp =False_, _adjust_stack =False_)¶
    

Bases: `SimStatePlugin`

Initialize or update a state from gdb dumps of the stack, heap, registers and data (or arbitrary) segments.

__init__(_omit_fp =False_, _adjust_stack =False_)¶
    

Parameters:
    

  * **omit_fp** – The frame pointer register is used for something else. (i.e. –omit_frame_pointer)

  * **adjust_stack** – Use different stack addresses than the gdb session (not recommended).

set_stack(_stack_dump_ , _stack_top_)¶
    

Stack dump is a dump of the stack from gdb, i.e. the result of the following gdb command :

`dump binary memory [stack_dump] [begin_addr] [end_addr]`

We set the stack to the same addresses as the gdb session to avoid pointers corruption.

Parameters:
    

  * **stack_dump** – The dump file.

  * **stack_top** – The address of the top of the stack in the gdb session.

set_heap(_heap_dump_ , _heap_base_)¶
    

Heap dump is a dump of the heap from gdb, i.e. the result of the following gdb command:

`dump binary memory [stack_dump] [begin] [end]`

Parameters:
    

  * **heap_dump** – The dump file.

  * **heap_base** – The start address of the heap in the gdb session.

set_data(_addr_ , _data_dump_)¶
    

Update any data range (most likely use is the data segments of loaded objects)

set_regs(_regs_dump_)¶
    

Initialize register values within the state

Parameters:
    

**regs_dump** – The output of `info registers` in gdb.

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

_class _angr.state_plugins.CallStack(_call_site_addr =0_, _func_addr =0_, _stack_ptr =0_, _ret_addr =0_, _jumpkind ='Ijk_Call'_, _next_frame =None_, _invoke_return_variable =None_)¶
    

Bases: `SimStatePlugin`

Stores the address of the function you’re in and the value of SP at the VERY BOTTOM of the stack, i.e. points to the return address.

Parameters:
    

**next_frame** (_CallStack_ _|__None_)

__init__(_call_site_addr =0_, _func_addr =0_, _stack_ptr =0_, _ret_addr =0_, _jumpkind ='Ijk_Call'_, _next_frame =None_, _invoke_return_variable =None_)¶
    

Parameters:
    

**next_frame** (_CallStack_ _|__None_)

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_property _current_function_address¶
    

Address of the current function.

Returns:
    

the address of the function

Return type:
    

[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

_property _current_stack_pointer¶
    

Get the value of the stack pointer.

Returns:
    

Value of the stack pointer

Return type:
    

[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

_property _current_return_target¶
    

Get the return target.

Returns:
    

The address of return target.

Return type:
    

[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

_static _stack_suffix_to_string(_stack_suffix_)¶
    

Convert a stack suffix to a human-readable string representation. :param tuple stack_suffix: The stack suffix. :return: A string representation :rtype: str

_property _top¶
    

Returns the element at the top of the callstack without removing it.

Returns:
    

A CallStack.

push(_cf_)¶
    

Push the frame cf onto the stack. Return the new stack.

pop()¶
    

Pop the top frame from the stack. Return the new stack.

call(_callsite_addr_ , _addr_ , _retn_target =None_, _stack_pointer =None_)¶
    

Push a stack frame into the call stack. This method is called when calling a function in CFG recovery.

Parameters:
    

  * **callsite_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the call site

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the call target

  * **retn_target** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _or_ _None_) – Address of the return target

  * **stack_pointer** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Value of the stack pointer

Returns:
    

None

ret(_retn_target =None_)¶
    

Pop one or many call frames from the stack. This method is called when returning from a function in CFG recovery.

Parameters:
    

**retn_target** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The target to return to.

Returns:
    

None

dbg_repr()¶
    

Debugging representation of this CallStack object.

Returns:
    

Details of this CalLStack

Return type:
    

[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

stack_suffix(_context_sensitivity_level_)¶
    

Generate the stack suffix. A stack suffix can be used as the key to a SimRun in CFG recovery.

Parameters:
    

**context_sensitivity_level** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Level of context sensitivity.

Returns:
    

A tuple of stack suffix.

Return type:
    

[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

_class _angr.state_plugins.PTChunk(_base_ , _sim_state_ , _heap =None_)¶
    

Bases: `Chunk`

A chunk, inspired by the implementation of chunks in ptmalloc. Provides a representation of a chunk via a view into the memory plugin. For the chunk definitions and docs that this was loosely based off of, see glibc malloc/malloc.c, line 1033, as of commit 5a580643111ef6081be7b4c7bd1997a5447c903f. Alternatively, take the following link. <https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=67cdfd0ad2f003964cd0f7dfe3bcd85ca98528a7;hb=5a580643111ef6081be7b4c7bd1997a5447c903f#l1033>

Variables:
    

  * **base** – the location of the base of the chunk in memory

  * **state** – the program state that the chunk is resident in

  * **heap** – the heap plugin that the chunk is managed by

__init__(_base_ , _sim_state_ , _heap =None_)¶
    

get_size()¶
    

Returns the actual size of a chunk (as opposed to the entire size field, which may include some flags).

get_data_size()¶
    

Returns the size of the data portion of a chunk.

set_size(_size_ , _is_free =None_)¶
    

Use this to set the size on a chunk. When the chunk is new (such as when a free chunk is shrunk to form an allocated chunk and a remainder free chunk) it is recommended that the is_free hint be used since setting the size depends on the chunk’s freeness, and vice versa.

Parameters:
    

  * **size** – size of the chunk

  * **is_free** – boolean indicating the chunk’s freeness

set_prev_freeness(_is_free_)¶
    

Sets (or unsets) the flag controlling whether the previous chunk is free.

Parameters:
    

**is_free** – if True, sets the previous chunk to be free; if False, sets it to be allocated

is_prev_free()¶
    

Returns a concrete state of the flag indicating whether the previous chunk is free or not. Issues a warning if that flag is symbolic and has multiple solutions, and then assumes that the previous chunk is free.

Returns:
    

True if the previous chunk is free; False otherwise

prev_size()¶
    

Returns the size of the previous chunk, masking off what would be the flag bits if it were in the actual size field. Performs NO CHECKING to determine whether the previous chunk size is valid (for example, when the previous chunk is not free, its size cannot be determined).

is_free()¶
    

Returns a concrete determination as to whether the chunk is free.

data_ptr()¶
    

Returns the address of the payload of the chunk.

next_chunk()¶
    

Returns the chunk immediately following (and adjacent to) this one, if it exists.

Returns:
    

The following chunk, or None if applicable

prev_chunk()¶
    

Returns the chunk immediately prior (and adjacent) to this one, if that chunk is free. If the prior chunk is not free, then its base cannot be located and this method raises an error.

Returns:
    

If possible, the previous chunk; otherwise, raises an error

fwd_chunk()¶
    

Returns the chunk following this chunk in the list of free chunks. If this chunk is not free, then it resides in no such list and this method raises an error.

Returns:
    

If possible, the forward chunk; otherwise, raises an error

set_fwd_chunk(_fwd_)¶
    

Sets the chunk following this chunk in the list of free chunks.

Parameters:
    

**fwd** – the chunk to follow this chunk in the list of free chunks

bck_chunk()¶
    

Returns the chunk backward from this chunk in the list of free chunks. If this chunk is not free, then it resides in no such list and this method raises an error.

Returns:
    

If possible, the backward chunk; otherwise, raises an error

set_bck_chunk(_bck_)¶
    

Sets the chunk backward from this chunk in the list of free chunks.

Parameters:
    

**bck** – the chunk to precede this chunk in the list of free chunks

_class _angr.state_plugins.PTChunkIterator(_chunk_ , _cond= <function PTChunkIterator.<lambda>>_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_chunk_ , _cond= <function PTChunkIterator.<lambda>>_)¶
    

_class _angr.state_plugins.PosixDevFS¶
    

Bases: `SimMount`

get(_path_)¶
    

Implement this function to instrument file lookups.

Parameters:
    

**path_elements** – A list of path elements traversing from the mountpoint to the file

Returns:
    

A SimFile, or None

insert(_path_ , _simfile_)¶
    

Implement this function to instrument file creation.

Parameters:
    

  * **path_elements** – A list of path elements traversing from the mountpoint to the file

  * **simfile** – The file to insert

Returns:
    

A bool indicating whether the insert occurred

delete(_path_)¶
    

Implement this function to instrument file deletion.

Parameters:
    

**path_elements** – A list of path elements traversing from the mountpoint to the file

Returns:
    

A bool indicating whether the delete occurred

lookup(___)¶
    

Look up the path of a SimFile in the mountpoint

Parameters:
    

**sim_file** – A SimFile object needs to be looked up

Returns:
    

A string representing the path of the file in the mountpoint Or None if the SimFile does not exist in the mountpoint

merge(_others_ , _conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

copy(___)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

_class _angr.state_plugins.PosixProcFS¶
    

Bases: `SimMount`

The virtual file system mounted at /proc (as of now, on Linux).

get(_path_)¶
    

Implement this function to instrument file lookups.

Parameters:
    

**path_elements** – A list of path elements traversing from the mountpoint to the file

Returns:
    

A SimFile, or None

insert(_path_ , _simfile_)¶
    

Implement this function to instrument file creation.

Parameters:
    

  * **path_elements** – A list of path elements traversing from the mountpoint to the file

  * **simfile** – The file to insert

Returns:
    

A bool indicating whether the insert occurred

delete(_path_)¶
    

Implement this function to instrument file deletion.

Parameters:
    

**path_elements** – A list of path elements traversing from the mountpoint to the file

Returns:
    

A bool indicating whether the delete occurred

lookup(___)¶
    

Look up the path of a SimFile in the mountpoint

Parameters:
    

**sim_file** – A SimFile object needs to be looked up

Returns:
    

A string representing the path of the file in the mountpoint Or None if the SimFile does not exist in the mountpoint

merge(_others_ , _conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

copy(___)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

_class _angr.state_plugins.SimAction(_state_ , _region_type_)¶
    

Bases: `SimEvent`

A SimAction represents a semantic action that an analyzed program performs.

TMP _ = 'tmp'_¶
    

REG _ = 'reg'_¶
    

MEM _ = 'mem'_¶
    

__init__(_state_ , _region_type_)¶
    

Initializes the SimAction.

Parameters:
    

**state** – the state that’s the SimAction is taking place in.

_property _all_objects¶
    

_property _is_symbolic¶
    

_property _tmp_deps¶
    

_property _reg_deps¶
    

copy()¶
    

downsize()¶
    

Clears some low-level details (that take up memory) out of the SimAction.

_class _angr.state_plugins.SimActionConstraint(_state_ , _constraint_ , _condition =None_)¶
    

Bases: `SimAction`

A constraint action represents an extra constraint added during execution of a path.

__init__(_state_ , _constraint_ , _condition =None_)¶
    

Initializes the SimAction.

Parameters:
    

**state** – the state that’s the SimAction is taking place in.

_property _all_objects¶
    

_property _is_symbolic¶
    

_class _angr.state_plugins.SimActionData(_state_ , _region_type_ , _action_ , _tmp =None_, _addr =None_, _size =None_, _data =None_, _condition =None_, _fallback =None_, _fd =None_)¶
    

Bases: `SimAction`

A Data action represents a read or a write from memory, registers or a file.

READ _ = 'read'_¶
    

WRITE _ = 'write'_¶
    

OPERATE _ = 'operate'_¶
    

__init__(_state_ , _region_type_ , _action_ , _tmp =None_, _addr =None_, _size =None_, _data =None_, _condition =None_, _fallback =None_, _fd =None_)¶
    

Initializes the SimAction.

Parameters:
    

**state** – the state that’s the SimAction is taking place in.

downsize()¶
    

Clears some low-level details (that take up memory) out of the SimAction.

_property _all_objects¶
    

_property _is_symbolic¶
    

_property _tmp_deps¶
    

_property _reg_deps¶
    

_property _storage¶
    

_class _angr.state_plugins.SimActionExit(_state_ , _target_ , _condition =None_, _exit_type =None_)¶
    

Bases: `SimAction`

An Exit action represents a (possibly conditional) jump.

CONDITIONAL _ = 'conditional'_¶
    

DEFAULT _ = 'default'_¶
    

__init__(_state_ , _target_ , _condition =None_, _exit_type =None_)¶
    

Initializes the SimAction.

Parameters:
    

**state** – the state that’s the SimAction is taking place in.

_property _all_objects¶
    

_property _is_symbolic¶
    

_class _angr.state_plugins.SimActionObject(_ast_ , _reg_deps =frozenset({})_, _tmp_deps =frozenset({})_, _deps =frozenset({})_, _state =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A SimActionObject tracks an AST and its dependencies.

Parameters:
    

  * **ast** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

  * **reg_deps** ([_frozenset_](https://docs.python.org/3/library/stdtypes.html#frozenset "\(in Python v3.13\)") _[__SimActionData_ _|__SimActionOperation_ _]_)

  * **tmp_deps** ([_frozenset_](https://docs.python.org/3/library/stdtypes.html#frozenset "\(in Python v3.13\)") _[__SimActionData_ _|__SimActionOperation_ _]_)

  * **deps** ([_frozenset_](https://docs.python.org/3/library/stdtypes.html#frozenset "\(in Python v3.13\)"))

  * **state** (_SimState_ _|__None_)

__init__(_ast_ , _reg_deps =frozenset({})_, _tmp_deps =frozenset({})_, _deps =frozenset({})_, _state =None_)¶
    

Parameters:
    

  * **ast** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

  * **reg_deps** ([_frozenset_](https://docs.python.org/3/library/stdtypes.html#frozenset "\(in Python v3.13\)") _[__SimActionData_ _|__SimActionOperation_ _]_)

  * **tmp_deps** ([_frozenset_](https://docs.python.org/3/library/stdtypes.html#frozenset "\(in Python v3.13\)") _[__SimActionData_ _|__SimActionOperation_ _]_)

  * **deps** ([_frozenset_](https://docs.python.org/3/library/stdtypes.html#frozenset "\(in Python v3.13\)"))

  * **state** (_SimState_ _|__None_)

ast _: [`Base`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)")_¶
    

reg_deps _: [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset "\(in Python v3.13\)")[`SimActionData` | `SimActionOperation`]_¶
    

tmp_deps _: [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset "\(in Python v3.13\)")[`SimActionData` | `SimActionOperation`]_¶
    

to_claripy()¶
    

Return type:
    

[`Base`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)")

copy()¶
    

Return type:
    

`SimActionObject`

is_leaf()¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_property _op _: [str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")_¶
    

_property _args _: [tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[ArgType, ...]_¶
    

_property _length _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

_property _variables _: [frozenset](https://docs.python.org/3/library/stdtypes.html#frozenset "\(in Python v3.13\)")[[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]_¶
    

_property _symbolic _: [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

_property _annotations _: [tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[Annotation](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.annotation.Annotation "\(in claripy\)"), ...]_¶
    

_property _depth _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

SDiv(_other_)¶
    

Return type:
    

`SimActionObject`

SMod(_other_)¶
    

Return type:
    

`SimActionObject`

union(_other_)¶
    

Return type:
    

`SimActionObject`

intersection(_other_)¶
    

Return type:
    

`SimActionObject`

widen(_other_)¶
    

Return type:
    

`SimActionObject`

raw_to_bv()¶
    

Return type:
    

`SimActionObject`

bv_to_fp()¶
    

Return type:
    

`SimActionObject`

_class _angr.state_plugins.SimActionOperation(_state_ , _op_ , _exprs_ , _result_)¶
    

Bases: `SimAction`

An action representing an operation between variables and/or constants.

__init__(_state_ , _op_ , _exprs_ , _result_)¶
    

Initializes the SimAction.

Parameters:
    

**state** – the state that’s the SimAction is taking place in.

_property _all_objects¶
    

_property _is_symbolic¶
    

_class _angr.state_plugins.SimDebugVariable(_state_ , _addr_ , _var_type_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A SimDebugVariable will get dynamically created when queriyng for variable in a state with the SimDebugVariablePlugin. It features a link to the state, an address and a type.

Parameters:
    

  * **state** (_SimState_)

  * **var_type** (_VariableType_)

__init__(_state_ , _addr_ , _var_type_)¶
    

Parameters:
    

  * **state** (_SimState_)

  * **var_type** ([_VariableType_](https://docs.angr.io/projects/cle/en/latest/api/backends/elf.html#cle.backends.elf.variable_type.VariableType "\(in cle\)"))

_static _from_cle_variable(_state_ , _cle_variable_ , _dwarf_cfa_)¶
    

Return type:
    

`SimDebugVariable`

Parameters:
    

  * **state** (_SimState_)

  * **cle_variable** ([_Variable_](https://docs.angr.io/projects/cle/en/latest/api/backends/elf.html#cle.backends.elf.variable.Variable "\(in cle\)"))

_property _mem_untyped _: SimMemView_¶
    

_property _mem _: SimMemView_¶
    

_property _string _: SimMemView_¶
    

with_type(_sim_type_)¶
    

Return type:
    

`SimMemView`

Parameters:
    

**sim_type** (_SimType_)

_property _resolvable¶
    

_property _resolved¶
    

_property _concrete¶
    

store(_value_)¶
    

_property _deref _: SimDebugVariable_¶
    

array(_i_)¶
    

Return type:
    

`SimDebugVariable`

member(_member_name_)¶
    

Return type:
    

`SimDebugVariable`

Parameters:
    

**member_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.state_plugins.SimDebugVariablePlugin¶
    

Bases: `SimStatePlugin`

This is the plugin you’ll use to interact with (global/local) program variables. These variables have a name and a visibility scope which depends on the pc address of the state. With this plugin, you can access/modify the value of such variable or find its memory address. For creating program variables, or for importing them from cle, see the knowledge plugin debug_variables. Run `p.kb.dvars.load_from_dwarf()` before using this plugin.

Example
    
    
    >>> p = angr.Project("various_variables", load_debug_info=True)
    >>> p.kb.dvars.load_from_dwarf()
    >>> state =  # navigate to the state you want
    >>> state.dvars.get_variable("pointer2").deref.mem
    <int (32 bits) <BV32 0x1> at 0x404020>
    

get_variable(_var_name_)¶
    

Returns the visible variable (if any) with name `var_name` based on the current `state.ip`.

Return type:
    

`SimDebugVariable`

Parameters:
    

**var_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_property _dwarf_cfa¶
    

Returns the current cfa computation. Set this property to the correct value if needed.

_property _dwarf_cfa_approx¶
    

_class _angr.state_plugins.SimEvent(_state_ , _event_type_ , _** kwargs_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A SimEvent is a log entry for some notable event during symbolic execution. It logs the location it was generated (ins_addr, bbl_addr, stmt_idx, and sim_procedure) as well as arbitrary tags (objects).

You may also be interested in SimAction, which is a specialization of SimEvent for CPU events.

__init__(_state_ , _event_type_ , _** kwargs_)¶
    

_class _angr.state_plugins.SimFilesystem(_files =None_, _pathsep =None_, _cwd =None_, _mountpoints =None_)¶
    

Bases: `SimStatePlugin`

angr’s emulated filesystem. Available as state.fs. When constructing, all parameters are optional.

Parameters:
    

  * **files** – A mapping from filepath to SimFile

  * **pathsep** – The character used to separate path elements, default forward slash.

  * **cwd** – The path of the current working directory to use

  * **mountpoints** – A mapping from filepath to SimMountpoint

Variables:
    

  * **pathsep** – The current pathsep

  * **cwd** – The current working directory

  * **unlinks** – A list of unlink operations, tuples of filename and simfile. Be careful, this list is shallow-copied from successor to successor, so don’t mutate anything in it without copying.

__init__(_files =None_, _pathsep =None_, _cwd =None_, _mountpoints =None_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

_property _unlinks¶
    

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

chdir(_path_)¶
    

Changes the current directory to the given path

get(_path_)¶
    

Get a file from the filesystem. Returns a SimFile or None.

insert(_path_ , _simfile_)¶
    

Insert a file into the filesystem. Returns whether the operation was successful.

delete(_path_)¶
    

Remove a file from the filesystem. Returns whether the operation was successful.

This will add a `fs_unlink` event with the path of the file and also the index into the unlinks list.

mount(_path_ , _mount_)¶
    

Add a mountpoint to the filesystem.

unmount(_path_)¶
    

Remove a mountpoint from the filesystem.

get_mountpoint(_path_)¶
    

Look up the mountpoint servicing the given path.

Returns:
    

A tuple of the mount and a list of path elements traversing from the mountpoint to the specified file.

_class _angr.state_plugins.SimHeapBase(_heap_base =None_, _heap_size =None_)¶
    

Bases: `SimStatePlugin`

This is the base heap class that all heap implementations should subclass. It defines a few handlers for common heap functions (the libc memory management functions). Heap implementations are expected to override these functions regardless of whether they implement the SimHeapLibc interface. For an example, see the SimHeapBrk implementation, which is based on the original libc SimProcedure implementations.

Variables:
    

  * **heap_base** – the address of the base of the heap in memory

  * **heap_size** – the total size of the main memory region managed by the heap in memory

  * **mmap_base** – the address of the region from which large mmap allocations will be made

__init__(_heap_base =None_, _heap_size =None_)¶
    

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

init_state()¶
    

Use this function to perform any initialization on the state at plugin-add time

_class _angr.state_plugins.SimHeapBrk(_heap_base =None_, _heap_size =None_)¶
    

Bases: `SimHeapBase`

SimHeapBrk represents a trivial heap implementation based on the Unix brk system call. This type of heap stores virtually no metadata, so it is up to the user to determine when it is safe to release memory. This also means that it does not properly support standard heap operations like realloc.

This heap implementation is a holdover from before any more proper implementations were modelled. At the time, various libc (or win32) SimProcedures handled the heap in the same way that this plugin does now. To make future heap implementations plug-and-playable, they should implement the necessary logic themselves, and dependent SimProcedures should invoke a method by the same name as theirs (prepended with an underscore) upon the heap plugin. Depending on the heap implementation, if the method is not supported, an error should be raised.

Out of consideration for the original way the heap was handled, this plugin implements functionality for all relevant SimProcedures (even those that would not normally be supported together in a single heap implementation).

Variables:
    

**heap_location** – the address of the top of the heap, bounding the allocations made starting from heap_base

__init__(_heap_base =None_, _heap_size =None_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

allocate(_sim_size_)¶
    

The actual allocation primitive for this heap implementation. Increases the position of the break to allocate space. Has no guards against the heap growing too large.

Parameters:
    

**sim_size** – a size specifying how much to increase the break pointer by

Returns:
    

a pointer to the previous break position, above which there is now allocated space

release(_sim_size_)¶
    

The memory release primitive for this heap implementation. Decreases the position of the break to deallocate space. Guards against releasing beyond the initial heap base.

Parameters:
    

**sim_size** – a size specifying how much to decrease the break pointer by (may be symbolic or not)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.state_plugins.SimHeapLibc(_heap_base =None_, _heap_size =None_)¶
    

Bases: `SimHeapBase`

A class of heap that implements the major libc heap management functions.

malloc(_sim_size_)¶
    

A somewhat faithful implementation of libc malloc.

Parameters:
    

**sim_size** – the amount of memory (in bytes) to be allocated

Returns:
    

the address of the allocation, or a NULL pointer if the allocation failed

free(_ptr_)¶
    

A somewhat faithful implementation of libc free.

Parameters:
    

**ptr** – the location in memory to be freed

calloc(_sim_nmemb_ , _sim_size_)¶
    

A somewhat faithful implementation of libc calloc.

Parameters:
    

  * **sim_nmemb** – the number of elements to allocated

  * **sim_size** – the size of each element (in bytes)

Returns:
    

the address of the allocation, or a NULL pointer if the allocation failed

realloc(_ptr_ , _size_)¶
    

A somewhat faithful implementation of libc realloc.

Parameters:
    

  * **ptr** – the location in memory to be reallocated

  * **size** – the new size desired for the allocation

Returns:
    

the address of the allocation, or a NULL pointer if the allocation was freed or if no new allocation was made

_class _angr.state_plugins.SimHeapPTMalloc(_heap_base =None_, _heap_size =None_)¶
    

Bases: `SimHeapFreelist`

A freelist-style heap implementation inspired by ptmalloc. The chunks used by this heap contain heap metadata in addition to user data. While the real-world ptmalloc is implemented using multiple lists of free chunks (corresponding to their different sizes), this more basic model uses a single list of chunks and searches for free chunks using a first-fit algorithm.

**NOTE:** The plugin must be registered using `register_plugin` with name `heap` in order to function properly.

Variables:
    

  * **heap_base** – the address of the base of the heap in memory

  * **heap_size** – the total size of the main memory region managed by the heap in memory

  * **mmap_base** – the address of the region from which large mmap allocations will be made

  * **free_head_chunk** – the head of the linked list of free chunks in the heap

__init__(_heap_base =None_, _heap_size =None_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

chunks()¶
    

Returns an iterator over all the chunks in the heap.

allocated_chunks()¶
    

Returns an iterator over all the allocated chunks in the heap.

free_chunks()¶
    

Returns an iterator over all the free chunks in the heap.

chunk_from_mem(_ptr_)¶
    

Given a pointer to a user payload, return the base of the chunk associated with that payload (i.e. the chunk pointer). Returns None if ptr is null.

Parameters:
    

**ptr** – a pointer to the base of a user payload in the heap

Returns:
    

a pointer to the base of the associated heap chunk, or None if ptr is null

malloc(_sim_size_)¶
    

A somewhat faithful implementation of libc malloc.

Parameters:
    

**sim_size** – the amount of memory (in bytes) to be allocated

Returns:
    

the address of the allocation, or a NULL pointer if the allocation failed

free(_ptr_)¶
    

A somewhat faithful implementation of libc free.

Parameters:
    

**ptr** – the location in memory to be freed

calloc(_sim_nmemb_ , _sim_size_)¶
    

A somewhat faithful implementation of libc calloc.

Parameters:
    

  * **sim_nmemb** – the number of elements to allocated

  * **sim_size** – the size of each element (in bytes)

Returns:
    

the address of the allocation, or a NULL pointer if the allocation failed

realloc(_ptr_ , _size_)¶
    

A somewhat faithful implementation of libc realloc.

Parameters:
    

  * **ptr** – the location in memory to be reallocated

  * **size** – the new size desired for the allocation

Returns:
    

the address of the allocation, or a NULL pointer if the allocation was freed or if no new allocation was made

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

init_state()¶
    

Use this function to perform any initialization on the state at plugin-add time

_class _angr.state_plugins.SimHostFilesystem(_host_path =None_, _** kwargs_)¶
    

Bases: `SimConcreteFilesystem`

Simulated mount that makes some piece from the host filesystem available to the guest.

Parameters:
    

  * **host_path** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The path on the host to mount

  * **pathsep** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The host path separator character, default os.path.sep

__init__(_host_path =None_, _** kwargs_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

_class _angr.state_plugins.SimInspector¶
    

Bases: `SimStatePlugin`

The breakpoint interface, used to instrument execution. For usage information, look here: <https://docs.angr.io/core-concepts/simulation#breakpoints>

BP_AFTER _ = 'after'_¶
    

BP_BEFORE _ = 'before'_¶
    

BP_BOTH _ = 'both'_¶
    

__init__()¶
    

action(_event_type_ , _when_ , _** kwargs_)¶
    

Called from within the engine when events happens. This function checks all breakpoints registered for that event and fires the ones whose conditions match.

make_breakpoint(_event_type_ , _* args_, _** kwargs_)¶
    

Creates and adds a breakpoint which would trigger on event_type. Additional arguments are passed to the `BP` constructor.

Returns:
    

The created breakpoint, so that it can be removed later.

b(_event_type_ , _* args_, _** kwargs_)¶
    

Creates and adds a breakpoint which would trigger on event_type. Additional arguments are passed to the `BP` constructor.

Returns:
    

The created breakpoint, so that it can be removed later.

add_breakpoint(_event_type_ , _bp_)¶
    

Adds a breakpoint which would trigger on event_type.

Parameters:
    

  * **event_type** – The event type to trigger on

  * **bp** – The breakpoint

Returns:
    

The created breakpoint.

remove_breakpoint(_event_type_ , _bp =None_, _filter_func =None_)¶
    

Removes a breakpoint.

Parameters:
    

  * **bp** – The breakpoint to remove.

  * **filter_func** – A filter function to specify whether each breakpoint should be removed or not.

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

downsize()¶
    

Remove previously stored attributes from this plugin instance to save memory. This method is supposed to be called by breakpoint implementors. A typical workflow looks like the following :
    
    
    >>> # Add `attr0` and `attr1` to `self.state.inspect`
    >>> self.state.inspect(xxxxxx, attr0=yyyy, attr1=zzzz)
    >>> # Get new attributes out of SimInspect in case they are modified by the user
    >>> new_attr0 = self.state._inspect.attr0
    >>> new_attr1 = self.state._inspect.attr1
    >>> # Remove them from SimInspect
    >>> self.state._inspect.downsize()
    

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

_class _angr.state_plugins.SimJavaVmClassloader(_initialized_classes =None_)¶
    

Bases: `SimStatePlugin`

JavaVM Classloader is used as an interface for resolving and initializing Java classes.

__init__(_initialized_classes =None_)¶
    

get_class(_class_name_ , _init_class =False_, _step_func =None_)¶
    

Get a class descriptor for the class.

Parameters:
    

  * **class_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of class.

  * **init_class** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether the class initializer <clinit> should be executed.

  * **step_func** (_func_) – Callback function executed at every step of the simulation manager during the execution of the main <clinit> method

get_superclass(_class__)¶
    

Get the superclass of the class.

get_class_hierarchy(_base_class_)¶
    

Walks up the class hierarchy and returns a list of all classes between base class (inclusive) and java.lang.Object (exclusive).

is_class_initialized(_class__)¶
    

Indicates whether the classes initializing method <clinit> was already executed on the state.

init_class(_class__ , _step_func =None_)¶
    

This method simulates the loading of a class by the JVM, during which parts of the class (e.g. static fields) are initialized. For this, we run the class initializer method <clinit> (if available) and update the state accordingly.

Note: Initialization is skipped, if the class has already been
    

initialized (or if it’s not loaded in CLE).

_property _initialized_classes¶
    

List of all initialized classes.

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.state_plugins.SimLightRegisters(_reg_map =None_, _registers =None_)¶
    

Bases: `SimStatePlugin`

__init__(_reg_map =None_, _registers =None_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

resolve_register(_offset_ , _size_)¶
    

load(_offset_ , _size =None_, _** kwargs_)¶
    

store(_offset_ , _value_ , _size =None_, _endness =None_, _** kwargs_)¶
    

_class _angr.state_plugins.SimMemView(_ty =None_, _addr =None_, _state =None_)¶
    

Bases: `SimStatePlugin`

This is a convenient interface with which you can access a program’s memory.

The interface works like this:

>   * You first use [array index notation] to specify the address you’d like to load from
> 
>   * If at that address is a pointer, you may access the `deref` property to return a SimMemView at the address present in memory.
> 
>   * You then specify a type for the data by simply accessing a property of that name. For a list of supported types, look at `state.mem.types`.
> 
>   * You can then _refine_ the type. Any type may support any refinement it likes. Right now the only refinements supported are that you may access any member of a struct by its member name, and you may index into a string or array to access that element.
> 
>   * If the address you specified initially points to an array of that type, you can say .array(n) to view the data as an array of n elements.
> 
>   * Finally, extract the structured data with `.resolved` or `.concrete`. `.resolved` will return bitvector values, while `.concrete` will return integer, string, array, etc values, whatever best represents the data.
> 
>   * Alternately, you may store a value to memory, by assigning to the chain of properties that you’ve constructed. Note that because of the way python works, `x = s.mem[...].prop; x = val` will NOT work, you must say `s.mem[...].prop = val`.
> 
> 

For example:
    
    
    >>> s.mem[0x601048].long
    <long (64 bits) <BV64 0x4008d0> at 0x601048>
    >>> s.mem[0x601048].long.resolved
    <BV64 0x4008d0>
    >>> s.mem[0x601048].deref
    <<untyped> <unresolvable> at 0x4008d0>
    >>> s.mem[0x601048].deref.string.concrete
    'SOSNEAKY'
    

Parameters:
    

**state** (_SimState_)

__init__(_ty =None_, _addr =None_, _state =None_)¶
    

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

types _: ClassVar[dict]__ = {'CharT': char, 'FILE_t': struct FILE_t, '_Bool': bool, '_ENTRY': struct _ENTRY, '_IO_codecvt': struct _IO_codecvt, '_IO_iconv_t': struct _IO_iconv_t, '_IO_lock_t': struct pthread_mutex_t, '_IO_marker': struct _IO_marker, '_IO_wide_data': struct _IO_wide_data, '__clock_t': uint32_t, '__dev_t': uint64_t, '__gid_t': unsigned int, '__ino64_t': unsigned long long, '__ino_t': unsigned long, '__int128': int128_t, '__int256': int256_t, '__mbstate_t': struct __mbstate_t, '__mode_t': unsigned int, '__nlink_t': unsigned int, '__off64_t': long long, '__off_t': long, '__pid_t': int, '__suseconds_t': int64_t, '__time_t': long, '__uid_t': unsigned int, '_obstack_chunk': struct _obstack_chunk, 'aiocb': struct aiocb, 'aiocb64': struct aiocb64, 'aioinit': struct aioinit, 'argp': struct argp, 'argp_child': struct argp_child, 'argp_option': struct argp_option, 'argp_parser_t': (int, char*, struct argp_state*) -> int, 'argp_state': struct argp_state, 'basic_string': string_t, 'bool': bool, 'byte': uint8_t, 'cc_t': char, 'char': char, 'clock_t': uint32_t, 'crypt_data': struct crypt_data, 'dirent': struct dirent, 'dirent64': struct dirent64, 'double': double, 'drand48_data': struct <anon>, 'dword': uint32_t, 'error_t': int, 'exit_status': struct exit_status, 'float': float, 'fstab': struct fstab, 'group': struct group, 'hostent': struct hostent, 'hsearch_data': struct hsearch_data, 'if_nameindex': struct if_nameindex, 'in_addr': struct in_addr, 'in_port_t': uint16_t, 'ino64_t': unsigned long long, 'ino_t': unsigned long, 'int': int, 'int16_t': int16_t, 'int32_t': int32_t, 'int64_t': int64_t, 'int8_t': int8_t, 'iovec': struct <anon>, 'itimerval': struct itimerval, 'lconv': struct lconv, 'long': long, 'long double': double, 'long int': long, 'long long': long long, 'long long int': long long, 'long signed': long, 'long unsigned int': unsigned long, 'mallinfo': struct mallinfo, 'mallinfo2': struct mallinfo2, 'mntent': struct mntent, 'netent': struct netent, 'ntptimeval': struct ntptimeval, 'obstack': struct obstack, 'off64_t': long long, 'off_t': long, 'option': struct option, 'passwd': struct passwd, 'pid_t': int, 'printf_info': struct printf_info, 'protoent': struct protoent, 'ptrdiff_t': long, 'qword': uint64_t, 'random_data': struct <anon>, 'rlim64_t': uint64_t, 'rlim_t': unsigned long, 'rlimit': struct rlimit, 'rlimit64': struct rlimit64, 'rusage': struct rusage, 'sa_family_t': unsigned short, 'sched_param': struct sched_param, 'sembuf': struct sembuf, 'servent': struct servent, 'sgttyb': struct sgttyb, 'short': short, 'short int': short, 'sigevent': struct sigevent, 'signed': int, 'signed char': char, 'signed int': int, 'signed long': long, 'signed long int': long, 'signed long long': long long, 'signed long long int': long long, 'signed short': short, 'signed short int': short, 'sigstack': struct sigstack, 'sigval': union sigval { sival_int int; sival_ptr void*; }, 'size_t': size_t, 'sockaddr': struct sockaddr, 'sockaddr_in': struct sockaddr_in, 'speed_t': long, 'ssize': size_t, 'ssize_t': size_t, 'stat': struct stat, 'stat64': struct stat64, 'std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>': string_t, 'string': string_t, 'struct iovec': struct iovec, 'struct timespec': struct timespec, 'struct timeval': struct timeval, 'tcflag_t': unsigned long, 'termios': struct termios, 'time_t': long, 'timespec': struct timeval, 'timeval': struct timeval, 'timex': struct timex, 'timezone': struct timezone, 'tm': struct tm, 'tms': struct tms, 'uint16_t': uint16_t, 'uint32_t': uint32_t, 'uint64_t': uint64_t, 'uint8_t': uint8_t, 'uintptr_t': unsigned long, 'unsigned': unsigned int, 'unsigned __int128': uint128_t, 'unsigned __int256': uint256_t, 'unsigned char': char, 'unsigned int': unsigned int, 'unsigned long': unsigned long, 'unsigned long int': unsigned long, 'unsigned long long': unsigned long long, 'unsigned long long int': unsigned long long, 'unsigned short': unsigned short, 'unsigned short int': unsigned short, 'utimbuf': struct utimbuf, 'utmp': struct utmp, 'utmpx': struct utmx, 'utsname': struct utsname, 'va_list': struct va_list[1], 'void': void, 'vtimes': struct vtimes, 'wchar_t': short, 'winsize': struct winsize, 'word': uint16_t, 'wstring': wstring_t}_¶
    

state _: angr.SimState_ _ = None_¶
    

struct _: StructMode_¶
    

with_type(_sim_type_)¶
    

Returns a copy of the SimMemView with a type.

Parameters:
    

**sim_type** (`SimType`) – The new type.

Return type:
    

`SimMemView`

Returns:
    

The typed SimMemView copy.

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_property _resolvable¶
    

_property _resolved¶
    

_property _concrete¶
    

_property _deref _: SimMemView_¶
    

array(_n_)¶
    

Return type:
    

`SimMemView`

member(_member_name_)¶
    

If self is a struct and member_name is a member of the struct, return that member element. Otherwise raise an exception.

Return type:
    

`SimMemView`

Parameters:
    

**member_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

store(_value_)¶
    

_class _angr.state_plugins.SimMount¶
    

Bases: `SimStatePlugin`

This is the base class for “mount points” in angr’s simulated filesystem. Subclass this class and give it to the filesystem to intercept all file creations and opens below the mountpoint. Since this a SimStatePlugin you may also want to implement set_state, copy, merge, etc.

get(_path_elements_)¶
    

Implement this function to instrument file lookups.

Parameters:
    

**path_elements** – A list of path elements traversing from the mountpoint to the file

Returns:
    

A SimFile, or None

insert(_path_elements_ , _simfile_)¶
    

Implement this function to instrument file creation.

Parameters:
    

  * **path_elements** – A list of path elements traversing from the mountpoint to the file

  * **simfile** – The file to insert

Returns:
    

A bool indicating whether the insert occurred

delete(_path_elements_)¶
    

Implement this function to instrument file deletion.

Parameters:
    

**path_elements** – A list of path elements traversing from the mountpoint to the file

Returns:
    

A bool indicating whether the delete occurred

lookup(_sim_file_)¶
    

Look up the path of a SimFile in the mountpoint

Parameters:
    

**sim_file** – A SimFile object needs to be looked up

Returns:
    

A string representing the path of the file in the mountpoint Or None if the SimFile does not exist in the mountpoint

_class _angr.state_plugins.SimRegNameView¶
    

Bases: `SimStatePlugin`

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

get(_reg_name_)¶
    

_class _angr.state_plugins.SimSolver(_solver =None_, _all_variables =None_, _temporal_tracked_variables =None_, _eternal_tracked_variables =None_)¶
    

Bases: `SimStatePlugin`

This is the plugin you’ll use to interact with symbolic variables, creating them and evaluating them. It should be available on a state as `state.solver`.

Any top-level variable of the claripy module can be accessed as a property of this object.

__init__(_solver =None_, _all_variables =None_, _temporal_tracked_variables =None_, _eternal_tracked_variables =None_)¶
    

reload_solver(_constraints =None_)¶
    

Reloads the solver. Useful when changing solver options.

Parameters:
    

**constraints** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A new list of constraints to use in the reloaded solver instead of the current one

get_variables(_* keys_)¶
    

Iterate over all variables for which their tracking key is a prefix of the values provided.

Elements are a tuple, the first element is the full tracking key, the second is the symbol.
    
    
    >>> list(s.solver.get_variables('mem'))
    [(('mem', 0x1000), <BV64 mem_1000_4_64>), (('mem', 0x1008), <BV64 mem_1008_5_64>)]
    
    
    
    >>> list(s.solver.get_variables('file'))
    [(('file', 1, 0), <BV8 file_1_0_6_8>), (('file', 1, 1), <BV8 file_1_1_7_8>),
        (('file', 2, 0), <BV8 file_2_0_8_8>)]
    
    
    
    >>> list(s.solver.get_variables('file', 2))
    [(('file', 2, 0), <BV8 file_2_0_8_8>)]
    
    
    
    >>> list(s.solver.get_variables())
    [(('mem', 0x1000), <BV64 mem_1000_4_64>), (('mem', 0x1008), <BV64 mem_1008_5_64>),
        (('file', 1, 0), <BV8 file_1_0_6_8>), (('file', 1, 1), <BV8 file_1_1_7_8>),
        (('file', 2, 0), <BV8 file_2_0_8_8>)]
    

register_variable(_v_ , _key_ , _eternal =True_)¶
    

Register a value with the variable tracking system

Parameters:
    

  * **v** – The BVS to register

  * **key** – A tuple to register the variable under

Parma eternal:
    

Whether this is an eternal variable, default True. If False, an incrementing counter will be appended to the key.

describe_variables(_v_)¶
    

Given an AST, iterate over all the keys of all the BVS leaves in the tree which are registered.

Unconstrained(_name_ , _bits_ , _uninitialized =True_, _inspect =True_, _events =True_, _key =None_, _eternal =False_, _uc_alloc_depth =None_, _** kwargs_)¶
    

Creates an unconstrained symbol or a default concrete value (0), based on the state options.

Parameters:
    

  * **name** – The name of the symbol.

  * **bits** – The size (in bits) of the symbol.

  * **uninitialized** – Whether this value should be counted as an “uninitialized” value in the course of an analysis.

  * **inspect** – Set to False to avoid firing SimInspect breakpoints

  * **events** – Set to False to avoid generating a SimEvent for the occasion

  * **key** – Set this to a tuple of increasingly specific identifiers (for example, `('mem', 0xffbeff00)` or `('file', 4, 0x20)` to cause it to be tracked, i.e. accessible through `solver.get_variables`.

  * **eternal** – Set to True in conjunction with setting a key to cause all states with the same ancestry to retrieve the same symbol when trying to create the value. If False, a counter will be appended to the key.

Returns:
    

an unconstrained symbol (or a concrete value of 0).

BVS(_name_ , _size_ , _min =None_, _max =None_, _stride =None_, _uninitialized =False_, _explicit_name =False_, _key =None_, _eternal =False_, _inspect =True_, _events =True_, _** kwargs_)¶
    

Creates a bit-vector symbol (i.e., a variable). Other keyword parameters are passed directly on to the constructor of claripy.ast.BV.

Parameters:
    

  * **name** – The name of the symbol.

  * **size** – The size (in bits) of the bit-vector.

  * **min** – The minimum value of the symbol. Note that this **only** work when using VSA.

  * **max** – The maximum value of the symbol. Note that this **only** work when using VSA.

  * **stride** – The stride of the symbol. Note that this **only** work when using VSA.

  * **uninitialized** – Whether this value should be counted as an “uninitialized” value in the course of an analysis.

  * **explicit_name** – Set to True to prevent an identifier from appended to the name to ensure uniqueness.

  * **key** – Set this to a tuple of increasingly specific identifiers (for example, `('mem', 0xffbeff00)` or `('file', 4, 0x20)` to cause it to be tracked, i.e. accessible through `solver.get_variables`.

  * **eternal** – Set to True in conjunction with setting a key to cause all states with the same ancestry to retrieve the same symbol when trying to create the value. If False, a counter will be appended to the key.

  * **inspect** – Set to False to avoid firing SimInspect breakpoints

  * **events** – Set to False to avoid generating a SimEvent for the occasion

Returns:
    

A BV object representing this symbol.

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

downsize()¶
    

Frees memory associated with the constraint solver by clearing all of its internal caches.

_property _constraints¶
    

Returns the constraints of the state stored by the solver.

eval_to_ast(_e_ , _n_ , _extra_constraints =()_, _exact =None_)¶
    

Evaluate an expression, using the solver if necessary. Returns AST objects.

Parameters:
    

  * **e** – the expression

  * **n** – the number of desired solutions

  * **extra_constraints** – extra constraints to apply to the solver

  * **exact** – if False, returns approximate solutions

Returns:
    

a tuple of the solutions, in the form of claripy AST nodes

Return type:
    

[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

max(_e_ , _extra_constraints =()_, _exact =None_, _signed =False_)¶
    

Return the maximum value of expression e.

:param e : expression (an AST) to evaluate :type extra_constraints: :param extra_constraints: extra constraints (as ASTs) to add to the solver for this solve :param exact : if False, return approximate solutions. :param signed : Whether the expression should be treated as a signed value. :return: the maximum possible value of e (backend object)

min(_e_ , _extra_constraints =()_, _exact =None_, _signed =False_)¶
    

Return the minimum value of expression e.

:param e : expression (an AST) to evaluate :type extra_constraints: :param extra_constraints: extra constraints (as ASTs) to add to the solver for this solve :param exact : if False, return approximate solutions. :param signed : Whether the expression should be treated as a signed value. :return: the minimum possible value of e (backend object)

solution(_e_ , _v_ , _extra_constraints =()_, _exact =None_)¶
    

Return True if v is a solution of expr with the extra constraints, False otherwise.

Parameters:
    

  * **e** – An expression (an AST) to evaluate

  * **v** – The proposed solution (an AST)

  * **extra_constraints** – Extra constraints (as ASTs) to add to the solver for this solve.

  * **exact** – If False, return approximate solutions.

Returns:
    

True if v is a solution of expr, False otherwise

is_true(_e_ , _extra_constraints =()_, _exact =None_)¶
    

If the expression provided is absolutely, definitely a true boolean, return True. Note that returning False doesn’t necessarily mean that the expression can be false, just that we couldn’t figure that out easily.

Parameters:
    

  * **e** – An expression (an AST) to evaluate

  * **extra_constraints** – Extra constraints (as ASTs) to add to the solver for this solve.

  * **exact** – If False, return approximate solutions.

Returns:
    

True if v is definitely true, False otherwise

is_false(_e_ , _extra_constraints =()_, _exact =None_)¶
    

If the expression provided is absolutely, definitely a false boolean, return True. Note that returning False doesn’t necessarily mean that the expression can be true, just that we couldn’t figure that out easily.

Parameters:
    

  * **e** – An expression (an AST) to evaluate

  * **extra_constraints** – Extra constraints (as ASTs) to add to the solver for this solve.

  * **exact** – If False, return approximate solutions.

Returns:
    

True if v is definitely false, False otherwise

unsat_core(_extra_constraints =()_)¶
    

This function returns the unsat core from the backend solver.

Parameters:
    

**extra_constraints** – Extra constraints (as ASTs) to add to the solver for this solve.

Returns:
    

The unsat core.

satisfiable(_extra_constraints =()_, _exact =None_)¶
    

This function does a constraint check and checks if the solver is in a sat state.

Parameters:
    

  * **extra_constraints** – Extra constraints (as ASTs) to add to s for this solve

  * **exact** – If False, return approximate solutions.

Returns:
    

True if sat, otherwise false

add(_* constraints_)¶
    

Add some constraints to the solver.

Parameters:
    

**constraints** – Pass any constraints that you want to add (ASTs) as varargs.

CastType _ = ~CastType_¶
    

eval_upto(_e_ , _n_ , _cast_to =None_, _** kwargs_)¶
    

Evaluate an expression, using the solver if necessary. Returns primitives as specified by the cast_to parameter. Only certain primitives are supported, check the implementation of _cast_to to see which ones.

Parameters:
    

  * **e** – the expression

  * **n** – the number of desired solutions

  * **extra_constraints** – extra constraints to apply to the solver

  * **exact** – if False, returns approximate solutions

  * **cast_to** – desired type of resulting values

Returns:
    

a tuple of the solutions, in the form of Python primitives

Return type:
    

[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

eval(_e_ , _cast_to =None_, _** kwargs_)¶
    

Evaluate an expression to get any possible solution. The desired output types can be specified using the cast_to parameter. extra_constraints can be used to specify additional constraints the returned values must satisfy.

Parameters:
    

  * **e** – the expression to get a solution for

  * **kwargs** – Any additional kwargs will be passed down to eval_upto

  * **cast_to** – desired type of resulting values

Raises:
    

**SimUnsatError** – if no solution could be found satisfying the given constraints

Returns:
    

eval_one(_e_ , _cast_to =None_, _** kwargs_)¶
    

Evaluate an expression to get the only possible solution. Errors if either no or more than one solution is returned. A kwarg parameter default can be specified to be returned instead of failure!

Parameters:
    

  * **e** – the expression to get a solution for

  * **cast_to** – desired type of resulting values

  * **default** – A value can be passed as a kwarg here. It will be returned in case of failure.

  * **kwargs** – Any additional kwargs will be passed down to eval_upto

Raises:
    

  * **SimUnsatError** – if no solution could be found satisfying the given constraints

  * **SimValueError** – if more than one solution was found to satisfy the given constraints

Returns:
    

The value for e

eval_atmost(_e_ , _n_ , _cast_to =None_, _** kwargs_)¶
    

Evaluate an expression to get at most n possible solutions. Errors if either none or more than n solutions are returned.

Parameters:
    

  * **e** – the expression to get a solution for

  * **n** – the inclusive upper limit on the number of solutions

  * **cast_to** – desired type of resulting values

  * **kwargs** – Any additional kwargs will be passed down to eval_upto

Raises:
    

  * **SimUnsatError** – if no solution could be found satisfying the given constraints

  * **SimValueError** – if more than n solutions were found to satisfy the given constraints

Returns:
    

The solutions for e

eval_atleast(_e_ , _n_ , _cast_to =None_, _** kwargs_)¶
    

Evaluate an expression to get at least n possible solutions. Errors if less than n solutions were found.

Parameters:
    

  * **e** – the expression to get a solution for

  * **n** – the inclusive lower limit on the number of solutions

  * **cast_to** – desired type of resulting values

  * **kwargs** – Any additional kwargs will be passed down to eval_upto

Raises:
    

  * **SimUnsatError** – if no solution could be found satisfying the given constraints

  * **SimValueError** – if less than n solutions were found to satisfy the given constraints

Returns:
    

The solutions for e

eval_exact(_e_ , _n_ , _cast_to =None_, _** kwargs_)¶
    

Evaluate an expression to get exactly the n possible solutions. Errors if any number of solutions other than n was found to exist.

Parameters:
    

  * **e** – the expression to get a solution for

  * **n** – the inclusive lower limit on the number of solutions

  * **cast_to** – desired type of resulting values

  * **kwargs** – Any additional kwargs will be passed down to eval_upto

Raises:
    

  * **SimUnsatError** – if no solution could be found satisfying the given constraints

  * **SimValueError** – if any number of solutions other than n were found to satisfy the given constraints

Returns:
    

The solutions for e

min_int(_e_ , _extra_constraints =()_, _exact =None_, _signed =False_)¶
    

Return the minimum value of expression e.

:param e : expression (an AST) to evaluate :type extra_constraints: :param extra_constraints: extra constraints (as ASTs) to add to the solver for this solve :param exact : if False, return approximate solutions. :param signed : Whether the expression should be treated as a signed value. :return: the minimum possible value of e (backend object)

max_int(_e_ , _extra_constraints =()_, _exact =None_, _signed =False_)¶
    

Return the maximum value of expression e.

:param e : expression (an AST) to evaluate :type extra_constraints: :param extra_constraints: extra constraints (as ASTs) to add to the solver for this solve :param exact : if False, return approximate solutions. :param signed : Whether the expression should be treated as a signed value. :return: the maximum possible value of e (backend object)

unique(_e_ , _** kwargs_)¶
    

Returns True if the expression e has only one solution by querying the constraint solver. It does also add that unique solution to the solver’s constraints.

symbolic(_e_)¶
    

Returns True if the expression e is symbolic.

single_valued(_e_)¶
    

Returns True whether e is a concrete value or is a value set with only 1 possible value. This differs from unique in that this _does_ not query the constraint solver.

simplify(_e =None_)¶
    

Simplifies e. If e is None, simplifies the constraints of this state.

variables(_e_)¶
    

Returns the symbolic variables present in the AST of e.

_class _angr.state_plugins.SimStateCGC¶
    

Bases: `SimStatePlugin`

This state plugin keeps track of CGC state.

EBADF _ = 1_¶
    

EFAULT _ = 2_¶
    

EINVAL _ = 3_¶
    

ENOMEM _ = 4_¶
    

ENOSYS _ = 5_¶
    

EPIPE _ = 6_¶
    

FD_SETSIZE _ = 1024_¶
    

max_allocation _ = 268435456_¶
    

__init__()¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

peek_input()¶
    

discard_input(_num_bytes_)¶
    

peek_output()¶
    

discard_output(_num_bytes_)¶
    

addr_invalid(_a_)¶
    

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

get_max_sinkhole(_length_)¶
    

Find a sinkhole which is large enough to support length bytes.

This uses first-fit. The first sinkhole (ordered in descending order by their address) which can hold length bytes is chosen. If there are more than length bytes in the sinkhole, a new sinkhole is created representing the remaining bytes while the old sinkhole is removed.

add_sinkhole(_address_ , _length_)¶
    

Add a sinkhole.

Allow the possibility for the program to reuse the memory represented by the address length pair.

_class _angr.state_plugins.SimStateGlobals(_backer =None_)¶
    

Bases: `SimStatePlugin`

__init__(_backer =None_)¶
    

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

keys()¶
    

values()¶
    

items()¶
    

get(_k_ , _alt =None_)¶
    

pop(_k_ , _alt =None_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

_class _angr.state_plugins.SimStateHistory(_parent =None_, _clone =None_)¶
    

Bases: `SimStatePlugin`

This class keeps track of historically-relevant information for paths.

STRONGREF_STATE _ = True_¶
    

__init__(_parent =None_, _clone =None_)¶
    

init_state()¶
    

Use this function to perform any initialization on the state at plugin-add time

set_strongref_state(_state_)¶
    

_property _addr¶
    

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

trim()¶
    

Discard the ancestry of this state.

filter_actions(_start_block_addr =None_, _end_block_addr =None_, _block_stmt =None_, _insn_addr =None_, _read_from =None_, _write_to =None_)¶
    

Filter self.actions based on some common parameters.

[start_block_addr, end_block_addr]

Parameters:
    

  * **start_block_addr** – Only return actions generated in blocks starting at this address.

  * **end_block_addr** – Only return actions generated in blocks ending at this address.

  * **block_stmt** – Only return actions generated in the nth statement of each block.

  * **insn_addr** – Only return actions generated in the assembly instruction at this address.

  * **read_from** – Only return actions that perform a read from the specified location.

  * **write_to** – Only return actions that perform a write to the specified location.

Notes: If IR optimization is turned on, reads and writes may not occur in the instruction they originally came from. Most commonly, If a register is read from twice in the same block, the second read will not happen, instead reusing the temp the value is already stored in.

Valid values for read_from and write_to are the string literals ‘reg’ or ‘mem’ (matching any read or write to registers or memory, respectively), any string (representing a read or write to the named register), and any integer (representing a read or write to the memory at this address).

demote()¶
    

Demotes this history node, causing it to drop the strong state reference.

reachable()¶
    

add_event(_event_type_ , _** kwargs_)¶
    

add_action(_action_)¶
    

extend_actions(_new_actions_)¶
    

subscribe_actions()¶
    

_property _recent_constraints¶
    

_property _recent_actions¶
    

_property _block_count¶
    

_property _lineage¶
    

_property _parents¶
    

_property _events _: [Reversible](https://docs.python.org/3/library/collections.abc.html#collections.abc.Reversible "\(in Python v3.13\)")[SimEvent]_¶
    

_property _actions _: [Reversible](https://docs.python.org/3/library/collections.abc.html#collections.abc.Reversible "\(in Python v3.13\)")[SimAction]_¶
    

_property _jumpkinds _: [Reversible](https://docs.python.org/3/library/collections.abc.html#collections.abc.Reversible "\(in Python v3.13\)")[[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]_¶
    

_property _jump_guards _: [Reversible](https://docs.python.org/3/library/collections.abc.html#collections.abc.Reversible "\(in Python v3.13\)")[[Bool](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bool.Bool "\(in claripy\)")]_¶
    

_property _jump_targets¶
    

_property _jump_sources¶
    

_property _descriptions _: [Reversible](https://docs.python.org/3/library/collections.abc.html#collections.abc.Reversible "\(in Python v3.13\)")[[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]_¶
    

_property _bbl_addrs _: [Reversible](https://docs.python.org/3/library/collections.abc.html#collections.abc.Reversible "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]_¶
    

_property _ins_addrs _: [Reversible](https://docs.python.org/3/library/collections.abc.html#collections.abc.Reversible "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]_¶
    

_property _stack_actions¶
    

closest_common_ancestor(_other_)¶
    

Find the common ancestor between this history node and ‘other’.

Parameters:
    

**other** – the PathHistory to find a common ancestor with.

Returns:
    

the common ancestor SimStateHistory, or None if there isn’t one

constraints_since(_other_)¶
    

Returns the constraints that have been accumulated since other.

Parameters:
    

**other** – a prior PathHistory object

Returns:
    

a list of constraints

make_child()¶
    

_class _angr.state_plugins.SimStateJNIReferences(_local_refs =None_, _global_refs =None_)¶
    

Bases: `SimStatePlugin`

Management of the mapping between opaque JNI references and the corresponding Java objects.

__init__(_local_refs =None_, _global_refs =None_)¶
    

lookup(_opaque_ref_)¶
    

Lookups the object that was used for creating the reference.

create_new_reference(_obj_ , _global_ref =False_)¶
    

Create a new reference thats maps to the given object.

Parameters:
    

  * **obj** – Object which gets referenced.

  * **global_ref** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether a local or global reference is created.

clear_local_references()¶
    

Clear all local references.

delete_reference(_opaque_ref_ , _global_ref =False_)¶
    

Delete the stored mapping of a reference.

Parameters:
    

  * **opaque_ref** – Reference which should be removed.

  * **global_ref** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether opaque_ref is a local or global reference.

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.state_plugins.SimStateLibc¶
    

Bases: `SimStatePlugin`

This state plugin keeps track of various libc stuff:

LOCALE_ARRAY _ = [b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x03 ', b'\x02 ', b'\x02 ', b'\x02 ', b'\x02 ', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x01`', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x08\xd8', b'\x08\xd8', b'\x08\xd8', b'\x08\xd8', b'\x08\xd8', b'\x08\xd8', b'\x08\xd8', b'\x08\xd8', b'\x08\xd8', b'\x08\xd8', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x08\xd5', b'\x08\xd5', b'\x08\xd5', b'\x08\xd5', b'\x08\xd5', b'\x08\xd5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x08\xd6', b'\x08\xd6', b'\x08\xd6', b'\x08\xd6', b'\x08\xd6', b'\x08\xd6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x02\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00']_¶
    

TOLOWER_LOC_ARRAY _ = [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 4294967295, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255]_¶
    

TOUPPER_LOC_ARRAY _ = [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 4294967295, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255]_¶
    

__init__()¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_property _errno¶
    

ret_errno(_val_)¶
    

_class _angr.state_plugins.SimStateLog(_log =None_)¶
    

Bases: `SimStatePlugin`

__init__(_log =None_)¶
    

_property _actions¶
    

add_event(_event_type_ , _** kwargs_)¶
    

add_action(_action_)¶
    

extend_actions(_new_actions_)¶
    

events_of_type(_event_type_)¶
    

actions_of_type(_action_type_)¶
    

_property _fresh_constraints¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

clear()¶
    

_class _angr.state_plugins.SimStateLoopData(_back_edge_trip_counts =None_, _header_trip_counts =None_, _current_loop =None_)¶
    

Bases: `SimStatePlugin`

This class keeps track of loop-related information for states. Note that we have 2 counters for loop iterations (trip counts): the first recording the number of times one of the back edges (or continue edges) of a loop is taken, whereas the second recording the number of times the loop header (or loop entry) is executed. These 2 counters may differ since compilers usually optimize loops hence completely change the loop structure at the binary level. This is supposed to be used with LoopSeer exploration technique, which monitors loop execution. For the moment, the only thing we want to analyze is loop trip counts, but nothing prevents us from extending this plugin for other loop analyses.

__init__(_back_edge_trip_counts =None_, _header_trip_counts =None_, _current_loop =None_)¶
    

Parameters:
    

  * **back_edge_trip_counts** – Dictionary that stores back edge based trip counts for each loop. Keys are address of loop headers.

  * **header_trip_counts** – Dictionary that stores header based trip counts for each loop. Keys are address of loop headers.

  * **current_loop** – List of currently running loops. Each element is a tuple (loop object, list of loop exits).

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

_class _angr.state_plugins.SimStatePlugin¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

This is a base class for SimState plugins. A SimState plugin will be copied along with the state when the state is branched. They are intended to be used for things such as tracking open files, tracking heap details, and providing storage and persistence for SimProcedures.

STRONGREF_STATE _ = False_¶
    

__init__()¶
    

state _: `SimState`_¶
    

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

set_strongref_state(_state_)¶
    

copy(__memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

_static _memo(_f_)¶
    

A decorator function you should apply to `copy`

Return type:
    

`_CopyFunc`[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)]

Parameters:
    

**f** ([_Callable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)") _[__[__T_ _,_[_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]__]__,__S_co_ _]_)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_classmethod _register_default(_name_ , _xtr =None_)¶
    

init_state()¶
    

Use this function to perform any initialization on the state at plugin-add time

_class _angr.state_plugins.SimStatePreconstrainer(_constrained_addrs =None_)¶
    

Bases: `SimStatePlugin`

This state plugin manages the concept of preconstraining - adding constraints which you would like to remove later.

Parameters:
    

**constrained_addrs** – SimActions for memory operations whose addresses should be constrained during crash analysis

__init__(_constrained_addrs =None_)¶
    

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

preconstrain(_value_ , _variable_)¶
    

Add a preconstraint that `variable == value` to the state.

Parameters:
    

  * **value** – The concrete value. Can be a bitvector or a bytestring or an integer.

  * **variable** – The BVS to preconstrain.

preconstrain_file(_content_ , _simfile_ , _set_length =False_)¶
    

Preconstrain the contents of a file.

Parameters:
    

  * **content** – The content to preconstrain the file to. Can be a bytestring or a list thereof.

  * **simfile** – The actual simfile to preconstrain

preconstrain_flag_page(_magic_content_)¶
    

Preconstrain the data in the flag page.

Parameters:
    

**magic_content** – The content of the magic page as a bytestring.

remove_preconstraints(_to_composite_solver =True_, _simplify =True_)¶
    

Remove the preconstraints from the state.

If you are using the zen plugin, this will also use that to filter the constraints.

Parameters:
    

  * **to_composite_solver** – Whether to convert the replacement solver to a composite solver. You probably want this if you’re switching from tracing to symbolic analysis.

  * **simplify** – Whether to simplify the resulting set of constraints.

reconstrain()¶
    

Split the solver. If any of the subsolvers time out after a short timeout (10 seconds), re-add the preconstraints associated with each of its variables. Hopefully these constraints still allow us to do meaningful things to the state.

_class _angr.state_plugins.SimStateScratch(_scratch =None_)¶
    

Bases: `SimStatePlugin`

Implements the scratch state plugin.

__init__(_scratch =None_)¶
    

_property _priv¶
    

push_priv(_priv_)¶
    

pop_priv()¶
    

set_tyenv(_tyenv_)¶
    

tmp_expr(_tmp_)¶
    

Returns the Claripy expression of a VEX temp value.

Parameters:
    

  * **tmp** – the number of the tmp

  * **simplify** – simplify the tmp before returning it

Returns:
    

a Claripy expression of the tmp

store_tmp(_tmp_ , _content_ , _reg_deps =frozenset({})_, _tmp_deps =frozenset({})_, _deps =None_, _** kwargs_)¶
    

Stores a Claripy expression in a VEX temp value. If in symbolic mode, this involves adding a constraint for the tmp’s symbolic variable.

Parameters:
    

  * **tmp** – the number of the tmp

  * **content** – a Claripy expression of the content

  * **reg_deps** – the register dependencies of the content

  * **tmp_deps** – the temporary value dependencies of the content

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

clear()¶
    

_class _angr.state_plugins.SimSymbolizer¶
    

Bases: `SimStatePlugin`

The symbolizer state plugin ensures that pointers that are stored in memory are symbolic. This allows for the tracking of and reasoning over these pointers (for example, to reason about memory disclosure).

__init__()¶
    

init_state()¶
    

Use this function to perform any initialization on the state at plugin-add time

set_symbolization_for_all_pages()¶
    

Sets the symbolizer to symbolize pointers to all pages as they are written to memory..

set_symbolized_target_range(_base_ , _length_)¶
    

All pointers to the target range will be symbolized as they are written to memory.

Due to optimizations, the _pages_ containing this range will be set as symbolization targets, not just the range itself.

resymbolize()¶
    

Re-symbolizes all pointers in memory. This can be called to symbolize any pointers to target regions that were written (and not mangled beyond recognition) before symbolization was set.

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

_class _angr.state_plugins.SimSystemPosix(_stdin =None_, _stdout =None_, _stderr =None_, _fd =None_, _sockets =None_, _socket_queue =None_, _argv =None_, _argc =None_, _environ =None_, _auxv =None_, _tls_modules =None_, _sigmask =None_, _pid =None_, _ppid =None_, _uid =None_, _gid =None_, _brk =None_)¶
    

Bases: `SimStatePlugin`

Data storage and interaction mechanisms for states with an environment conforming to posix. Available as `state.posix`.

SIG_BLOCK _ = 0_¶
    

SIG_UNBLOCK _ = 1_¶
    

SIG_SETMASK _ = 2_¶
    

EPERM _ = 1_¶
    

ENOENT _ = 2_¶
    

ESRCH _ = 3_¶
    

EINTR _ = 4_¶
    

EIO _ = 5_¶
    

ENXIO _ = 6_¶
    

E2BIG _ = 7_¶
    

ENOEXEC _ = 8_¶
    

EBADF _ = 9_¶
    

ECHILD _ = 10_¶
    

EAGAIN _ = 11_¶
    

ENOMEM _ = 12_¶
    

EACCES _ = 13_¶
    

EFAULT _ = 14_¶
    

ENOTBLK _ = 15_¶
    

EBUSY _ = 16_¶
    

EEXIST _ = 17_¶
    

EXDEV _ = 18_¶
    

ENODEV _ = 19_¶
    

ENOTDIR _ = 20_¶
    

EISDIR _ = 21_¶
    

EINVAL _ = 22_¶
    

ENFILE _ = 23_¶
    

EMFILE _ = 24_¶
    

ENOTTY _ = 25_¶
    

ETXTBSY _ = 26_¶
    

EFBIG _ = 27_¶
    

ENOSPC _ = 28_¶
    

ESPIPE _ = 29_¶
    

EROFS _ = 30_¶
    

EMLINK _ = 31_¶
    

EPIPE _ = 32_¶
    

EDOM _ = 33_¶
    

ERANGE _ = 34_¶
    

__init__(_stdin =None_, _stdout =None_, _stderr =None_, _fd =None_, _sockets =None_, _socket_queue =None_, _argv =None_, _argc =None_, _environ =None_, _auxv =None_, _tls_modules =None_, _sigmask =None_, _pid =None_, _ppid =None_, _uid =None_, _gid =None_, _brk =None_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

_property _closed_fds¶
    

init_state()¶
    

Use this function to perform any initialization on the state at plugin-add time

set_brk(_new_brk_)¶
    

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

open(_name_ , _flags_ , _preferred_fd =None_)¶
    

Open a symbolic file. Basically open(2).

Parameters:
    

  * **name** (_string_ _or_[ _bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)")) – Path of the symbolic file, as a string or bytes.

  * **flags** – File operation flags, a bitfield of constants from open(2), as an AST

  * **preferred_fd** – Assign this fd if it’s not already claimed.

Returns:
    

The file descriptor number allocated (maps through posix.get_fd to a SimFileDescriptor) or -1 if the open fails.

`mode` from open(2) is unsupported at present.

open_socket(_ident_)¶
    

get_fd(_fd_ , _create_file =True_)¶
    

Looks up the SimFileDescriptor associated with the given number (an AST). If the number is concrete and does not map to anything, return None. If the number is symbolic, constrain it to an open fd and create a new file for it. Set create_file to False if no write-access is planned (i.e. fd is read-only).

get_concrete_fd(_fd_ , _create_file =True_)¶
    

Same behavior as get_fd(fd), only the result is a concrete integer fd (or -1) instead of a SimFileDescriptor.

close(_fd_)¶
    

Closes the given file descriptor (an AST). Returns whether the operation succeeded (a concrete boolean)

fstat(_fd_)¶
    

fstat_with_result(_sim_fd_)¶
    

sigmask(_sigsetsize =None_)¶
    

Gets the current sigmask. If it’s blank, a new one is created (of sigsetsize).

Parameters:
    

**sigsetsize** – the size (in _bytes_ of the sigmask set)

Returns:
    

the sigmask

sigprocmask(_how_ , _new_mask_ , _sigsetsize_ , _valid_ptr =True_)¶
    

Updates the signal mask.

Parameters:
    

  * **how** – the “how” argument of sigprocmask (see manpage)

  * **new_mask** – the mask modification to apply

  * **sigsetsize** – the size (in _bytes_ of the sigmask set)

  * **valid_ptr** – is set if the new_mask was not NULL

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(___)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

dump_file_by_path(_path_ , _** kwargs_)¶
    

Returns the concrete content for a file by path.

Parameters:
    

  * **path** – file path as string

  * **kwargs** – passed to state.solver.eval

Returns:
    

file contents as string

dumps(_fd_ , _** kwargs_)¶
    

Returns the concrete content for a file descriptor.

BACKWARD COMPATIBILITY: if you ask for file descriptors 0 1 or 2, it will return the data from stdin, stdout, or stderr as a flat string.

Parameters:
    

**fd** – A file descriptor.

Returns:
    

The concrete content.

Return type:
    

[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

_class _angr.state_plugins.SimUCManager(_man =None_)¶
    

Bases: `SimStatePlugin`

__init__(_man =None_)¶
    

assign(_dst_addr_ast_)¶
    

Assign a new region for under-constrained symbolic execution.

Parameters:
    

**dst_addr_ast** – the symbolic AST which address of the new allocated region will be assigned to.

Returns:
    

as ast of memory address that points to a new region

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

get_alloc_depth(_addr_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

set_alloc_depth(_addr_ , _depth_)¶
    

Parameters:
    

  * **addr** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

  * **depth** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

is_bounded(_ast_)¶
    

Test whether an AST is bounded by any existing constraint in the related solver.

Parameters:
    

**ast** – an claripy.AST object

Returns:
    

True if there is at least one related constraint, False otherwise

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

_class _angr.state_plugins.Stat(_st_dev_ , _st_ino_ , _st_nlink_ , _st_mode_ , _st_uid_ , _st_gid_ , _st_rdev_ , _st_size_ , _st_blksize_ , _st_blocks_ , _st_atime_ , _st_atimensec_ , _st_mtime_ , _st_mtimensec_ , _st_ctime_ , _st_ctimensec_)¶
    

Bases: [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

st_atime¶
    

Alias for field number 10

st_atimensec¶
    

Alias for field number 11

st_blksize¶
    

Alias for field number 8

st_blocks¶
    

Alias for field number 9

st_ctime¶
    

Alias for field number 14

st_ctimensec¶
    

Alias for field number 15

st_dev¶
    

Alias for field number 0

st_gid¶
    

Alias for field number 5

st_ino¶
    

Alias for field number 1

st_mode¶
    

Alias for field number 3

st_mtime¶
    

Alias for field number 12

st_mtimensec¶
    

Alias for field number 13

st_nlink¶
    

Alias for field number 2

st_rdev¶
    

Alias for field number 6

st_size¶
    

Alias for field number 7

st_uid¶
    

Alias for field number 4

_class _angr.state_plugins.StructMode(_view_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_view_)¶
    

_class _angr.state_plugins.Unicorn(_syscall_hooks =None_, _cache_key =None_, _unicount =None_, _symbolic_var_counts =None_, _symbolic_inst_counts =None_, _concretized_asts =None_, _always_concretize =None_, _never_concretize =None_, _concretize_at =None_, _concretization_threshold_memory =None_, _concretization_threshold_registers =None_, _concretization_threshold_instruction =None_, _cooldown_symbolic_stop =2_, _cooldown_unsupported_stop =2_, _cooldown_nonunicorn_blocks =100_, _cooldown_stop_point =1_, _max_steps =1000000_)¶
    

Bases: `SimStatePlugin`

setup the unicorn engine for a state

UC_CONFIG _ = {}_¶
    

__init__(_syscall_hooks =None_, _cache_key =None_, _unicount =None_, _symbolic_var_counts =None_, _symbolic_inst_counts =None_, _concretized_asts =None_, _always_concretize =None_, _never_concretize =None_, _concretize_at =None_, _concretization_threshold_memory =None_, _concretization_threshold_registers =None_, _concretization_threshold_instruction =None_, _cooldown_symbolic_stop =2_, _cooldown_unsupported_stop =2_, _cooldown_nonunicorn_blocks =100_, _cooldown_stop_point =1_, _max_steps =1000000_)¶
    

Initializes the Unicorn plugin for angr. This plugin handles communication with UnicornEngine.

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

_property _uc¶
    

_static _delete_uc()¶
    

set_last_block_details(_details_)¶
    

set_stops(_stop_points_)¶
    

set_tracking(_track_bbls_ , _track_stack_)¶
    

hook()¶
    

uncache_region(_addr_ , _length_)¶
    

clear_page_cache()¶
    

setup(_syscall_data =None_, _fd_bytes =None_)¶
    

start(_step =None_)¶
    

get_recent_bbl_addrs()¶
    

get_stop_details()¶
    

finish(_succ_state_)¶
    

destroy(_succ_state_)¶
    

set_regs()¶
    

setting unicorn registers

setup_flags()¶
    

setup_gdt(_fs_ , _gs_)¶
    

read_msr(_msr =3221225728_)¶
    

write_msr(_val_ , _msr =3221225728_)¶
    

get_regs(_succ_state_)¶
    

loading registers from unicorn. If succ_state is not None, update it instead of self.state. Needed when handling symbolic exits in native interface

angr.state_plugins.resource_event(_state_ , _exception_)¶
    

_class _angr.state_plugins.plugin.SimStatePlugin¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

This is a base class for SimState plugins. A SimState plugin will be copied along with the state when the state is branched. They are intended to be used for things such as tracking open files, tracking heap details, and providing storage and persistence for SimProcedures.

STRONGREF_STATE _ = False_¶
    

__init__()¶
    

state _: `SimState`_¶
    

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

set_strongref_state(_state_)¶
    

copy(__memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

_static _memo(_f_)¶
    

A decorator function you should apply to `copy`

Return type:
    

`_CopyFunc`[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)]

Parameters:
    

**f** ([_Callable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)") _[__[__T_ _,_[_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]__]__,__S_co_ _]_)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_classmethod _register_default(_name_ , _xtr =None_)¶
    

init_state()¶
    

Use this function to perform any initialization on the state at plugin-add time

_class _angr.state_plugins.inspect.BP(_when ='before'_, _enabled =None_, _condition =None_, _action =None_, _** kwargs_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A breakpoint.

__init__(_when ='before'_, _enabled =None_, _condition =None_, _action =None_, _** kwargs_)¶
    

check(_state_ , _when_)¶
    

Checks state state to see if the breakpoint should fire.

Parameters:
    

  * **state** – The state.

  * **when** – Whether the check is happening before or after the event.

Returns:
    

A boolean representing whether the checkpoint should fire.

fire(_state_)¶
    

Trigger the breakpoint.

Parameters:
    

**state** – The state.

_class _angr.state_plugins.inspect.SimInspector¶
    

Bases: `SimStatePlugin`

The breakpoint interface, used to instrument execution. For usage information, look here: <https://docs.angr.io/core-concepts/simulation#breakpoints>

BP_AFTER _ = 'after'_¶
    

BP_BEFORE _ = 'before'_¶
    

BP_BOTH _ = 'both'_¶
    

__init__()¶
    

action(_event_type_ , _when_ , _** kwargs_)¶
    

Called from within the engine when events happens. This function checks all breakpoints registered for that event and fires the ones whose conditions match.

make_breakpoint(_event_type_ , _* args_, _** kwargs_)¶
    

Creates and adds a breakpoint which would trigger on event_type. Additional arguments are passed to the `BP` constructor.

Returns:
    

The created breakpoint, so that it can be removed later.

b(_event_type_ , _* args_, _** kwargs_)¶
    

Creates and adds a breakpoint which would trigger on event_type. Additional arguments are passed to the `BP` constructor.

Returns:
    

The created breakpoint, so that it can be removed later.

add_breakpoint(_event_type_ , _bp_)¶
    

Adds a breakpoint which would trigger on event_type.

Parameters:
    

  * **event_type** – The event type to trigger on

  * **bp** – The breakpoint

Returns:
    

The created breakpoint.

remove_breakpoint(_event_type_ , _bp =None_, _filter_func =None_)¶
    

Removes a breakpoint.

Parameters:
    

  * **bp** – The breakpoint to remove.

  * **filter_func** – A filter function to specify whether each breakpoint should be removed or not.

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

downsize()¶
    

Remove previously stored attributes from this plugin instance to save memory. This method is supposed to be called by breakpoint implementors. A typical workflow looks like the following :
    
    
    >>> # Add `attr0` and `attr1` to `self.state.inspect`
    >>> self.state.inspect(xxxxxx, attr0=yyyy, attr1=zzzz)
    >>> # Get new attributes out of SimInspect in case they are modified by the user
    >>> new_attr0 = self.state._inspect.attr0
    >>> new_attr1 = self.state._inspect.attr1
    >>> # Remove them from SimInspect
    >>> self.state._inspect.downsize()
    

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

state _: angr.SimState_¶
    

_class _angr.state_plugins.libc.SimStateLibc¶
    

Bases: `SimStatePlugin`

This state plugin keeps track of various libc stuff:

LOCALE_ARRAY _ = [b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x03 ', b'\x02 ', b'\x02 ', b'\x02 ', b'\x02 ', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x02\x00', b'\x01`', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x08\xd8', b'\x08\xd8', b'\x08\xd8', b'\x08\xd8', b'\x08\xd8', b'\x08\xd8', b'\x08\xd8', b'\x08\xd8', b'\x08\xd8', b'\x08\xd8', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x08\xd5', b'\x08\xd5', b'\x08\xd5', b'\x08\xd5', b'\x08\xd5', b'\x08\xd5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x08\xc5', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x08\xd6', b'\x08\xd6', b'\x08\xd6', b'\x08\xd6', b'\x08\xd6', b'\x08\xd6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x08\xc6', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x04\xc0', b'\x02\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00', b'\x00\x00']_¶
    

TOLOWER_LOC_ARRAY _ = [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 4294967295, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255]_¶
    

TOUPPER_LOC_ARRAY _ = [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 4294967295, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255]_¶
    

__init__()¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_property _errno¶
    

ret_errno(_val_)¶
    

state _: angr.SimState_¶
    

_class _angr.state_plugins.posix.PosixDevFS¶
    

Bases: `SimMount`

get(_path_)¶
    

Implement this function to instrument file lookups.

Parameters:
    

**path_elements** – A list of path elements traversing from the mountpoint to the file

Returns:
    

A SimFile, or None

insert(_path_ , _simfile_)¶
    

Implement this function to instrument file creation.

Parameters:
    

  * **path_elements** – A list of path elements traversing from the mountpoint to the file

  * **simfile** – The file to insert

Returns:
    

A bool indicating whether the insert occurred

delete(_path_)¶
    

Implement this function to instrument file deletion.

Parameters:
    

**path_elements** – A list of path elements traversing from the mountpoint to the file

Returns:
    

A bool indicating whether the delete occurred

lookup(___)¶
    

Look up the path of a SimFile in the mountpoint

Parameters:
    

**sim_file** – A SimFile object needs to be looked up

Returns:
    

A string representing the path of the file in the mountpoint Or None if the SimFile does not exist in the mountpoint

merge(_others_ , _conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

copy(___)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

_class _angr.state_plugins.posix.PosixProcFS¶
    

Bases: `SimMount`

The virtual file system mounted at /proc (as of now, on Linux).

get(_path_)¶
    

Implement this function to instrument file lookups.

Parameters:
    

**path_elements** – A list of path elements traversing from the mountpoint to the file

Returns:
    

A SimFile, or None

insert(_path_ , _simfile_)¶
    

Implement this function to instrument file creation.

Parameters:
    

  * **path_elements** – A list of path elements traversing from the mountpoint to the file

  * **simfile** – The file to insert

Returns:
    

A bool indicating whether the insert occurred

delete(_path_)¶
    

Implement this function to instrument file deletion.

Parameters:
    

**path_elements** – A list of path elements traversing from the mountpoint to the file

Returns:
    

A bool indicating whether the delete occurred

lookup(___)¶
    

Look up the path of a SimFile in the mountpoint

Parameters:
    

**sim_file** – A SimFile object needs to be looked up

Returns:
    

A string representing the path of the file in the mountpoint Or None if the SimFile does not exist in the mountpoint

merge(_others_ , _conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

copy(___)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

_class _angr.state_plugins.posix.SimSystemPosix(_stdin =None_, _stdout =None_, _stderr =None_, _fd =None_, _sockets =None_, _socket_queue =None_, _argv =None_, _argc =None_, _environ =None_, _auxv =None_, _tls_modules =None_, _sigmask =None_, _pid =None_, _ppid =None_, _uid =None_, _gid =None_, _brk =None_)¶
    

Bases: `SimStatePlugin`

Data storage and interaction mechanisms for states with an environment conforming to posix. Available as `state.posix`.

SIG_BLOCK _ = 0_¶
    

SIG_UNBLOCK _ = 1_¶
    

SIG_SETMASK _ = 2_¶
    

EPERM _ = 1_¶
    

ENOENT _ = 2_¶
    

ESRCH _ = 3_¶
    

EINTR _ = 4_¶
    

EIO _ = 5_¶
    

ENXIO _ = 6_¶
    

E2BIG _ = 7_¶
    

ENOEXEC _ = 8_¶
    

EBADF _ = 9_¶
    

ECHILD _ = 10_¶
    

EAGAIN _ = 11_¶
    

ENOMEM _ = 12_¶
    

EACCES _ = 13_¶
    

EFAULT _ = 14_¶
    

ENOTBLK _ = 15_¶
    

EBUSY _ = 16_¶
    

EEXIST _ = 17_¶
    

EXDEV _ = 18_¶
    

ENODEV _ = 19_¶
    

ENOTDIR _ = 20_¶
    

EISDIR _ = 21_¶
    

EINVAL _ = 22_¶
    

ENFILE _ = 23_¶
    

EMFILE _ = 24_¶
    

ENOTTY _ = 25_¶
    

ETXTBSY _ = 26_¶
    

EFBIG _ = 27_¶
    

ENOSPC _ = 28_¶
    

ESPIPE _ = 29_¶
    

EROFS _ = 30_¶
    

EMLINK _ = 31_¶
    

EPIPE _ = 32_¶
    

EDOM _ = 33_¶
    

ERANGE _ = 34_¶
    

__init__(_stdin =None_, _stdout =None_, _stderr =None_, _fd =None_, _sockets =None_, _socket_queue =None_, _argv =None_, _argc =None_, _environ =None_, _auxv =None_, _tls_modules =None_, _sigmask =None_, _pid =None_, _ppid =None_, _uid =None_, _gid =None_, _brk =None_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

_property _closed_fds¶
    

init_state()¶
    

Use this function to perform any initialization on the state at plugin-add time

set_brk(_new_brk_)¶
    

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

open(_name_ , _flags_ , _preferred_fd =None_)¶
    

Open a symbolic file. Basically open(2).

Parameters:
    

  * **name** (_string_ _or_[ _bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)")) – Path of the symbolic file, as a string or bytes.

  * **flags** – File operation flags, a bitfield of constants from open(2), as an AST

  * **preferred_fd** – Assign this fd if it’s not already claimed.

Returns:
    

The file descriptor number allocated (maps through posix.get_fd to a SimFileDescriptor) or -1 if the open fails.

`mode` from open(2) is unsupported at present.

open_socket(_ident_)¶
    

get_fd(_fd_ , _create_file =True_)¶
    

Looks up the SimFileDescriptor associated with the given number (an AST). If the number is concrete and does not map to anything, return None. If the number is symbolic, constrain it to an open fd and create a new file for it. Set create_file to False if no write-access is planned (i.e. fd is read-only).

get_concrete_fd(_fd_ , _create_file =True_)¶
    

Same behavior as get_fd(fd), only the result is a concrete integer fd (or -1) instead of a SimFileDescriptor.

close(_fd_)¶
    

Closes the given file descriptor (an AST). Returns whether the operation succeeded (a concrete boolean)

fstat(_fd_)¶
    

fstat_with_result(_sim_fd_)¶
    

sigmask(_sigsetsize =None_)¶
    

Gets the current sigmask. If it’s blank, a new one is created (of sigsetsize).

Parameters:
    

**sigsetsize** – the size (in _bytes_ of the sigmask set)

Returns:
    

the sigmask

sigprocmask(_how_ , _new_mask_ , _sigsetsize_ , _valid_ptr =True_)¶
    

Updates the signal mask.

Parameters:
    

  * **how** – the “how” argument of sigprocmask (see manpage)

  * **new_mask** – the mask modification to apply

  * **sigsetsize** – the size (in _bytes_ of the sigmask set)

  * **valid_ptr** – is set if the new_mask was not NULL

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(___)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

dump_file_by_path(_path_ , _** kwargs_)¶
    

Returns the concrete content for a file by path.

Parameters:
    

  * **path** – file path as string

  * **kwargs** – passed to state.solver.eval

Returns:
    

file contents as string

dumps(_fd_ , _** kwargs_)¶
    

Returns the concrete content for a file descriptor.

BACKWARD COMPATIBILITY: if you ask for file descriptors 0 1 or 2, it will return the data from stdin, stdout, or stderr as a flat string.

Parameters:
    

**fd** – A file descriptor.

Returns:
    

The concrete content.

Return type:
    

[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

state _: angr.SimState_¶
    

_class _angr.state_plugins.filesystem.Stat(_st_dev_ , _st_ino_ , _st_nlink_ , _st_mode_ , _st_uid_ , _st_gid_ , _st_rdev_ , _st_size_ , _st_blksize_ , _st_blocks_ , _st_atime_ , _st_atimensec_ , _st_mtime_ , _st_mtimensec_ , _st_ctime_ , _st_ctimensec_)¶
    

Bases: [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

st_atime¶
    

Alias for field number 10

st_atimensec¶
    

Alias for field number 11

st_blksize¶
    

Alias for field number 8

st_blocks¶
    

Alias for field number 9

st_ctime¶
    

Alias for field number 14

st_ctimensec¶
    

Alias for field number 15

st_dev¶
    

Alias for field number 0

st_gid¶
    

Alias for field number 5

st_ino¶
    

Alias for field number 1

st_mode¶
    

Alias for field number 3

st_mtime¶
    

Alias for field number 12

st_mtimensec¶
    

Alias for field number 13

st_nlink¶
    

Alias for field number 2

st_rdev¶
    

Alias for field number 6

st_size¶
    

Alias for field number 7

st_uid¶
    

Alias for field number 4

_class _angr.state_plugins.filesystem.SimFilesystem(_files =None_, _pathsep =None_, _cwd =None_, _mountpoints =None_)¶
    

Bases: `SimStatePlugin`

angr’s emulated filesystem. Available as state.fs. When constructing, all parameters are optional.

Parameters:
    

  * **files** – A mapping from filepath to SimFile

  * **pathsep** – The character used to separate path elements, default forward slash.

  * **cwd** – The path of the current working directory to use

  * **mountpoints** – A mapping from filepath to SimMountpoint

Variables:
    

  * **pathsep** – The current pathsep

  * **cwd** – The current working directory

  * **unlinks** – A list of unlink operations, tuples of filename and simfile. Be careful, this list is shallow-copied from successor to successor, so don’t mutate anything in it without copying.

__init__(_files =None_, _pathsep =None_, _cwd =None_, _mountpoints =None_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

_property _unlinks¶
    

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

chdir(_path_)¶
    

Changes the current directory to the given path

get(_path_)¶
    

Get a file from the filesystem. Returns a SimFile or None.

insert(_path_ , _simfile_)¶
    

Insert a file into the filesystem. Returns whether the operation was successful.

delete(_path_)¶
    

Remove a file from the filesystem. Returns whether the operation was successful.

This will add a `fs_unlink` event with the path of the file and also the index into the unlinks list.

mount(_path_ , _mount_)¶
    

Add a mountpoint to the filesystem.

unmount(_path_)¶
    

Remove a mountpoint from the filesystem.

get_mountpoint(_path_)¶
    

Look up the mountpoint servicing the given path.

Returns:
    

A tuple of the mount and a list of path elements traversing from the mountpoint to the specified file.

_class _angr.state_plugins.filesystem.SimMount¶
    

Bases: `SimStatePlugin`

This is the base class for “mount points” in angr’s simulated filesystem. Subclass this class and give it to the filesystem to intercept all file creations and opens below the mountpoint. Since this a SimStatePlugin you may also want to implement set_state, copy, merge, etc.

get(_path_elements_)¶
    

Implement this function to instrument file lookups.

Parameters:
    

**path_elements** – A list of path elements traversing from the mountpoint to the file

Returns:
    

A SimFile, or None

insert(_path_elements_ , _simfile_)¶
    

Implement this function to instrument file creation.

Parameters:
    

  * **path_elements** – A list of path elements traversing from the mountpoint to the file

  * **simfile** – The file to insert

Returns:
    

A bool indicating whether the insert occurred

delete(_path_elements_)¶
    

Implement this function to instrument file deletion.

Parameters:
    

**path_elements** – A list of path elements traversing from the mountpoint to the file

Returns:
    

A bool indicating whether the delete occurred

lookup(_sim_file_)¶
    

Look up the path of a SimFile in the mountpoint

Parameters:
    

**sim_file** – A SimFile object needs to be looked up

Returns:
    

A string representing the path of the file in the mountpoint Or None if the SimFile does not exist in the mountpoint

_class _angr.state_plugins.filesystem.SimConcreteFilesystem(_pathsep ='/'_)¶
    

Bases: `SimMount`

Abstract SimMount allowing the user to import files from some external source into the guest

Parameters:
    

**pathsep** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The host path separator character, default os.path.sep

__init__(_pathsep ='/'_)¶
    

get(_path_elements_)¶
    

Implement this function to instrument file lookups.

Parameters:
    

**path_elements** – A list of path elements traversing from the mountpoint to the file

Returns:
    

A SimFile, or None

insert(_path_elements_ , _simfile_)¶
    

Implement this function to instrument file creation.

Parameters:
    

  * **path_elements** – A list of path elements traversing from the mountpoint to the file

  * **simfile** – The file to insert

Returns:
    

A bool indicating whether the insert occurred

delete(_path_elements_)¶
    

Implement this function to instrument file deletion.

Parameters:
    

**path_elements** – A list of path elements traversing from the mountpoint to the file

Returns:
    

A bool indicating whether the delete occurred

lookup(_sim_file_)¶
    

Look up the path of a SimFile in the mountpoint

Parameters:
    

**sim_file** – A SimFile object needs to be looked up

Returns:
    

A string representing the path of the file in the mountpoint Or None if the SimFile does not exist in the mountpoint

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.state_plugins.filesystem.SimHostFilesystem(_host_path =None_, _** kwargs_)¶
    

Bases: `SimConcreteFilesystem`

Simulated mount that makes some piece from the host filesystem available to the guest.

Parameters:
    

  * **host_path** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The path on the host to mount

  * **pathsep** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The host path separator character, default os.path.sep

__init__(_host_path =None_, _** kwargs_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

angr.state_plugins.solver.timed_function(_f_)¶
    

angr.state_plugins.solver.enable_timing()¶
    

angr.state_plugins.solver.disable_timing()¶
    

angr.state_plugins.solver.error_converter(_f_)¶
    

angr.state_plugins.solver.concrete_path_bool(_f_)¶
    

angr.state_plugins.solver.concrete_path_not_bool(_f_)¶
    

angr.state_plugins.solver.concrete_path_scalar(_f_)¶
    

angr.state_plugins.solver.concrete_path_tuple(_f_)¶
    

angr.state_plugins.solver.concrete_path_list(_f_)¶
    

_class _angr.state_plugins.solver.SimSolver(_solver =None_, _all_variables =None_, _temporal_tracked_variables =None_, _eternal_tracked_variables =None_)¶
    

Bases: `SimStatePlugin`

This is the plugin you’ll use to interact with symbolic variables, creating them and evaluating them. It should be available on a state as `state.solver`.

Any top-level variable of the claripy module can be accessed as a property of this object.

__init__(_solver =None_, _all_variables =None_, _temporal_tracked_variables =None_, _eternal_tracked_variables =None_)¶
    

reload_solver(_constraints =None_)¶
    

Reloads the solver. Useful when changing solver options.

Parameters:
    

**constraints** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A new list of constraints to use in the reloaded solver instead of the current one

get_variables(_* keys_)¶
    

Iterate over all variables for which their tracking key is a prefix of the values provided.

Elements are a tuple, the first element is the full tracking key, the second is the symbol.
    
    
    >>> list(s.solver.get_variables('mem'))
    [(('mem', 0x1000), <BV64 mem_1000_4_64>), (('mem', 0x1008), <BV64 mem_1008_5_64>)]
    
    
    
    >>> list(s.solver.get_variables('file'))
    [(('file', 1, 0), <BV8 file_1_0_6_8>), (('file', 1, 1), <BV8 file_1_1_7_8>),
        (('file', 2, 0), <BV8 file_2_0_8_8>)]
    
    
    
    >>> list(s.solver.get_variables('file', 2))
    [(('file', 2, 0), <BV8 file_2_0_8_8>)]
    
    
    
    >>> list(s.solver.get_variables())
    [(('mem', 0x1000), <BV64 mem_1000_4_64>), (('mem', 0x1008), <BV64 mem_1008_5_64>),
        (('file', 1, 0), <BV8 file_1_0_6_8>), (('file', 1, 1), <BV8 file_1_1_7_8>),
        (('file', 2, 0), <BV8 file_2_0_8_8>)]
    

register_variable(_v_ , _key_ , _eternal =True_)¶
    

Register a value with the variable tracking system

Parameters:
    

  * **v** – The BVS to register

  * **key** – A tuple to register the variable under

Parma eternal:
    

Whether this is an eternal variable, default True. If False, an incrementing counter will be appended to the key.

describe_variables(_v_)¶
    

Given an AST, iterate over all the keys of all the BVS leaves in the tree which are registered.

Unconstrained(_name_ , _bits_ , _uninitialized =True_, _inspect =True_, _events =True_, _key =None_, _eternal =False_, _uc_alloc_depth =None_, _** kwargs_)¶
    

Creates an unconstrained symbol or a default concrete value (0), based on the state options.

Parameters:
    

  * **name** – The name of the symbol.

  * **bits** – The size (in bits) of the symbol.

  * **uninitialized** – Whether this value should be counted as an “uninitialized” value in the course of an analysis.

  * **inspect** – Set to False to avoid firing SimInspect breakpoints

  * **events** – Set to False to avoid generating a SimEvent for the occasion

  * **key** – Set this to a tuple of increasingly specific identifiers (for example, `('mem', 0xffbeff00)` or `('file', 4, 0x20)` to cause it to be tracked, i.e. accessible through `solver.get_variables`.

  * **eternal** – Set to True in conjunction with setting a key to cause all states with the same ancestry to retrieve the same symbol when trying to create the value. If False, a counter will be appended to the key.

Returns:
    

an unconstrained symbol (or a concrete value of 0).

BVS(_name_ , _size_ , _min =None_, _max =None_, _stride =None_, _uninitialized =False_, _explicit_name =False_, _key =None_, _eternal =False_, _inspect =True_, _events =True_, _** kwargs_)¶
    

Creates a bit-vector symbol (i.e., a variable). Other keyword parameters are passed directly on to the constructor of claripy.ast.BV.

Parameters:
    

  * **name** – The name of the symbol.

  * **size** – The size (in bits) of the bit-vector.

  * **min** – The minimum value of the symbol. Note that this **only** work when using VSA.

  * **max** – The maximum value of the symbol. Note that this **only** work when using VSA.

  * **stride** – The stride of the symbol. Note that this **only** work when using VSA.

  * **uninitialized** – Whether this value should be counted as an “uninitialized” value in the course of an analysis.

  * **explicit_name** – Set to True to prevent an identifier from appended to the name to ensure uniqueness.

  * **key** – Set this to a tuple of increasingly specific identifiers (for example, `('mem', 0xffbeff00)` or `('file', 4, 0x20)` to cause it to be tracked, i.e. accessible through `solver.get_variables`.

  * **eternal** – Set to True in conjunction with setting a key to cause all states with the same ancestry to retrieve the same symbol when trying to create the value. If False, a counter will be appended to the key.

  * **inspect** – Set to False to avoid firing SimInspect breakpoints

  * **events** – Set to False to avoid generating a SimEvent for the occasion

Returns:
    

A BV object representing this symbol.

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

downsize()¶
    

Frees memory associated with the constraint solver by clearing all of its internal caches.

_property _constraints¶
    

Returns the constraints of the state stored by the solver.

eval_to_ast(_e_ , _n_ , _extra_constraints =()_, _exact =None_)¶
    

Evaluate an expression, using the solver if necessary. Returns AST objects.

Parameters:
    

  * **e** – the expression

  * **n** – the number of desired solutions

  * **extra_constraints** – extra constraints to apply to the solver

  * **exact** – if False, returns approximate solutions

Returns:
    

a tuple of the solutions, in the form of claripy AST nodes

Return type:
    

[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

max(_e_ , _extra_constraints =()_, _exact =None_, _signed =False_)¶
    

Return the maximum value of expression e.

:param e : expression (an AST) to evaluate :type extra_constraints: :param extra_constraints: extra constraints (as ASTs) to add to the solver for this solve :param exact : if False, return approximate solutions. :param signed : Whether the expression should be treated as a signed value. :return: the maximum possible value of e (backend object)

min(_e_ , _extra_constraints =()_, _exact =None_, _signed =False_)¶
    

Return the minimum value of expression e.

:param e : expression (an AST) to evaluate :type extra_constraints: :param extra_constraints: extra constraints (as ASTs) to add to the solver for this solve :param exact : if False, return approximate solutions. :param signed : Whether the expression should be treated as a signed value. :return: the minimum possible value of e (backend object)

solution(_e_ , _v_ , _extra_constraints =()_, _exact =None_)¶
    

Return True if v is a solution of expr with the extra constraints, False otherwise.

Parameters:
    

  * **e** – An expression (an AST) to evaluate

  * **v** – The proposed solution (an AST)

  * **extra_constraints** – Extra constraints (as ASTs) to add to the solver for this solve.

  * **exact** – If False, return approximate solutions.

Returns:
    

True if v is a solution of expr, False otherwise

is_true(_e_ , _extra_constraints =()_, _exact =None_)¶
    

If the expression provided is absolutely, definitely a true boolean, return True. Note that returning False doesn’t necessarily mean that the expression can be false, just that we couldn’t figure that out easily.

Parameters:
    

  * **e** – An expression (an AST) to evaluate

  * **extra_constraints** – Extra constraints (as ASTs) to add to the solver for this solve.

  * **exact** – If False, return approximate solutions.

Returns:
    

True if v is definitely true, False otherwise

is_false(_e_ , _extra_constraints =()_, _exact =None_)¶
    

If the expression provided is absolutely, definitely a false boolean, return True. Note that returning False doesn’t necessarily mean that the expression can be true, just that we couldn’t figure that out easily.

Parameters:
    

  * **e** – An expression (an AST) to evaluate

  * **extra_constraints** – Extra constraints (as ASTs) to add to the solver for this solve.

  * **exact** – If False, return approximate solutions.

Returns:
    

True if v is definitely false, False otherwise

unsat_core(_extra_constraints =()_)¶
    

This function returns the unsat core from the backend solver.

Parameters:
    

**extra_constraints** – Extra constraints (as ASTs) to add to the solver for this solve.

Returns:
    

The unsat core.

satisfiable(_extra_constraints =()_, _exact =None_)¶
    

This function does a constraint check and checks if the solver is in a sat state.

Parameters:
    

  * **extra_constraints** – Extra constraints (as ASTs) to add to s for this solve

  * **exact** – If False, return approximate solutions.

Returns:
    

True if sat, otherwise false

add(_* constraints_)¶
    

Add some constraints to the solver.

Parameters:
    

**constraints** – Pass any constraints that you want to add (ASTs) as varargs.

CastType _ = ~CastType_¶
    

eval_upto(_e_ , _n_ , _cast_to =None_, _** kwargs_)¶
    

Evaluate an expression, using the solver if necessary. Returns primitives as specified by the cast_to parameter. Only certain primitives are supported, check the implementation of _cast_to to see which ones.

Parameters:
    

  * **e** – the expression

  * **n** – the number of desired solutions

  * **extra_constraints** – extra constraints to apply to the solver

  * **exact** – if False, returns approximate solutions

  * **cast_to** – desired type of resulting values

Returns:
    

a tuple of the solutions, in the form of Python primitives

Return type:
    

[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

eval(_e_ , _cast_to =None_, _** kwargs_)¶
    

Evaluate an expression to get any possible solution. The desired output types can be specified using the cast_to parameter. extra_constraints can be used to specify additional constraints the returned values must satisfy.

Parameters:
    

  * **e** – the expression to get a solution for

  * **kwargs** – Any additional kwargs will be passed down to eval_upto

  * **cast_to** – desired type of resulting values

Raises:
    

**SimUnsatError** – if no solution could be found satisfying the given constraints

Returns:
    

state _: angr.SimState_¶
    

eval_one(_e_ , _cast_to =None_, _** kwargs_)¶
    

Evaluate an expression to get the only possible solution. Errors if either no or more than one solution is returned. A kwarg parameter default can be specified to be returned instead of failure!

Parameters:
    

  * **e** – the expression to get a solution for

  * **cast_to** – desired type of resulting values

  * **default** – A value can be passed as a kwarg here. It will be returned in case of failure.

  * **kwargs** – Any additional kwargs will be passed down to eval_upto

Raises:
    

  * **SimUnsatError** – if no solution could be found satisfying the given constraints

  * **SimValueError** – if more than one solution was found to satisfy the given constraints

Returns:
    

The value for e

eval_atmost(_e_ , _n_ , _cast_to =None_, _** kwargs_)¶
    

Evaluate an expression to get at most n possible solutions. Errors if either none or more than n solutions are returned.

Parameters:
    

  * **e** – the expression to get a solution for

  * **n** – the inclusive upper limit on the number of solutions

  * **cast_to** – desired type of resulting values

  * **kwargs** – Any additional kwargs will be passed down to eval_upto

Raises:
    

  * **SimUnsatError** – if no solution could be found satisfying the given constraints

  * **SimValueError** – if more than n solutions were found to satisfy the given constraints

Returns:
    

The solutions for e

eval_atleast(_e_ , _n_ , _cast_to =None_, _** kwargs_)¶
    

Evaluate an expression to get at least n possible solutions. Errors if less than n solutions were found.

Parameters:
    

  * **e** – the expression to get a solution for

  * **n** – the inclusive lower limit on the number of solutions

  * **cast_to** – desired type of resulting values

  * **kwargs** – Any additional kwargs will be passed down to eval_upto

Raises:
    

  * **SimUnsatError** – if no solution could be found satisfying the given constraints

  * **SimValueError** – if less than n solutions were found to satisfy the given constraints

Returns:
    

The solutions for e

eval_exact(_e_ , _n_ , _cast_to =None_, _** kwargs_)¶
    

Evaluate an expression to get exactly the n possible solutions. Errors if any number of solutions other than n was found to exist.

Parameters:
    

  * **e** – the expression to get a solution for

  * **n** – the inclusive lower limit on the number of solutions

  * **cast_to** – desired type of resulting values

  * **kwargs** – Any additional kwargs will be passed down to eval_upto

Raises:
    

  * **SimUnsatError** – if no solution could be found satisfying the given constraints

  * **SimValueError** – if any number of solutions other than n were found to satisfy the given constraints

Returns:
    

The solutions for e

min_int(_e_ , _extra_constraints =()_, _exact =None_, _signed =False_)¶
    

Return the minimum value of expression e.

:param e : expression (an AST) to evaluate :type extra_constraints: :param extra_constraints: extra constraints (as ASTs) to add to the solver for this solve :param exact : if False, return approximate solutions. :param signed : Whether the expression should be treated as a signed value. :return: the minimum possible value of e (backend object)

max_int(_e_ , _extra_constraints =()_, _exact =None_, _signed =False_)¶
    

Return the maximum value of expression e.

:param e : expression (an AST) to evaluate :type extra_constraints: :param extra_constraints: extra constraints (as ASTs) to add to the solver for this solve :param exact : if False, return approximate solutions. :param signed : Whether the expression should be treated as a signed value. :return: the maximum possible value of e (backend object)

unique(_e_ , _** kwargs_)¶
    

Returns True if the expression e has only one solution by querying the constraint solver. It does also add that unique solution to the solver’s constraints.

symbolic(_e_)¶
    

Returns True if the expression e is symbolic.

single_valued(_e_)¶
    

Returns True whether e is a concrete value or is a value set with only 1 possible value. This differs from unique in that this _does_ not query the constraint solver.

simplify(_e =None_)¶
    

Simplifies e. If e is None, simplifies the constraints of this state.

variables(_e_)¶
    

Returns the symbolic variables present in the AST of e.

_class _angr.state_plugins.log.SimStateLog(_log =None_)¶
    

Bases: `SimStatePlugin`

__init__(_log =None_)¶
    

_property _actions¶
    

add_event(_event_type_ , _** kwargs_)¶
    

add_action(_action_)¶
    

extend_actions(_new_actions_)¶
    

events_of_type(_event_type_)¶
    

actions_of_type(_action_type_)¶
    

_property _fresh_constraints¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

clear()¶
    

_class _angr.state_plugins.callstack.CallStack(_call_site_addr =0_, _func_addr =0_, _stack_ptr =0_, _ret_addr =0_, _jumpkind ='Ijk_Call'_, _next_frame =None_, _invoke_return_variable =None_)¶
    

Bases: `SimStatePlugin`

Stores the address of the function you’re in and the value of SP at the VERY BOTTOM of the stack, i.e. points to the return address.

Parameters:
    

**next_frame** (_CallStack_ _|__None_)

__init__(_call_site_addr =0_, _func_addr =0_, _stack_ptr =0_, _ret_addr =0_, _jumpkind ='Ijk_Call'_, _next_frame =None_, _invoke_return_variable =None_)¶
    

Parameters:
    

**next_frame** (_CallStack_ _|__None_)

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_property _current_function_address¶
    

Address of the current function.

Returns:
    

the address of the function

Return type:
    

[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

_property _current_stack_pointer¶
    

Get the value of the stack pointer.

Returns:
    

Value of the stack pointer

Return type:
    

[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

_property _current_return_target¶
    

Get the return target.

Returns:
    

The address of return target.

Return type:
    

[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

_static _stack_suffix_to_string(_stack_suffix_)¶
    

Convert a stack suffix to a human-readable string representation. :param tuple stack_suffix: The stack suffix. :return: A string representation :rtype: str

_property _top¶
    

Returns the element at the top of the callstack without removing it.

Returns:
    

A CallStack.

push(_cf_)¶
    

Push the frame cf onto the stack. Return the new stack.

pop()¶
    

Pop the top frame from the stack. Return the new stack.

call(_callsite_addr_ , _addr_ , _retn_target =None_, _stack_pointer =None_)¶
    

Push a stack frame into the call stack. This method is called when calling a function in CFG recovery.

Parameters:
    

  * **callsite_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the call site

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the call target

  * **retn_target** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _or_ _None_) – Address of the return target

  * **stack_pointer** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Value of the stack pointer

Returns:
    

None

ret(_retn_target =None_)¶
    

Pop one or many call frames from the stack. This method is called when returning from a function in CFG recovery.

Parameters:
    

**retn_target** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The target to return to.

Returns:
    

None

dbg_repr()¶
    

Debugging representation of this CallStack object.

Returns:
    

Details of this CalLStack

Return type:
    

[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

stack_suffix(_context_sensitivity_level_)¶
    

Generate the stack suffix. A stack suffix can be used as the key to a SimRun in CFG recovery.

Parameters:
    

**context_sensitivity_level** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Level of context sensitivity.

Returns:
    

A tuple of stack suffix.

Return type:
    

[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

_class _angr.state_plugins.callstack.CallStackAction(_callstack_hash_ , _callstack_depth_ , _action_ , _callframe =None_, _ret_site_addr =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Used in callstack backtrace, which is a history of callstacks along a path, to record individual actions occurred each time the callstack is changed.

__init__(_callstack_hash_ , _callstack_depth_ , _action_ , _callframe =None_, _ret_site_addr =None_)¶
    

_class _angr.state_plugins.light_registers.SimLightRegisters(_reg_map =None_, _registers =None_)¶
    

Bases: `SimStatePlugin`

__init__(_reg_map =None_, _registers =None_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

resolve_register(_offset_ , _size_)¶
    

load(_offset_ , _size =None_, _** kwargs_)¶
    

store(_offset_ , _value_ , _size =None_, _endness =None_, _** kwargs_)¶
    

_class _angr.state_plugins.history.SimStateHistory(_parent =None_, _clone =None_)¶
    

Bases: `SimStatePlugin`

This class keeps track of historically-relevant information for paths.

STRONGREF_STATE _ = True_¶
    

__init__(_parent =None_, _clone =None_)¶
    

jump_guard _: claripy.ast.BV | None_¶
    

jumpkind _: str | None_¶
    

init_state()¶
    

Use this function to perform any initialization on the state at plugin-add time

set_strongref_state(_state_)¶
    

_property _addr¶
    

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

trim()¶
    

Discard the ancestry of this state.

filter_actions(_start_block_addr =None_, _end_block_addr =None_, _block_stmt =None_, _insn_addr =None_, _read_from =None_, _write_to =None_)¶
    

Filter self.actions based on some common parameters.

[start_block_addr, end_block_addr]

Parameters:
    

  * **start_block_addr** – Only return actions generated in blocks starting at this address.

  * **end_block_addr** – Only return actions generated in blocks ending at this address.

  * **block_stmt** – Only return actions generated in the nth statement of each block.

  * **insn_addr** – Only return actions generated in the assembly instruction at this address.

  * **read_from** – Only return actions that perform a read from the specified location.

  * **write_to** – Only return actions that perform a write to the specified location.

Notes: If IR optimization is turned on, reads and writes may not occur in the instruction they originally came from. Most commonly, If a register is read from twice in the same block, the second read will not happen, instead reusing the temp the value is already stored in.

Valid values for read_from and write_to are the string literals ‘reg’ or ‘mem’ (matching any read or write to registers or memory, respectively), any string (representing a read or write to the named register), and any integer (representing a read or write to the memory at this address).

demote()¶
    

Demotes this history node, causing it to drop the strong state reference.

reachable()¶
    

add_event(_event_type_ , _** kwargs_)¶
    

add_action(_action_)¶
    

extend_actions(_new_actions_)¶
    

subscribe_actions()¶
    

_property _recent_constraints¶
    

_property _recent_actions¶
    

_property _block_count¶
    

_property _lineage¶
    

_property _parents¶
    

_property _events _: [Reversible](https://docs.python.org/3/library/collections.abc.html#collections.abc.Reversible "\(in Python v3.13\)")[SimEvent]_¶
    

_property _actions _: [Reversible](https://docs.python.org/3/library/collections.abc.html#collections.abc.Reversible "\(in Python v3.13\)")[SimAction]_¶
    

_property _jumpkinds _: [Reversible](https://docs.python.org/3/library/collections.abc.html#collections.abc.Reversible "\(in Python v3.13\)")[[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]_¶
    

_property _jump_guards _: [Reversible](https://docs.python.org/3/library/collections.abc.html#collections.abc.Reversible "\(in Python v3.13\)")[[Bool](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bool.Bool "\(in claripy\)")]_¶
    

_property _jump_targets¶
    

_property _jump_sources¶
    

_property _descriptions _: [Reversible](https://docs.python.org/3/library/collections.abc.html#collections.abc.Reversible "\(in Python v3.13\)")[[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]_¶
    

_property _bbl_addrs _: [Reversible](https://docs.python.org/3/library/collections.abc.html#collections.abc.Reversible "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]_¶
    

_property _ins_addrs _: [Reversible](https://docs.python.org/3/library/collections.abc.html#collections.abc.Reversible "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]_¶
    

_property _stack_actions¶
    

closest_common_ancestor(_other_)¶
    

Find the common ancestor between this history node and ‘other’.

Parameters:
    

**other** – the PathHistory to find a common ancestor with.

Returns:
    

the common ancestor SimStateHistory, or None if there isn’t one

constraints_since(_other_)¶
    

Returns the constraints that have been accumulated since other.

Parameters:
    

**other** – a prior PathHistory object

Returns:
    

a list of constraints

make_child()¶
    

state _: angr.SimState_¶
    

_class _angr.state_plugins.history.TreeIter(_start_ , _end =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_start_ , _end =None_)¶
    

_property _hardcopy¶
    

count(_v_)¶
    

Count occurrences of value v in the entire history. Note that the subclass must implement the __reversed__ method, otherwise an exception will be thrown. :param object v: The value to look for :return: The number of occurrences :rtype: int

_class _angr.state_plugins.history.HistoryIter(_start_ , _end =None_)¶
    

Bases: `TreeIter`

_class _angr.state_plugins.history.LambdaAttrIter(_start_ , _f_ , _** kwargs_)¶
    

Bases: `TreeIter`

__init__(_start_ , _f_ , _** kwargs_)¶
    

_class _angr.state_plugins.history.LambdaIterIter(_start_ , _f_ , _reverse =True_, _** kwargs_)¶
    

Bases: `LambdaAttrIter`

__init__(_start_ , _f_ , _reverse =True_, _** kwargs_)¶
    

_class _angr.state_plugins.gdb.GDB(_omit_fp =False_, _adjust_stack =False_)¶
    

Bases: `SimStatePlugin`

Initialize or update a state from gdb dumps of the stack, heap, registers and data (or arbitrary) segments.

__init__(_omit_fp =False_, _adjust_stack =False_)¶
    

Parameters:
    

  * **omit_fp** – The frame pointer register is used for something else. (i.e. –omit_frame_pointer)

  * **adjust_stack** – Use different stack addresses than the gdb session (not recommended).

set_stack(_stack_dump_ , _stack_top_)¶
    

Stack dump is a dump of the stack from gdb, i.e. the result of the following gdb command :

`dump binary memory [stack_dump] [begin_addr] [end_addr]`

We set the stack to the same addresses as the gdb session to avoid pointers corruption.

Parameters:
    

  * **stack_dump** – The dump file.

  * **stack_top** – The address of the top of the stack in the gdb session.

set_heap(_heap_dump_ , _heap_base_)¶
    

Heap dump is a dump of the heap from gdb, i.e. the result of the following gdb command:

`dump binary memory [stack_dump] [begin] [end]`

Parameters:
    

  * **heap_dump** – The dump file.

  * **heap_base** – The start address of the heap in the gdb session.

set_data(_addr_ , _data_dump_)¶
    

Update any data range (most likely use is the data segments of loaded objects)

set_regs(_regs_dump_)¶
    

Initialize register values within the state

Parameters:
    

**regs_dump** – The output of `info registers` in gdb.

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

_class _angr.state_plugins.cgc.SimStateCGC¶
    

Bases: `SimStatePlugin`

This state plugin keeps track of CGC state.

EBADF _ = 1_¶
    

EFAULT _ = 2_¶
    

EINVAL _ = 3_¶
    

ENOMEM _ = 4_¶
    

ENOSYS _ = 5_¶
    

EPIPE _ = 6_¶
    

FD_SETSIZE _ = 1024_¶
    

max_allocation _ = 268435456_¶
    

__init__()¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

peek_input()¶
    

discard_input(_num_bytes_)¶
    

peek_output()¶
    

discard_output(_num_bytes_)¶
    

addr_invalid(_a_)¶
    

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

get_max_sinkhole(_length_)¶
    

Find a sinkhole which is large enough to support length bytes.

This uses first-fit. The first sinkhole (ordered in descending order by their address) which can hold length bytes is chosen. If there are more than length bytes in the sinkhole, a new sinkhole is created representing the remaining bytes while the old sinkhole is removed.

add_sinkhole(_address_ , _length_)¶
    

Add a sinkhole.

Allow the possibility for the program to reuse the memory represented by the address length pair.

state _: angr.SimState_¶
    

This file contains objects to track additional information during a trace or modify symbolic variables during a trace.

The ChallRespInfo plugin tracks variables in stdin and stdout to enable handling of challenge response It handles atoi/int2str in a special manner since path constraints will usually prevent their values from being modified

The Zen plugin simplifies expressions created from variables in the flag page (losing some accuracy) to avoid situations where they become to complex for z3, but the actual equation doesn’t matter much. This can happen in challenge response if all of the values in the flag page are multiplied together before being printed.

_class _angr.state_plugins.trace_additions.FormatInfo¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

copy()¶
    

compute(_state_)¶
    

get_type()¶
    

_class _angr.state_plugins.trace_additions.FormatInfoStrToInt(_addr_ , _func_name_ , _str_arg_num_ , _base_ , _base_arg_ , _allows_negative_)¶
    

Bases: `FormatInfo`

__init__(_addr_ , _func_name_ , _str_arg_num_ , _base_ , _base_arg_ , _allows_negative_)¶
    

copy()¶
    

compute(_state_)¶
    

get_type()¶
    

_class _angr.state_plugins.trace_additions.FormatInfoIntToStr(_addr_ , _func_name_ , _int_arg_num_ , _str_dst_num_ , _base_ , _base_arg_)¶
    

Bases: `FormatInfo`

__init__(_addr_ , _func_name_ , _int_arg_num_ , _str_dst_num_ , _base_ , _base_arg_)¶
    

copy()¶
    

compute(_state_)¶
    

get_type()¶
    

_class _angr.state_plugins.trace_additions.FormatInfoDontConstrain(_addr_ , _func_name_ , _check_symbolic_arg_)¶
    

Bases: `FormatInfo`

__init__(_addr_ , _func_name_ , _check_symbolic_arg_)¶
    

copy()¶
    

compute(_state_)¶
    

get_type()¶
    

angr.state_plugins.trace_additions.int2base(_x_ , _base_)¶
    

angr.state_plugins.trace_additions.generic_info_hook(_state_)¶
    

angr.state_plugins.trace_additions.end_info_hook(_state_)¶
    

angr.state_plugins.trace_additions.exit_hook(_state_)¶
    

angr.state_plugins.trace_additions.syscall_hook(_state_)¶
    

angr.state_plugins.trace_additions.constraint_hook(_state_)¶
    

_class _angr.state_plugins.trace_additions.ChallRespInfo¶
    

Bases: `SimStatePlugin`

This state plugin keeps track of the reads and writes to symbolic addresses

__init__()¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_static _get_byte(_var_name_)¶
    

lookup_original(_replacement_)¶
    

pop_from_backup()¶
    

get_stdin_indices(_variable_)¶
    

get_stdout_indices(_variable_)¶
    

get_real_len(_input_val_ , _base_ , _result_bv_ , _allows_negative_)¶
    

get_possible_len(_input_val_ , _base_ , _allows_negative_)¶
    

get_same_length_constraints()¶
    

_static _atoi_dumps(_state_ , _require_same_length =True_)¶
    

_static _prep_tracer(_state_ , _format_infos =None_)¶
    

angr.state_plugins.trace_additions.zen_hook(_state_ , _expr_)¶
    

angr.state_plugins.trace_additions.zen_memory_write(_state_)¶
    

angr.state_plugins.trace_additions.zen_register_write(_state_)¶
    

_class _angr.state_plugins.trace_additions.ZenPlugin(_max_depth =13_)¶
    

Bases: `SimStatePlugin`

__init__(_max_depth =13_)¶
    

_static _get_flag_rand_args(_expr_)¶
    

get_expr_depth(_expr_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

get_flag_bytes(_ast_)¶
    

filter_constraints(_constraints_)¶
    

analyze_transmit(_state_ , _buf_)¶
    

_static _prep_tracer(_state_)¶
    

_class _angr.state_plugins.globals.SimStateGlobals(_backer =None_)¶
    

Bases: `SimStatePlugin`

__init__(_backer =None_)¶
    

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

keys()¶
    

values()¶
    

items()¶
    

get(_k_ , _alt =None_)¶
    

pop(_k_ , _alt =None_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

_class _angr.state_plugins.uc_manager.SimUCManager(_man =None_)¶
    

Bases: `SimStatePlugin`

__init__(_man =None_)¶
    

assign(_dst_addr_ast_)¶
    

Assign a new region for under-constrained symbolic execution.

Parameters:
    

**dst_addr_ast** – the symbolic AST which address of the new allocated region will be assigned to.

Returns:
    

as ast of memory address that points to a new region

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

get_alloc_depth(_addr_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

set_alloc_depth(_addr_ , _depth_)¶
    

Parameters:
    

  * **addr** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

  * **depth** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

is_bounded(_ast_)¶
    

Test whether an AST is bounded by any existing constraint in the related solver.

Parameters:
    

**ast** – an claripy.AST object

Returns:
    

True if there is at least one related constraint, False otherwise

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

_class _angr.state_plugins.scratch.SimStateScratch(_scratch =None_)¶
    

Bases: `SimStatePlugin`

Implements the scratch state plugin.

__init__(_scratch =None_)¶
    

_property _priv¶
    

push_priv(_priv_)¶
    

pop_priv()¶
    

set_tyenv(_tyenv_)¶
    

tmp_expr(_tmp_)¶
    

Returns the Claripy expression of a VEX temp value.

Parameters:
    

  * **tmp** – the number of the tmp

  * **simplify** – simplify the tmp before returning it

Returns:
    

a Claripy expression of the tmp

store_tmp(_tmp_ , _content_ , _reg_deps =frozenset({})_, _tmp_deps =frozenset({})_, _deps =None_, _** kwargs_)¶
    

Stores a Claripy expression in a VEX temp value. If in symbolic mode, this involves adding a constraint for the tmp’s symbolic variable.

Parameters:
    

  * **tmp** – the number of the tmp

  * **content** – a Claripy expression of the content

  * **reg_deps** – the register dependencies of the content

  * **tmp_deps** – the temporary value dependencies of the content

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

clear()¶
    

_class _angr.state_plugins.preconstrainer.SimStatePreconstrainer(_constrained_addrs =None_)¶
    

Bases: `SimStatePlugin`

This state plugin manages the concept of preconstraining - adding constraints which you would like to remove later.

Parameters:
    

**constrained_addrs** – SimActions for memory operations whose addresses should be constrained during crash analysis

__init__(_constrained_addrs =None_)¶
    

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

preconstrain(_value_ , _variable_)¶
    

Add a preconstraint that `variable == value` to the state.

Parameters:
    

  * **value** – The concrete value. Can be a bitvector or a bytestring or an integer.

  * **variable** – The BVS to preconstrain.

preconstrain_file(_content_ , _simfile_ , _set_length =False_)¶
    

Preconstrain the contents of a file.

Parameters:
    

  * **content** – The content to preconstrain the file to. Can be a bytestring or a list thereof.

  * **simfile** – The actual simfile to preconstrain

preconstrain_flag_page(_magic_content_)¶
    

Preconstrain the data in the flag page.

Parameters:
    

**magic_content** – The content of the magic page as a bytestring.

remove_preconstraints(_to_composite_solver =True_, _simplify =True_)¶
    

Remove the preconstraints from the state.

If you are using the zen plugin, this will also use that to filter the constraints.

Parameters:
    

  * **to_composite_solver** – Whether to convert the replacement solver to a composite solver. You probably want this if you’re switching from tracing to symbolic analysis.

  * **simplify** – Whether to simplify the resulting set of constraints.

reconstrain()¶
    

Split the solver. If any of the subsolvers time out after a short timeout (10 seconds), re-add the preconstraints associated with each of its variables. Hopefully these constraints still allow us to do meaningful things to the state.

_class _angr.state_plugins.unicorn_engine.MEM_PATCH¶
    

Bases: `Structure`

struct mem_update_t

address¶
    

Structure/Union member

length¶
    

Structure/Union member

next¶
    

Structure/Union member

_class _angr.state_plugins.unicorn_engine.TRANSMIT_RECORD¶
    

Bases: `Structure`

struct transmit_record_t

count¶
    

Structure/Union member

data¶
    

Structure/Union member

fd¶
    

Structure/Union member

_class _angr.state_plugins.unicorn_engine.TaintEntityEnum¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

taint_entity_enum_t

TAINT_ENTITY_REG _ = 0_¶
    

TAINT_ENTITY_TMP _ = 1_¶
    

TAINT_ENTITY_MEM _ = 2_¶
    

TAINT_ENTITY_NONE _ = 3_¶
    

_class _angr.state_plugins.unicorn_engine.MemoryValue¶
    

Bases: `Structure`

struct memory_value_t

address¶
    

Structure/Union member

is_value_set¶
    

Structure/Union member

is_value_symbolic¶
    

Structure/Union member

value¶
    

Structure/Union member

_class _angr.state_plugins.unicorn_engine.RegisterValue¶
    

Bases: `Structure`

struct register_value_t

offset¶
    

Structure/Union member

size¶
    

Structure/Union member

value¶
    

Structure/Union member

_class _angr.state_plugins.unicorn_engine.VEXStmtDetails¶
    

Bases: `Structure`

struct sym_vex_stmt_details_t

has_memory_dep¶
    

Structure/Union member

memory_values¶
    

Structure/Union member

memory_values_count¶
    

Structure/Union member

stmt_idx¶
    

Structure/Union member

_class _angr.state_plugins.unicorn_engine.BlockDetails¶
    

Bases: `Structure`

struct sym_block_details_ret_t

block_addr¶
    

Structure/Union member

block_size¶
    

Structure/Union member

block_trace_ind¶
    

Structure/Union member

has_symbolic_exit¶
    

Structure/Union member

register_values¶
    

Structure/Union member

register_values_count¶
    

Structure/Union member

symbolic_vex_stmts¶
    

Structure/Union member

symbolic_vex_stmts_count¶
    

Structure/Union member

_class _angr.state_plugins.unicorn_engine.STOP¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

enum stop_t

STOP_NORMAL _ = 0_¶
    

STOP_STOPPOINT _ = 1_¶
    

STOP_ERROR _ = 2_¶
    

STOP_SYSCALL _ = 3_¶
    

STOP_EXECNONE _ = 4_¶
    

STOP_ZEROPAGE _ = 5_¶
    

STOP_NOSTART _ = 6_¶
    

STOP_SEGFAULT _ = 7_¶
    

STOP_ZERO_DIV _ = 8_¶
    

STOP_NODECODE _ = 9_¶
    

STOP_HLT _ = 10_¶
    

STOP_VEX_LIFT_FAILED _ = 11_¶
    

STOP_SYMBOLIC_PC _ = 12_¶
    

STOP_SYMBOLIC_READ_ADDR _ = 13_¶
    

STOP_SYMBOLIC_READ_SYMBOLIC_TRACKING_DISABLED _ = 14_¶
    

STOP_SYMBOLIC_WRITE_ADDR _ = 15_¶
    

STOP_SYMBOLIC_BLOCK_EXIT_CONDITION _ = 16_¶
    

STOP_SYMBOLIC_BLOCK_EXIT_TARGET _ = 17_¶
    

STOP_UNSUPPORTED_STMT_PUTI _ = 18_¶
    

STOP_UNSUPPORTED_STMT_STOREG _ = 19_¶
    

STOP_UNSUPPORTED_STMT_LOADG _ = 20_¶
    

STOP_UNSUPPORTED_STMT_CAS _ = 21_¶
    

STOP_UNSUPPORTED_STMT_LLSC _ = 22_¶
    

STOP_UNSUPPORTED_STMT_DIRTY _ = 23_¶
    

STOP_UNSUPPORTED_EXPR_GETI _ = 24_¶
    

STOP_UNSUPPORTED_STMT_UNKNOWN _ = 25_¶
    

STOP_UNSUPPORTED_EXPR_UNKNOWN _ = 26_¶
    

STOP_UNKNOWN_MEMORY_WRITE_SIZE _ = 27_¶
    

STOP_SYSCALL_ARM _ = 28_¶
    

STOP_X86_CPUID _ = 29_¶
    

stop_message _ = {0: 'Reached maximum steps', 1: 'Hit a stop point', 2: 'Something wrong', 3: 'Unable to handle syscall', 4: 'Fetching empty page', 5: 'Accessing zero page', 6: 'Failed to start', 7: 'Permissions or mapping error', 8: 'Divide by zero', 9: 'Instruction decoding error', 10: 'hlt instruction encountered', 11: 'Failed to lift block to VEX', 12: 'Instruction pointer became symbolic', 13: 'Attempted to read from symbolic address', 14: 'Attempted to read symbolic data from memory but symbolic tracking is disabled', 15: 'Attempted to write to symbolic address', 16: "Guard condition of block's exit statement is symbolic", 17: 'Target of default exit of block is symbolic', 18: 'Symbolic taint propagation for PutI statement not yet supported', 19: 'Symbolic taint propagation for StoreG statement not yet supported', 20: 'Symbolic taint propagation for LoadG statement not yet supported', 21: 'Symbolic taint propagation for CAS statement not yet supported', 22: 'Symbolic taint propagation for LLSC statement not yet supported', 23: 'Symbolic taint propagation for Dirty statement not yet supported', 24: 'Symbolic taint propagation for GetI expression not yet supported', 25: 'Canoo propagate symbolic taint for unsupported VEX statement type', 26: 'Cannot propagate symbolic taint for unsupported VEX expression', 27: 'Unicorn failed to determine size of memory write', 28: 'ARM syscalls are currently not supported by SimEngineUnicorn', 29: 'Block executes cpuid which should be handled in VEX engine'}_¶
    

symbolic_stop_reasons _ = {12, 13, 14, 15, 16, 17, 28, 29}_¶
    

unsupported_reasons _ = {11, 18, 19, 20, 21, 22, 23, 25, 26}_¶
    

_static _name_stop(_num_)¶
    

_static _get_stop_msg(_stop_reason_)¶
    

_class _angr.state_plugins.unicorn_engine.StopDetails¶
    

Bases: `Structure`

struct stop_details_t

block_addr¶
    

Structure/Union member

block_size¶
    

Structure/Union member

stop_reason¶
    

Structure/Union member

_class _angr.state_plugins.unicorn_engine.SimOSEnum¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

enum simos_t

SIMOS_CGC _ = 0_¶
    

SIMOS_LINUX _ = 1_¶
    

SIMOS_OTHER _ = 2_¶
    

_exception _angr.state_plugins.unicorn_engine.MemoryMappingError¶
    

Bases: [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception "\(in Python v3.13\)")

_exception _angr.state_plugins.unicorn_engine.AccessingZeroPageError¶
    

Bases: `MemoryMappingError`

_exception _angr.state_plugins.unicorn_engine.FetchingZeroPageError¶
    

Bases: `MemoryMappingError`

_exception _angr.state_plugins.unicorn_engine.SegfaultError¶
    

Bases: `MemoryMappingError`

_exception _angr.state_plugins.unicorn_engine.MixedPermissonsError¶
    

Bases: `MemoryMappingError`

_class _angr.state_plugins.unicorn_engine.AggressiveConcretizationAnnotation(_addr_)¶
    

Bases: [`SimplificationAvoidanceAnnotation`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.annotation.SimplificationAvoidanceAnnotation "\(in claripy\)")

__init__(_addr_)¶
    

_class _angr.state_plugins.unicorn_engine.Uniwrapper(_arch_ , _cache_key_ , _thumb =False_)¶
    

Bases: `Uc`

__init__(_arch_ , _cache_key_ , _thumb =False_)¶
    

hook_add(_htype_ , _callback_ , _user_data =None_, _begin =1_, _end =0_, _arg1 =0_)¶
    

hook_del(_h_)¶
    

mem_map(_addr_ , _size_ , _perms =7_)¶
    

mem_map_ptr(_addr_ , _size_ , _perms_ , _ptr_)¶
    

mem_unmap(_addr_ , _size_)¶
    

mem_reset()¶
    

hook_reset()¶
    

reset()¶
    

_class _angr.state_plugins.unicorn_engine.Unicorn(_syscall_hooks =None_, _cache_key =None_, _unicount =None_, _symbolic_var_counts =None_, _symbolic_inst_counts =None_, _concretized_asts =None_, _always_concretize =None_, _never_concretize =None_, _concretize_at =None_, _concretization_threshold_memory =None_, _concretization_threshold_registers =None_, _concretization_threshold_instruction =None_, _cooldown_symbolic_stop =2_, _cooldown_unsupported_stop =2_, _cooldown_nonunicorn_blocks =100_, _cooldown_stop_point =1_, _max_steps =1000000_)¶
    

Bases: `SimStatePlugin`

setup the unicorn engine for a state

UC_CONFIG _ = {}_¶
    

__init__(_syscall_hooks =None_, _cache_key =None_, _unicount =None_, _symbolic_var_counts =None_, _symbolic_inst_counts =None_, _concretized_asts =None_, _always_concretize =None_, _never_concretize =None_, _concretize_at =None_, _concretization_threshold_memory =None_, _concretization_threshold_registers =None_, _concretization_threshold_instruction =None_, _cooldown_symbolic_stop =2_, _cooldown_unsupported_stop =2_, _cooldown_nonunicorn_blocks =100_, _cooldown_stop_point =1_, _max_steps =1000000_)¶
    

Initializes the Unicorn plugin for angr. This plugin handles communication with UnicornEngine.

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

_property _uc¶
    

_static _delete_uc()¶
    

set_last_block_details(_details_)¶
    

set_stops(_stop_points_)¶
    

set_tracking(_track_bbls_ , _track_stack_)¶
    

hook()¶
    

uncache_region(_addr_ , _length_)¶
    

clear_page_cache()¶
    

setup(_syscall_data =None_, _fd_bytes =None_)¶
    

start(_step =None_)¶
    

get_recent_bbl_addrs()¶
    

get_stop_details()¶
    

finish(_succ_state_)¶
    

destroy(_succ_state_)¶
    

set_regs()¶
    

setting unicorn registers

setup_flags()¶
    

setup_gdt(_fs_ , _gs_)¶
    

read_msr(_msr =3221225728_)¶
    

write_msr(_val_ , _msr =3221225728_)¶
    

get_regs(_succ_state_)¶
    

loading registers from unicorn. If succ_state is not None, update it instead of self.state. Needed when handling symbolic exits in native interface

state _: angr.SimState_¶
    

_class _angr.state_plugins.loop_data.SimStateLoopData(_back_edge_trip_counts =None_, _header_trip_counts =None_, _current_loop =None_)¶
    

Bases: `SimStatePlugin`

This class keeps track of loop-related information for states. Note that we have 2 counters for loop iterations (trip counts): the first recording the number of times one of the back edges (or continue edges) of a loop is taken, whereas the second recording the number of times the loop header (or loop entry) is executed. These 2 counters may differ since compilers usually optimize loops hence completely change the loop structure at the binary level. This is supposed to be used with LoopSeer exploration technique, which monitors loop execution. For the moment, the only thing we want to analyze is loop trip counts, but nothing prevents us from extending this plugin for other loop analyses.

__init__(_back_edge_trip_counts =None_, _header_trip_counts =None_, _current_loop =None_)¶
    

Parameters:
    

  * **back_edge_trip_counts** – Dictionary that stores back edge based trip counts for each loop. Keys are address of loop headers.

  * **header_trip_counts** – Dictionary that stores header based trip counts for each loop. Keys are address of loop headers.

  * **current_loop** – List of currently running loops. Each element is a tuple (loop object, list of loop exits).

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

_class _angr.state_plugins.javavm_classloader.SimJavaVmClassloader(_initialized_classes =None_)¶
    

Bases: `SimStatePlugin`

JavaVM Classloader is used as an interface for resolving and initializing Java classes.

__init__(_initialized_classes =None_)¶
    

get_class(_class_name_ , _init_class =False_, _step_func =None_)¶
    

Get a class descriptor for the class.

Parameters:
    

  * **class_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of class.

  * **init_class** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether the class initializer <clinit> should be executed.

  * **step_func** (_func_) – Callback function executed at every step of the simulation manager during the execution of the main <clinit> method

get_superclass(_class__)¶
    

Get the superclass of the class.

get_class_hierarchy(_base_class_)¶
    

Walks up the class hierarchy and returns a list of all classes between base class (inclusive) and java.lang.Object (exclusive).

is_class_initialized(_class__)¶
    

Indicates whether the classes initializing method <clinit> was already executed on the state.

init_class(_class__ , _step_func =None_)¶
    

This method simulates the loading of a class by the JVM, during which parts of the class (e.g. static fields) are initialized. For this, we run the class initializer method <clinit> (if available) and update the state accordingly.

Note: Initialization is skipped, if the class has already been
    

initialized (or if it’s not loaded in CLE).

_property _initialized_classes¶
    

List of all initialized classes.

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.state_plugins.jni_references.SimStateJNIReferences(_local_refs =None_, _global_refs =None_)¶
    

Bases: `SimStatePlugin`

Management of the mapping between opaque JNI references and the corresponding Java objects.

__init__(_local_refs =None_, _global_refs =None_)¶
    

lookup(_opaque_ref_)¶
    

Lookups the object that was used for creating the reference.

create_new_reference(_obj_ , _global_ref =False_)¶
    

Create a new reference thats maps to the given object.

Parameters:
    

  * **obj** – Object which gets referenced.

  * **global_ref** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether a local or global reference is created.

clear_local_references()¶
    

Clear all local references.

delete_reference(_opaque_ref_ , _global_ref =False_)¶
    

Delete the stored mapping of a reference.

Parameters:
    

  * **opaque_ref** – Reference which should be removed.

  * **global_ref** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether opaque_ref is a local or global reference.

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.state_plugins.heap.PTChunk(_base_ , _sim_state_ , _heap =None_)¶
    

Bases: `Chunk`

A chunk, inspired by the implementation of chunks in ptmalloc. Provides a representation of a chunk via a view into the memory plugin. For the chunk definitions and docs that this was loosely based off of, see glibc malloc/malloc.c, line 1033, as of commit 5a580643111ef6081be7b4c7bd1997a5447c903f. Alternatively, take the following link. <https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=67cdfd0ad2f003964cd0f7dfe3bcd85ca98528a7;hb=5a580643111ef6081be7b4c7bd1997a5447c903f#l1033>

Variables:
    

  * **base** – the location of the base of the chunk in memory

  * **state** – the program state that the chunk is resident in

  * **heap** – the heap plugin that the chunk is managed by

__init__(_base_ , _sim_state_ , _heap =None_)¶
    

get_size()¶
    

Returns the actual size of a chunk (as opposed to the entire size field, which may include some flags).

get_data_size()¶
    

Returns the size of the data portion of a chunk.

set_size(_size_ , _is_free =None_)¶
    

Use this to set the size on a chunk. When the chunk is new (such as when a free chunk is shrunk to form an allocated chunk and a remainder free chunk) it is recommended that the is_free hint be used since setting the size depends on the chunk’s freeness, and vice versa.

Parameters:
    

  * **size** – size of the chunk

  * **is_free** – boolean indicating the chunk’s freeness

set_prev_freeness(_is_free_)¶
    

Sets (or unsets) the flag controlling whether the previous chunk is free.

Parameters:
    

**is_free** – if True, sets the previous chunk to be free; if False, sets it to be allocated

is_prev_free()¶
    

Returns a concrete state of the flag indicating whether the previous chunk is free or not. Issues a warning if that flag is symbolic and has multiple solutions, and then assumes that the previous chunk is free.

Returns:
    

True if the previous chunk is free; False otherwise

prev_size()¶
    

Returns the size of the previous chunk, masking off what would be the flag bits if it were in the actual size field. Performs NO CHECKING to determine whether the previous chunk size is valid (for example, when the previous chunk is not free, its size cannot be determined).

is_free()¶
    

Returns a concrete determination as to whether the chunk is free.

data_ptr()¶
    

Returns the address of the payload of the chunk.

next_chunk()¶
    

Returns the chunk immediately following (and adjacent to) this one, if it exists.

Returns:
    

The following chunk, or None if applicable

prev_chunk()¶
    

Returns the chunk immediately prior (and adjacent) to this one, if that chunk is free. If the prior chunk is not free, then its base cannot be located and this method raises an error.

Returns:
    

If possible, the previous chunk; otherwise, raises an error

fwd_chunk()¶
    

Returns the chunk following this chunk in the list of free chunks. If this chunk is not free, then it resides in no such list and this method raises an error.

Returns:
    

If possible, the forward chunk; otherwise, raises an error

set_fwd_chunk(_fwd_)¶
    

Sets the chunk following this chunk in the list of free chunks.

Parameters:
    

**fwd** – the chunk to follow this chunk in the list of free chunks

bck_chunk()¶
    

Returns the chunk backward from this chunk in the list of free chunks. If this chunk is not free, then it resides in no such list and this method raises an error.

Returns:
    

If possible, the backward chunk; otherwise, raises an error

set_bck_chunk(_bck_)¶
    

Sets the chunk backward from this chunk in the list of free chunks.

Parameters:
    

**bck** – the chunk to precede this chunk in the list of free chunks

_class _angr.state_plugins.heap.PTChunkIterator(_chunk_ , _cond= <function PTChunkIterator.<lambda>>_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_chunk_ , _cond= <function PTChunkIterator.<lambda>>_)¶
    

_class _angr.state_plugins.heap.SimHeapBase(_heap_base =None_, _heap_size =None_)¶
    

Bases: `SimStatePlugin`

This is the base heap class that all heap implementations should subclass. It defines a few handlers for common heap functions (the libc memory management functions). Heap implementations are expected to override these functions regardless of whether they implement the SimHeapLibc interface. For an example, see the SimHeapBrk implementation, which is based on the original libc SimProcedure implementations.

Variables:
    

  * **heap_base** – the address of the base of the heap in memory

  * **heap_size** – the total size of the main memory region managed by the heap in memory

  * **mmap_base** – the address of the region from which large mmap allocations will be made

__init__(_heap_base =None_, _heap_size =None_)¶
    

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

init_state()¶
    

Use this function to perform any initialization on the state at plugin-add time

_class _angr.state_plugins.heap.SimHeapBrk(_heap_base =None_, _heap_size =None_)¶
    

Bases: `SimHeapBase`

SimHeapBrk represents a trivial heap implementation based on the Unix brk system call. This type of heap stores virtually no metadata, so it is up to the user to determine when it is safe to release memory. This also means that it does not properly support standard heap operations like realloc.

This heap implementation is a holdover from before any more proper implementations were modelled. At the time, various libc (or win32) SimProcedures handled the heap in the same way that this plugin does now. To make future heap implementations plug-and-playable, they should implement the necessary logic themselves, and dependent SimProcedures should invoke a method by the same name as theirs (prepended with an underscore) upon the heap plugin. Depending on the heap implementation, if the method is not supported, an error should be raised.

Out of consideration for the original way the heap was handled, this plugin implements functionality for all relevant SimProcedures (even those that would not normally be supported together in a single heap implementation).

Variables:
    

**heap_location** – the address of the top of the heap, bounding the allocations made starting from heap_base

__init__(_heap_base =None_, _heap_size =None_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

allocate(_sim_size_)¶
    

The actual allocation primitive for this heap implementation. Increases the position of the break to allocate space. Has no guards against the heap growing too large.

Parameters:
    

**sim_size** – a size specifying how much to increase the break pointer by

Returns:
    

a pointer to the previous break position, above which there is now allocated space

release(_sim_size_)¶
    

The memory release primitive for this heap implementation. Decreases the position of the break to deallocate space. Guards against releasing beyond the initial heap base.

Parameters:
    

**sim_size** – a size specifying how much to decrease the break pointer by (may be symbolic or not)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.state_plugins.heap.SimHeapLibc(_heap_base =None_, _heap_size =None_)¶
    

Bases: `SimHeapBase`

A class of heap that implements the major libc heap management functions.

malloc(_sim_size_)¶
    

A somewhat faithful implementation of libc malloc.

Parameters:
    

**sim_size** – the amount of memory (in bytes) to be allocated

Returns:
    

the address of the allocation, or a NULL pointer if the allocation failed

free(_ptr_)¶
    

A somewhat faithful implementation of libc free.

Parameters:
    

**ptr** – the location in memory to be freed

calloc(_sim_nmemb_ , _sim_size_)¶
    

A somewhat faithful implementation of libc calloc.

Parameters:
    

  * **sim_nmemb** – the number of elements to allocated

  * **sim_size** – the size of each element (in bytes)

Returns:
    

the address of the allocation, or a NULL pointer if the allocation failed

realloc(_ptr_ , _size_)¶
    

A somewhat faithful implementation of libc realloc.

Parameters:
    

  * **ptr** – the location in memory to be reallocated

  * **size** – the new size desired for the allocation

Returns:
    

the address of the allocation, or a NULL pointer if the allocation was freed or if no new allocation was made

_class _angr.state_plugins.heap.SimHeapPTMalloc(_heap_base =None_, _heap_size =None_)¶
    

Bases: `SimHeapFreelist`

A freelist-style heap implementation inspired by ptmalloc. The chunks used by this heap contain heap metadata in addition to user data. While the real-world ptmalloc is implemented using multiple lists of free chunks (corresponding to their different sizes), this more basic model uses a single list of chunks and searches for free chunks using a first-fit algorithm.

**NOTE:** The plugin must be registered using `register_plugin` with name `heap` in order to function properly.

Variables:
    

  * **heap_base** – the address of the base of the heap in memory

  * **heap_size** – the total size of the main memory region managed by the heap in memory

  * **mmap_base** – the address of the region from which large mmap allocations will be made

  * **free_head_chunk** – the head of the linked list of free chunks in the heap

__init__(_heap_base =None_, _heap_size =None_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

chunks()¶
    

Returns an iterator over all the chunks in the heap.

allocated_chunks()¶
    

Returns an iterator over all the allocated chunks in the heap.

free_chunks()¶
    

Returns an iterator over all the free chunks in the heap.

chunk_from_mem(_ptr_)¶
    

Given a pointer to a user payload, return the base of the chunk associated with that payload (i.e. the chunk pointer). Returns None if ptr is null.

Parameters:
    

**ptr** – a pointer to the base of a user payload in the heap

Returns:
    

a pointer to the base of the associated heap chunk, or None if ptr is null

malloc(_sim_size_)¶
    

A somewhat faithful implementation of libc malloc.

Parameters:
    

**sim_size** – the amount of memory (in bytes) to be allocated

Returns:
    

the address of the allocation, or a NULL pointer if the allocation failed

free(_ptr_)¶
    

A somewhat faithful implementation of libc free.

Parameters:
    

**ptr** – the location in memory to be freed

calloc(_sim_nmemb_ , _sim_size_)¶
    

A somewhat faithful implementation of libc calloc.

Parameters:
    

  * **sim_nmemb** – the number of elements to allocated

  * **sim_size** – the size of each element (in bytes)

Returns:
    

the address of the allocation, or a NULL pointer if the allocation failed

realloc(_ptr_ , _size_)¶
    

A somewhat faithful implementation of libc realloc.

Parameters:
    

  * **ptr** – the location in memory to be reallocated

  * **size** – the new size desired for the allocation

Returns:
    

the address of the allocation, or a NULL pointer if the allocation was freed or if no new allocation was made

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

init_state()¶
    

Use this function to perform any initialization on the state at plugin-add time

_class _angr.state_plugins.heap.heap_base.SimHeapBase(_heap_base =None_, _heap_size =None_)¶
    

Bases: `SimStatePlugin`

This is the base heap class that all heap implementations should subclass. It defines a few handlers for common heap functions (the libc memory management functions). Heap implementations are expected to override these functions regardless of whether they implement the SimHeapLibc interface. For an example, see the SimHeapBrk implementation, which is based on the original libc SimProcedure implementations.

Variables:
    

  * **heap_base** – the address of the base of the heap in memory

  * **heap_size** – the total size of the main memory region managed by the heap in memory

  * **mmap_base** – the address of the region from which large mmap allocations will be made

__init__(_heap_base =None_, _heap_size =None_)¶
    

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

init_state()¶
    

Use this function to perform any initialization on the state at plugin-add time

_class _angr.state_plugins.heap.heap_brk.SimHeapBrk(_heap_base =None_, _heap_size =None_)¶
    

Bases: `SimHeapBase`

SimHeapBrk represents a trivial heap implementation based on the Unix brk system call. This type of heap stores virtually no metadata, so it is up to the user to determine when it is safe to release memory. This also means that it does not properly support standard heap operations like realloc.

This heap implementation is a holdover from before any more proper implementations were modelled. At the time, various libc (or win32) SimProcedures handled the heap in the same way that this plugin does now. To make future heap implementations plug-and-playable, they should implement the necessary logic themselves, and dependent SimProcedures should invoke a method by the same name as theirs (prepended with an underscore) upon the heap plugin. Depending on the heap implementation, if the method is not supported, an error should be raised.

Out of consideration for the original way the heap was handled, this plugin implements functionality for all relevant SimProcedures (even those that would not normally be supported together in a single heap implementation).

Variables:
    

**heap_location** – the address of the top of the heap, bounding the allocations made starting from heap_base

__init__(_heap_base =None_, _heap_size =None_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

allocate(_sim_size_)¶
    

The actual allocation primitive for this heap implementation. Increases the position of the break to allocate space. Has no guards against the heap growing too large.

Parameters:
    

**sim_size** – a size specifying how much to increase the break pointer by

Returns:
    

a pointer to the previous break position, above which there is now allocated space

release(_sim_size_)¶
    

The memory release primitive for this heap implementation. Decreases the position of the break to deallocate space. Guards against releasing beyond the initial heap base.

Parameters:
    

**sim_size** – a size specifying how much to decrease the break pointer by (may be symbolic or not)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.state_plugins.heap.heap_freelist.Chunk(_base_ , _sim_state_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

The sort of chunk as would typically be found in a freelist-style heap implementation. Provides a representation of a chunk via a view into the memory plugin. Chunks may be adjacent, in different senses, to as many as four other chunks. For any given chunk, two of these chunks are adjacent to it in memory, and are referred to as the “previous” and “next” chunks throughout this implementation. For any given free chunk, there may also be two significant chunks that are adjacent to it in some linked list of free chunks. These chunks are referred to the “backward” and “forward” chunks relative to the chunk in question.

Variables:
    

  * **base** – the location of the base of the chunk in memory

  * **state** – the program state that the chunk is resident in

__init__(_base_ , _sim_state_)¶
    

get_size()¶
    

Returns the actual size of a chunk (as opposed to the entire size field, which may include some flags).

get_data_size()¶
    

Returns the size of the data portion of a chunk.

set_size(_size_)¶
    

Sets the size of the chunk, preserving any flags.

data_ptr()¶
    

Returns the address of the payload of the chunk.

is_free()¶
    

Returns a concrete determination as to whether the chunk is free.

next_chunk()¶
    

Returns the chunk immediately following (and adjacent to) this one.

prev_chunk()¶
    

Returns the chunk immediately prior (and adjacent) to this one.

fwd_chunk()¶
    

Returns the chunk following this chunk in the list of free chunks.

set_fwd_chunk(_fwd_)¶
    

Sets the chunk following this chunk in the list of free chunks.

Parameters:
    

**fwd** – the chunk to follow this chunk in the list of free chunks

bck_chunk()¶
    

Returns the chunk backward from this chunk in the list of free chunks.

set_bck_chunk(_bck_)¶
    

Sets the chunk backward from this chunk in the list of free chunks.

Parameters:
    

**bck** – the chunk to precede this chunk in the list of free chunks

_class _angr.state_plugins.heap.heap_freelist.SimHeapFreelist(_heap_base =None_, _heap_size =None_)¶
    

Bases: `SimHeapLibc`

A freelist-style heap implementation. Distinguishing features of such heaps include chunks containing heap metadata in addition to user data and at least (but often more than) one linked list of free chunks.

chunks()¶
    

Returns an iterator over all the chunks in the heap.

allocated_chunks()¶
    

Returns an iterator over all the allocated chunks in the heap.

free_chunks()¶
    

Returns an iterator over all the free chunks in the heap.

chunk_from_mem(_ptr_)¶
    

Given a pointer to a user payload, return the chunk associated with that payload.

Parameters:
    

**ptr** – a pointer to the base of a user payload in the heap

Returns:
    

the associated heap chunk

print_heap_state()¶
    

print_all_chunks()¶
    

_class _angr.state_plugins.heap.heap_libc.SimHeapLibc(_heap_base =None_, _heap_size =None_)¶
    

Bases: `SimHeapBase`

A class of heap that implements the major libc heap management functions.

malloc(_sim_size_)¶
    

A somewhat faithful implementation of libc malloc.

Parameters:
    

**sim_size** – the amount of memory (in bytes) to be allocated

Returns:
    

the address of the allocation, or a NULL pointer if the allocation failed

free(_ptr_)¶
    

A somewhat faithful implementation of libc free.

Parameters:
    

**ptr** – the location in memory to be freed

calloc(_sim_nmemb_ , _sim_size_)¶
    

A somewhat faithful implementation of libc calloc.

Parameters:
    

  * **sim_nmemb** – the number of elements to allocated

  * **sim_size** – the size of each element (in bytes)

Returns:
    

the address of the allocation, or a NULL pointer if the allocation failed

realloc(_ptr_ , _size_)¶
    

A somewhat faithful implementation of libc realloc.

Parameters:
    

  * **ptr** – the location in memory to be reallocated

  * **size** – the new size desired for the allocation

Returns:
    

the address of the allocation, or a NULL pointer if the allocation was freed or if no new allocation was made

_class _angr.state_plugins.heap.heap_ptmalloc.PTChunk(_base_ , _sim_state_ , _heap =None_)¶
    

Bases: `Chunk`

A chunk, inspired by the implementation of chunks in ptmalloc. Provides a representation of a chunk via a view into the memory plugin. For the chunk definitions and docs that this was loosely based off of, see glibc malloc/malloc.c, line 1033, as of commit 5a580643111ef6081be7b4c7bd1997a5447c903f. Alternatively, take the following link. <https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=67cdfd0ad2f003964cd0f7dfe3bcd85ca98528a7;hb=5a580643111ef6081be7b4c7bd1997a5447c903f#l1033>

Variables:
    

  * **base** – the location of the base of the chunk in memory

  * **state** – the program state that the chunk is resident in

  * **heap** – the heap plugin that the chunk is managed by

__init__(_base_ , _sim_state_ , _heap =None_)¶
    

get_size()¶
    

Returns the actual size of a chunk (as opposed to the entire size field, which may include some flags).

get_data_size()¶
    

Returns the size of the data portion of a chunk.

set_size(_size_ , _is_free =None_)¶
    

Use this to set the size on a chunk. When the chunk is new (such as when a free chunk is shrunk to form an allocated chunk and a remainder free chunk) it is recommended that the is_free hint be used since setting the size depends on the chunk’s freeness, and vice versa.

Parameters:
    

  * **size** – size of the chunk

  * **is_free** – boolean indicating the chunk’s freeness

set_prev_freeness(_is_free_)¶
    

Sets (or unsets) the flag controlling whether the previous chunk is free.

Parameters:
    

**is_free** – if True, sets the previous chunk to be free; if False, sets it to be allocated

is_prev_free()¶
    

Returns a concrete state of the flag indicating whether the previous chunk is free or not. Issues a warning if that flag is symbolic and has multiple solutions, and then assumes that the previous chunk is free.

Returns:
    

True if the previous chunk is free; False otherwise

prev_size()¶
    

Returns the size of the previous chunk, masking off what would be the flag bits if it were in the actual size field. Performs NO CHECKING to determine whether the previous chunk size is valid (for example, when the previous chunk is not free, its size cannot be determined).

is_free()¶
    

Returns a concrete determination as to whether the chunk is free.

data_ptr()¶
    

Returns the address of the payload of the chunk.

next_chunk()¶
    

Returns the chunk immediately following (and adjacent to) this one, if it exists.

Returns:
    

The following chunk, or None if applicable

prev_chunk()¶
    

Returns the chunk immediately prior (and adjacent) to this one, if that chunk is free. If the prior chunk is not free, then its base cannot be located and this method raises an error.

Returns:
    

If possible, the previous chunk; otherwise, raises an error

fwd_chunk()¶
    

Returns the chunk following this chunk in the list of free chunks. If this chunk is not free, then it resides in no such list and this method raises an error.

Returns:
    

If possible, the forward chunk; otherwise, raises an error

set_fwd_chunk(_fwd_)¶
    

Sets the chunk following this chunk in the list of free chunks.

Parameters:
    

**fwd** – the chunk to follow this chunk in the list of free chunks

bck_chunk()¶
    

Returns the chunk backward from this chunk in the list of free chunks. If this chunk is not free, then it resides in no such list and this method raises an error.

Returns:
    

If possible, the backward chunk; otherwise, raises an error

set_bck_chunk(_bck_)¶
    

Sets the chunk backward from this chunk in the list of free chunks.

Parameters:
    

**bck** – the chunk to precede this chunk in the list of free chunks

_class _angr.state_plugins.heap.heap_ptmalloc.PTChunkIterator(_chunk_ , _cond= <function PTChunkIterator.<lambda>>_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_chunk_ , _cond= <function PTChunkIterator.<lambda>>_)¶
    

_class _angr.state_plugins.heap.heap_ptmalloc.SimHeapPTMalloc(_heap_base =None_, _heap_size =None_)¶
    

Bases: `SimHeapFreelist`

A freelist-style heap implementation inspired by ptmalloc. The chunks used by this heap contain heap metadata in addition to user data. While the real-world ptmalloc is implemented using multiple lists of free chunks (corresponding to their different sizes), this more basic model uses a single list of chunks and searches for free chunks using a first-fit algorithm.

**NOTE:** The plugin must be registered using `register_plugin` with name `heap` in order to function properly.

Variables:
    

  * **heap_base** – the address of the base of the heap in memory

  * **heap_size** – the total size of the main memory region managed by the heap in memory

  * **mmap_base** – the address of the region from which large mmap allocations will be made

  * **free_head_chunk** – the head of the linked list of free chunks in the heap

__init__(_heap_base =None_, _heap_size =None_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

chunks()¶
    

Returns an iterator over all the chunks in the heap.

allocated_chunks()¶
    

Returns an iterator over all the allocated chunks in the heap.

free_chunks()¶
    

Returns an iterator over all the free chunks in the heap.

chunk_from_mem(_ptr_)¶
    

Given a pointer to a user payload, return the base of the chunk associated with that payload (i.e. the chunk pointer). Returns None if ptr is null.

Parameters:
    

**ptr** – a pointer to the base of a user payload in the heap

Returns:
    

a pointer to the base of the associated heap chunk, or None if ptr is null

malloc(_sim_size_)¶
    

A somewhat faithful implementation of libc malloc.

Parameters:
    

**sim_size** – the amount of memory (in bytes) to be allocated

Returns:
    

the address of the allocation, or a NULL pointer if the allocation failed

free(_ptr_)¶
    

A somewhat faithful implementation of libc free.

Parameters:
    

**ptr** – the location in memory to be freed

calloc(_sim_nmemb_ , _sim_size_)¶
    

A somewhat faithful implementation of libc calloc.

Parameters:
    

  * **sim_nmemb** – the number of elements to allocated

  * **sim_size** – the size of each element (in bytes)

Returns:
    

the address of the allocation, or a NULL pointer if the allocation failed

realloc(_ptr_ , _size_)¶
    

A somewhat faithful implementation of libc realloc.

Parameters:
    

  * **ptr** – the location in memory to be reallocated

  * **size** – the new size desired for the allocation

Returns:
    

the address of the allocation, or a NULL pointer if the allocation was freed or if no new allocation was made

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

init_state()¶
    

Use this function to perform any initialization on the state at plugin-add time

angr.state_plugins.heap.utils.concretize(_x_ , _solver_ , _sym_handler_)¶
    

For now a lot of naive concretization is done when handling heap metadata to keep things manageable. This idiom showed up a lot as a result, so to reduce code repetition this function uses a callback to handle the one or two operations that varied across invocations.

Parameters:
    

  * **x** – the item to be concretized

  * **solver** – the solver to evaluate the item with

  * **sym_handler** – the handler to be used when the item may take on more than one value

Returns:
    

a concrete value for the item

_class _angr.state_plugins.symbolizer.SimSymbolizer¶
    

Bases: `SimStatePlugin`

The symbolizer state plugin ensures that pointers that are stored in memory are symbolic. This allows for the tracking of and reasoning over these pointers (for example, to reason about memory disclosure).

__init__()¶
    

init_state()¶
    

Use this function to perform any initialization on the state at plugin-add time

set_symbolization_for_all_pages()¶
    

Sets the symbolizer to symbolize pointers to all pages as they are written to memory..

set_symbolized_target_range(_base_ , _length_)¶
    

All pointers to the target range will be symbolized as they are written to memory.

Due to optimizations, the _pages_ containing this range will be set as symbolization targets, not just the range itself.

resymbolize()¶
    

Re-symbolizes all pointers in memory. This can be called to symbolize any pointers to target regions that were written (and not mangled beyond recognition) before symbolization was set.

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

_class _angr.state_plugins.debug_variables.SimDebugVariable(_state_ , _addr_ , _var_type_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A SimDebugVariable will get dynamically created when queriyng for variable in a state with the SimDebugVariablePlugin. It features a link to the state, an address and a type.

Parameters:
    

  * **state** (_SimState_)

  * **var_type** (_VariableType_)

__init__(_state_ , _addr_ , _var_type_)¶
    

Parameters:
    

  * **state** (_SimState_)

  * **var_type** ([_VariableType_](https://docs.angr.io/projects/cle/en/latest/api/backends/elf.html#cle.backends.elf.variable_type.VariableType "\(in cle\)"))

_static _from_cle_variable(_state_ , _cle_variable_ , _dwarf_cfa_)¶
    

Return type:
    

`SimDebugVariable`

Parameters:
    

  * **state** (_SimState_)

  * **cle_variable** ([_Variable_](https://docs.angr.io/projects/cle/en/latest/api/backends/elf.html#cle.backends.elf.variable.Variable "\(in cle\)"))

_property _mem_untyped _: SimMemView_¶
    

_property _mem _: SimMemView_¶
    

_property _string _: SimMemView_¶
    

with_type(_sim_type_)¶
    

Return type:
    

`SimMemView`

Parameters:
    

**sim_type** (_SimType_)

_property _resolvable¶
    

_property _resolved¶
    

_property _concrete¶
    

store(_value_)¶
    

_property _deref _: SimDebugVariable_¶
    

array(_i_)¶
    

Return type:
    

`SimDebugVariable`

member(_member_name_)¶
    

Return type:
    

`SimDebugVariable`

Parameters:
    

**member_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.state_plugins.debug_variables.SimDebugVariablePlugin¶
    

Bases: `SimStatePlugin`

This is the plugin you’ll use to interact with (global/local) program variables. These variables have a name and a visibility scope which depends on the pc address of the state. With this plugin, you can access/modify the value of such variable or find its memory address. For creating program variables, or for importing them from cle, see the knowledge plugin debug_variables. Run `p.kb.dvars.load_from_dwarf()` before using this plugin.

Example
    
    
    >>> p = angr.Project("various_variables", load_debug_info=True)
    >>> p.kb.dvars.load_from_dwarf()
    >>> state =  # navigate to the state you want
    >>> state.dvars.get_variable("pointer2").deref.mem
    <int (32 bits) <BV32 0x1> at 0x404020>
    

get_variable(_var_name_)¶
    

Returns the visible variable (if any) with name `var_name` based on the current `state.ip`.

Return type:
    

`SimDebugVariable`

Parameters:
    

**var_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_property _dwarf_cfa¶
    

Returns the current cfa computation. Set this property to the correct value if needed.

_property _dwarf_cfa_approx¶
    

## Storage¶

_class _angr.storage.DefaultMemory(_* args_, _** kwargs_)¶
    

Bases: `HexDumperMixin`, `SmartFindMixin`, `UnwrapperMixin`, `NameResolutionMixin`, `DataNormalizationMixin`, `SimplificationMixin`, `InspectMixinHigh`, `ActionsMixinHigh`, `UnderconstrainedMixin`, `SizeConcretizationMixin`, `SizeNormalizationMixin`, `AddressConcretizationMixin`, `ActionsMixinLow`, `ConditionalMixin`, `ConvenientMappingsMixin`, `DirtyAddrsMixin`, `StackAllocationMixin`, `ConcreteBackerMixin`, `ClemoryBackerMixin`, `DictBackerMixin`, `PrivilegedPagingMixin`, `UltraPagesMixin`, `DefaultFillerMixin`, `SymbolicMergerMixin`, `PagedMemoryMixin`

_class _angr.storage.SimFile(_name =None_, _content =None_, _size =None_, _has_end =None_, _seekable =True_, _writable =True_, _ident =None_, _concrete =None_, _** kwargs_)¶
    

Bases: `SimFileBase`, `DefaultMemory`

The normal SimFile is meant to model files on disk. It subclasses SimSymbolicMemory so loads and stores to/from it are very simple.

Parameters:
    

  * **name** – The name of the file

  * **content** – Optional initial content for the file as a string or bitvector

  * **size** – Optional size of the file. If content is not specified, it defaults to zero

  * **has_end** – Whether the size boundary is treated as the end of the file or a frontier at which new content will be generated. If unspecified, will pick its value based on options.FILES_HAVE_EOF. Another caveat is that if the size is also unspecified this value will default to False.

  * **seekable** – Optional bool indicating whether seek operations on this file should succeed, default True.

  * **writable** – Whether writing to this file is allowed

  * **concrete** – Whether or not this file contains mostly concrete data. Will be used by some SimProcedures to choose how to handle variable-length operations like fgets.

Variables:
    

**has_end** – Whether this file has an EOF

__init__(_name =None_, _content =None_, _size =None_, _has_end =None_, _seekable =True_, _writable =True_, _ident =None_, _concrete =None_, _** kwargs_)¶
    

_property _category¶
    

reg, mem, or file.

Type:
    

Return the category of this SimMemory instance. It can be one of the three following categories

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

_property _size¶
    

The number of data bytes stored by the file at present. May be a symbolic value.

concretize(_** kwargs_)¶
    

Return a concretization of the contents of the file, as a flat bytestring.

read(_pos_ , _size_ , _** kwargs_)¶
    

Read some data from the file.

Parameters:
    

  * **pos** – The offset in the file to read from.

  * **size** – The size to read. May be symbolic.

Returns:
    

A tuple of the data read (a bitvector of the length that is the maximum length of the read), the actual size of the read, and the new file position pointer.

write(_pos_ , _data_ , _size =None_, _events =True_, _** kwargs_)¶
    

Write some data to the file.

Parameters:
    

  * **pos** – The offset in the file to write to. May be ignored if the file is a stream or device.

  * **data** – The data to write as a bitvector

  * **size** – The optional size of the data to write. If not provided will default to the length of the data. Must be constrained to less than or equal to the size of the data.

Returns:
    

The new file position pointer.

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(___)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.storage.SimMemoryObject(_obj_ , _base_ , _endness_ , _length =None_, _byte_width =8_)¶
    

Bases: `object`

A SimMemoryObject is a reference to a byte or several bytes in a specific object in memory. It should be used only by the bottom layer of memory.

__init__(_obj_ , _base_ , _endness_ , _length =None_, _byte_width =8_)¶
    

is_bytes¶
    

base¶
    

object _: [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`FP`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)")_¶
    

length¶
    

endness¶
    

size()¶
    

_property _variables¶
    

_property _symbolic¶
    

_property _last_addr¶
    

concrete_bytes(_offset_ , _size_)¶
    

Return type:
    

[`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

includes(_x_)¶
    

bytes_at(_addr_ , _length_ , _allow_concrete =False_, _endness ='Iend_BE'_)¶
    

_class _angr.state_plugins.view.SimRegNameView¶
    

Bases: `SimStatePlugin`

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

get(_reg_name_)¶
    

_class _angr.state_plugins.view.SimMemView(_ty =None_, _addr =None_, _state =None_)¶
    

Bases: `SimStatePlugin`

This is a convenient interface with which you can access a program’s memory.

The interface works like this:

>   * You first use [array index notation] to specify the address you’d like to load from
> 
>   * If at that address is a pointer, you may access the `deref` property to return a SimMemView at the address present in memory.
> 
>   * You then specify a type for the data by simply accessing a property of that name. For a list of supported types, look at `state.mem.types`.
> 
>   * You can then _refine_ the type. Any type may support any refinement it likes. Right now the only refinements supported are that you may access any member of a struct by its member name, and you may index into a string or array to access that element.
> 
>   * If the address you specified initially points to an array of that type, you can say .array(n) to view the data as an array of n elements.
> 
>   * Finally, extract the structured data with `.resolved` or `.concrete`. `.resolved` will return bitvector values, while `.concrete` will return integer, string, array, etc values, whatever best represents the data.
> 
>   * Alternately, you may store a value to memory, by assigning to the chain of properties that you’ve constructed. Note that because of the way python works, `x = s.mem[...].prop; x = val` will NOT work, you must say `s.mem[...].prop = val`.
> 
> 

For example:
    
    
    >>> s.mem[0x601048].long
    <long (64 bits) <BV64 0x4008d0> at 0x601048>
    >>> s.mem[0x601048].long.resolved
    <BV64 0x4008d0>
    >>> s.mem[0x601048].deref
    <<untyped> <unresolvable> at 0x4008d0>
    >>> s.mem[0x601048].deref.string.concrete
    'SOSNEAKY'
    

__init__(_ty =None_, _addr =None_, _state =None_)¶
    

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

types _: ClassVar[dict]__ = {'CharT': char, 'FILE_t': struct FILE_t, '_Bool': bool, '_ENTRY': struct _ENTRY, '_IO_codecvt': struct _IO_codecvt, '_IO_iconv_t': struct _IO_iconv_t, '_IO_lock_t': struct pthread_mutex_t, '_IO_marker': struct _IO_marker, '_IO_wide_data': struct _IO_wide_data, '__clock_t': uint32_t, '__dev_t': uint64_t, '__gid_t': unsigned int, '__ino64_t': unsigned long long, '__ino_t': unsigned long, '__int128': int128_t, '__int256': int256_t, '__mbstate_t': struct __mbstate_t, '__mode_t': unsigned int, '__nlink_t': unsigned int, '__off64_t': long long, '__off_t': long, '__pid_t': int, '__suseconds_t': int64_t, '__time_t': long, '__uid_t': unsigned int, '_obstack_chunk': struct _obstack_chunk, 'aiocb': struct aiocb, 'aiocb64': struct aiocb64, 'aioinit': struct aioinit, 'argp': struct argp, 'argp_child': struct argp_child, 'argp_option': struct argp_option, 'argp_parser_t': (int, char*, struct argp_state*) -> int, 'argp_state': struct argp_state, 'basic_string': string_t, 'bool': bool, 'byte': uint8_t, 'cc_t': char, 'char': char, 'clock_t': uint32_t, 'crypt_data': struct crypt_data, 'dirent': struct dirent, 'dirent64': struct dirent64, 'double': double, 'drand48_data': struct <anon>, 'dword': uint32_t, 'error_t': int, 'exit_status': struct exit_status, 'float': float, 'fstab': struct fstab, 'group': struct group, 'hostent': struct hostent, 'hsearch_data': struct hsearch_data, 'if_nameindex': struct if_nameindex, 'in_addr': struct in_addr, 'in_port_t': uint16_t, 'ino64_t': unsigned long long, 'ino_t': unsigned long, 'int': int, 'int16_t': int16_t, 'int32_t': int32_t, 'int64_t': int64_t, 'int8_t': int8_t, 'iovec': struct <anon>, 'itimerval': struct itimerval, 'lconv': struct lconv, 'long': long, 'long double': double, 'long int': long, 'long long': long long, 'long long int': long long, 'long signed': long, 'long unsigned int': unsigned long, 'mallinfo': struct mallinfo, 'mallinfo2': struct mallinfo2, 'mntent': struct mntent, 'netent': struct netent, 'ntptimeval': struct ntptimeval, 'obstack': struct obstack, 'off64_t': long long, 'off_t': long, 'option': struct option, 'passwd': struct passwd, 'pid_t': int, 'printf_info': struct printf_info, 'protoent': struct protoent, 'ptrdiff_t': long, 'qword': uint64_t, 'random_data': struct <anon>, 'rlim64_t': uint64_t, 'rlim_t': unsigned long, 'rlimit': struct rlimit, 'rlimit64': struct rlimit64, 'rusage': struct rusage, 'sa_family_t': unsigned short, 'sched_param': struct sched_param, 'sembuf': struct sembuf, 'servent': struct servent, 'sgttyb': struct sgttyb, 'short': short, 'short int': short, 'sigevent': struct sigevent, 'signed': int, 'signed char': char, 'signed int': int, 'signed long': long, 'signed long int': long, 'signed long long': long long, 'signed long long int': long long, 'signed short': short, 'signed short int': short, 'sigstack': struct sigstack, 'sigval': union sigval { sival_int int; sival_ptr void*; }, 'size_t': size_t, 'sockaddr': struct sockaddr, 'sockaddr_in': struct sockaddr_in, 'speed_t': long, 'ssize': size_t, 'ssize_t': size_t, 'stat': struct stat, 'stat64': struct stat64, 'std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>': string_t, 'string': string_t, 'struct iovec': struct iovec, 'struct timespec': struct timespec, 'struct timeval': struct timeval, 'tcflag_t': unsigned long, 'termios': struct termios, 'time_t': long, 'timespec': struct timeval, 'timeval': struct timeval, 'timex': struct timex, 'timezone': struct timezone, 'tm': struct tm, 'tms': struct tms, 'uint16_t': uint16_t, 'uint32_t': uint32_t, 'uint64_t': uint64_t, 'uint8_t': uint8_t, 'uintptr_t': unsigned long, 'unsigned': unsigned int, 'unsigned __int128': uint128_t, 'unsigned __int256': uint256_t, 'unsigned char': char, 'unsigned int': unsigned int, 'unsigned long': unsigned long, 'unsigned long int': unsigned long, 'unsigned long long': unsigned long long, 'unsigned long long int': unsigned long long, 'unsigned short': unsigned short, 'unsigned short int': unsigned short, 'utimbuf': struct utimbuf, 'utmp': struct utmp, 'utmpx': struct utmx, 'utsname': struct utsname, 'va_list': struct va_list[1], 'void': void, 'vtimes': struct vtimes, 'wchar_t': short, 'winsize': struct winsize, 'word': uint16_t, 'wstring': wstring_t}_¶
    

state _: angr.SimState_ _ = None_¶
    

struct _: StructMode_¶
    

with_type(_sim_type_)¶
    

Returns a copy of the SimMemView with a type.

Parameters:
    

**sim_type** (`SimType`) – The new type.

Return type:
    

`SimMemView`

Returns:
    

The typed SimMemView copy.

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_property _resolvable¶
    

_property _resolved¶
    

_property _concrete¶
    

_property _deref _: SimMemView_¶
    

array(_n_)¶
    

Return type:
    

`SimMemView`

member(_member_name_)¶
    

If self is a struct and member_name is a member of the struct, return that member element. Otherwise raise an exception.

Return type:
    

`SimMemView`

Parameters:
    

**member_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

store(_value_)¶
    

_class _angr.state_plugins.view.StructMode(_view_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_view_)¶
    

_class _angr.storage.file.Flags¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

O_RDONLY _ = 0_¶
    

O_WRONLY _ = 1_¶
    

O_RDWR _ = 2_¶
    

O_ACCMODE _ = 3_¶
    

O_APPEND _ = 1024_¶
    

O_ASYNC _ = 8192_¶
    

O_CLOEXEC _ = 524288_¶
    

O_CREAT _ = 64_¶
    

O_DIRECT _ = 16384_¶
    

O_DIRECTORY _ = 65536_¶
    

O_DSYNC _ = 4096_¶
    

O_EXCL _ = 128_¶
    

O_LARGEFILE _ = 32768_¶
    

O_NOATIME _ = 262144_¶
    

O_NOCTTY _ = 256_¶
    

O_NOFOLLOW _ = 131072_¶
    

O_NONBLOCK _ = 2048_¶
    

O_NDELAY _ = 2048_¶
    

O_PATH _ = 2097152_¶
    

O_SYNC _ = 1052672_¶
    

O_TMPFILE _ = 4259840_¶
    

O_TRUNC _ = 512_¶
    

_class _angr.storage.file.SimFileBase(_name =None_, _writable =True_, _ident =None_, _concrete =False_, _file_exists =True_, _** kwargs_)¶
    

Bases: `SimStatePlugin`

SimFiles are the storage mechanisms used by SimFileDescriptors.

Different types of SimFiles can have drastically different interfaces, and as a result there’s not much that can be specified on this base class. All the read and write methods take a `pos` argument, which may have different semantics per-class. `0` will always be a valid position to use, though, and the next position you should use is part of the return tuple.

Some simfiles are “streams”, meaning that the position that reads come from is determined not by the position you pass in (it will in fact be ignored), but by an internal variable. This is stored as `.pos` if you care to read it. Don’t write to it. The same lack-of-semantics applies to this field as well.

Variables:
    

  * **name** – The name of the file. Purely for cosmetic purposes

  * **ident** – The identifier of the file, typically autogenerated from the name and a nonce. Purely for cosmetic purposes, but does appear in symbolic values autogenerated in the file.

  * **seekable** – Bool indicating whether seek operations on this file should succeed. If this is True, then `pos` must be a number of bytes from the start of the file.

  * **writable** – Bool indicating whether writing to this file is allowed.

  * **pos** – If the file is a stream, this will be the current position. Otherwise, None.

  * **concrete** – Whether or not this file contains mostly concrete data. Will be used by some SimProcedures to choose how to handle variable-length operations like fgets.

  * **file_exists** – Set to False, if file does not exists, set to a claripy Bool if unknown, default True.

seekable _ = False_¶
    

pos _ = None_¶
    

__init__(_name =None_, _writable =True_, _ident =None_, _concrete =False_, _file_exists =True_, _** kwargs_)¶
    

_static _make_ident(_name_)¶
    

concretize(_** kwargs_)¶
    

Return a concretization of the contents of the file. The type of the return value of this method will vary depending on which kind of SimFile you’re using.

read(_pos_ , _size_ , _** kwargs_)¶
    

Read some data from the file.

Parameters:
    

  * **pos** – The offset in the file to read from.

  * **size** – The size to read. May be symbolic.

Returns:
    

A tuple of the data read (a bitvector of the length that is the maximum length of the read), the actual size of the read, and the new file position pointer.

write(_pos_ , _data_ , _size =None_, _** kwargs_)¶
    

Write some data to the file.

Parameters:
    

  * **pos** – The offset in the file to write to. May be ignored if the file is a stream or device.

  * **data** – The data to write as a bitvector

  * **size** – The optional size of the data to write. If not provided will default to the length of the data. Must be constrained to less than or equal to the size of the data.

Returns:
    

The new file position pointer.

_property _size¶
    

The number of data bytes stored by the file at present. May be a symbolic value.

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

state _: angr.SimState_¶
    

_class _angr.storage.file.SimFile(_name =None_, _content =None_, _size =None_, _has_end =None_, _seekable =True_, _writable =True_, _ident =None_, _concrete =None_, _** kwargs_)¶
    

Bases: `SimFileBase`, `DefaultMemory`

The normal SimFile is meant to model files on disk. It subclasses SimSymbolicMemory so loads and stores to/from it are very simple.

Parameters:
    

  * **name** – The name of the file

  * **content** – Optional initial content for the file as a string or bitvector

  * **size** – Optional size of the file. If content is not specified, it defaults to zero

  * **has_end** – Whether the size boundary is treated as the end of the file or a frontier at which new content will be generated. If unspecified, will pick its value based on options.FILES_HAVE_EOF. Another caveat is that if the size is also unspecified this value will default to False.

  * **seekable** – Optional bool indicating whether seek operations on this file should succeed, default True.

  * **writable** – Whether writing to this file is allowed

  * **concrete** – Whether or not this file contains mostly concrete data. Will be used by some SimProcedures to choose how to handle variable-length operations like fgets.

Variables:
    

**has_end** – Whether this file has an EOF

__init__(_name =None_, _content =None_, _size =None_, _has_end =None_, _seekable =True_, _writable =True_, _ident =None_, _concrete =None_, _** kwargs_)¶
    

_property _category¶
    

reg, mem, or file.

Type:
    

Return the category of this SimMemory instance. It can be one of the three following categories

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

_property _size¶
    

The number of data bytes stored by the file at present. May be a symbolic value.

concretize(_** kwargs_)¶
    

Return a concretization of the contents of the file, as a flat bytestring.

read(_pos_ , _size_ , _** kwargs_)¶
    

Read some data from the file.

Parameters:
    

  * **pos** – The offset in the file to read from.

  * **size** – The size to read. May be symbolic.

Returns:
    

A tuple of the data read (a bitvector of the length that is the maximum length of the read), the actual size of the read, and the new file position pointer.

write(_pos_ , _data_ , _size =None_, _events =True_, _** kwargs_)¶
    

Write some data to the file.

Parameters:
    

  * **pos** – The offset in the file to write to. May be ignored if the file is a stream or device.

  * **data** – The data to write as a bitvector

  * **size** – The optional size of the data to write. If not provided will default to the length of the data. Must be constrained to less than or equal to the size of the data.

Returns:
    

The new file position pointer.

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(___)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.storage.file.SimFileStream(_name =None_, _content =None_, _pos =0_, _** kwargs_)¶
    

Bases: `SimFile`

A specialized SimFile that uses a flat memory backing, but functions as a stream, tracking its position internally.

The pos argument to the read and write methods will be ignored, and will return None. Instead, there is an attribute `pos` on the file itself, which will give you what you want.

Parameters:
    

  * **name** – The name of the file, for cosmetic purposes

  * **pos** – The initial position of the file, default zero

  * **kwargs** – Any other keyword arguments will go on to the SimFile constructor.

Variables:
    

**pos** – The current position in the file.

__init__(_name =None_, _content =None_, _pos =0_, _** kwargs_)¶
    

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

read(_pos_ , _size_ , _** kwargs_)¶
    

Read some data from the file.

Parameters:
    

  * **pos** – The offset in the file to read from.

  * **size** – The size to read. May be symbolic.

Returns:
    

A tuple of the data read (a bitvector of the length that is the maximum length of the read), the actual size of the read, and the new file position pointer.

write(___ , _data_ , _size =None_, _** kwargs_)¶
    

Write some data to the file.

Parameters:
    

  * **pos** – The offset in the file to write to. May be ignored if the file is a stream or device.

  * **data** – The data to write as a bitvector

  * **size** – The optional size of the data to write. If not provided will default to the length of the data. Must be constrained to less than or equal to the size of the data.

Returns:
    

The new file position pointer.

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.storage.file.SimPackets(_name_ , _write_mode =None_, _content =None_, _writable =True_, _ident =None_, _** kwargs_)¶
    

Bases: `SimFileBase`

The SimPackets is meant to model inputs whose content is delivered a series of asynchronous chunks. The data is stored as a list of read or write results. For symbolic sizes, state.libc.max_packet_size will be respected. If the SHORT_READS option is enabled, reads will return a symbolic size constrained to be less than or equal to the requested size.

A SimPackets cannot be used for both reading and writing - for socket objects that can be both read and written to you should use a file descriptor to multiplex the read and write operations into two separate file storage mechanisms.

Parameters:
    

  * **name** – The name of the file, for cosmetic purposes

  * **write_mode** – Whether this file is opened in read or write mode. If this is unspecified it will be autodetected.

  * **content** – Some initial content to use for the file. Can be a list of bytestrings or a list of tuples of content ASTs and size ASTs.

Variables:
    

  * **write_mode** – See the eponymous parameter

  * **content** – A list of packets, as tuples of content ASTs and size ASTs.

__init__(_name_ , _write_mode =None_, _content =None_, _writable =True_, _ident =None_, _** kwargs_)¶
    

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

_property _size¶
    

The number of data bytes stored by the file at present. May be a symbolic value.

concretize(_** kwargs_)¶
    

Returns a list of the packets read or written as bytestrings.

read(_pos_ , _size_ , _** kwargs_)¶
    

Read a packet from the stream.

Parameters:
    

  * **pos** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The packet number to read from the sequence of the stream. May be None to append to the stream.

  * **size** – The size to read. May be symbolic.

  * **short_reads** – Whether to replace the size with a symbolic value constrained to less than or equal to the original size. If unspecified, will be chosen based on the state option.

Returns:
    

A tuple of the data read (a bitvector of the length that is the maximum length of the read) and the actual size of the read.

write(_pos_ , _data_ , _size =None_, _events =True_, _** kwargs_)¶
    

Write a packet to the stream.

Parameters:
    

  * **pos** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The packet number to write in the sequence of the stream. May be None to append to the stream.

  * **data** – The data to write, as a string or bitvector.

  * **size** – The optional size to write. May be symbolic; must be constrained to at most the size of data.

Returns:
    

The next packet to use after this

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(___)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.storage.file.SimPacketsStream(_name_ , _pos =0_, _** kwargs_)¶
    

Bases: `SimPackets`

A specialized SimPackets that tracks its position internally.

The pos argument to the read and write methods will be ignored, and will return None. Instead, there is an attribute `pos` on the file itself, which will give you what you want.

Parameters:
    

  * **name** – The name of the file, for cosmetic purposes

  * **pos** – The initial position of the file, default zero

  * **kwargs** – Any other keyword arguments will go on to the SimPackets constructor.

Variables:
    

**pos** – The current position in the file.

__init__(_name_ , _pos =0_, _** kwargs_)¶
    

read(_pos_ , _size_ , _** kwargs_)¶
    

Read a packet from the stream.

Parameters:
    

  * **pos** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The packet number to read from the sequence of the stream. May be None to append to the stream.

  * **size** – The size to read. May be symbolic.

  * **short_reads** – Whether to replace the size with a symbolic value constrained to less than or equal to the original size. If unspecified, will be chosen based on the state option.

Returns:
    

A tuple of the data read (a bitvector of the length that is the maximum length of the read) and the actual size of the read.

write(___ , _data_ , _size =None_, _** kwargs_)¶
    

Write a packet to the stream.

Parameters:
    

  * **pos** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The packet number to write in the sequence of the stream. May be None to append to the stream.

  * **data** – The data to write, as a string or bitvector.

  * **size** – The optional size to write. May be symbolic; must be constrained to at most the size of data.

Returns:
    

The next packet to use after this

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.storage.file.SimFileDescriptorBase¶
    

Bases: `SimStatePlugin`

The base class for implementations of POSIX file descriptors.

All file descriptors should respect the CONCRETIZE_SYMBOLIC_{READ,WRITE}_SIZES state options.

read(_pos_ , _size_ , _** kwargs_)¶
    

Reads some data from the file, storing it into memory.

Parameters:
    

  * **pos** – The address to read data from file

  * **size** – The requested length of the read

Returns:
    

The real length of the read

write(_pos_ , _size_ , _** kwargs_)¶
    

Writes some data, loaded from the state, into the file.

Parameters:
    

  * **pos** – The address to read the data to write from in memory

  * **size** – The requested size of the write

Returns:
    

The real length of the write

read_data(_size_ , _** kwargs_)¶
    

Reads some data from the file, returning the data.

Parameters:
    

**size** – The requested length of the read

Returns:
    

A tuple of the data read and the real length of the read

write_data(_data_ , _size =None_, _** kwargs_)¶
    

Write some data, provided as an argument into the file.

Parameters:
    

  * **data** – A bitvector to write into the file

  * **size** – The requested size of the write (may be symbolic)

Returns:
    

The real length of the write

seek(_offset_ , _whence ='start'_)¶
    

Seek the file descriptor to a different position in the file.

Parameters:
    

  * **offset** – The offset to seek to, interpreted according to whence

  * **whence** – What the offset is relative to; one of the strings “start”, “current”, or “end”

Returns:
    

A symbolic boolean describing whether the seek succeeded or not

tell()¶
    

Return the current position, or None if the concept doesn’t make sense for the given file.

eof()¶
    

Return the EOF status. May be a symbolic boolean.

size()¶
    

Return the size of the data stored in the file in bytes, or None if the concept doesn’t make sense for the given file.

_property _read_storage¶
    

Return the SimFile backing reads from this fd

_property _write_storage¶
    

Return the SimFile backing writes to this fd

_property _read_pos¶
    

Return the current position of the read file pointer.

If the underlying read file is a stream, this will return the position of the stream. Otherwise, will return the position of the file descriptor in the file.

_property _write_pos¶
    

Return the current position of the read file pointer.

If the underlying read file is a stream, this will return the position of the stream. Otherwise, will return the position of the file descriptor in the file.

concretize(_** kwargs_)¶
    

Return a concretizeation of the data in the underlying file. Has different return types to represent different data structures on a per-class basis.

Any arguments passed to this will be passed onto state.solver.eval.

_property _file_exists¶
    

This should be True in most cases. Only if we opened an fd of unknown existence, ALL_FILES_EXIST is False and ANY_FILE_MIGHT_EXIST is True, this is a symbolic boolean.

_class _angr.storage.file.SimFileDescriptor(_simfile_ , _flags =0_)¶
    

Bases: `SimFileDescriptorBase`

A simple file descriptor forwarding reads and writes to a SimFile. Contains information about the current opened state of the file, such as the flags or (if relevant) the current position.

Variables:
    

  * **file** – The SimFile described to by this descriptor

  * **flags** – The mode that the file descriptor was opened with, a bitfield of flags

__init__(_simfile_ , _flags =0_)¶
    

read_data(_size_ , _** kwargs_)¶
    

Reads some data from the file, returning the data.

Parameters:
    

**size** – The requested length of the read

Returns:
    

A tuple of the data read and the real length of the read

write_data(_data_ , _size =None_, _** kwargs_)¶
    

Write some data, provided as an argument into the file.

Parameters:
    

  * **data** – A bitvector to write into the file

  * **size** – The requested size of the write (may be symbolic)

Returns:
    

The real length of the write

seek(_offset_ , _whence ='start'_)¶
    

Seek the file descriptor to a different position in the file.

Parameters:
    

  * **offset** – The offset to seek to, interpreted according to whence

  * **whence** – What the offset is relative to; one of the strings “start”, “current”, or “end”

Returns:
    

A symbolic boolean describing whether the seek succeeded or not

eof()¶
    

Return the EOF status. May be a symbolic boolean.

tell()¶
    

Return the current position, or None if the concept doesn’t make sense for the given file.

size()¶
    

Return the size of the data stored in the file in bytes, or None if the concept doesn’t make sense for the given file.

concretize(_** kwargs_)¶
    

Return a concretization of the underlying file. Returns whatever format is preferred by the file.

_property _file_exists¶
    

This should be True in most cases. Only if we opened an fd of unknown existence, ALL_FILES_EXIST is False and ANY_FILE_MIGHT_EXIST is True, this is a symbolic boolean.

_property _read_storage¶
    

Return the SimFile backing reads from this fd

_property _write_storage¶
    

Return the SimFile backing writes to this fd

_property _read_pos¶
    

Return the current position of the read file pointer.

If the underlying read file is a stream, this will return the position of the stream. Otherwise, will return the position of the file descriptor in the file.

_property _write_pos¶
    

Return the current position of the read file pointer.

If the underlying read file is a stream, this will return the position of the stream. Otherwise, will return the position of the file descriptor in the file.

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(___)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.storage.file.SimFileDescriptorDuplex(_read_file_ , _write_file_)¶
    

Bases: `SimFileDescriptorBase`

A file descriptor that refers to two file storage mechanisms, one to read from and one to write to. As a result, operations like seek, eof, etc no longer make sense.

Parameters:
    

  * **read_file** – The SimFile to read from

  * **write_file** – The SimFile to write to

__init__(_read_file_ , _write_file_)¶
    

read_data(_size_ , _** kwargs_)¶
    

Reads some data from the file, returning the data.

Parameters:
    

**size** – The requested length of the read

Returns:
    

A tuple of the data read and the real length of the read

write_data(_data_ , _size =None_, _** kwargs_)¶
    

Write some data, provided as an argument into the file.

Parameters:
    

  * **data** – A bitvector to write into the file

  * **size** – The requested size of the write (may be symbolic)

Returns:
    

The real length of the write

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

eof()¶
    

Return the EOF status. May be a symbolic boolean.

tell()¶
    

Return the current position, or None if the concept doesn’t make sense for the given file.

seek(_offset_ , _whence ='start'_)¶
    

Seek the file descriptor to a different position in the file.

Parameters:
    

  * **offset** – The offset to seek to, interpreted according to whence

  * **whence** – What the offset is relative to; one of the strings “start”, “current”, or “end”

Returns:
    

A symbolic boolean describing whether the seek succeeded or not

size()¶
    

Return the size of the data stored in the file in bytes, or None if the concept doesn’t make sense for the given file.

concretize(_** kwargs_)¶
    

Return a concretization of the underlying files, as a tuple of (read file, write file).

_property _read_storage¶
    

Return the SimFile backing reads from this fd

_property _write_storage¶
    

Return the SimFile backing writes to this fd

_property _read_pos¶
    

Return the current position of the read file pointer.

If the underlying read file is a stream, this will return the position of the stream. Otherwise, will return the position of the file descriptor in the file.

_property _write_pos¶
    

Return the current position of the read file pointer.

If the underlying read file is a stream, this will return the position of the stream. Otherwise, will return the position of the file descriptor in the file.

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(___)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.storage.file.SimPacketsSlots(_name_ , _read_sizes_ , _ident =None_, _** kwargs_)¶
    

Bases: `SimFileBase`

SimPacketsSlots is the new SimDialogue, if you’ve ever seen that before.

The idea is that in some cases, the only thing you really care about is getting the lengths of reads right, and some of them should be short reads, and some of them should be truncated. You provide to this class a list of read lengths, and it figures out the length of each read, and delivers some content.

This class will NOT respect the position argument you pass it - this storage is not stateless.

seekable _ = False_¶
    

__init__(_name_ , _read_sizes_ , _ident =None_, _** kwargs_)¶
    

concretize(_** kwargs_)¶
    

Return a concretization of the contents of the file. The type of the return value of this method will vary depending on which kind of SimFile you’re using.

read(_pos_ , _size_ , _** kwargs_)¶
    

Read some data from the file.

Parameters:
    

  * **pos** – The offset in the file to read from.

  * **size** – The size to read. May be symbolic.

Returns:
    

A tuple of the data read (a bitvector of the length that is the maximum length of the read), the actual size of the read, and the new file position pointer.

write(_pos_ , _data_ , _size =None_, _** kwargs_)¶
    

Write some data to the file.

Parameters:
    

  * **pos** – The offset in the file to write to. May be ignored if the file is a stream or device.

  * **data** – The data to write as a bitvector

  * **size** – The optional size of the data to write. If not provided will default to the length of the data. Must be constrained to less than or equal to the size of the data.

Returns:
    

The new file position pointer.

_property _size¶
    

The number of data bytes stored by the file at present. May be a symbolic value.

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(___)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

angr.storage.memory_object.obj_bit_size(_o_)¶
    

_class _angr.storage.memory_object.SimMemoryObject(_obj_ , _base_ , _endness_ , _length =None_, _byte_width =8_)¶
    

Bases: `object`

A SimMemoryObject is a reference to a byte or several bytes in a specific object in memory. It should be used only by the bottom layer of memory.

__init__(_obj_ , _base_ , _endness_ , _length =None_, _byte_width =8_)¶
    

is_bytes¶
    

base¶
    

object _: [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`FP`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)")_¶
    

length¶
    

endness¶
    

size()¶
    

_property _variables¶
    

_property _symbolic¶
    

_property _last_addr¶
    

concrete_bytes(_offset_ , _size_)¶
    

Return type:
    

[`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

includes(_x_)¶
    

bytes_at(_addr_ , _length_ , _allow_concrete =False_, _endness ='Iend_BE'_)¶
    

_class _angr.storage.memory_object.SimLabeledMemoryObject(_obj_ , _base_ , _endness_ , _length =None_, _byte_width =8_, _label =None_)¶
    

Bases: `SimMemoryObject`

SimLabeledMemoryObject is a SimMemoryObject with a label

__init__(_obj_ , _base_ , _endness_ , _length =None_, _byte_width =8_, _label =None_)¶
    

label¶
    

angr.storage.memory_object.bv_slice(_value_ , _offset_ , _size_ , _rev_ , _bw_)¶
    

Extremely cute utility to pretend you’ve serialized a value to stored bytes, sliced it a la python slicing, and then deserialized those bytes to an integer again.

Parameters:
    

  * **value** ([`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")) – The bitvector to slice

  * **offset** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The byte offset from the first stored byte to slice from, or a negative offset from the end.

  * **size** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The number of bytes to return. If None, return all bytes from the offset to the end. If larger than the number of bytes from the offset to the end, return all bytes from the offset to the end.

  * **rev** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether the pretend-serialization should be little-endian

  * **bw** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The byte width

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Returns:
    

The new bitvector

_class _angr.concretization_strategies.SimConcretizationStrategy(_filter =None_, _exact =True_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Concretization strategies control the resolution of symbolic memory indices in SimuVEX. By subclassing this class and setting it as a concretization strategy (on state.memory.read_strategies and state.memory.write_strategies), SimuVEX’s memory index concretization behavior can be modified.

__init__(_filter =None_, _exact =True_)¶
    

Initializes the base SimConcretizationStrategy.

Parameters:
    

  * **filter** – A function, taking arguments of (SimMemory, claripy.AST) that determines if this strategy can handle resolving the provided AST.

  * **exact** – A flag (default: True) that determines if the convenience resolution functions provided by this class use exact or approximate resolution.

concretize(_memory_ , _addr_ , _** kwargs_)¶
    

Concretizes the address into a list of values. If this strategy cannot handle this address, returns None.

copy()¶
    

Returns a copy of the strategy, if there is data that should be kept separate between states. If not, returns self.

merge(_others_)¶
    

Merges this strategy with others (if there is data that should be kept separate between states. If not, is a no-op.

_class _angr.concretization_strategies.SimConcretizationStrategyAny(_filter =None_, _exact =True_)¶
    

Bases: `SimConcretizationStrategy`

Concretization strategy that returns any single solution.

_class _angr.concretization_strategies.SimConcretizationStrategyControlledData(_limit_ , _fixed_addrs_ , _** kwargs_)¶
    

Bases: `SimConcretizationStrategy`

Concretization strategy that constraints the address to controlled data. Controlled data consists of symbolic data and the addresses given as arguments. memory.

__init__(_limit_ , _fixed_addrs_ , _** kwargs_)¶
    

Initializes the base SimConcretizationStrategy.

Parameters:
    

  * **filter** – A function, taking arguments of (SimMemory, claripy.AST) that determines if this strategy can handle resolving the provided AST.

  * **exact** – A flag (default: True) that determines if the convenience resolution functions provided by this class use exact or approximate resolution.

_class _angr.concretization_strategies.SimConcretizationStrategyEval(_limit_ , _** kwargs_)¶
    

Bases: `SimConcretizationStrategy`

Concretization strategy that resolves an address into some limited number of solutions. Always handles the concretization, but only returns a maximum of limit number of solutions. Therefore, should only be used as the fallback strategy.

__init__(_limit_ , _** kwargs_)¶
    

Initializes the base SimConcretizationStrategy.

Parameters:
    

  * **filter** – A function, taking arguments of (SimMemory, claripy.AST) that determines if this strategy can handle resolving the provided AST.

  * **exact** – A flag (default: True) that determines if the convenience resolution functions provided by this class use exact or approximate resolution.

_class _angr.concretization_strategies.SimConcretizationStrategyMax(_max_addr =None_)¶
    

Bases: `SimConcretizationStrategy`

Concretization strategy that returns the maximum address.

Parameters:
    

**max_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_max_addr =None_)¶
    

Initializes the base SimConcretizationStrategy.

Parameters:
    

  * **filter** – A function, taking arguments of (SimMemory, claripy.AST) that determines if this strategy can handle resolving the provided AST.

  * **exact** – A flag (default: True) that determines if the convenience resolution functions provided by this class use exact or approximate resolution.

  * **max_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

_class _angr.concretization_strategies.SimConcretizationStrategyNonzero(_filter =None_, _exact =True_)¶
    

Bases: `SimConcretizationStrategy`

Concretization strategy that returns any non-zero solution.

_class _angr.concretization_strategies.SimConcretizationStrategyNonzeroRange(_limit_ , _** kwargs_)¶
    

Bases: `SimConcretizationStrategy`

Concretization strategy that resolves a range in a non-zero location.

__init__(_limit_ , _** kwargs_)¶
    

Initializes the base SimConcretizationStrategy.

Parameters:
    

  * **filter** – A function, taking arguments of (SimMemory, claripy.AST) that determines if this strategy can handle resolving the provided AST.

  * **exact** – A flag (default: True) that determines if the convenience resolution functions provided by this class use exact or approximate resolution.

_class _angr.concretization_strategies.SimConcretizationStrategyNorepeats(_repeat_expr_ , _repeat_constraints =None_, _** kwargs_)¶
    

Bases: `SimConcretizationStrategy`

Concretization strategy that resolves addresses, without repeating.

__init__(_repeat_expr_ , _repeat_constraints =None_, _** kwargs_)¶
    

Initializes the base SimConcretizationStrategy.

Parameters:
    

  * **filter** – A function, taking arguments of (SimMemory, claripy.AST) that determines if this strategy can handle resolving the provided AST.

  * **exact** – A flag (default: True) that determines if the convenience resolution functions provided by this class use exact or approximate resolution.

copy()¶
    

Returns a copy of the strategy, if there is data that should be kept separate between states. If not, returns self.

merge(_others_)¶
    

Merges this strategy with others (if there is data that should be kept separate between states. If not, is a no-op.

_class _angr.concretization_strategies.SimConcretizationStrategyNorepeatsRange(_repeat_expr_ , _min =None_, _granularity =None_, _** kwargs_)¶
    

Bases: `SimConcretizationStrategy`

Concretization strategy that resolves a range, with no repeats.

__init__(_repeat_expr_ , _min =None_, _granularity =None_, _** kwargs_)¶
    

Initializes the base SimConcretizationStrategy.

Parameters:
    

  * **filter** – A function, taking arguments of (SimMemory, claripy.AST) that determines if this strategy can handle resolving the provided AST.

  * **exact** – A flag (default: True) that determines if the convenience resolution functions provided by this class use exact or approximate resolution.

copy()¶
    

Returns a copy of the strategy, if there is data that should be kept separate between states. If not, returns self.

merge(_others_)¶
    

Merges this strategy with others (if there is data that should be kept separate between states. If not, is a no-op.

_class _angr.concretization_strategies.SimConcretizationStrategyRange(_limit_ , _** kwargs_)¶
    

Bases: `SimConcretizationStrategy`

Concretization strategy that resolves addresses to a range.

__init__(_limit_ , _** kwargs_)¶
    

Initializes the base SimConcretizationStrategy.

Parameters:
    

  * **filter** – A function, taking arguments of (SimMemory, claripy.AST) that determines if this strategy can handle resolving the provided AST.

  * **exact** – A flag (default: True) that determines if the convenience resolution functions provided by this class use exact or approximate resolution.

_class _angr.concretization_strategies.SimConcretizationStrategySingle(_filter =None_, _exact =True_)¶
    

Bases: `SimConcretizationStrategy`

Concretization strategy that ensures a single solution for an address.

_class _angr.concretization_strategies.SimConcretizationStrategySolutions(_limit_ , _** kwargs_)¶
    

Bases: `SimConcretizationStrategy`

Concretization strategy that resolves an address into some limited number of solutions.

__init__(_limit_ , _** kwargs_)¶
    

Initializes the base SimConcretizationStrategy.

Parameters:
    

  * **filter** – A function, taking arguments of (SimMemory, claripy.AST) that determines if this strategy can handle resolving the provided AST.

  * **exact** – A flag (default: True) that determines if the convenience resolution functions provided by this class use exact or approximate resolution.

_class _angr.concretization_strategies.SimConcretizationStrategyUnlimitedRange(_limit_ , _** kwargs_)¶
    

Bases: `SimConcretizationStrategy`

Concretization strategy that resolves addresses to a range without checking if the number of possible addresses is within the limit.

__init__(_limit_ , _** kwargs_)¶
    

Initializes the base SimConcretizationStrategy.

Parameters:
    

  * **filter** – A function, taking arguments of (SimMemory, claripy.AST) that determines if this strategy can handle resolving the provided AST.

  * **exact** – A flag (default: True) that determines if the convenience resolution functions provided by this class use exact or approximate resolution.

## Memory Mixins¶

_class _angr.storage.memory_mixins.AbstractMemory(_* args_, _** kwargs_)¶
    

Bases: `UnwrapperMixin`, `NameResolutionMixin`, `DataNormalizationMixin`, `SimplificationMixin`, `InspectMixinHigh`, `ActionsMixinHigh`, `UnderconstrainedMixin`, `SizeConcretizationMixin`, `SizeNormalizationMixin`, `ActionsMixinLow`, `ConditionalMixin`, `RegionedAddressConcretizationMixin`, `RegionedMemoryMixin`

_class _angr.storage.memory_mixins.AbstractMergerMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

AbstractMergerMixin handles merging initialized values.

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.storage.memory_mixins.ActionsMixinHigh(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

load(_addr_ , _size =None_, _*_ , _condition =None_, _fallback =None_, _disable_actions =False_, _action =None_, _** kwargs_)¶
    

store(_addr_ , _data_ , _size =None_, _*_ , _disable_actions =False_, _action =None_, _condition =None_, _** kwargs_)¶
    

_class _angr.storage.memory_mixins.ActionsMixinLow(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

load(_addr_ , _size =None_, _*_ , _action =None_, _** kwargs_)¶
    

store(_addr_ , _data_ , _size =None_, _*_ , _action =None_, _** kwargs_)¶
    

Parameters:
    

**action** (_SimActionData_ _|__None_)

_class _angr.storage.memory_mixins.AddressConcretizationMixin(_read_strategies =None_, _write_strategies =None_, _** kwargs_)¶
    

Bases: `MemoryMixin`

The address concretization mixin allows symbolic reads and writes to be handled sanely by dispatching them as a number of conditional concrete reads/writes. It provides a “concretization strategies” interface allowing the process of serializing symbolic addresses into concrete ones to be specified.

__init__(_read_strategies =None_, _write_strategies =None_, _** kwargs_)¶
    

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

concretize_write_addr(_addr_ , _strategies =None_, _condition =None_)¶
    

Concretizes an address meant for writing.

Parameters:
    

  * **addr** – An expression for the address.

  * **strategies** – A list of concretization strategies (to override the default).

  * **condition** – Any extra constraints that should be observed when determining address satisfiability

Returns:
    

A list of concrete addresses.

concretize_read_addr(_addr_ , _strategies =None_, _condition =None_)¶
    

Concretizes an address meant for reading.

Parameters:
    

  * **addr** – An expression for the address.

  * **strategies** – A list of concretization strategies (to override the default).

Returns:
    

A list of concrete addresses.

load(_addr_ , _size =None_, _*_ , _condition =None_, _** kwargs_)¶
    

store(_addr_ , _data_ , _size =None_, _*_ , _condition =None_, _** kwargs_)¶
    

permissions(_addr_ , _permissions =None_, _** kwargs_)¶
    

map_region(_addr_ , _length_ , _permissions_ , _** kwargs_)¶
    

unmap_region(_addr_ , _length_ , _** kwargs_)¶
    

concrete_load(_addr_ , _size_ , _writing =False_, _** kwargs_)¶
    

Set SUPPORTS_CONCRETE_LOAD to True and implement concrete_load if reading concrete bytes is faster in this memory model.

Parameters:
    

  * **addr** – The address to load from.

  * **size** – Size of the memory read.

  * **writing**

Returns:
    

A memoryview into the loaded bytes.

_class _angr.storage.memory_mixins.ClemoryBackerMixin(_cle_memory_backer =None_, _** kwargs_)¶
    

Bases: `PagedMemoryMixin`

Parameters:
    

**cle_memory_backer** (_None_ _|_[_cle.Loader_](https://docs.angr.io/projects/cle/en/latest/api/loader.html#cle.Loader "\(in cle\)") _|__cle.Clemory_)

__init__(_cle_memory_backer =None_, _** kwargs_)¶
    

Parameters:
    

**cle_memory_backer** (_None_ _|_[_Loader_](https://docs.angr.io/projects/cle/en/latest/api/loader.html#cle.Loader "\(in cle\)") _|_[_Clemory_](https://docs.angr.io/projects/cle/en/latest/api/utils.html#cle.memory.Clemory "\(in cle\)"))

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

_class _angr.storage.memory_mixins.ConcreteBackerMixin(_cle_memory_backer =None_, _** kwargs_)¶
    

Bases: `ClemoryBackerMixin`

Parameters:
    

**cle_memory_backer** (_None_ _|_[_cle.Loader_](https://docs.angr.io/projects/cle/en/latest/api/loader.html#cle.Loader "\(in cle\)") _|__cle.Clemory_)

_class _angr.storage.memory_mixins.ConditionalMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

load(_addr_ , _size =None_, _*_ , _condition =None_, _fallback =None_, _** kwargs_)¶
    

store(_addr_ , _data_ , _size =None_, _*_ , _condition =None_, _** kwargs_)¶
    

_class _angr.storage.memory_mixins.ConvenientMappingsMixin(_** kwargs_)¶
    

Bases: `MemoryMixin`

Implements mappings between names and hashes of symbolic variables and these variables themselves.

__init__(_** kwargs_)¶
    

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

store(_addr_ , _data_ , _size =None_, _** kwargs_)¶
    

get_symbolic_addrs()¶
    

addrs_for_name(_n_)¶
    

Returns addresses that contain expressions that contain a variable named n.

addrs_for_hash(_h_)¶
    

Returns addresses that contain expressions that contain a variable with the hash of h.

replace_all(_old_ , _new_)¶
    

Replaces all instances of expression old with expression new.

Parameters:
    

  * **old** ([`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")) – A claripy expression. Must contain at least one named variable (to make it possible to use the name index for speedup).

  * **new** ([`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")) – The new variable to replace it with.

_class _angr.storage.memory_mixins.CooperationBase¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`T`]

Any given subclass of this class which is not a subclass of MemoryMixin should have the property that any subclass it which _is_ a subclass of MemoryMixin should all work with the same datatypes

_class _angr.storage.memory_mixins.DataNormalizationMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

Normalizes the data field for a store and the fallback field for a load to be BVs.

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

store(_addr_ , _data_ , _size =None_, _** kwargs_)¶
    

load(_addr_ , _size =None_, _*_ , _fallback =None_, _** kwargs_)¶
    

_class _angr.storage.memory_mixins.DefaultFillerMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.storage.memory_mixins.DefaultListPagesMemory(_* args_, _** kwargs_)¶
    

Bases: `HexDumperMixin`, `SmartFindMixin`, `UnwrapperMixin`, `NameResolutionMixin`, `DataNormalizationMixin`, `SimplificationMixin`, `ActionsMixinHigh`, `UnderconstrainedMixin`, `SizeConcretizationMixin`, `SizeNormalizationMixin`, `InspectMixinHigh`, `AddressConcretizationMixin`, `ActionsMixinLow`, `ConditionalMixin`, `ConvenientMappingsMixin`, `DirtyAddrsMixin`, `StackAllocationMixin`, `ClemoryBackerMixin`, `DictBackerMixin`, `PrivilegedPagingMixin`, `ListPagesMixin`, `DefaultFillerMixin`, `SymbolicMergerMixin`, `PagedMemoryMixin`

_class _angr.storage.memory_mixins.DefaultMemory(_* args_, _** kwargs_)¶
    

Bases: `HexDumperMixin`, `SmartFindMixin`, `UnwrapperMixin`, `NameResolutionMixin`, `DataNormalizationMixin`, `SimplificationMixin`, `InspectMixinHigh`, `ActionsMixinHigh`, `UnderconstrainedMixin`, `SizeConcretizationMixin`, `SizeNormalizationMixin`, `AddressConcretizationMixin`, `ActionsMixinLow`, `ConditionalMixin`, `ConvenientMappingsMixin`, `DirtyAddrsMixin`, `StackAllocationMixin`, `ConcreteBackerMixin`, `ClemoryBackerMixin`, `DictBackerMixin`, `PrivilegedPagingMixin`, `UltraPagesMixin`, `DefaultFillerMixin`, `SymbolicMergerMixin`, `PagedMemoryMixin`

_class _angr.storage.memory_mixins.DictBackerMixin(_dict_memory_backer =None_, _** kwargs_)¶
    

Bases: `PagedMemoryMixin`

__init__(_dict_memory_backer =None_, _** kwargs_)¶
    

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

_class _angr.storage.memory_mixins.DirtyAddrsMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

store(_addr_ , _data_ , _size =None_, _** kwargs_)¶
    

_class _angr.storage.memory_mixins.ExplicitFillerMixin(_uninitialized_read_handler =None_, _** kwargs_)¶
    

Bases: `MemoryMixin`

__init__(_uninitialized_read_handler =None_, _** kwargs_)¶
    

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

_class _angr.storage.memory_mixins.FastMemory(_uninitialized_read_handler =None_, _** kwargs_)¶
    

Bases: `NameResolutionMixin`, `SimpleInterfaceMixin`, `SimplificationMixin`, `InspectMixinHigh`, `ConditionalMixin`, `ExplicitFillerMixin`, `DefaultFillerMixin`, `SlottedMemoryMixin`

_class _angr.storage.memory_mixins.HexDumperMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

hex_dump(_start_ , _size_ , _word_size =4_, _words_per_row =4_, _endianness ='Iend_BE'_, _symbolic_char ='?'_, _unprintable_char ='.'_, _solve =False_, _extra_constraints =None_, _inspect =False_, _disable_actions =True_)¶
    

Returns a hex dump as a string. The solver, if enabled, is called once for every byte potentially making this function very slow. It is meant to be used mainly as a “visualization” for debugging.

Warning: May read and display more bytes than size due to rounding. Particularly, if size is less than, or not a multiple of word_size*words_per_line.

Parameters:
    

  * **start** – starting address from which to print

  * **size** – number of bytes to display

  * **word_size** – number of bytes to group together as one space-delimited unit

  * **words_per_row** – number of words to display per row of output

  * **endianness** – endianness to use when displaying each word (ASCII representation is unchanged)

  * **symbolic_char** – the character to display when a byte is symbolic and has multiple solutions

  * **unprintable_char** – the character to display when a byte is not printable

  * **solve** – whether or not to attempt to solve (warning: can be very slow)

  * **extra_constraints** – extra constraints to pass to the solver is solve is True

  * **inspect** – whether or not to trigger SimInspect breakpoints for the memory load

  * **disable_actions** – whether or not to disable SimActions for the memory load

Returns:
    

hex dump as a string

_class _angr.storage.memory_mixins.HistoryTrackingMixin(_* args_, _** kwargs_)¶
    

Bases: `RefcountMixin`, `MemoryMixin`

Tracks the history of memory writes.

__init__(_* args_, _** kwargs_)¶
    

store(_addr_ , _data_ , _size =None_, _** kwargs_)¶
    

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

acquire_unique()¶
    

Call this function to return a version of this page which can be used for writing, which may or may not be the same object as before. If you use this you must immediately replace the shared reference you previously had with the new unique copy.

parents()¶
    

changed_bytes(_other_ , _** kwargs_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

all_bytes_changed_in_history()¶
    

Return type:
    

`SegmentList`

_class _angr.storage.memory_mixins.ISPOMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

An implementation of the International Stateless Persons Organisation, a mixin which should be applied as a bottom layer for memories which have no state and must redirect certain operations to a parent memory. Main usecase is for memory region classes which are stored within other memories, such as pages.

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

_class _angr.storage.memory_mixins.InspectMixinHigh(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

store(_addr_ , _data_ , _size =None_, _*_ , _condition =None_, _endness =None_, _inspect =True_, _** kwargs_)¶
    

load(_addr_ , _size =None_, _*_ , _condition =None_, _endness =None_, _inspect =True_, _** kwargs_)¶
    

_class _angr.storage.memory_mixins.JavaVmMemory(_memory_id ='mem'_, _stack =None_, _heap =None_, _vm_static_table =None_, _load_strategies =None_, _store_strategies =None_, _max_array_size =1000_, _** kwargs_)¶
    

Bases: `JavaVmMemoryMixin`

_class _angr.storage.memory_mixins.JavaVmMemoryMixin(_memory_id ='mem'_, _stack =None_, _heap =None_, _vm_static_table =None_, _load_strategies =None_, _store_strategies =None_, _max_array_size =1000_, _** kwargs_)¶
    

Bases: `MemoryMixin`

A memory mixin for JavaVM memory.

__init__(_memory_id ='mem'_, _stack =None_, _heap =None_, _vm_static_table =None_, _load_strategies =None_, _store_strategies =None_, _max_array_size =1000_, _** kwargs_)¶
    

_static _get_new_uuid()¶
    

Generate a unique id within the scope of the JavaVM memory. This, for example, is used for distinguishing memory objects of the same type (e.g. multiple instances of the same class).

store(_addr_ , _data_ , _frame =0_)¶
    

load(_addr_ , _frame =0_, _none_if_missing =False_)¶
    

push_stack_frame()¶
    

pop_stack_frame()¶
    

_property _stack¶
    

store_array_element(_array_ , _idx_ , _value_)¶
    

store_array_elements(_array_ , _start_idx_ , _data_)¶
    

Stores either a single element or a range of elements in the array.

Parameters:
    

  * **array** – Reference to the array.

  * **start_idx** – Starting index for the store.

  * **data** – Either a single value or a list of values.

load_array_element(_array_ , _idx_)¶
    

load_array_elements(_array_ , _start_idx_ , _no_of_elements_)¶
    

Loads either a single element or a range of elements from the array.

Parameters:
    

  * **array** – Reference to the array.

  * **start_idx** – Starting index for the load.

  * **no_of_elements** – Number of elements to load.

concretize_store_idx(_idx_ , _strategies =None_)¶
    

Concretizes a store index.

Parameters:
    

  * **idx** – An expression for the index.

  * **strategies** – A list of concretization strategies (to override the default).

  * **min_idx** – Minimum value for a concretized index (inclusive).

  * **max_idx** – Maximum value for a concretized index (exclusive).

Returns:
    

A list of concrete indexes.

concretize_load_idx(_idx_ , _strategies =None_)¶
    

Concretizes a load index.

Parameters:
    

  * **idx** – An expression for the index.

  * **strategies** – A list of concretization strategies (to override the default).

  * **min_idx** – Minimum value for a concretized index (inclusive).

  * **max_idx** – Maximum value for a concretized index (exclusive).

Returns:
    

A list of concrete indexes.

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.storage.memory_mixins.KeyValueMemory(_* args_, _** kwargs_)¶
    

Bases: `KeyValueMemoryMixin`

_class _angr.storage.memory_mixins.KeyValueMemoryMixin(_* args_, _** kwargs_)¶
    

Bases: `MemoryMixin`

KeyValueMemoryMixin is a mixin that provides a simple key-value store for memory.

__init__(_* args_, _** kwargs_)¶
    

load(_addr_ , _size =None_, _none_if_missing =False_, _** kwargs_)¶
    

store(_addr_ , _data_ , _type_ =None_, _** kwargs_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

_class _angr.storage.memory_mixins.LabelMergerMixin(_* args_, _** kwargs_)¶
    

Bases: `MemoryMixin`

A memory mixin for merging labels. Labels come from SimLabeledMemoryObject.

__init__(_* args_, _** kwargs_)¶
    

copy(_memo =None_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

_class _angr.storage.memory_mixins.LabeledMemory(_* args_, _top_func =None_, _** kwargs_)¶
    

Bases: `SizeNormalizationMixin`, `ListPagesWithLabelsMixin`, `DefaultFillerMixin`, `TopMergerMixin`, `LabelMergerMixin`, `PagedMemoryMixin`

LabeledMemory is used in static analysis. It allows storing values with labels, such as Definition.

_class _angr.storage.memory_mixins.ListPage(_memory =None_, _content =None_, _sinkhole =None_, _mo_cmp =None_, _** kwargs_)¶
    

Bases: `MemoryObjectMixin`, `PageBase`

This class implements a page memory mixin with lists as the main content store.

__init__(_memory =None_, _content =None_, _sinkhole =None_, _mo_cmp =None_, _** kwargs_)¶
    

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

load(_addr_ , _size =None_, _endness =None_, _page_addr =None_, _memory =None_, _cooperate =False_, _** kwargs_)¶
    

store(_addr_ , _data_ , _size =None_, _endness =None_, _memory =None_, _cooperate =False_, _** kwargs_)¶
    

erase(_addr_ , _size =None_, _** kwargs_)¶
    

Set [addr:addr+size) to uninitialized. In many cases this will be faster than overwriting those locations with new values. This is commonly used during static data flow analysis.

Parameters:
    

  * **addr** – The address to start erasing.

  * **size** – The number of bytes for erasing.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

None

merge(_others_ , _merge_conditions_ , _common_ancestor =None_, _page_addr =None_, _memory =None_, _changed_offsets =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** ([`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`ListPage`]) – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

  * **page_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **changed_offsets** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

changed_bytes(_other_ , _page_addr =None_)¶
    

Parameters:
    

  * **other** (_ListPage_)

  * **page_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

_class _angr.storage.memory_mixins.ListPagesMixin(_page_size =4096_, _default_permissions =3_, _permissions_map =None_, _page_kwargs =None_, _** kwargs_)¶
    

Bases: `PagedMemoryMixin`

PAGE_TYPE¶
    

alias of `ListPage`

_class _angr.storage.memory_mixins.ListPagesWithLabelsMixin(_page_size =4096_, _default_permissions =3_, _permissions_map =None_, _page_kwargs =None_, _** kwargs_)¶
    

Bases: `LabeledPagesMixin`, `ListPagesMixin`

_class _angr.storage.memory_mixins.MVListPage(_memory =None_, _content =None_, _sinkhole =None_, _mo_cmp =None_, _** kwargs_)¶
    

Bases: `MemoryObjectSetMixin`, `PageBase`

MVListPage allows storing multiple values at the same location.

Each store() may take a value or multiple values. Each load() returns an iterator of all values stored at that location.

__init__(_memory =None_, _content =None_, _sinkhole =None_, _mo_cmp =None_, _** kwargs_)¶
    

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

Return type:
    

`MVListPage`

load(_addr_ , _size =None_, _endness =None_, _page_addr =None_, _memory =None_, _cooperate =False_, _** kwargs_)¶
    

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), `SimMemoryObject` | `SimLabeledMemoryObject`]]

store(_addr_ , _data_ , _size =None_, _endness =None_, _memory =None_, _cooperate =False_, _** kwargs_)¶
    

erase(_addr_ , _size =None_, _** kwargs_)¶
    

Set [addr:addr+size) to uninitialized. In many cases this will be faster than overwriting those locations with new values. This is commonly used during static data flow analysis.

Parameters:
    

  * **addr** – The address to start erasing.

  * **size** – The number of bytes for erasing.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

None

merge(_others_ , _merge_conditions_ , _common_ancestor =None_, _*_ , _page_addr_ , _memory_ , _changed_offsets =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** ([`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`MVListPage`]) – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

  * **page_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **memory** (_MemoryMixin_)

  * **changed_offsets** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

compare(_other_ , _page_addr =None_, _memory =None_, _changed_offsets =None_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

  * **other** (_MVListPage_)

  * **page_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

changed_bytes(_other_ , _page_addr =None_)¶
    

Parameters:
    

  * **other** (_MVListPage_)

  * **page_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

content_gen(_index_)¶
    

_class _angr.storage.memory_mixins.MVListPagesMixin(_* args_, _skip_missing_values_during_merging =False_, _** kwargs_)¶
    

Bases: `PagedMemoryMixin`

PAGE_TYPE¶
    

alias of `MVListPage`

__init__(_* args_, _skip_missing_values_during_merging =False_, _** kwargs_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

_class _angr.storage.memory_mixins.MVListPagesWithLabelsMixin(_* args_, _skip_missing_values_during_merging =False_, _** kwargs_)¶
    

Bases: `LabeledPagesMixin`, `MVListPagesMixin`

_class _angr.storage.memory_mixins.MemoryObjectMixin¶
    

Bases: `CooperationBase`[`SimMemoryObject`]

Uses SimMemoryObjects in region storage. With this, load will return a list of tuple (address, MO) and store will take a MO.

_class _angr.storage.memory_mixins.MemoryRegionMetaMixin(_related_function_addr =None_, _** kwargs_)¶
    

Bases: `MemoryMixin`

__init__(_related_function_addr =None_, _** kwargs_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

_property _is_stack¶
    

_property _related_function_addr¶
    

get_abstract_locations(_addr_ , _size_)¶
    

Get a list of abstract locations that is within the range of [addr, addr + size]

This implementation is pretty slow. But since this method won’t be called frequently, we can live with the bad implementation for now.

Parameters:
    

  * **addr** – Starting address of the memory region.

  * **size** – Size of the memory region, in bytes.

Returns:
    

A list of covered AbstractLocation objects, or an empty list if there is none.

store(_addr_ , _data_ , _size =None_, _*_ , _bbl_addr =None_, _stmt_id =None_, _ins_addr =None_, _endness =None_, _** kwargs_)¶
    

load(_addr_ , _size =None_, _*_ , _bbl_addr =None_, _stmt_idx =None_, _ins_addr =None_, _** kwargs_)¶
    

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

dbg_print(_indent =0_)¶
    

Print out debugging information

_class _angr.storage.memory_mixins.MultiValueMergerMixin(_* args_, _element_limit =5_, _annotation_limit =256_, _top_func =None_, _is_top_func =None_, _phi_maker =None_, _merge_into_top =True_, _** kwargs_)¶
    

Bases: `MemoryMixin`

__init__(_* args_, _element_limit =5_, _annotation_limit =256_, _top_func =None_, _is_top_func =None_, _phi_maker =None_, _merge_into_top =True_, _** kwargs_)¶
    

copy(_memo =None_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

_class _angr.storage.memory_mixins.MultiValuedMemory(_* args_, _skip_missing_values_during_merging =False_, _** kwargs_)¶
    

Bases: `SizeNormalizationMixin`, `MVListPagesMixin`, `DefaultFillerMixin`, `MultiValueMergerMixin`, `PagedMemoryMixin`, `PagedMemoryMultiValueMixin`

_class _angr.storage.memory_mixins.NameResolutionMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

This mixin allows you to provide register names as load addresses, and will automatically translate this to an offset and size.

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

store(_addr_ , _data_ , _size =None_, _** kwargs_)¶
    

load(_addr_ , _size =None_, _** kwargs_)¶
    

_class _angr.storage.memory_mixins.PageBase(_* args_, _** kwargs_)¶
    

Bases: `HistoryTrackingMixin`, `RefcountMixin`, `CooperationBase`, `ISPOMixin`, `PermissionsMixin`, `MemoryMixin`

This is a fairly succinct definition of the contract between PagedMemoryMixin and its constituent pages:

  * Pages must implement the MemoryMixin model for loads, stores, copying, merging, etc

  * However, loading/storing may not necessarily use the same data domain as PagedMemoryMixin. In order to do more efficient loads/stores across pages, we use the CooperationBase interface which allows the page class to determine how to generate and unwrap the objects which are actually stored.

  * To support COW, we use the RefcountMixin and the ISPOMixin (which adds the contract element that `memory=self` be passed to every method call)

  * Pages have permissions associated with them, stored in the PermissionsMixin.

Read the docstrings for each of the constituent classes to understand the nuances of their functionalities

_class _angr.storage.memory_mixins.PagedMemoryMixin(_page_size =4096_, _default_permissions =3_, _permissions_map =None_, _page_kwargs =None_, _** kwargs_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`PageType`], `MemoryMixin`[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | `SimActionObject`, [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"), [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | `SimActionObject`]

A bottom-level storage mechanism. Dispatches reads to individual pages, the type of which is the PAGE_TYPE class variable.

SUPPORTS_CONCRETE_LOAD _: bool_ _ = True_¶
    

PAGE_TYPE _: type[PageType]_¶
    

__init__(_page_size =4096_, _default_permissions =3_, _permissions_map =None_, _page_kwargs =None_, _** kwargs_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

load(_addr_ , _size =None_, _*_ , _endness =None_, _** kwargs_)¶
    

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

store(_addr_ , _data_ , _size =None_, _*_ , _endness =None_, _** kwargs_)¶
    

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

erase(_addr_ , _size =None_, _** kwargs_)¶
    

Set [addr:addr+size) to uninitialized. In many cases this will be faster than overwriting those locations with new values. This is commonly used during static data flow analysis.

Parameters:
    

  * **addr** – The address to start erasing.

  * **size** – The number of bytes for erasing.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

None

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

compare(_other_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**other** (_PagedMemoryMixin_)

permissions(_addr_ , _permissions =None_, _** kwargs_)¶
    

map_region(_addr_ , _length_ , _permissions_ , _*_ , _init_zero =False_, _** kwargs_)¶
    

unmap_region(_addr_ , _length_ , _** kwargs_)¶
    

concrete_load(_addr_ , _size_ , _writing =False_, _*_ , _with_bitmap =False_, _** kwargs_)¶
    

Set SUPPORTS_CONCRETE_LOAD to True and implement concrete_load if reading concrete bytes is faster in this memory model.

Parameters:
    

  * **addr** – The address to load from.

  * **size** – Size of the memory read.

  * **writing**

  * **with_bitmap** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Returns:
    

A memoryview into the loaded bytes.

changed_bytes(_other_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]

changed_pages(_other_)¶
    

Return type:
    

[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")]

copy_contents(_dst_ , _src_ , _size_ , _condition =None_, _** kwargs_)¶
    

Override this method to provide faster copying of large chunks of data.

Parameters:
    

  * **dst** – The destination of copying.

  * **src** – The source of copying.

  * **size** – The size of copying.

  * **condition** – The storing condition.

  * **kwargs** – Other parameters.

Returns:
    

None

flush_pages(_white_list_)¶
    

Flush all pages not included in the white_list by removing their pages. Note, this will not wipe them from memory if they were backed by a memory_backer, it will simply reset them to their initial state. Returns the list of pages that were cleared consisting of (addr, length) tuples. :type white_list: :param white_list: white list of regions in the form of (start, end) to exclude from the flush :return: a list of memory page ranges that were flushed :rtype: list

_class _angr.storage.memory_mixins.PagedMemoryMultiValueMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

Implement optimizations and fast accessors for the MultiValues-variant of Paged Memory.

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

load_annotations(_addr_ , _size_ , _** kwargs_)¶
    

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_class _angr.storage.memory_mixins.PermissionsMixin(_permissions =None_, _** kwargs_)¶
    

Bases: `MemoryMixin`

This mixin adds a permissions_bits field and properties for extracting the read/write/exec permissions. It does NOT add permissions checking.

Parameters:
    

**permissions** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_claripy.ast.BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.BV "\(in claripy\)") _|__None_)

__init__(_permissions =None_, _** kwargs_)¶
    

Parameters:
    

**permissions** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _|__None_)

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

_property _perm_read¶
    

_property _perm_write¶
    

_property _perm_exec¶
    

_class _angr.storage.memory_mixins.PrivilegedPagingMixin(_page_size =4096_, _default_permissions =3_, _permissions_map =None_, _page_kwargs =None_, _** kwargs_)¶
    

Bases: `PagedMemoryMixin`

A mixin for paged memory models which will raise SimSegfaultExceptions if STRICT_PAGE_ACCESS is enabled and a segfault condition is detected.

Segfault conditions include: \- getting a page for reading which is non-readable \- getting a page for writing which is non-writable \- creating a page

The latter condition means that this should be inserted under any mixins which provide other implementations of `_initialize_page`.

_class _angr.storage.memory_mixins.RefcountMixin(_** kwargs_)¶
    

Bases: `MemoryMixin`

This mixin adds a locked reference counter and methods to manipulate it, to facilitate copy-on-write optimizations.

__init__(_** kwargs_)¶
    

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

acquire_unique()¶
    

Call this function to return a version of this page which can be used for writing, which may or may not be the same object as before. If you use this you must immediately replace the shared reference you previously had with the new unique copy.

acquire_shared()¶
    

Call this function to indicate that this page has had a reference added to it and must be copied before it can be acquired uniquely again. Creating the object implicitly starts it with one shared reference.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

release_shared()¶
    

Call this function to indicate that this page has had a shared reference to it released

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

_class _angr.storage.memory_mixins.RegionCategoryMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_property _category¶
    

reg, mem, or file.

Type:
    

Return the category of this SimMemory instance. It can be one of the three following categories

_class _angr.storage.memory_mixins.RegionedAddressConcretizationMixin(_read_strategies =None_, _write_strategies =None_, _** kwargs_)¶
    

Bases: `MemoryMixin`

__init__(_read_strategies =None_, _write_strategies =None_, _** kwargs_)¶
    

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.storage.memory_mixins.RegionedMemory(_related_function_addr =None_, _** kwargs_)¶
    

Bases: `RegionCategoryMixin`, `MemoryRegionMetaMixin`, `StaticFindMixin`, `UnwrapperMixin`, `NameResolutionMixin`, `DataNormalizationMixin`, `SimplificationMixin`, `SizeConcretizationMixin`, `SizeNormalizationMixin`, `AddressConcretizationMixin`, `ConvenientMappingsMixin`, `DirtyAddrsMixin`, `ClemoryBackerMixin`, `DictBackerMixin`, `UltraPagesMixin`, `DefaultFillerMixin`, `AbstractMergerMixin`, `PagedMemoryMixin`

_class _angr.storage.memory_mixins.RegionedMemoryMixin(_write_targets_limit =2048_, _read_targets_limit =4096_, _stack_region_map =None_, _generic_region_map =None_, _stack_size =65536_, _cle_memory_backer =None_, _dict_memory_backer =None_, _regioned_memory_cls =None_, _** kwargs_)¶
    

Bases: `MemoryMixin`

Regioned memory. This mixin manages multiple memory regions. Each address is represented as a tuple of (region ID, offset into the region), which is called a regioned address.

Converting absolute addresses into regioned addresses: We map an absolute address to a region by looking up which region this address belongs to in the region map. Currently this is only enabled for stack. Heap support has not landed yet.

When start analyzing a function, the user should call set_stack_address_mapping() to create a new region mapping. Likewise, when exiting from a function, the user should cancel the previous mapping by calling unset_stack_address_mapping().

Parameters:
    

  * **write_targets_limit** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **read_targets_limit** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **stack_region_map** (_RegionMap_ _|__None_)

  * **generic_region_map** (_RegionMap_ _|__None_)

  * **stack_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **cle_memory_backer** (_Optional_ _|__None_)

  * **dict_memory_backer** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _|__None_)

  * **regioned_memory_cls** ([_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _|__None_)

__init__(_write_targets_limit =2048_, _read_targets_limit =4096_, _stack_region_map =None_, _generic_region_map =None_, _stack_size =65536_, _cle_memory_backer =None_, _dict_memory_backer =None_, _regioned_memory_cls =None_, _** kwargs_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

load(_addr_ , _size =None_, _*_ , _endness =None_, _condition =None_, _** kwargs_)¶
    

Parameters:
    

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _|__None_)

  * **condition** ([_Bool_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bool.Bool "\(in claripy\)") _|__None_)

store(_addr_ , _data_ , _size =None_, _*_ , _endness =None_, _** kwargs_)¶
    

Parameters:
    

**size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

find(_addr_ , _data_ , _max_search_ , _** kwargs_)¶
    

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_Bits_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bits.Bits "\(in claripy\)"))

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

replace_all(_old_ , _new_)¶
    

Parameters:
    

  * **old** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **new** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

set_stack_address_mapping(_absolute_address_ , _region_id_ , _related_function_address =None_)¶
    

Create a new mapping between an absolute address (which is the base address of a specific stack frame) and a region ID.

Parameters:
    

  * **absolute_address** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The absolute memory address.

  * **region_id** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The region ID.

  * **related_function_address** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – Related function address.

unset_stack_address_mapping(_absolute_address_)¶
    

Remove a stack mapping.

Parameters:
    

**absolute_address** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – An absolute memory address that is the base address of the stack frame to destroy.

stack_id(_function_address_)¶
    

Return a memory region ID for a function. If the default region ID exists in the region mapping, an integer will appended to the region name. In this way we can handle recursive function calls, or a function that appears more than once in the call frame.

This also means that stack_id() should only be called when creating a new stack frame for a function. You are not supposed to call this function every time you want to map a function address to a stack ID.

Parameters:
    

**function_address** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function.

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

Returns:
    

ID of the new memory region.

set_stack_size(_size_)¶
    

Parameters:
    

**size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_class _angr.storage.memory_mixins.SimpleInterfaceMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

load(_addr_ , _size =None_, _*_ , _endness =None_, _condition =None_, _fallback =None_, _** kwargs_)¶
    

store(_addr_ , _data_ , _size =None_, _*_ , _endness =None_, _condition =None_, _** kwargs_)¶
    

_class _angr.storage.memory_mixins.SimplificationMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

store(_addr_ , _data_ , _size =None_, _** kwargs_)¶
    

_class _angr.storage.memory_mixins.SizeConcretizationMixin(_concretize_symbolic_write_size =False_, _max_concretize_count =256_, _max_symbolic_size =4194304_, _raise_memory_limit_error =False_, _size_limit =257_, _** kwargs_)¶
    

Bases: `MemoryMixin`

This mixin allows memory to process symbolic sizes. It will not touch any sizes which are not ASTs with non-BVV ops. Assumes that the data is a BV.

  * symbolic load sizes will be concretized as their maximum and a warning will be logged

  * symbolic store sizes will be dispatched as several conditional stores with concrete sizes

Parameters:
    

  * **concretize_symbolic_write_size** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **max_concretize_count** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **max_symbolic_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **raise_memory_limit_error** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **size_limit** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_concretize_symbolic_write_size =False_, _max_concretize_count =256_, _max_symbolic_size =4194304_, _raise_memory_limit_error =False_, _size_limit =257_, _** kwargs_)¶
    

Parameters:
    

  * **concretize_symbolic_write_size** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **max_concretize_count** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **max_symbolic_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **raise_memory_limit_error** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **size_limit** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

load(_addr_ , _size =None_, _** kwargs_)¶
    

store(_addr_ , _data_ , _size =None_, _*_ , _condition =None_, _** kwargs_)¶
    

_class _angr.storage.memory_mixins.SizeNormalizationMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

Provides basic services related to normalizing sizes. After this mixin, sizes will always be a plain int. Assumes that the data is a BV.

  * load will throw a TypeError if no size is provided

  * store will default to len(data)//byte_width if no size is provided

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

load(_addr_ , _size =None_, _** kwargs_)¶
    

store(_addr_ , _data_ , _size =None_, _** kwargs_)¶
    

_class _angr.storage.memory_mixins.SlottedMemoryMixin(_width =None_, _** kwargs_)¶
    

Bases: `MemoryMixin`

__init__(_width =None_, _** kwargs_)¶
    

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

load(_addr_ , _size =None_, _*_ , _endness =None_, _** kwargs_)¶
    

store(_addr_ , _data_ , _size =None_, _*_ , _endness =None_, _** kwargs_)¶
    

changed_bytes(_other_)¶
    

_class _angr.storage.memory_mixins.SmartFindMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

Memory mixin providing basic searching over concrete and symbolic data.

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

find(_addr_ , _data_ , _max_search_ , _*_ , _default =None_, _endness =None_, _chunk_size =None_, _max_symbolic_bytes =None_, _condition =None_, _char_size =1_, _** kwargs_)¶
    

_class _angr.storage.memory_mixins.SpecialFillerMixin(_special_memory_filler =None_, _** kwargs_)¶
    

Bases: `MemoryMixin`

__init__(_special_memory_filler =None_, _** kwargs_)¶
    

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

_class _angr.storage.memory_mixins.StackAllocationMixin(_stack_end =None_, _stack_size =None_, _stack_perms =None_, _** kwargs_)¶
    

Bases: `PagedMemoryMixin`

This mixin adds automatic allocation for a stack region based on the stack_end and stack_size parameters.

__init__(_stack_end =None_, _stack_size =None_, _stack_perms =None_, _** kwargs_)¶
    

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

allocate_stack_pages(_addr_ , _size_ , _** kwargs_)¶
    

Pre-allocates pages for the stack without triggering any logic related to reading from them.

Parameters:
    

  * **addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The highest address that should be mapped

  * **size** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The number of bytes to be allocated. byte 1 is the one at addr, byte 2 is the one before that, and so on.

Returns:
    

A list of the new page objects

_class _angr.storage.memory_mixins.StaticFindMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `SmartFindMixin`

Implements data finding for abstract memory.

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

find(_addr_ , _data_ , _max_search_ , _*_ , _default =None_, _endness =None_, _chunk_size =None_, _max_symbolic_bytes =None_, _condition =None_, _char_size =1_, _** kwargs_)¶
    

_class _angr.storage.memory_mixins.SymbolicMergerMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.storage.memory_mixins.TopMergerMixin(_* args_, _top_func =None_, _** kwargs_)¶
    

Bases: `MemoryMixin`

A memory mixin for merging values in memory to TOP.

__init__(_* args_, _top_func =None_, _** kwargs_)¶
    

copy(_memo =None_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

_class _angr.storage.memory_mixins.UltraPage(_memory =None_, _init_zero =False_, _** kwargs_)¶
    

Bases: `MemoryObjectMixin`, `PageBase`

Default page implementation

SUPPORTS_CONCRETE_LOAD _: bool_ _ = True_¶
    

__init__(_memory =None_, _init_zero =False_, _** kwargs_)¶
    

_classmethod _new_from_shared(_data_ , _memory =None_, _** kwargs_)¶
    

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

load(_addr_ , _size =None_, _page_addr =None_, _endness =None_, _memory =None_, _cooperate =False_, _** kwargs_)¶
    

store(_addr_ , _data_ , _size =None_, _endness =None_, _memory =None_, _page_addr =None_, _cooperate =False_, _** kwargs_)¶
    

Parameters:
    

  * **data** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__SimMemoryObject_)

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_, _page_addr =None_, _memory =None_, _changed_offsets =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** ([`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`UltraPage`]) – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

  * **page_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **changed_offsets** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

concrete_load(_addr_ , _size_ , _writing =False_, _with_bitmap =False_, _** kwargs_)¶
    

Set SUPPORTS_CONCRETE_LOAD to True and implement concrete_load if reading concrete bytes is faster in this memory model.

Parameters:
    

  * **addr** – The address to load from.

  * **size** – Size of the memory read.

  * **writing**

Returns:
    

A memoryview into the loaded bytes.

changed_bytes(_other_ , _page_addr =None_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]

replace_all_with_offsets(_offsets_ , _old_ , _new_ , _memory =None_)¶
    

Parameters:
    

  * **offsets** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]_)

  * **old** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **new** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

_class _angr.storage.memory_mixins.UltraPagesMixin(_page_size =4096_, _default_permissions =3_, _permissions_map =None_, _page_kwargs =None_, _** kwargs_)¶
    

Bases: `PagedMemoryMixin`

PAGE_TYPE¶
    

alias of `UltraPage`

_class _angr.storage.memory_mixins.UnderconstrainedMixin(_* args_, _** kwargs_)¶
    

Bases: `MemoryMixin`

__init__(_* args_, _** kwargs_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

load(_addr_ , _size =None_, _** kwargs_)¶
    

store(_addr_ , _data_ , _size =None_, _** kwargs_)¶
    

_class _angr.storage.memory_mixins.UnwrapperMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

This mixin processes SimActionObjects by passing on their .ast field.

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

store(_addr_ , _data_ , _size =None_, _*_ , _condition =None_, _** kwargs_)¶
    

load(_addr_ , _size =None_, _*_ , _condition =None_, _fallback =None_, _** kwargs_)¶
    

find(_addr_ , _data_ , _max_search_ , _*_ , _default =None_, _** kwargs_)¶
    

copy_contents(_dst_ , _src_ , _size_ , _condition =None_, _** kwargs_)¶
    

Override this method to provide faster copying of large chunks of data.

Parameters:
    

  * **dst** – The destination of copying.

  * **src** – The source of copying.

  * **size** – The size of copying.

  * **condition** – The storing condition.

  * **kwargs** – Other parameters.

Returns:
    

None

_class _angr.storage.memory_mixins.name_resolution_mixin.NameResolutionMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

This mixin allows you to provide register names as load addresses, and will automatically translate this to an offset and size.

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

store(_addr_ , _data_ , _size =None_, _** kwargs_)¶
    

load(_addr_ , _size =None_, _** kwargs_)¶
    

_class _angr.storage.memory_mixins.smart_find_mixin.SmartFindMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

Memory mixin providing basic searching over concrete and symbolic data.

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

find(_addr_ , _data_ , _max_search_ , _*_ , _default =None_, _endness =None_, _chunk_size =None_, _max_symbolic_bytes =None_, _condition =None_, _char_size =1_, _** kwargs_)¶
    

_class _angr.storage.memory_mixins.default_filler_mixin.DefaultFillerMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.storage.memory_mixins.default_filler_mixin.SpecialFillerMixin(_special_memory_filler =None_, _** kwargs_)¶
    

Bases: `MemoryMixin`

__init__(_special_memory_filler =None_, _** kwargs_)¶
    

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

_class _angr.storage.memory_mixins.default_filler_mixin.ExplicitFillerMixin(_uninitialized_read_handler =None_, _** kwargs_)¶
    

Bases: `MemoryMixin`

__init__(_uninitialized_read_handler =None_, _** kwargs_)¶
    

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

_class _angr.storage.memory_mixins.bvv_conversion_mixin.DataNormalizationMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

Normalizes the data field for a store and the fallback field for a load to be BVs.

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

store(_addr_ , _data_ , _size =None_, _** kwargs_)¶
    

load(_addr_ , _size =None_, _*_ , _fallback =None_, _** kwargs_)¶
    

_class _angr.storage.memory_mixins.hex_dumper_mixin.HexDumperMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

hex_dump(_start_ , _size_ , _word_size =4_, _words_per_row =4_, _endianness ='Iend_BE'_, _symbolic_char ='?'_, _unprintable_char ='.'_, _solve =False_, _extra_constraints =None_, _inspect =False_, _disable_actions =True_)¶
    

Returns a hex dump as a string. The solver, if enabled, is called once for every byte potentially making this function very slow. It is meant to be used mainly as a “visualization” for debugging.

Warning: May read and display more bytes than size due to rounding. Particularly, if size is less than, or not a multiple of word_size*words_per_line.

Parameters:
    

  * **start** – starting address from which to print

  * **size** – number of bytes to display

  * **word_size** – number of bytes to group together as one space-delimited unit

  * **words_per_row** – number of words to display per row of output

  * **endianness** – endianness to use when displaying each word (ASCII representation is unchanged)

  * **symbolic_char** – the character to display when a byte is symbolic and has multiple solutions

  * **unprintable_char** – the character to display when a byte is not printable

  * **solve** – whether or not to attempt to solve (warning: can be very slow)

  * **extra_constraints** – extra constraints to pass to the solver is solve is True

  * **inspect** – whether or not to trigger SimInspect breakpoints for the memory load

  * **disable_actions** – whether or not to disable SimActions for the memory load

Returns:
    

hex dump as a string

_class _angr.storage.memory_mixins.underconstrained_mixin.UnderconstrainedMixin(_* args_, _** kwargs_)¶
    

Bases: `MemoryMixin`

__init__(_* args_, _** kwargs_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

load(_addr_ , _size =None_, _** kwargs_)¶
    

store(_addr_ , _data_ , _size =None_, _** kwargs_)¶
    

_class _angr.storage.memory_mixins.simple_interface_mixin.SimpleInterfaceMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

load(_addr_ , _size =None_, _*_ , _endness =None_, _condition =None_, _fallback =None_, _** kwargs_)¶
    

store(_addr_ , _data_ , _size =None_, _*_ , _endness =None_, _condition =None_, _** kwargs_)¶
    

_class _angr.storage.memory_mixins.actions_mixin.ActionsMixinHigh(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

load(_addr_ , _size =None_, _*_ , _condition =None_, _fallback =None_, _disable_actions =False_, _action =None_, _** kwargs_)¶
    

store(_addr_ , _data_ , _size =None_, _*_ , _disable_actions =False_, _action =None_, _condition =None_, _** kwargs_)¶
    

_class _angr.storage.memory_mixins.actions_mixin.ActionsMixinLow(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

load(_addr_ , _size =None_, _*_ , _action =None_, _** kwargs_)¶
    

store(_addr_ , _data_ , _size =None_, _*_ , _action =None_, _** kwargs_)¶
    

Parameters:
    

**action** (_SimActionData_ _|__None_)

_class _angr.storage.memory_mixins.symbolic_merger_mixin.SymbolicMergerMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.storage.memory_mixins.size_resolution_mixin.SizeNormalizationMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

Provides basic services related to normalizing sizes. After this mixin, sizes will always be a plain int. Assumes that the data is a BV.

  * load will throw a TypeError if no size is provided

  * store will default to len(data)//byte_width if no size is provided

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

load(_addr_ , _size =None_, _** kwargs_)¶
    

store(_addr_ , _data_ , _size =None_, _** kwargs_)¶
    

_class _angr.storage.memory_mixins.size_resolution_mixin.SizeConcretizationMixin(_concretize_symbolic_write_size =False_, _max_concretize_count =256_, _max_symbolic_size =4194304_, _raise_memory_limit_error =False_, _size_limit =257_, _** kwargs_)¶
    

Bases: `MemoryMixin`

This mixin allows memory to process symbolic sizes. It will not touch any sizes which are not ASTs with non-BVV ops. Assumes that the data is a BV.

  * symbolic load sizes will be concretized as their maximum and a warning will be logged

  * symbolic store sizes will be dispatched as several conditional stores with concrete sizes

Parameters:
    

  * **concretize_symbolic_write_size** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **max_concretize_count** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **max_symbolic_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **raise_memory_limit_error** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **size_limit** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_concretize_symbolic_write_size =False_, _max_concretize_count =256_, _max_symbolic_size =4194304_, _raise_memory_limit_error =False_, _size_limit =257_, _** kwargs_)¶
    

Parameters:
    

  * **concretize_symbolic_write_size** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **max_concretize_count** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **max_symbolic_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **raise_memory_limit_error** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **size_limit** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

load(_addr_ , _size =None_, _** kwargs_)¶
    

store(_addr_ , _data_ , _size =None_, _*_ , _condition =None_, _** kwargs_)¶
    

_class _angr.storage.memory_mixins.dirty_addrs_mixin.DirtyAddrsMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

store(_addr_ , _data_ , _size =None_, _** kwargs_)¶
    

_class _angr.storage.memory_mixins.address_concretization_mixin.MultiwriteAnnotation¶
    

Bases: [`Annotation`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.annotation.Annotation "\(in claripy\)")

_property _eliminatable¶
    

Returns whether this annotation can be eliminated in a simplification.

Returns:
    

True if eliminatable, False otherwise

_property _relocateable¶
    

_class _angr.storage.memory_mixins.address_concretization_mixin.AddressConcretizationMixin(_read_strategies =None_, _write_strategies =None_, _** kwargs_)¶
    

Bases: `MemoryMixin`

The address concretization mixin allows symbolic reads and writes to be handled sanely by dispatching them as a number of conditional concrete reads/writes. It provides a “concretization strategies” interface allowing the process of serializing symbolic addresses into concrete ones to be specified.

__init__(_read_strategies =None_, _write_strategies =None_, _** kwargs_)¶
    

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

concretize_write_addr(_addr_ , _strategies =None_, _condition =None_)¶
    

Concretizes an address meant for writing.

Parameters:
    

  * **addr** – An expression for the address.

  * **strategies** – A list of concretization strategies (to override the default).

  * **condition** – Any extra constraints that should be observed when determining address satisfiability

Returns:
    

A list of concrete addresses.

concretize_read_addr(_addr_ , _strategies =None_, _condition =None_)¶
    

Concretizes an address meant for reading.

Parameters:
    

  * **addr** – An expression for the address.

  * **strategies** – A list of concretization strategies (to override the default).

Returns:
    

A list of concrete addresses.

load(_addr_ , _size =None_, _*_ , _condition =None_, _** kwargs_)¶
    

store(_addr_ , _data_ , _size =None_, _*_ , _condition =None_, _** kwargs_)¶
    

permissions(_addr_ , _permissions =None_, _** kwargs_)¶
    

map_region(_addr_ , _length_ , _permissions_ , _** kwargs_)¶
    

unmap_region(_addr_ , _length_ , _** kwargs_)¶
    

concrete_load(_addr_ , _size_ , _writing =False_, _** kwargs_)¶
    

Set SUPPORTS_CONCRETE_LOAD to True and implement concrete_load if reading concrete bytes is faster in this memory model.

Parameters:
    

  * **addr** – The address to load from.

  * **size** – Size of the memory read.

  * **writing**

Returns:
    

A memoryview into the loaded bytes.

_class _angr.storage.memory_mixins.clouseau_mixin.InspectMixinHigh(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

store(_addr_ , _data_ , _size =None_, _*_ , _condition =None_, _endness =None_, _inspect =True_, _** kwargs_)¶
    

load(_addr_ , _size =None_, _*_ , _condition =None_, _endness =None_, _inspect =True_, _** kwargs_)¶
    

_class _angr.storage.memory_mixins.conditional_store_mixin.ConditionalMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

load(_addr_ , _size =None_, _*_ , _condition =None_, _fallback =None_, _** kwargs_)¶
    

store(_addr_ , _data_ , _size =None_, _*_ , _condition =None_, _** kwargs_)¶
    

_class _angr.storage.memory_mixins.label_merger_mixin.LabelMergerMixin(_* args_, _** kwargs_)¶
    

Bases: `MemoryMixin`

A memory mixin for merging labels. Labels come from SimLabeledMemoryObject.

__init__(_* args_, _** kwargs_)¶
    

copy(_memo =None_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

_class _angr.storage.memory_mixins.simplification_mixin.SimplificationMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

store(_addr_ , _data_ , _size =None_, _** kwargs_)¶
    

_class _angr.storage.memory_mixins.unwrapper_mixin.UnwrapperMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

This mixin processes SimActionObjects by passing on their .ast field.

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

store(_addr_ , _data_ , _size =None_, _*_ , _condition =None_, _** kwargs_)¶
    

load(_addr_ , _size =None_, _*_ , _condition =None_, _fallback =None_, _** kwargs_)¶
    

find(_addr_ , _data_ , _max_search_ , _*_ , _default =None_, _** kwargs_)¶
    

copy_contents(_dst_ , _src_ , _size_ , _condition =None_, _** kwargs_)¶
    

Override this method to provide faster copying of large chunks of data.

Parameters:
    

  * **dst** – The destination of copying.

  * **src** – The source of copying.

  * **size** – The size of copying.

  * **condition** – The storing condition.

  * **kwargs** – Other parameters.

Returns:
    

None

_class _angr.storage.memory_mixins.convenient_mappings_mixin.ConvenientMappingsMixin(_** kwargs_)¶
    

Bases: `MemoryMixin`

Implements mappings between names and hashes of symbolic variables and these variables themselves.

__init__(_** kwargs_)¶
    

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

store(_addr_ , _data_ , _size =None_, _** kwargs_)¶
    

get_symbolic_addrs()¶
    

addrs_for_name(_n_)¶
    

Returns addresses that contain expressions that contain a variable named n.

addrs_for_hash(_h_)¶
    

Returns addresses that contain expressions that contain a variable with the hash of h.

replace_all(_old_ , _new_)¶
    

Replaces all instances of expression old with expression new.

Parameters:
    

  * **old** ([`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")) – A claripy expression. Must contain at least one named variable (to make it possible to use the name index for speedup).

  * **new** ([`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")) – The new variable to replace it with.

_class _angr.storage.memory_mixins.paged_memory.pages.mv_list_page.MVListPage(_memory =None_, _content =None_, _sinkhole =None_, _mo_cmp =None_, _** kwargs_)¶
    

Bases: `MemoryObjectSetMixin`, `PageBase`

MVListPage allows storing multiple values at the same location.

Each store() may take a value or multiple values. Each load() returns an iterator of all values stored at that location.

__init__(_memory =None_, _content =None_, _sinkhole =None_, _mo_cmp =None_, _** kwargs_)¶
    

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

Return type:
    

`MVListPage`

load(_addr_ , _size =None_, _endness =None_, _page_addr =None_, _memory =None_, _cooperate =False_, _** kwargs_)¶
    

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), `SimMemoryObject` | `SimLabeledMemoryObject`]]

store(_addr_ , _data_ , _size =None_, _endness =None_, _memory =None_, _cooperate =False_, _** kwargs_)¶
    

erase(_addr_ , _size =None_, _** kwargs_)¶
    

Set [addr:addr+size) to uninitialized. In many cases this will be faster than overwriting those locations with new values. This is commonly used during static data flow analysis.

Parameters:
    

  * **addr** – The address to start erasing.

  * **size** – The number of bytes for erasing.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

None

merge(_others_ , _merge_conditions_ , _common_ancestor =None_, _*_ , _page_addr_ , _memory_ , _changed_offsets =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** ([`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`MVListPage`]) – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

  * **page_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **memory** (_MemoryMixin_)

  * **changed_offsets** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

compare(_other_ , _page_addr =None_, _memory =None_, _changed_offsets =None_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

  * **other** (_MVListPage_)

  * **page_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

changed_bytes(_other_ , _page_addr =None_)¶
    

Parameters:
    

  * **other** (_MVListPage_)

  * **page_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

content_gen(_index_)¶
    

_class _angr.storage.memory_mixins.paged_memory.pages.multi_values.MultiValues(_v =None_, _offset_to_values =None_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`MVType`]

Represents a byte vector where each byte can have one or multiple values.

As an implementation optimization (so that we do not create excessive sets and dicts), self._single_value stores a claripy AST when this MultiValues object represents only one value at offset 0.

Parameters:
    

  * **v** (_MVType_ _|__MultiValues_ _[__MVType_ _]__|__None_ _|_[_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__MVType_ _]__]_)

  * **offset_to_values** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__MVType_ _]__]__|__None_)

__init__(_v =None_, _offset_to_values =None_)¶
    

Parameters:
    

  * **v** (_MVType_ _|__MultiValues_ _[__MVType_ _]__|__None_ _|_[_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__MVType_ _]__]_)

  * **offset_to_values** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__MVType_ _]__]__|__None_)

add_value(_offset_ , _value_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **value** (_MVType_)

one_value(_strip_annotations =False_)¶
    

Return type:
    

[`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`MVType`, bound= [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`FP`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)"))]

Parameters:
    

**strip_annotations** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

merge(_mv_)¶
    

Return type:
    

`MultiValues`[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`MVType`, bound= [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`FP`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)"))]

Parameters:
    

**mv** (_MultiValues_ _[__MVType_ _]_)

keys()¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]

values()¶
    

Return type:
    

[`Iterator`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterator "\(in Python v3.13\)")[[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`MVType`, bound= [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`FP`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)"))]]

items()¶
    

Return type:
    

[`Iterator`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterator "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`MVType`, bound= [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`FP`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)"))]]]

count()¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

extract(_offset_ , _length_ , _endness_)¶
    

Return type:
    

`MultiValues`[[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")]

Parameters:
    

  * **self** (_MultiValues_ _[_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _]_)

  * **offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **length** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

concat(_other_)¶
    

Return type:
    

`MultiValues`[[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")]

Parameters:
    

  * **self** (_MultiValues_ _[_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _]_)

  * **other** (_MultiValues_ _[_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _]__|_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _|_[_bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)"))

angr.storage.memory_mixins.paged_memory.pages.multi_values.mv_is_bv(_mv_)¶
    

Return type:
    

`TypeGuard`[`MultiValues`[[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")]]

Parameters:
    

**mv** (_MultiValues_ _[_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]_)

angr.storage.memory_mixins.paged_memory.pages.multi_values.mv_is_fp(_mv_)¶
    

Return type:
    

`TypeGuard`[`MultiValues`[[`FP`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)")]]

Parameters:
    

**mv** (_MultiValues_ _[_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]_)

_class _angr.storage.memory_mixins.top_merger_mixin.TopMergerMixin(_* args_, _top_func =None_, _** kwargs_)¶
    

Bases: `MemoryMixin`

A memory mixin for merging values in memory to TOP.

__init__(_* args_, _top_func =None_, _** kwargs_)¶
    

copy(_memo =None_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

_class _angr.storage.memory_mixins.multi_value_merger_mixin.MultiValueMergerMixin(_* args_, _element_limit =5_, _annotation_limit =256_, _top_func =None_, _is_top_func =None_, _phi_maker =None_, _merge_into_top =True_, _** kwargs_)¶
    

Bases: `MemoryMixin`

__init__(_* args_, _element_limit =5_, _annotation_limit =256_, _top_func =None_, _is_top_func =None_, _phi_maker =None_, _merge_into_top =True_, _** kwargs_)¶
    

copy(_memo =None_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

_class _angr.storage.memory_mixins.paged_memory.paged_memory_mixin.PagedMemoryMixin(_page_size =4096_, _default_permissions =3_, _permissions_map =None_, _page_kwargs =None_, _** kwargs_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`PageType`], `MemoryMixin`[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | `SimActionObject`, [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"), [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | `SimActionObject`]

A bottom-level storage mechanism. Dispatches reads to individual pages, the type of which is the PAGE_TYPE class variable.

SUPPORTS_CONCRETE_LOAD _: bool_ _ = True_¶
    

PAGE_TYPE _: type[PageType]_¶
    

__init__(_page_size =4096_, _default_permissions =3_, _permissions_map =None_, _page_kwargs =None_, _** kwargs_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

load(_addr_ , _size =None_, _*_ , _endness =None_, _** kwargs_)¶
    

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

store(_addr_ , _data_ , _size =None_, _*_ , _endness =None_, _** kwargs_)¶
    

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

erase(_addr_ , _size =None_, _** kwargs_)¶
    

Set [addr:addr+size) to uninitialized. In many cases this will be faster than overwriting those locations with new values. This is commonly used during static data flow analysis.

Parameters:
    

  * **addr** – The address to start erasing.

  * **size** – The number of bytes for erasing.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

None

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

compare(_other_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**other** (_PagedMemoryMixin_)

permissions(_addr_ , _permissions =None_, _** kwargs_)¶
    

map_region(_addr_ , _length_ , _permissions_ , _*_ , _init_zero =False_, _** kwargs_)¶
    

unmap_region(_addr_ , _length_ , _** kwargs_)¶
    

concrete_load(_addr_ , _size_ , _writing =False_, _*_ , _with_bitmap =False_, _** kwargs_)¶
    

Set SUPPORTS_CONCRETE_LOAD to True and implement concrete_load if reading concrete bytes is faster in this memory model.

Parameters:
    

  * **addr** – The address to load from.

  * **size** – Size of the memory read.

  * **writing**

  * **with_bitmap** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Returns:
    

A memoryview into the loaded bytes.

changed_bytes(_other_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]

changed_pages(_other_)¶
    

Return type:
    

[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")]

copy_contents(_dst_ , _src_ , _size_ , _condition =None_, _** kwargs_)¶
    

Override this method to provide faster copying of large chunks of data.

Parameters:
    

  * **dst** – The destination of copying.

  * **src** – The source of copying.

  * **size** – The size of copying.

  * **condition** – The storing condition.

  * **kwargs** – Other parameters.

Returns:
    

None

flush_pages(_white_list_)¶
    

Flush all pages not included in the white_list by removing their pages. Note, this will not wipe them from memory if they were backed by a memory_backer, it will simply reset them to their initial state. Returns the list of pages that were cleared consisting of (addr, length) tuples. :type white_list: :param white_list: white list of regions in the form of (start, end) to exclude from the flush :return: a list of memory page ranges that were flushed :rtype: list

state _: angr.SimState_¶
    

_class _angr.storage.memory_mixins.paged_memory.paged_memory_mixin.LabeledPagesMixin(_page_size =4096_, _default_permissions =3_, _permissions_map =None_, _page_kwargs =None_, _** kwargs_)¶
    

Bases: `PagedMemoryMixin`

load_with_labels(_addr_ , _size =None_, _endness =None_, _** kwargs_)¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`Base`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"), [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]]

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

_class _angr.storage.memory_mixins.paged_memory.paged_memory_mixin.ListPagesMixin(_page_size =4096_, _default_permissions =3_, _permissions_map =None_, _page_kwargs =None_, _** kwargs_)¶
    

Bases: `PagedMemoryMixin`

PAGE_TYPE¶
    

alias of `ListPage`

_class _angr.storage.memory_mixins.paged_memory.paged_memory_mixin.MVListPagesMixin(_* args_, _skip_missing_values_during_merging =False_, _** kwargs_)¶
    

Bases: `PagedMemoryMixin`

PAGE_TYPE¶
    

alias of `MVListPage`

__init__(_* args_, _skip_missing_values_during_merging =False_, _** kwargs_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

_class _angr.storage.memory_mixins.paged_memory.paged_memory_mixin.ListPagesWithLabelsMixin(_page_size =4096_, _default_permissions =3_, _permissions_map =None_, _page_kwargs =None_, _** kwargs_)¶
    

Bases: `LabeledPagesMixin`, `ListPagesMixin`

_class _angr.storage.memory_mixins.paged_memory.paged_memory_mixin.MVListPagesWithLabelsMixin(_* args_, _skip_missing_values_during_merging =False_, _** kwargs_)¶
    

Bases: `LabeledPagesMixin`, `MVListPagesMixin`

_class _angr.storage.memory_mixins.paged_memory.paged_memory_mixin.UltraPagesMixin(_page_size =4096_, _default_permissions =3_, _permissions_map =None_, _page_kwargs =None_, _** kwargs_)¶
    

Bases: `PagedMemoryMixin`

PAGE_TYPE¶
    

alias of `UltraPage`

_class _angr.storage.memory_mixins.paged_memory.page_backer_mixins.NotMemoryview(_obj_ , _offset_ , _size_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_obj_ , _offset_ , _size_)¶
    

_class _angr.storage.memory_mixins.paged_memory.page_backer_mixins.ClemoryBackerMixin(_cle_memory_backer =None_, _** kwargs_)¶
    

Bases: `PagedMemoryMixin`

Parameters:
    

**cle_memory_backer** (_None_ _|_[_cle.Loader_](https://docs.angr.io/projects/cle/en/latest/api/loader.html#cle.Loader "\(in cle\)") _|__cle.Clemory_)

__init__(_cle_memory_backer =None_, _** kwargs_)¶
    

Parameters:
    

**cle_memory_backer** (_None_ _|_[_Loader_](https://docs.angr.io/projects/cle/en/latest/api/loader.html#cle.Loader "\(in cle\)") _|_[_Clemory_](https://docs.angr.io/projects/cle/en/latest/api/utils.html#cle.memory.Clemory "\(in cle\)"))

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

_class _angr.storage.memory_mixins.paged_memory.page_backer_mixins.ConcreteBackerMixin(_cle_memory_backer =None_, _** kwargs_)¶
    

Bases: `ClemoryBackerMixin`

Parameters:
    

**cle_memory_backer** (_None_ _|_[_cle.Loader_](https://docs.angr.io/projects/cle/en/latest/api/loader.html#cle.Loader "\(in cle\)") _|__cle.Clemory_)

_class _angr.storage.memory_mixins.paged_memory.page_backer_mixins.DictBackerMixin(_dict_memory_backer =None_, _** kwargs_)¶
    

Bases: `PagedMemoryMixin`

__init__(_dict_memory_backer =None_, _** kwargs_)¶
    

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

_class _angr.storage.memory_mixins.paged_memory.stack_allocation_mixin.StackAllocationMixin(_stack_end =None_, _stack_size =None_, _stack_perms =None_, _** kwargs_)¶
    

Bases: `PagedMemoryMixin`

This mixin adds automatic allocation for a stack region based on the stack_end and stack_size parameters.

__init__(_stack_end =None_, _stack_size =None_, _stack_perms =None_, _** kwargs_)¶
    

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

allocate_stack_pages(_addr_ , _size_ , _** kwargs_)¶
    

Pre-allocates pages for the stack without triggering any logic related to reading from them.

Parameters:
    

  * **addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The highest address that should be mapped

  * **size** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The number of bytes to be allocated. byte 1 is the one at addr, byte 2 is the one before that, and so on.

Returns:
    

A list of the new page objects

_class _angr.storage.memory_mixins.paged_memory.privileged_mixin.PrivilegedPagingMixin(_page_size =4096_, _default_permissions =3_, _permissions_map =None_, _page_kwargs =None_, _** kwargs_)¶
    

Bases: `PagedMemoryMixin`

A mixin for paged memory models which will raise SimSegfaultExceptions if STRICT_PAGE_ACCESS is enabled and a segfault condition is detected.

Segfault conditions include: \- getting a page for reading which is non-readable \- getting a page for writing which is non-writable \- creating a page

The latter condition means that this should be inserted under any mixins which provide other implementations of `_initialize_page`.

_class _angr.storage.memory_mixins.paged_memory.pages.CooperationBase¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`T`]

Any given subclass of this class which is not a subclass of MemoryMixin should have the property that any subclass it which _is_ a subclass of MemoryMixin should all work with the same datatypes

_class _angr.storage.memory_mixins.paged_memory.pages.HistoryTrackingMixin(_* args_, _** kwargs_)¶
    

Bases: `RefcountMixin`, `MemoryMixin`

Tracks the history of memory writes.

__init__(_* args_, _** kwargs_)¶
    

store(_addr_ , _data_ , _size =None_, _** kwargs_)¶
    

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

acquire_unique()¶
    

Call this function to return a version of this page which can be used for writing, which may or may not be the same object as before. If you use this you must immediately replace the shared reference you previously had with the new unique copy.

parents()¶
    

changed_bytes(_other_ , _** kwargs_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

all_bytes_changed_in_history()¶
    

Return type:
    

`SegmentList`

_class _angr.storage.memory_mixins.paged_memory.pages.ISPOMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

An implementation of the International Stateless Persons Organisation, a mixin which should be applied as a bottom layer for memories which have no state and must redirect certain operations to a parent memory. Main usecase is for memory region classes which are stored within other memories, such as pages.

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

_class _angr.storage.memory_mixins.paged_memory.pages.ListPage(_memory =None_, _content =None_, _sinkhole =None_, _mo_cmp =None_, _** kwargs_)¶
    

Bases: `MemoryObjectMixin`, `PageBase`

This class implements a page memory mixin with lists as the main content store.

__init__(_memory =None_, _content =None_, _sinkhole =None_, _mo_cmp =None_, _** kwargs_)¶
    

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

load(_addr_ , _size =None_, _endness =None_, _page_addr =None_, _memory =None_, _cooperate =False_, _** kwargs_)¶
    

store(_addr_ , _data_ , _size =None_, _endness =None_, _memory =None_, _cooperate =False_, _** kwargs_)¶
    

erase(_addr_ , _size =None_, _** kwargs_)¶
    

Set [addr:addr+size) to uninitialized. In many cases this will be faster than overwriting those locations with new values. This is commonly used during static data flow analysis.

Parameters:
    

  * **addr** – The address to start erasing.

  * **size** – The number of bytes for erasing.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

None

merge(_others_ , _merge_conditions_ , _common_ancestor =None_, _page_addr =None_, _memory =None_, _changed_offsets =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** ([`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`ListPage`]) – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

  * **page_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **changed_offsets** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

changed_bytes(_other_ , _page_addr =None_)¶
    

Parameters:
    

  * **other** (_ListPage_)

  * **page_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

_class _angr.storage.memory_mixins.paged_memory.pages.MVListPage(_memory =None_, _content =None_, _sinkhole =None_, _mo_cmp =None_, _** kwargs_)¶
    

Bases: `MemoryObjectSetMixin`, `PageBase`

MVListPage allows storing multiple values at the same location.

Each store() may take a value or multiple values. Each load() returns an iterator of all values stored at that location.

__init__(_memory =None_, _content =None_, _sinkhole =None_, _mo_cmp =None_, _** kwargs_)¶
    

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

Return type:
    

`MVListPage`

load(_addr_ , _size =None_, _endness =None_, _page_addr =None_, _memory =None_, _cooperate =False_, _** kwargs_)¶
    

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), `SimMemoryObject` | `SimLabeledMemoryObject`]]

store(_addr_ , _data_ , _size =None_, _endness =None_, _memory =None_, _cooperate =False_, _** kwargs_)¶
    

erase(_addr_ , _size =None_, _** kwargs_)¶
    

Set [addr:addr+size) to uninitialized. In many cases this will be faster than overwriting those locations with new values. This is commonly used during static data flow analysis.

Parameters:
    

  * **addr** – The address to start erasing.

  * **size** – The number of bytes for erasing.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

None

merge(_others_ , _merge_conditions_ , _common_ancestor =None_, _*_ , _page_addr_ , _memory_ , _changed_offsets =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** ([`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`MVListPage`]) – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

  * **page_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **memory** (_MemoryMixin_)

  * **changed_offsets** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

compare(_other_ , _page_addr =None_, _memory =None_, _changed_offsets =None_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

  * **other** (_MVListPage_)

  * **page_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

changed_bytes(_other_ , _page_addr =None_)¶
    

Parameters:
    

  * **other** (_MVListPage_)

  * **page_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

content_gen(_index_)¶
    

_class _angr.storage.memory_mixins.paged_memory.pages.MemoryObjectMixin¶
    

Bases: `CooperationBase`[`SimMemoryObject`]

Uses SimMemoryObjects in region storage. With this, load will return a list of tuple (address, MO) and store will take a MO.

_class _angr.storage.memory_mixins.paged_memory.pages.PageBase(_* args_, _** kwargs_)¶
    

Bases: `HistoryTrackingMixin`, `RefcountMixin`, `CooperationBase`, `ISPOMixin`, `PermissionsMixin`, `MemoryMixin`

This is a fairly succinct definition of the contract between PagedMemoryMixin and its constituent pages:

  * Pages must implement the MemoryMixin model for loads, stores, copying, merging, etc

  * However, loading/storing may not necessarily use the same data domain as PagedMemoryMixin. In order to do more efficient loads/stores across pages, we use the CooperationBase interface which allows the page class to determine how to generate and unwrap the objects which are actually stored.

  * To support COW, we use the RefcountMixin and the ISPOMixin (which adds the contract element that `memory=self` be passed to every method call)

  * Pages have permissions associated with them, stored in the PermissionsMixin.

Read the docstrings for each of the constituent classes to understand the nuances of their functionalities

_class _angr.storage.memory_mixins.paged_memory.pages.PermissionsMixin(_permissions =None_, _** kwargs_)¶
    

Bases: `MemoryMixin`

This mixin adds a permissions_bits field and properties for extracting the read/write/exec permissions. It does NOT add permissions checking.

Parameters:
    

**permissions** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_claripy.ast.BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.BV "\(in claripy\)") _|__None_)

__init__(_permissions =None_, _** kwargs_)¶
    

Parameters:
    

**permissions** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _|__None_)

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

_property _perm_read¶
    

_property _perm_write¶
    

_property _perm_exec¶
    

_class _angr.storage.memory_mixins.paged_memory.pages.RefcountMixin(_** kwargs_)¶
    

Bases: `MemoryMixin`

This mixin adds a locked reference counter and methods to manipulate it, to facilitate copy-on-write optimizations.

__init__(_** kwargs_)¶
    

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

acquire_unique()¶
    

Call this function to return a version of this page which can be used for writing, which may or may not be the same object as before. If you use this you must immediately replace the shared reference you previously had with the new unique copy.

acquire_shared()¶
    

Call this function to indicate that this page has had a reference added to it and must be copied before it can be acquired uniquely again. Creating the object implicitly starts it with one shared reference.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

release_shared()¶
    

Call this function to indicate that this page has had a shared reference to it released

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

_class _angr.storage.memory_mixins.paged_memory.pages.UltraPage(_memory =None_, _init_zero =False_, _** kwargs_)¶
    

Bases: `MemoryObjectMixin`, `PageBase`

Default page implementation

SUPPORTS_CONCRETE_LOAD _: bool_ _ = True_¶
    

__init__(_memory =None_, _init_zero =False_, _** kwargs_)¶
    

_classmethod _new_from_shared(_data_ , _memory =None_, _** kwargs_)¶
    

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

load(_addr_ , _size =None_, _page_addr =None_, _endness =None_, _memory =None_, _cooperate =False_, _** kwargs_)¶
    

store(_addr_ , _data_ , _size =None_, _endness =None_, _memory =None_, _page_addr =None_, _cooperate =False_, _** kwargs_)¶
    

Parameters:
    

  * **data** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__SimMemoryObject_)

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_, _page_addr =None_, _memory =None_, _changed_offsets =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** ([`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`UltraPage`]) – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

  * **page_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **changed_offsets** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

concrete_load(_addr_ , _size_ , _writing =False_, _with_bitmap =False_, _** kwargs_)¶
    

Set SUPPORTS_CONCRETE_LOAD to True and implement concrete_load if reading concrete bytes is faster in this memory model.

Parameters:
    

  * **addr** – The address to load from.

  * **size** – Size of the memory read.

  * **writing**

Returns:
    

A memoryview into the loaded bytes.

changed_bytes(_other_ , _page_addr =None_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]

state _: angr.SimState_¶
    

replace_all_with_offsets(_offsets_ , _old_ , _new_ , _memory =None_)¶
    

Parameters:
    

  * **offsets** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]_)

  * **old** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **new** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

_class _angr.storage.memory_mixins.paged_memory.pages.refcount_mixin.RefcountMixin(_** kwargs_)¶
    

Bases: `MemoryMixin`

This mixin adds a locked reference counter and methods to manipulate it, to facilitate copy-on-write optimizations.

__init__(_** kwargs_)¶
    

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

acquire_unique()¶
    

Call this function to return a version of this page which can be used for writing, which may or may not be the same object as before. If you use this you must immediately replace the shared reference you previously had with the new unique copy.

acquire_shared()¶
    

Call this function to indicate that this page has had a reference added to it and must be copied before it can be acquired uniquely again. Creating the object implicitly starts it with one shared reference.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

release_shared()¶
    

Call this function to indicate that this page has had a shared reference to it released

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

_class _angr.storage.memory_mixins.paged_memory.pages.permissions_mixin.PermissionsMixin(_permissions =None_, _** kwargs_)¶
    

Bases: `MemoryMixin`

This mixin adds a permissions_bits field and properties for extracting the read/write/exec permissions. It does NOT add permissions checking.

Parameters:
    

**permissions** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_claripy.ast.BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.BV "\(in claripy\)") _|__None_)

__init__(_permissions =None_, _** kwargs_)¶
    

Parameters:
    

**permissions** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _|__None_)

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

_property _perm_read¶
    

_property _perm_write¶
    

_property _perm_exec¶
    

_class _angr.storage.memory_mixins.paged_memory.pages.history_tracking_mixin.HistoryTrackingMixin(_* args_, _** kwargs_)¶
    

Bases: `RefcountMixin`, `MemoryMixin`

Tracks the history of memory writes.

__init__(_* args_, _** kwargs_)¶
    

store(_addr_ , _data_ , _size =None_, _** kwargs_)¶
    

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

acquire_unique()¶
    

Call this function to return a version of this page which can be used for writing, which may or may not be the same object as before. If you use this you must immediately replace the shared reference you previously had with the new unique copy.

parents()¶
    

changed_bytes(_other_ , _** kwargs_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

all_bytes_changed_in_history()¶
    

Return type:
    

`SegmentList`

_class _angr.storage.memory_mixins.paged_memory.pages.ispo_mixin.ISPOMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

An implementation of the International Stateless Persons Organisation, a mixin which should be applied as a bottom layer for memories which have no state and must redirect certain operations to a parent memory. Main usecase is for memory region classes which are stored within other memories, such as pages.

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

_class _angr.storage.memory_mixins.paged_memory.pages.cooperation.CooperationBase¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`T`]

Any given subclass of this class which is not a subclass of MemoryMixin should have the property that any subclass it which _is_ a subclass of MemoryMixin should all work with the same datatypes

_class _angr.storage.memory_mixins.paged_memory.pages.cooperation.MemoryObjectMixin¶
    

Bases: `CooperationBase`[`SimMemoryObject`]

Uses SimMemoryObjects in region storage. With this, load will return a list of tuple (address, MO) and store will take a MO.

_class _angr.storage.memory_mixins.paged_memory.pages.cooperation.MemoryObjectSetMixin¶
    

Bases: `CooperationBase`

Uses sets of SimMemoryObjects in region storage.

_class _angr.storage.memory_mixins.paged_memory.pages.cooperation.BasicClaripyCooperation¶
    

Bases: `CooperationBase`

Mix this (along with PageBase) into a storage class which supports loading and storing claripy bitvectors and it will be able to work as a page in the paged memory model.

_class _angr.storage.memory_mixins.paged_memory.pages.list_page.ListPage(_memory =None_, _content =None_, _sinkhole =None_, _mo_cmp =None_, _** kwargs_)¶
    

Bases: `MemoryObjectMixin`, `PageBase`

This class implements a page memory mixin with lists as the main content store.

__init__(_memory =None_, _content =None_, _sinkhole =None_, _mo_cmp =None_, _** kwargs_)¶
    

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

load(_addr_ , _size =None_, _endness =None_, _page_addr =None_, _memory =None_, _cooperate =False_, _** kwargs_)¶
    

store(_addr_ , _data_ , _size =None_, _endness =None_, _memory =None_, _cooperate =False_, _** kwargs_)¶
    

erase(_addr_ , _size =None_, _** kwargs_)¶
    

Set [addr:addr+size) to uninitialized. In many cases this will be faster than overwriting those locations with new values. This is commonly used during static data flow analysis.

Parameters:
    

  * **addr** – The address to start erasing.

  * **size** – The number of bytes for erasing.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

None

merge(_others_ , _merge_conditions_ , _common_ancestor =None_, _page_addr =None_, _memory =None_, _changed_offsets =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** ([`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`ListPage`]) – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

  * **page_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **changed_offsets** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

changed_bytes(_other_ , _page_addr =None_)¶
    

Parameters:
    

  * **other** (_ListPage_)

  * **page_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

_class _angr.storage.memory_mixins.paged_memory.pages.ultra_page.UltraPage(_memory =None_, _init_zero =False_, _** kwargs_)¶
    

Bases: `MemoryObjectMixin`, `PageBase`

Default page implementation

SUPPORTS_CONCRETE_LOAD _: bool_ _ = True_¶
    

__init__(_memory =None_, _init_zero =False_, _** kwargs_)¶
    

_classmethod _new_from_shared(_data_ , _memory =None_, _** kwargs_)¶
    

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

load(_addr_ , _size =None_, _page_addr =None_, _endness =None_, _memory =None_, _cooperate =False_, _** kwargs_)¶
    

store(_addr_ , _data_ , _size =None_, _endness =None_, _memory =None_, _page_addr =None_, _cooperate =False_, _** kwargs_)¶
    

Parameters:
    

  * **data** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__SimMemoryObject_)

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_, _page_addr =None_, _memory =None_, _changed_offsets =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** ([`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`UltraPage`]) – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

  * **page_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **changed_offsets** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

concrete_load(_addr_ , _size_ , _writing =False_, _with_bitmap =False_, _** kwargs_)¶
    

Set SUPPORTS_CONCRETE_LOAD to True and implement concrete_load if reading concrete bytes is faster in this memory model.

Parameters:
    

  * **addr** – The address to load from.

  * **size** – Size of the memory read.

  * **writing**

Returns:
    

A memoryview into the loaded bytes.

changed_bytes(_other_ , _page_addr =None_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]

state _: angr.SimState_¶
    

replace_all_with_offsets(_offsets_ , _old_ , _new_ , _memory =None_)¶
    

Parameters:
    

  * **offsets** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]_)

  * **old** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **new** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

_class _angr.storage.memory_mixins.regioned_memory.AbstractMergerMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

AbstractMergerMixin handles merging initialized values.

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.storage.memory_mixins.regioned_memory.MemoryRegionMetaMixin(_related_function_addr =None_, _** kwargs_)¶
    

Bases: `MemoryMixin`

__init__(_related_function_addr =None_, _** kwargs_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

_property _is_stack¶
    

_property _related_function_addr¶
    

get_abstract_locations(_addr_ , _size_)¶
    

Get a list of abstract locations that is within the range of [addr, addr + size]

This implementation is pretty slow. But since this method won’t be called frequently, we can live with the bad implementation for now.

Parameters:
    

  * **addr** – Starting address of the memory region.

  * **size** – Size of the memory region, in bytes.

Returns:
    

A list of covered AbstractLocation objects, or an empty list if there is none.

store(_addr_ , _data_ , _size =None_, _*_ , _bbl_addr =None_, _stmt_id =None_, _ins_addr =None_, _endness =None_, _** kwargs_)¶
    

load(_addr_ , _size =None_, _*_ , _bbl_addr =None_, _stmt_idx =None_, _ins_addr =None_, _** kwargs_)¶
    

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

dbg_print(_indent =0_)¶
    

Print out debugging information

_class _angr.storage.memory_mixins.regioned_memory.RegionCategoryMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_property _category¶
    

reg, mem, or file.

Type:
    

Return the category of this SimMemory instance. It can be one of the three following categories

_class _angr.storage.memory_mixins.regioned_memory.RegionedAddressConcretizationMixin(_read_strategies =None_, _write_strategies =None_, _** kwargs_)¶
    

Bases: `MemoryMixin`

__init__(_read_strategies =None_, _write_strategies =None_, _** kwargs_)¶
    

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.storage.memory_mixins.regioned_memory.RegionedMemoryMixin(_write_targets_limit =2048_, _read_targets_limit =4096_, _stack_region_map =None_, _generic_region_map =None_, _stack_size =65536_, _cle_memory_backer =None_, _dict_memory_backer =None_, _regioned_memory_cls =None_, _** kwargs_)¶
    

Bases: `MemoryMixin`

Regioned memory. This mixin manages multiple memory regions. Each address is represented as a tuple of (region ID, offset into the region), which is called a regioned address.

Converting absolute addresses into regioned addresses: We map an absolute address to a region by looking up which region this address belongs to in the region map. Currently this is only enabled for stack. Heap support has not landed yet.

When start analyzing a function, the user should call set_stack_address_mapping() to create a new region mapping. Likewise, when exiting from a function, the user should cancel the previous mapping by calling unset_stack_address_mapping().

__init__(_write_targets_limit =2048_, _read_targets_limit =4096_, _stack_region_map =None_, _generic_region_map =None_, _stack_size =65536_, _cle_memory_backer =None_, _dict_memory_backer =None_, _regioned_memory_cls =None_, _** kwargs_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

load(_addr_ , _size =None_, _*_ , _endness =None_, _condition =None_, _** kwargs_)¶
    

Parameters:
    

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _|__None_)

  * **condition** ([_Bool_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bool.Bool "\(in claripy\)") _|__None_)

store(_addr_ , _data_ , _size =None_, _*_ , _endness =None_, _** kwargs_)¶
    

Parameters:
    

**size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

find(_addr_ , _data_ , _max_search_ , _** kwargs_)¶
    

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_Bits_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bits.Bits "\(in claripy\)"))

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

replace_all(_old_ , _new_)¶
    

Parameters:
    

  * **old** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **new** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

set_stack_address_mapping(_absolute_address_ , _region_id_ , _related_function_address =None_)¶
    

Create a new mapping between an absolute address (which is the base address of a specific stack frame) and a region ID.

Parameters:
    

  * **absolute_address** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The absolute memory address.

  * **region_id** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The region ID.

  * **related_function_address** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – Related function address.

unset_stack_address_mapping(_absolute_address_)¶
    

Remove a stack mapping.

Parameters:
    

**absolute_address** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – An absolute memory address that is the base address of the stack frame to destroy.

stack_id(_function_address_)¶
    

Return a memory region ID for a function. If the default region ID exists in the region mapping, an integer will appended to the region name. In this way we can handle recursive function calls, or a function that appears more than once in the call frame.

This also means that stack_id() should only be called when creating a new stack frame for a function. You are not supposed to call this function every time you want to map a function address to a stack ID.

Parameters:
    

**function_address** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function.

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

Returns:
    

ID of the new memory region.

set_stack_size(_size_)¶
    

Parameters:
    

**size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_class _angr.storage.memory_mixins.regioned_memory.StaticFindMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `SmartFindMixin`

Implements data finding for abstract memory.

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

find(_addr_ , _data_ , _max_search_ , _*_ , _default =None_, _endness =None_, _chunk_size =None_, _max_symbolic_bytes =None_, _condition =None_, _char_size =1_, _** kwargs_)¶
    

_class _angr.storage.memory_mixins.regioned_memory.regioned_memory_mixin.RegionedMemoryMixin(_write_targets_limit =2048_, _read_targets_limit =4096_, _stack_region_map =None_, _generic_region_map =None_, _stack_size =65536_, _cle_memory_backer =None_, _dict_memory_backer =None_, _regioned_memory_cls =None_, _** kwargs_)¶
    

Bases: `MemoryMixin`

Regioned memory. This mixin manages multiple memory regions. Each address is represented as a tuple of (region ID, offset into the region), which is called a regioned address.

Converting absolute addresses into regioned addresses: We map an absolute address to a region by looking up which region this address belongs to in the region map. Currently this is only enabled for stack. Heap support has not landed yet.

When start analyzing a function, the user should call set_stack_address_mapping() to create a new region mapping. Likewise, when exiting from a function, the user should cancel the previous mapping by calling unset_stack_address_mapping().

__init__(_write_targets_limit =2048_, _read_targets_limit =4096_, _stack_region_map =None_, _generic_region_map =None_, _stack_size =65536_, _cle_memory_backer =None_, _dict_memory_backer =None_, _regioned_memory_cls =None_, _** kwargs_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

load(_addr_ , _size =None_, _*_ , _endness =None_, _condition =None_, _** kwargs_)¶
    

Parameters:
    

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _|__None_)

  * **condition** ([_Bool_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bool.Bool "\(in claripy\)") _|__None_)

store(_addr_ , _data_ , _size =None_, _*_ , _endness =None_, _** kwargs_)¶
    

Parameters:
    

**size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

find(_addr_ , _data_ , _max_search_ , _** kwargs_)¶
    

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_Bits_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bits.Bits "\(in claripy\)"))

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

replace_all(_old_ , _new_)¶
    

Parameters:
    

  * **old** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **new** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

set_stack_address_mapping(_absolute_address_ , _region_id_ , _related_function_address =None_)¶
    

Create a new mapping between an absolute address (which is the base address of a specific stack frame) and a region ID.

Parameters:
    

  * **absolute_address** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The absolute memory address.

  * **region_id** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The region ID.

  * **related_function_address** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – Related function address.

unset_stack_address_mapping(_absolute_address_)¶
    

Remove a stack mapping.

Parameters:
    

**absolute_address** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – An absolute memory address that is the base address of the stack frame to destroy.

stack_id(_function_address_)¶
    

Return a memory region ID for a function. If the default region ID exists in the region mapping, an integer will appended to the region name. In this way we can handle recursive function calls, or a function that appears more than once in the call frame.

This also means that stack_id() should only be called when creating a new stack frame for a function. You are not supposed to call this function every time you want to map a function address to a stack ID.

Parameters:
    

**function_address** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function.

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

Returns:
    

ID of the new memory region.

set_stack_size(_size_)¶
    

Parameters:
    

**size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_class _angr.storage.memory_mixins.regioned_memory.region_data.AddressWrapper(_region_ , _region_base_addr_ , _address_ , _is_on_stack_ , _function_address_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

AddressWrapper is used in SimAbstractMemory, which provides extra meta information for an address (or a ValueSet object) that is normalized from an integer/BVV/StridedInterval.

Parameters:
    

  * **region** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **region_base_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **is_on_stack** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **function_address** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_region_ , _region_base_addr_ , _address_ , _is_on_stack_ , _function_address_)¶
    

Constructor for the class AddressWrapper.

Parameters:
    

  * **region** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of the memory regions it belongs to.

  * **region_base_addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Base address of the memory region

  * **address** – An address (not a ValueSet object).

  * **is_on_stack** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether this address is on a stack region or not.

  * **function_address** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")) – Related function address (if any).

region¶
    

region_base_addr¶
    

address¶
    

is_on_stack¶
    

function_address¶
    

to_valueset(_state_)¶
    

Convert to a ValueSet instance

Parameters:
    

**state** – A state

Returns:
    

The converted ValueSet instance

_class _angr.storage.memory_mixins.regioned_memory.region_data.RegionDescriptor(_region_id_ , _base_address_ , _related_function_address =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Descriptor for a memory region ID.

__init__(_region_id_ , _base_address_ , _related_function_address =None_)¶
    

region_id¶
    

base_address¶
    

related_function_address¶
    

_class _angr.storage.memory_mixins.regioned_memory.region_data.RegionMap(_is_stack_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Mostly used in SimAbstractMemory, RegionMap stores a series of mappings between concrete memory address ranges and memory regions, like stack frames and heap regions.

__init__(_is_stack_)¶
    

Constructor

Parameters:
    

**is_stack** – Whether this is a region map for stack frames or not. Different strategies apply for stack regions.

_property _is_empty¶
    

_property _stack_base¶
    

_property _region_ids¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

Parameters:
    

  * **memo** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]__|__None_)

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

map(_absolute_address_ , _region_id_ , _related_function_address =None_)¶
    

Add a mapping between an absolute address and a region ID. If this is a stack region map, all stack regions beyond (lower than) this newly added regions will be discarded.

Parameters:
    

  * **absolute_address** – An absolute memory address.

  * **region_id** – ID of the memory region.

  * **related_function_address** – A related function address, mostly used for stack regions.

unmap_by_address(_absolute_address_)¶
    

Removes a mapping based on its absolute address.

Parameters:
    

**absolute_address** – An absolute address

absolutize(_region_id_ , _relative_address_)¶
    

Convert a relative address in some memory region to an absolute address.

Parameters:
    

  * **region_id** – The memory region ID

  * **relative_address** – The relative memory offset in that memory region

Returns:
    

An absolute address if converted, or an exception is raised when region id does not exist.

relativize(_absolute_address_ , _target_region_id =None_)¶
    

Convert an absolute address to the memory offset in a memory region.

Note that if an address belongs to heap region is passed in to a stack region map, it will be converted to an offset included in the closest stack frame, and vice versa for passing a stack address to a heap region. Therefore you should only pass in address that belongs to the same category (stack or non-stack) of this region map.

Parameters:
    

**absolute_address** – An absolute memory address

Returns:
    

A tuple of the closest region ID, the relative offset, and the related function address.

_class _angr.storage.memory_mixins.regioned_memory.region_category_mixin.RegionCategoryMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_property _category¶
    

reg, mem, or file.

Type:
    

Return the category of this SimMemory instance. It can be one of the three following categories

_class _angr.storage.memory_mixins.regioned_memory.static_find_mixin.StaticFindMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `SmartFindMixin`

Implements data finding for abstract memory.

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

find(_addr_ , _data_ , _max_search_ , _*_ , _default =None_, _endness =None_, _chunk_size =None_, _max_symbolic_bytes =None_, _condition =None_, _char_size =1_, _** kwargs_)¶
    

_class _angr.storage.memory_mixins.regioned_memory.abstract_address_descriptor.AbstractAddressDescriptor¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

AbstractAddressDescriptor describes a list of region+offset tuples. It provides a convenient way for accessing the cardinality (the total number of addresses) without enumerating or creating all addresses in static mode.

__init__()¶
    

_property _cardinality¶
    

add_regioned_address(_region_ , _addr_)¶
    

Parameters:
    

  * **region** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **addr** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

clear()¶
    

_class _angr.storage.memory_mixins.regioned_memory.region_meta_mixin.Segment(_offset_ , _size =0_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Segment represents a continuous memory region.

__init__(_offset_ , _size =0_)¶
    

_class _angr.storage.memory_mixins.regioned_memory.region_meta_mixin.AbstractLocation(_bbl_key_ , _stmt_id_ , _region_id_ , _segment_list =None_, _region_offset =None_, _size =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

AbstractLocation represents a location in memory.

__init__(_bbl_key_ , _stmt_id_ , _region_id_ , _segment_list =None_, _region_offset =None_, _size =None_)¶
    

_property _basicblock_key¶
    

_property _statement_id¶
    

_property _region¶
    

_property _segments¶
    

update(_region_offset_ , _size_)¶
    

copy()¶
    

merge(_other_)¶
    

_class _angr.storage.memory_mixins.regioned_memory.region_meta_mixin.MemoryRegionMetaMixin(_related_function_addr =None_, _** kwargs_)¶
    

Bases: `MemoryMixin`

__init__(_related_function_addr =None_, _** kwargs_)¶
    

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

_property _is_stack¶
    

_property _related_function_addr¶
    

get_abstract_locations(_addr_ , _size_)¶
    

Get a list of abstract locations that is within the range of [addr, addr + size]

This implementation is pretty slow. But since this method won’t be called frequently, we can live with the bad implementation for now.

Parameters:
    

  * **addr** – Starting address of the memory region.

  * **size** – Size of the memory region, in bytes.

Returns:
    

A list of covered AbstractLocation objects, or an empty list if there is none.

store(_addr_ , _data_ , _size =None_, _*_ , _bbl_addr =None_, _stmt_id =None_, _ins_addr =None_, _endness =None_, _** kwargs_)¶
    

load(_addr_ , _size =None_, _*_ , _bbl_addr =None_, _stmt_idx =None_, _ins_addr =None_, _** kwargs_)¶
    

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

widen(_others_)¶
    

The widening operation for plugins. Widening is a special kind of merging that produces a more general state from several more specific states. It is used only during intensive static analysis. The same behavior regarding copying and mutation from `merge` should be followed.

Parameters:
    

**others** – the other state plugin

Returns:
    

True if the state plugin is actually widened.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

dbg_print(_indent =0_)¶
    

Print out debugging information

_class _angr.storage.memory_mixins.regioned_memory.abstract_merger_mixin.AbstractMergerMixin(_memory_id =None_, _endness ='Iend_BE'_)¶
    

Bases: `MemoryMixin`

AbstractMergerMixin handles merging initialized values.

Parameters:
    

  * **memory_id** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.storage.memory_mixins.regioned_memory.regioned_address_concretization_mixin.RegionedAddressConcretizationMixin(_read_strategies =None_, _write_strategies =None_, _** kwargs_)¶
    

Bases: `MemoryMixin`

__init__(_read_strategies =None_, _write_strategies =None_, _** kwargs_)¶
    

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

copy(_memo : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")] | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") = None_, _** kwargs: [Any](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_) → S_co¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

  * **memo** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`S_co`, covariant=True)

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.storage.memory_mixins.slotted_memory.SlottedMemoryMixin(_width =None_, _** kwargs_)¶
    

Bases: `MemoryMixin`

__init__(_width =None_, _** kwargs_)¶
    

set_state(_state_)¶
    

Sets a new state (for example, if the state has been branched)

copy(_memo_)¶
    

Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to memo if it ends up making a new copy.

In order to simplify using the memo, you should annotate implementations of this function with `SimStatePlugin.memo`

The base implementation of this function constructs a new instance of the plugin’s class without calling its initializer. If you super-call down to it, make sure you instantiate all the fields in your copy method!

Parameters:
    

**memo** – A dictionary mapping object identifiers (id(obj)) to their copied instance. Use this to avoid infinite recursion and diverged copies.

merge(_others_ , _merge_conditions_ , _common_ancestor =None_)¶
    

Should merge the state plugin with the provided others. This will be called by `state.merge()` after copying the target state, so this should mutate the current instance to merge with the others.

Note that when multiple instances of a single plugin object (for example, a file) are referenced in the state, it is important that merge only ever be called once. This should be solved by designating one of the plugin’s referees as the “real owner”, who should be the one to actually merge it. This technique doesn’t work to resolve the similar issue that arises during copying because merging doesn’t produce a new reference to insert.

There will be n `others` and n+1 merge conditions, since the first condition corresponds to self. To match elements up to conditions, say `zip([self] + others, merge_conditions)`

When implementing this, make sure that you “deepen” both `others` and `common_ancestor` before calling sub-elements’ merge methods, e.g.
    
    
    self.foo.merge(
        [o.foo for o in others],
        merge_conditions,
        common_ancestor=common_ancestor.foo if common_ancestor is not None else None
    )
    

During static analysis, merge_conditions can be None, in which case you should use `state.solver.union(values)`. TODO: fish please make this less bullshit

There is a utility `claripy.ite_cases` which will help with constructing arbitrarily large merged ASTs. Use it like `self.bar = claripy.ite_cases(zip(conditions[1:], [o.bar for o in others]), self.bar)`

Parameters:
    

  * **others** – the other state plugins to merge with

  * **merge_conditions** – a symbolic condition for each of the plugins

  * **common_ancestor** – a common ancestor of this plugin and the others being merged

Returns:
    

True if the state plugins are actually merged.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

load(_addr_ , _size =None_, _*_ , _endness =None_, _** kwargs_)¶
    

store(_addr_ , _data_ , _size =None_, _*_ , _endness =None_, _** kwargs_)¶
    

changed_bytes(_other_)¶
    

## Concretization Strategies¶

_class _angr.concretization_strategies.single.SimConcretizationStrategySingle(_filter =None_, _exact =True_)¶
    

Bases: `SimConcretizationStrategy`

Concretization strategy that ensures a single solution for an address.

_class _angr.concretization_strategies.eval.SimConcretizationStrategyEval(_limit_ , _** kwargs_)¶
    

Bases: `SimConcretizationStrategy`

Concretization strategy that resolves an address into some limited number of solutions. Always handles the concretization, but only returns a maximum of limit number of solutions. Therefore, should only be used as the fallback strategy.

__init__(_limit_ , _** kwargs_)¶
    

Initializes the base SimConcretizationStrategy.

Parameters:
    

  * **filter** – A function, taking arguments of (SimMemory, claripy.AST) that determines if this strategy can handle resolving the provided AST.

  * **exact** – A flag (default: True) that determines if the convenience resolution functions provided by this class use exact or approximate resolution.

_class _angr.concretization_strategies.norepeats.SimConcretizationStrategyNorepeats(_repeat_expr_ , _repeat_constraints =None_, _** kwargs_)¶
    

Bases: `SimConcretizationStrategy`

Concretization strategy that resolves addresses, without repeating.

__init__(_repeat_expr_ , _repeat_constraints =None_, _** kwargs_)¶
    

Initializes the base SimConcretizationStrategy.

Parameters:
    

  * **filter** – A function, taking arguments of (SimMemory, claripy.AST) that determines if this strategy can handle resolving the provided AST.

  * **exact** – A flag (default: True) that determines if the convenience resolution functions provided by this class use exact or approximate resolution.

copy()¶
    

Returns a copy of the strategy, if there is data that should be kept separate between states. If not, returns self.

merge(_others_)¶
    

Merges this strategy with others (if there is data that should be kept separate between states. If not, is a no-op.

_class _angr.concretization_strategies.solutions.SimConcretizationStrategySolutions(_limit_ , _** kwargs_)¶
    

Bases: `SimConcretizationStrategy`

Concretization strategy that resolves an address into some limited number of solutions.

__init__(_limit_ , _** kwargs_)¶
    

Initializes the base SimConcretizationStrategy.

Parameters:
    

  * **filter** – A function, taking arguments of (SimMemory, claripy.AST) that determines if this strategy can handle resolving the provided AST.

  * **exact** – A flag (default: True) that determines if the convenience resolution functions provided by this class use exact or approximate resolution.

_class _angr.concretization_strategies.nonzero_range.SimConcretizationStrategyNonzeroRange(_limit_ , _** kwargs_)¶
    

Bases: `SimConcretizationStrategy`

Concretization strategy that resolves a range in a non-zero location.

__init__(_limit_ , _** kwargs_)¶
    

Initializes the base SimConcretizationStrategy.

Parameters:
    

  * **filter** – A function, taking arguments of (SimMemory, claripy.AST) that determines if this strategy can handle resolving the provided AST.

  * **exact** – A flag (default: True) that determines if the convenience resolution functions provided by this class use exact or approximate resolution.

_class _angr.concretization_strategies.range.SimConcretizationStrategyRange(_limit_ , _** kwargs_)¶
    

Bases: `SimConcretizationStrategy`

Concretization strategy that resolves addresses to a range.

__init__(_limit_ , _** kwargs_)¶
    

Initializes the base SimConcretizationStrategy.

Parameters:
    

  * **filter** – A function, taking arguments of (SimMemory, claripy.AST) that determines if this strategy can handle resolving the provided AST.

  * **exact** – A flag (default: True) that determines if the convenience resolution functions provided by this class use exact or approximate resolution.

_class _angr.concretization_strategies.max.SimConcretizationStrategyMax(_max_addr =None_)¶
    

Bases: `SimConcretizationStrategy`

Concretization strategy that returns the maximum address.

Parameters:
    

**max_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_max_addr =None_)¶
    

Initializes the base SimConcretizationStrategy.

Parameters:
    

  * **filter** – A function, taking arguments of (SimMemory, claripy.AST) that determines if this strategy can handle resolving the provided AST.

  * **exact** – A flag (default: True) that determines if the convenience resolution functions provided by this class use exact or approximate resolution.

  * **max_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

_class _angr.concretization_strategies.norepeats_range.SimConcretizationStrategyNorepeatsRange(_repeat_expr_ , _min =None_, _granularity =None_, _** kwargs_)¶
    

Bases: `SimConcretizationStrategy`

Concretization strategy that resolves a range, with no repeats.

__init__(_repeat_expr_ , _min =None_, _granularity =None_, _** kwargs_)¶
    

Initializes the base SimConcretizationStrategy.

Parameters:
    

  * **filter** – A function, taking arguments of (SimMemory, claripy.AST) that determines if this strategy can handle resolving the provided AST.

  * **exact** – A flag (default: True) that determines if the convenience resolution functions provided by this class use exact or approximate resolution.

copy()¶
    

Returns a copy of the strategy, if there is data that should be kept separate between states. If not, returns self.

merge(_others_)¶
    

Merges this strategy with others (if there is data that should be kept separate between states. If not, is a no-op.

_class _angr.concretization_strategies.nonzero.SimConcretizationStrategyNonzero(_filter =None_, _exact =True_)¶
    

Bases: `SimConcretizationStrategy`

Concretization strategy that returns any non-zero solution.

_class _angr.concretization_strategies.any.SimConcretizationStrategyAny(_filter =None_, _exact =True_)¶
    

Bases: `SimConcretizationStrategy`

Concretization strategy that returns any single solution.

_class _angr.concretization_strategies.controlled_data.SimConcretizationStrategyControlledData(_limit_ , _fixed_addrs_ , _** kwargs_)¶
    

Bases: `SimConcretizationStrategy`

Concretization strategy that constraints the address to controlled data. Controlled data consists of symbolic data and the addresses given as arguments. memory.

__init__(_limit_ , _fixed_addrs_ , _** kwargs_)¶
    

Initializes the base SimConcretizationStrategy.

Parameters:
    

  * **filter** – A function, taking arguments of (SimMemory, claripy.AST) that determines if this strategy can handle resolving the provided AST.

  * **exact** – A flag (default: True) that determines if the convenience resolution functions provided by this class use exact or approximate resolution.

_class _angr.concretization_strategies.unlimited_range.SimConcretizationStrategyUnlimitedRange(_limit_ , _** kwargs_)¶
    

Bases: `SimConcretizationStrategy`

Concretization strategy that resolves addresses to a range without checking if the number of possible addresses is within the limit.

__init__(_limit_ , _** kwargs_)¶
    

Initializes the base SimConcretizationStrategy.

Parameters:
    

  * **filter** – A function, taking arguments of (SimMemory, claripy.AST) that determines if this strategy can handle resolving the provided AST.

  * **exact** – A flag (default: True) that determines if the convenience resolution functions provided by this class use exact or approximate resolution.

## Simulation Manager¶

_class _angr.sim_manager.SimulationManager(_project_ , _active_states=None_ , _stashes=None_ , _hierarchy=None_ , _resilience=None_ , _save_unsat=False_ , _auto_drop=None_ , _errored=None_ , _completion_mode= <built-in function any>_, _techniques=None_ , _suggestions=True_ , _**kwargs_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

The Simulation Manager is the future future.

Simulation managers allow you to wrangle multiple states in a slick way. States are organized into “stashes”, which you can step forward, filter, merge, and move around as you wish. This allows you to, for example, step two different stashes of states at different rates, then merge them together.

Stashes can be accessed as attributes (i.e. .active). A mulpyplexed stash can be retrieved by prepending the name with mp_, e.g. .mp_active. A single state from the stash can be retrieved by prepending the name with one_, e.g. .one_active.

Note that you shouldn’t usually be constructing SimulationManagers directly - there is a convenient shortcut for creating them in `Project.factory`: see `angr.factory.AngrObjectFactory`.

The most important methods you should look at are `step`, `explore`, and `use_technique`.

Parameters:
    

  * **project** (_angr.project.Project_) – A Project instance.

  * **stashes** – A dictionary to use as the stash store.

  * **active_states** – Active states to seed the “active” stash with.

  * **hierarchy** – A StateHierarchy object to use to track the relationships between states.

  * **resilience** – A set of errors to catch during stepping to put a state in the `errore` list. You may also provide the values False, None (default), or True to catch, respectively, no errors, all angr-specific errors, and a set of many common errors.

  * **save_unsat** – Set to True in order to introduce unsatisfiable states into the `unsat` stash instead of discarding them immediately.

  * **auto_drop** – A set of stash names which should be treated as garbage chutes.

  * **completion_mode** – A function describing how multiple exploration techniques with the `complete` hook set will interact. By default, the builtin function `any`.

  * **techniques** – A list of techniques that should be pre-set to use with this manager.

  * **suggestions** – Whether to automatically install the Suggestions exploration technique. Default True.

Variables:
    

  * **errored** – Not a stash, but a list of ErrorRecords. Whenever a step raises an exception that we catch, the state and some information about the error are placed in this list. You can adjust the list of caught exceptions with the resilience parameter.

  * **stashes** – All the stashes on this instance, as a dictionary.

  * **completion_mode** – A function describing how multiple exploration techniques with the `complete` hook set will interact. By default, the builtin function `any`.

ALL _ = '_ALL'_¶
    

DROP _ = '_DROP'_¶
    

__init__(_project_ , _active_states=None_ , _stashes=None_ , _hierarchy=None_ , _resilience=None_ , _save_unsat=False_ , _auto_drop=None_ , _errored=None_ , _completion_mode= <built-in function any>_, _techniques=None_ , _suggestions=True_ , _**kwargs_)¶
    

active _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`SimState`]_¶
    

stashed _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`SimState`]_¶
    

pruned _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`SimState`]_¶
    

unsat _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`SimState`]_¶
    

deadended _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`SimState`]_¶
    

unconstrained _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`SimState`]_¶
    

found _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`SimState`]_¶
    

one_active _: `SimState`_¶
    

one_stashed _: `SimState`_¶
    

one_pruned _: `SimState`_¶
    

one_unsat _: `SimState`_¶
    

one_deadended _: `SimState`_¶
    

one_unconstrained _: `SimState`_¶
    

one_found _: `SimState`_¶
    

_property _errored _: [list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[ErrorRecord]_¶
    

_property _stashes _: [defaultdict](https://docs.python.org/3/library/collections.html#collections.defaultdict "\(in Python v3.13\)")[[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"), [list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[SimState]]_¶
    

mulpyplex(_* stashes_)¶
    

Mulpyplex across several stashes.

Parameters:
    

**stashes** – the stashes to mulpyplex

Returns:
    

a mulpyplexed list of states from the stashes in question, in the specified order

copy(_deep =False_)¶
    

Make a copy of this simulation manager. Pass `deep=True` to copy all the states in it as well.

If the current callstack includes hooked methods, the already-called methods will not be included in the copy.

use_technique(_tech_)¶
    

Use an exploration technique with this SimulationManager.

Techniques can be found in `angr.exploration_techniques`.

Parameters:
    

**tech** (_ExplorationTechnique_) – An ExplorationTechnique object that contains code to modify this SimulationManager’s behavior.

Returns:
    

The technique that was added, for convenience

remove_technique(_tech_)¶
    

Remove an exploration technique from a list of active techniques.

Parameters:
    

**tech** (_ExplorationTechnique_) – An ExplorationTechnique object.

explore(_stash ='active'_, _n =None_, _find =None_, _avoid =None_, _find_stash ='found'_, _avoid_stash ='avoid'_, _cfg =None_, _num_find =1_, _avoid_priority =False_, _** kwargs_)¶
    

Tick stash “stash” forward (up to “n” times or until “num_find” states are found), looking for condition “find”, avoiding condition “avoid”. Stores found states into “find_stash’ and avoided states into “avoid_stash”.

The “find” and “avoid” parameters may be any of:

  * An address to find

  * A set or list of addresses to find

  * A function that takes a state and returns whether or not it matches.

If an angr CFG is passed in as the “cfg” parameter and “find” is either a number or a list or a set, then any states which cannot possibly reach a success state without going through a failure state will be preemptively avoided.

run(_stash ='active'_, _n =None_, _until =None_, _** kwargs_)¶
    

Run until the SimulationManager has reached a completed state, according to the current exploration techniques. If no exploration techniques that define a completion state are being used, run until there is nothing left to run.

Parameters:
    

  * **stash** – Operate on this stash

  * **n** – Step at most this many times

  * **until** – If provided, should be a function that takes a SimulationManager and returns True or False. Stepping will terminate when it is True.

Returns:
    

The simulation manager, for chaining.

Return type:
    

SimulationManager

complete()¶
    

Returns whether or not this manager has reached a “completed” state.

step(_stash ='active'_, _target_stash =None_, _n =None_, _selector_func =None_, _step_func =None_, _error_list =None_, _successor_func =None_, _until =None_, _filter_func =None_, _** run_args_)¶
    

Step a stash of states forward and categorize the successors appropriately.

The parameters to this function allow you to control everything about the stepping and categorization process.

Parameters:
    

  * **stash** – The name of the stash to step (default: ‘active’)

  * **target_stash** – The name of the stash to put the results in (default: same as `stash`)

  * **error_list** – The list to put ErrorRecord objects in (default: `self.errored`)

  * **selector_func** – If provided, should be a function that takes a state and returns a boolean. If True, the state will be stepped. Otherwise, it will be kept as-is.

  * **step_func** – If provided, should be a function that takes a SimulationManager and returns a SimulationManager. Will be called with the SimulationManager at every step. Note that this function should not actually perform any stepping - it is meant to be a maintenance function called after each step.

  * **successor_func** – If provided, should be a function that takes a state and return its successors. Otherwise, project.factory.successors will be used.

  * **filter_func** – If provided, should be a function that takes a state and return the name of the stash, to which the state should be moved.

  * **until** – (DEPRECATED) If provided, should be a function that takes a SimulationManager and returns True or False. Stepping will terminate when it is True.

  * **n** – (DEPRECATED) The number of times to step (default: 1 if “until” is not provided)

Additionally, you can pass in any of the following keyword args for project.factory.successors:

Parameters:
    

  * **jumpkind** – The jumpkind of the previous exit

  * **addr** – An address to execute at instead of the state’s ip.

  * **stmt_whitelist** – A list of stmt indexes to which to confine execution.

  * **last_stmt** – A statement index at which to stop execution.

  * **thumb** – Whether the block should be lifted in ARM’s THUMB mode.

  * **backup_state** – A state to read bytes from instead of using project memory.

  * **opt_level** – The VEX optimization level to use.

  * **insn_bytes** – A string of bytes to use for the block instead of the project.

  * **size** – The maximum size of the block, in bytes.

  * **num_inst** – The maximum number of instructions.

  * **traceflags** – traceflags to be passed to VEX. Default: 0

Returns:
    

The simulation manager, for chaining.

Return type:
    

SimulationManager

step_state(_state_ , _successor_func =None_, _error_list =None_, _** run_args_)¶
    

Don’t use this function manually - it is meant to interface with exploration techniques.

filter(_state_ , _filter_func =None_)¶
    

Don’t use this function manually - it is meant to interface with exploration techniques.

selector(_state_ , _selector_func =None_)¶
    

Don’t use this function manually - it is meant to interface with exploration techniques.

successors(_state_ , _successor_func =None_, _** run_args_)¶
    

Don’t use this function manually - it is meant to interface with exploration techniques.

prune(_filter_func =None_, _from_stash ='active'_, _to_stash ='pruned'_)¶
    

Prune unsatisfiable states from a stash.

This function will move all unsatisfiable states in the given stash into a different stash.

Parameters:
    

  * **filter_func** – Only prune states that match this filter.

  * **from_stash** – Prune states from this stash. (default: ‘active’)

  * **to_stash** – Put pruned states in this stash. (default: ‘pruned’)

Returns:
    

The simulation manager, for chaining.

Return type:
    

SimulationManager

populate(_stash_ , _states_)¶
    

Populate a stash with a collection of states.

Parameters:
    

  * **stash** – A stash to populate.

  * **states** – A list of states with which to populate the stash.

absorb(_simgr_)¶
    

Collect all the states from `simgr` and put them in their corresponding stashes in this manager. This will not modify `simgr`.

move(_from_stash_ , _to_stash_ , _filter_func =None_)¶
    

Move states from one stash to another.

Parameters:
    

  * **from_stash** – Take matching states from this stash.

  * **to_stash** – Put matching states into this stash.

  * **filter_func** – Stash states that match this filter. Should be a function that takes a state and returns True or False. (default: stash all states)

Returns:
    

The simulation manager, for chaining.

Return type:
    

SimulationManager

stash(_filter_func =None_, _from_stash ='active'_, _to_stash ='stashed'_)¶
    

Stash some states. This is an alias for move(), with defaults for the stashes.

Parameters:
    

  * **filter_func** – Stash states that match this filter. Should be a function that takes a state and returns True or False. (default: stash all states)

  * **from_stash** – Take matching states from this stash. (default: ‘active’)

  * **to_stash** – Put matching states into this stash. (default: ‘stashed’)

Returns:
    

The simulation manager, for chaining.

Return type:
    

SimulationManager

unstash(_filter_func =None_, _to_stash ='active'_, _from_stash ='stashed'_)¶
    

Unstash some states. This is an alias for move(), with defaults for the stashes.

Parameters:
    

  * **filter_func** – Unstash states that match this filter. Should be a function that takes a state and returns True or False. (default: unstash all states)

  * **from_stash** – take matching states from this stash. (default: ‘stashed’)

  * **to_stash** – put matching states into this stash. (default: ‘active’)

Returns:
    

The simulation manager, for chaining.

Return type:
    

SimulationManager

drop(_filter_func =None_, _stash ='active'_)¶
    

Drops states from a stash. This is an alias for move(), with defaults for the stashes.

Parameters:
    

  * **filter_func** – Drop states that match this filter. Should be a function that takes a state and returns True or False. (default: drop all states)

  * **stash** – Drop matching states from this stash. (default: ‘active’)

Returns:
    

The simulation manager, for chaining.

Return type:
    

SimulationManager

apply(_state_func =None_, _stash_func =None_, _stash ='active'_, _to_stash =None_)¶
    

Applies a given function to a given stash.

Parameters:
    

  * **state_func** – A function to apply to every state. Should take a state and return a state. The returned state will take the place of the old state. If the function _doesn’t_ return a state, the old state will be used. If the function returns a list of states, they will replace the original states.

  * **stash_func** – A function to apply to the whole stash. Should take a list of states and return a list of states. The resulting list will replace the stash. If both state_func and stash_func are provided state_func is applied first, then stash_func is applied on the results.

  * **stash** – A stash to work with.

  * **to_stash** – If specified, this stash will be used to store the resulting states instead.

Returns:
    

The simulation manager, for chaining.

Return type:
    

SimulationManager

split(_stash_splitter =None_, _stash_ranker =None_, _state_ranker =None_, _limit =8_, _from_stash ='active'_, _to_stash ='stashed'_)¶
    

Split a stash of states into two stashes depending on the specified options.

The stash from_stash will be split into two stashes depending on the other options passed in. If to_stash is provided, the second stash will be written there.

stash_splitter overrides stash_ranker, which in turn overrides state_ranker. If no functions are provided, the states are simply split according to the limit.

The sort done with state_ranker is ascending.

Parameters:
    

  * **stash_splitter** – A function that should take a list of states and return a tuple of two lists (the two resulting stashes).

  * **stash_ranker** – A function that should take a list of states and return a sorted list of states. This list will then be split according to “limit”.

  * **state_ranker** – An alternative to stash_splitter. States will be sorted with outputs of this function, which are to be used as a key. The first “limit” of them will be kept, the rest split off.

  * **limit** – For use with state_ranker. The number of states to keep. Default: 8

  * **from_stash** – The stash to split (default: ‘active’)

  * **to_stash** – The stash to write to (default: ‘stashed’)

Returns:
    

The simulation manager, for chaining.

Return type:
    

SimulationManager

merge(_merge_func =None_, _merge_key =None_, _stash ='active'_, _prune =True_)¶
    

Merge the states in a given stash.

Parameters:
    

  * **stash** – The stash (default: ‘active’)

  * **merge_func** – If provided, instead of using state.merge, call this function with the states as the argument. Should return the merged state.

  * **merge_key** – If provided, should be a function that takes a state and returns a key that will compare equal for all states that are allowed to be merged together, as a first approximation. By default: uses PC, callstack, and open file descriptors.

  * **prune** – Whether to prune the stash prior to merging it

Returns:
    

The simulation manager, for chaining.

Return type:
    

SimulationManager

_class _angr.sim_manager.ErrorRecord(_state_ , _error_ , _traceback_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A container class for a state and an error that was thrown during its execution. You can find these in SimulationManager.errored.

Variables:
    

  * **state** – The state that encountered an error, at the point in time just before the erroring step began.

  * **error** – The error that was thrown.

  * **traceback** – The traceback for the error that was thrown.

__init__(_state_ , _error_ , _traceback_)¶
    

debug()¶
    

Launch a postmortem debug shell at the site of the error.

reraise()¶
    

_class _angr.state_hierarchy.StateHierarchy¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

The state hierarchy holds weak references to SimStateHistory objects in a directed acyclic graph. It is useful for queries about a state’s ancestry, notably “what is the best ancestor state for a merge among these states” and “what is the most recent unsatisfiable state while using LAZY_SOLVES”

__init__()¶
    

get_ref(_obj_)¶
    

dead_ref(_ref_)¶
    

defer_cleanup()¶
    

add_state(_s_)¶
    

add_history(_h_)¶
    

simplify()¶
    

full_simplify()¶
    

lineage(_h_)¶
    

Returns the lineage of histories leading up to h.

all_successors(_h_)¶
    

history_successors(_h_)¶
    

history_predecessors(_h_)¶
    

history_contains(_h_)¶
    

unreachable_state(_state_)¶
    

unreachable_history(_h_)¶
    

most_mergeable(_states_)¶
    

Find the “most mergeable” set of states from those provided.

Parameters:
    

**states** – a list of states

Returns:
    

a tuple of: (list of states to merge, those states’ common history, list of states to not merge yet)

## Exploration Techniques¶

_class _angr.exploration_techniques.DFS(_deferred_stash ='deferred'_)¶
    

Bases: `ExplorationTechnique`

Depth-first search.

Will only keep one path active at a time, any others will be stashed in the ‘deferred’ stash. When we run out of active paths to step, we take the longest one from deferred and continue.

__init__(_deferred_stash ='deferred'_)¶
    

setup(_simgr_)¶
    

Perform any initialization on this manager you might need to do.

Parameters:
    

**simgr** (_angr.SimulationManager_) – The simulation manager to which you have just been added

step(_simgr_ , _stash ='active'_, _** kwargs_)¶
    

Hook the process of stepping a stash forward. Should call `simgr.step(stash, **kwargs)` in order to do the actual processing.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.exploration_techniques.Bucketizer¶
    

Bases: `ExplorationTechnique`

Loop bucketization: Pick log(n) paths out of n possible paths, and stash (or drop) everything else.

successors(_simgr_ , _state_ , _** kwargs_)¶
    

Perform the process of stepping a state forward, returning a SimSuccessors object.

To defer to the original succession procedure, return the result of `simgr.successors(state, **kwargs)`. Be careful about not calling this method (e.g. calling `project.factory.successors` manually) as it denies other hooks the opportunity to instrument the step. Instead, you can mutate the kwargs for the step before calling the original, and mutate the result before returning it yourself.

If the user provided a `successor_func` in their step or run command, it will appear here.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

_class _angr.exploration_techniques.CallFunctionGoal(_function_ , _arguments_)¶
    

Bases: `BaseGoal`

A goal that prioritizes states reaching certain function, and optionally with specific arguments. Note that constraints on arguments (and on function address as well) have to be identifiable on an accurate CFG. For example, you may have a CallFunctionGoal saying “call printf with the first argument being ‘Hello, world’”, and CFGEmulated must be able to figure our the first argument to printf is in fact “Hello, world”, not some symbolic strings that will be constrained to “Hello, world” during symbolic execution (or simulation, however you put it).

REQUIRE_CFG_STATES _ = True_¶
    

__init__(_function_ , _arguments_)¶
    

check(_cfg_ , _state_ , _peek_blocks_)¶
    

Check if the specified function will be reached with certain arguments.

Parameters:
    

  * **cfg**

  * **state**

  * **peek_blocks**

Returns:
    

check_state(_state_)¶
    

Check if the specific function is reached with certain arguments

Parameters:
    

**state** (_angr.SimState_) – The state to check

Returns:
    

True if the function is reached with certain arguments, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.exploration_techniques.Director(_peek_blocks =100_, _peek_functions =5_, _goals =None_, _cfg_keep_states =False_, _goal_satisfied_callback =None_, _num_fallback_states =5_)¶
    

Bases: `ExplorationTechnique`

An exploration technique for directed symbolic execution.

A control flow graph (using CFGEmulated) is built and refined during symbolic execution. Each time the execution reaches a block that is outside of the CFG, the CFG recovery will be triggered with that state, with a maximum recovery depth (100 by default). If we see a basic block during state stepping that is not yet in the control flow graph, we go back to control flow graph recovery and “peek” more blocks forward.

When stepping a simulation manager, all states are categorized into three different categories:

  * Might reach the destination within the peek depth. Those states are prioritized.

  * Will not reach the destination within the peek depth. Those states are de-prioritized. However, there is a little chance for those states to be explored as well in order to prevent over-fitting.

__init__(_peek_blocks =100_, _peek_functions =5_, _goals =None_, _cfg_keep_states =False_, _goal_satisfied_callback =None_, _num_fallback_states =5_)¶
    

Constructor.

step(_simgr_ , _stash ='active'_, _** kwargs_)¶
    

Parameters:
    

  * **simgr**

  * **stash**

  * **kwargs**

Returns:
    

add_goal(_goal_)¶
    

Add a goal.

Parameters:
    

**goal** (_BaseGoal_) – The goal to add.

Returns:
    

None

_class _angr.exploration_techniques.DrillerCore(_trace_ , _fuzz_bitmap =None_)¶
    

Bases: `ExplorationTechnique`

An exploration technique that symbolically follows an input looking for new state transitions.

It has to be used with Tracer exploration technique. Results are put in ‘diverted’ stash.

__init__(_trace_ , _fuzz_bitmap =None_)¶
    

:param trace : The basic block trace. :type fuzz_bitmap: :param fuzz_bitmap: AFL’s bitmap of state transitions. Defaults to saying every transition is worth satisfying.

setup(_simgr_)¶
    

Perform any initialization on this manager you might need to do.

Parameters:
    

**simgr** (_angr.SimulationManager_) – The simulation manager to which you have just been added

step(_simgr_ , _stash ='active'_, _** kwargs_)¶
    

Hook the process of stepping a stash forward. Should call `simgr.step(stash, **kwargs)` in order to do the actual processing.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.exploration_techniques.ExecuteAddressGoal(_addr_)¶
    

Bases: `BaseGoal`

A goal that prioritizes states reaching (or are likely to reach) certain address in some specific steps.

__init__(_addr_)¶
    

check(_cfg_ , _state_ , _peek_blocks_)¶
    

Check if the specified address will be executed

Parameters:
    

  * **cfg**

  * **state**

  * **peek_blocks** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

Returns:
    

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

check_state(_state_)¶
    

Check if the current address is the target address.

Parameters:
    

**state** (_angr.SimState_) – The state to check.

Returns:
    

True if the current address is the target address, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.exploration_techniques.ExplorationTechnique¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

An ExplorationTechnique is a set of hooks for a simulation manager that assists in the implementation of new techniques in symbolic exploration.

Any number of these methods may be overridden by a subclass. To use an exploration technique, call `simgr.use_technique` with an _instance_ of the technique.

__init__()¶
    

setup(_simgr_)¶
    

Perform any initialization on this manager you might need to do.

Parameters:
    

**simgr** (_angr.SimulationManager_) – The simulation manager to which you have just been added

step(_simgr_ , _stash ='active'_, _** kwargs_)¶
    

Hook the process of stepping a stash forward. Should call `simgr.step(stash, **kwargs)` in order to do the actual processing.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

filter(_simgr_ , _state_ , _** kwargs_)¶
    

Perform filtering on which stash a state should be inserted into.

If the state should be filtered, return the name of the stash to move the state to. If you want to modify the state before filtering it, return a tuple of the stash to move the state to and the modified state. To defer to the original categorization procedure, return the result of `simgr.filter(state, **kwargs)`

If the user provided a `filter_func` in their step or run command, it will appear here.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

selector(_simgr_ , _state_ , _** kwargs_)¶
    

Determine if a state should participate in the current round of stepping. Return True if the state should be stepped, and False if the state should not be stepped. To defer to the original selection procedure, return the result of `simgr.selector(state, **kwargs)`.

If the user provided a `selector_func` in their step or run command, it will appear here.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

step_state(_simgr_ , _state_ , _** kwargs_)¶
    

Determine the categorization of state successors into stashes. The result should be a dict mapping stash names to the list of successor states that fall into that stash, or None as a stash name to use the original stash name.

If you would like to directly work with a SimSuccessors object, you can obtain it with `simgr.successors(state, **kwargs)`. This is not recommended, as it denies other hooks the opportunity to look at the successors. Therefore, the usual technique is to call `simgr.step_state(state, **kwargs)` and then mutate the returned dict before returning it yourself.

..note:: This takes precedence over the filter hook - filter is only applied to states returned from here in the None stash.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

successors(_simgr_ , _state_ , _** kwargs_)¶
    

Perform the process of stepping a state forward, returning a SimSuccessors object.

To defer to the original succession procedure, return the result of `simgr.successors(state, **kwargs)`. Be careful about not calling this method (e.g. calling `project.factory.successors` manually) as it denies other hooks the opportunity to instrument the step. Instead, you can mutate the kwargs for the step before calling the original, and mutate the result before returning it yourself.

If the user provided a `successor_func` in their step or run command, it will appear here.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

complete(_simgr_)¶
    

Return whether or not this manager has reached a “completed” state, i.e. `SimulationManager.run()` should halt.

This is the one hook which is _not_ subject to the nesting rules of hooks. You should _not_ call `simgr.complete`, you should make your own decision and return True or False. Each of the techniques’ completion checkers will be called and the final result will be compted with `simgr.completion_mode`.

Parameters:
    

**simgr** (_angr.SimulationManager_)

_class _angr.exploration_techniques.Explorer(_find =None_, _avoid =None_, _find_stash ='found'_, _avoid_stash ='avoid'_, _cfg =None_, _num_find =1_, _avoid_priority =False_)¶
    

Bases: `ExplorationTechnique`

Search for up to “num_find” paths that satisfy condition “find”, avoiding condition “avoid”. Stashes found paths into “find_stash’ and avoided paths into “avoid_stash”.

The “find” and “avoid” parameters may be any of:

  * An address to find

  * A set or list of addresses to find

  * A function that takes a path and returns whether or not it matches.

If an angr CFG is passed in as the “cfg” parameter and “find” is either a number or a list or a set, then any paths which cannot possibly reach a success state without going through a failure state will be preemptively avoided.

If either the “find” or “avoid” parameter is a function returning a boolean, and a path triggers both conditions, it will be added to the find stash, unless “avoid_priority” is set to True.

__init__(_find =None_, _avoid =None_, _find_stash ='found'_, _avoid_stash ='avoid'_, _cfg =None_, _num_find =1_, _avoid_priority =False_)¶
    

setup(_simgr_)¶
    

Perform any initialization on this manager you might need to do.

Parameters:
    

**simgr** (_angr.SimulationManager_) – The simulation manager to which you have just been added

step(_simgr_ , _stash ='active'_, _** kwargs_)¶
    

Hook the process of stepping a stash forward. Should call `simgr.step(stash, **kwargs)` in order to do the actual processing.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

filter(_simgr_ , _state_ , _** kwargs_)¶
    

Perform filtering on which stash a state should be inserted into.

If the state should be filtered, return the name of the stash to move the state to. If you want to modify the state before filtering it, return a tuple of the stash to move the state to and the modified state. To defer to the original categorization procedure, return the result of `simgr.filter(state, **kwargs)`

If the user provided a `filter_func` in their step or run command, it will appear here.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

complete(_simgr_)¶
    

Return whether or not this manager has reached a “completed” state, i.e. `SimulationManager.run()` should halt.

This is the one hook which is _not_ subject to the nesting rules of hooks. You should _not_ call `simgr.complete`, you should make your own decision and return True or False. Each of the techniques’ completion checkers will be called and the final result will be compted with `simgr.completion_mode`.

Parameters:
    

**simgr** (_angr.SimulationManager_)

_class _angr.exploration_techniques.LengthLimiter(_max_length_ , _drop =False_)¶
    

Bases: `ExplorationTechnique`

Length limiter on paths.

__init__(_max_length_ , _drop =False_)¶
    

step(_simgr_ , _stash ='active'_, _** kwargs_)¶
    

Hook the process of stepping a stash forward. Should call `simgr.step(stash, **kwargs)` in order to do the actual processing.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.exploration_techniques.LocalLoopSeer(_bound =None_, _bound_reached =None_, _discard_stash ='spinning'_)¶
    

Bases: `ExplorationTechnique`

LocalLoopSeer monitors exploration and maintains all loop-related data without relying on a control flow graph.

__init__(_bound =None_, _bound_reached =None_, _discard_stash ='spinning'_)¶
    

Parameters:
    

  * **bound** – Limit the number of iterations a loop may be executed.

  * **bound_reached** – If provided, should be a function that takes the LoopSeer and the succ_state. Will be called when loop execution reach the given bound. Default to moving states that exceed the loop limit to a discard stash.

  * **discard_stash** – Name of the stash containing states exceeding the loop limit.

setup(_simgr_)¶
    

Perform any initialization on this manager you might need to do.

Parameters:
    

**simgr** (_angr.SimulationManager_) – The simulation manager to which you have just been added

filter(_simgr_ , _state_ , _** kwargs_)¶
    

Perform filtering on which stash a state should be inserted into.

If the state should be filtered, return the name of the stash to move the state to. If you want to modify the state before filtering it, return a tuple of the stash to move the state to and the modified state. To defer to the original categorization procedure, return the result of `simgr.filter(state, **kwargs)`

If the user provided a `filter_func` in their step or run command, it will appear here.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

successors(_simgr_ , _state_ , _** kwargs_)¶
    

Perform the process of stepping a state forward, returning a SimSuccessors object.

To defer to the original succession procedure, return the result of `simgr.successors(state, **kwargs)`. Be careful about not calling this method (e.g. calling `project.factory.successors` manually) as it denies other hooks the opportunity to instrument the step. Instead, you can mutate the kwargs for the step before calling the original, and mutate the result before returning it yourself.

If the user provided a `successor_func` in their step or run command, it will appear here.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

_class _angr.exploration_techniques.LoopSeer(_cfg =None_, _functions =None_, _loops =None_, _use_header =False_, _bound =None_, _bound_reached =None_, _discard_stash ='spinning'_, _limit_concrete_loops =True_)¶
    

Bases: `ExplorationTechnique`

This exploration technique monitors exploration and maintains all loop-related data (well, currently it is just the loop trip counts, but feel free to add something else).

__init__(_cfg =None_, _functions =None_, _loops =None_, _use_header =False_, _bound =None_, _bound_reached =None_, _discard_stash ='spinning'_, _limit_concrete_loops =True_)¶
    

Parameters:
    

  * **cfg** – Normalized CFG is required.

  * **functions** – Function(s) containing the loop(s) to be analyzed.

  * **loops** – Specific group of Loop(s) to be analyzed, if this is None we run the LoopFinder analysis.

  * **use_header** – Whether to use header based trip counter to compare with the bound limit.

  * **bound** – Limit the number of iterations a loop may be executed.

  * **bound_reached** – If provided, should be a function that takes the LoopSeer and the succ_state. Will be called when loop execution reach the given bound. Default to moving states that exceed the loop limit to a discard stash.

  * **discard_stash** – Name of the stash containing states exceeding the loop limit.

  * **limit_concrete_loops** – If False, do not limit a loop back-edge if it is the only successor (Defaults to True to maintain the original behavior)

setup(_simgr_)¶
    

Perform any initialization on this manager you might need to do.

Parameters:
    

**simgr** (_angr.SimulationManager_) – The simulation manager to which you have just been added

filter(_simgr_ , _state_ , _** kwargs_)¶
    

Perform filtering on which stash a state should be inserted into.

If the state should be filtered, return the name of the stash to move the state to. If you want to modify the state before filtering it, return a tuple of the stash to move the state to and the modified state. To defer to the original categorization procedure, return the result of `simgr.filter(state, **kwargs)`

If the user provided a `filter_func` in their step or run command, it will appear here.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

successors(_simgr_ , _state_ , _** kwargs_)¶
    

Perform the process of stepping a state forward, returning a SimSuccessors object.

To defer to the original succession procedure, return the result of `simgr.successors(state, **kwargs)`. Be careful about not calling this method (e.g. calling `project.factory.successors` manually) as it denies other hooks the opportunity to instrument the step. Instead, you can mutate the kwargs for the step before calling the original, and mutate the result before returning it yourself.

If the user provided a `successor_func` in their step or run command, it will appear here.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

_class _angr.exploration_techniques.ManualMergepoint(_address_ , _wait_counter =10_, _prune =True_)¶
    

Bases: `ExplorationTechnique`

__init__(_address_ , _wait_counter =10_, _prune =True_)¶
    

setup(_simgr_)¶
    

Perform any initialization on this manager you might need to do.

Parameters:
    

**simgr** (_angr.SimulationManager_) – The simulation manager to which you have just been added

mark_nofilter(_simgr_ , _stash_)¶
    

mark_okfilter(_simgr_ , _stash_)¶
    

step(_simgr_ , _stash ='active'_, _** kwargs_)¶
    

Hook the process of stepping a stash forward. Should call `simgr.step(stash, **kwargs)` in order to do the actual processing.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.exploration_techniques.MemoryWatcher(_min_memory =512_, _memory_stash ='lowmem'_)¶
    

Bases: `ExplorationTechnique`

Memory Watcher

Parameters:
    

  * **min_memory** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__optional_) – Minimum amount of free memory in MB before stopping execution (default: 95% memory use)

  * **memory_stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__optional_) – What to call the low memory stash (default: ‘lowmem’)

At each step, keep an eye on how much memory is left on the system. Stash off states to effectively stop execution if we’re below a given threshold.

__init__(_min_memory =512_, _memory_stash ='lowmem'_)¶
    

setup(_simgr_)¶
    

Perform any initialization on this manager you might need to do.

Parameters:
    

**simgr** (_angr.SimulationManager_) – The simulation manager to which you have just been added

step(_simgr_ , _stash ='active'_, _** kwargs_)¶
    

Hook the process of stepping a stash forward. Should call `simgr.step(stash, **kwargs)` in order to do the actual processing.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.exploration_techniques.Oppologist¶
    

Bases: `ExplorationTechnique`

The Oppologist is an exploration technique that forces uncooperative code through qemu.

__init__()¶
    

successors(_simgr_ , _state_ , _** kwargs_)¶
    

Perform the process of stepping a state forward, returning a SimSuccessors object.

To defer to the original succession procedure, return the result of `simgr.successors(state, **kwargs)`. Be careful about not calling this method (e.g. calling `project.factory.successors` manually) as it denies other hooks the opportunity to instrument the step. Instead, you can mutate the kwargs for the step before calling the original, and mutate the result before returning it yourself.

If the user provided a `successor_func` in their step or run command, it will appear here.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

_class _angr.exploration_techniques.Slicecutor(_annotated_cfg_ , _force_taking_exit =False_, _force_sat =False_)¶
    

Bases: `ExplorationTechnique`

The Slicecutor is an exploration that executes provided code slices.

Parameters:
    

**force_sat** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_annotated_cfg_ , _force_taking_exit =False_, _force_sat =False_)¶
    

All parameters except annotated_cfg are optional.

Parameters:
    

  * **annotated_cfg** – The AnnotatedCFG that provides the code slice.

  * **force_taking_exit** – Set to True if you want to create a successor based on our slice in case of unconstrained successors.

  * **force_sat** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If a branch specified by the slice is unsatisfiable, set this option to True if you want to force it to be satisfiable and be taken anyway.

setup(_simgr_)¶
    

Perform any initialization on this manager you might need to do.

Parameters:
    

**simgr** (_angr.SimulationManager_) – The simulation manager to which you have just been added

filter(_simgr_ , _state_ , _** kwargs_)¶
    

Perform filtering on which stash a state should be inserted into.

If the state should be filtered, return the name of the stash to move the state to. If you want to modify the state before filtering it, return a tuple of the stash to move the state to and the modified state. To defer to the original categorization procedure, return the result of `simgr.filter(state, **kwargs)`

If the user provided a `filter_func` in their step or run command, it will appear here.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

step_state(_simgr_ , _state_ , _** kwargs_)¶
    

Determine the categorization of state successors into stashes. The result should be a dict mapping stash names to the list of successor states that fall into that stash, or None as a stash name to use the original stash name.

If you would like to directly work with a SimSuccessors object, you can obtain it with `simgr.successors(state, **kwargs)`. This is not recommended, as it denies other hooks the opportunity to look at the successors. Therefore, the usual technique is to call `simgr.step_state(state, **kwargs)` and then mutate the returned dict before returning it yourself.

..note:: This takes precedence over the filter hook - filter is only applied to states returned from here in the None stash.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

successors(_simgr_ , _state_ , _** kwargs_)¶
    

Perform the process of stepping a state forward, returning a SimSuccessors object.

To defer to the original succession procedure, return the result of `simgr.successors(state, **kwargs)`. Be careful about not calling this method (e.g. calling `project.factory.successors` manually) as it denies other hooks the opportunity to instrument the step. Instead, you can mutate the kwargs for the step before calling the original, and mutate the result before returning it yourself.

If the user provided a `successor_func` in their step or run command, it will appear here.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

_class _angr.exploration_techniques.Spiller(_src_stash ='active'_, _min =5_, _max =10_, _staging_stash ='spill_stage'_, _staging_min =10_, _staging_max =20_, _pickle_callback =None_, _unpickle_callback =None_, _post_pickle_callback =None_, _priority_key =None_, _vault =None_, _states_collection =None_)¶
    

Bases: `ExplorationTechnique`

Automatically spill states out. It can spill out states to a different stash, spill them out to ANA, or first do the former and then (after enough states) the latter.

__init__(_src_stash ='active'_, _min =5_, _max =10_, _staging_stash ='spill_stage'_, _staging_min =10_, _staging_max =20_, _pickle_callback =None_, _unpickle_callback =None_, _post_pickle_callback =None_, _priority_key =None_, _vault =None_, _states_collection =None_)¶
    

Initializes the spiller.

Parameters:
    

  * **max** – the number of states that are _not_ spilled

  * **src_stash** – the stash from which to spill states (default: active)

  * **staging_stash** – the stash _to_ which to spill states (default: “spill_stage”)

  * **staging_max** – the number of states that can be in the staging stash before things get spilled to ANA (default: None. If staging_stash is set, then this means unlimited, and ANA will not be used).

  * **priority_key** – a function that takes a state and returns its numerical priority (MAX_INT is lowest priority). By default, self.state_priority will be used, which prioritizes by object ID.

  * **vault** – an angr.Vault object to handle storing and loading of states. If not provided, an angr.vaults.VaultShelf will be created with a temporary file.

step(_simgr_ , _stash ='active'_, _** kwargs_)¶
    

Hook the process of stepping a stash forward. Should call `simgr.step(stash, **kwargs)` in order to do the actual processing.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_static _state_priority(_state_)¶
    

_class _angr.exploration_techniques.StochasticSearch(_start_state_ , _restart_prob =0.0001_)¶
    

Bases: `ExplorationTechnique`

Stochastic Search.

Will only keep one path active at a time, any others will be discarded. Before each pass through, weights are randomly assigned to each basic block. These weights form a probability distribution for determining which state remains after splits. When we run out of active paths to step, we start again from the start state.

__init__(_start_state_ , _restart_prob =0.0001_)¶
    

Parameters:
    

  * **start_state** – The initial state from which exploration stems.

  * **restart_prob** – The probability of randomly restarting the search (default 0.0001).

step(_simgr_ , _stash ='active'_, _** kwargs_)¶
    

Hook the process of stepping a stash forward. Should call `simgr.step(stash, **kwargs)` in order to do the actual processing.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.exploration_techniques.StubStasher¶
    

Bases: `ExplorationTechnique`

Stash states that reach a stub SimProcedure.

_static _post_filter(_state_)¶
    

step(_simgr_ , _stash ='active'_, _** kwargs_)¶
    

Hook the process of stepping a stash forward. Should call `simgr.step(stash, **kwargs)` in order to do the actual processing.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.exploration_techniques.Suggestions¶
    

Bases: `ExplorationTechnique`

An exploration technique which analyzes failure cases and logs suggestions for how to mitigate them in future analyses.

__init__()¶
    

step(_simgr_ , _stash ='active'_, _** kwargs_)¶
    

Hook the process of stepping a stash forward. Should call `simgr.step(stash, **kwargs)` in order to do the actual processing.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_static _report(_state_ , _event_)¶
    

_class _angr.exploration_techniques.TechniqueBuilder(_setup =None_, _step_state =None_, _step =None_, _successors =None_, _filter =None_, _selector =None_, _complete =None_)¶
    

Bases: `ExplorationTechnique`

This meta technique could be used to hook a couple of simulation manager methods without actually creating a new exploration technique, for example:

class SomeComplexAnalysis(Analysis):

> def do_something():
>     
> 
> simgr = self.project.factory.simulation_manager() simgr.use_tech(ProxyTechnique(step_state=self._step_state)) simgr.run()
> 
> def _step_state(self, state):
>     
> 
> # Do stuff! pass

In the above example, the _step_state method can access all the necessary stuff, hidden in the analysis instance, without passing that instance to a one-shot-styled exploration technique.

__init__(_setup =None_, _step_state =None_, _step =None_, _successors =None_, _filter =None_, _selector =None_, _complete =None_)¶
    

_class _angr.exploration_techniques.Threading(_threads =8_, _local_stash ='thread_local'_)¶
    

Bases: `ExplorationTechnique`

Enable multithreading.

This is only useful in paths where a lot of time is taken inside z3, doing constraint solving. This is because of python’s GIL, which says that only one thread at a time may be executing python code.

__init__(_threads =8_, _local_stash ='thread_local'_)¶
    

step(_simgr_ , _stash ='active'_, _error_list =None_, _target_stash =None_, _** kwargs_)¶
    

Hook the process of stepping a stash forward. Should call `simgr.step(stash, **kwargs)` in order to do the actual processing.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

inner_step(_state_ , _simgr_ , _** kwargs_)¶
    

_class _angr.exploration_techniques.Timeout(_timeout =None_)¶
    

Bases: `ExplorationTechnique`

Timeout exploration technique that stops an active exploration if the run time exceeds a predefined timeout

__init__(_timeout =None_)¶
    

setup(_simgr_)¶
    

Perform any initialization on this manager you might need to do.

Parameters:
    

**simgr** (_angr.SimulationManager_) – The simulation manager to which you have just been added

step(_simgr_ , _stash ='active'_, _** kwargs_)¶
    

Hook the process of stepping a stash forward. Should call `simgr.step(stash, **kwargs)` in order to do the actual processing.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.exploration_techniques.Tracer(_trace =None_, _resiliency =False_, _keep_predecessors =1_, _crash_addr =None_, _syscall_data =None_, _copy_states =False_, _fast_forward_to_entry =True_, _mode ='strict'_, _aslr =True_, _follow_unsat =False_)¶
    

Bases: `ExplorationTechnique`

An exploration technique that follows an angr path with a concrete input. The tracing result is the state at the last address of the trace, which can be found in the ‘traced’ stash.

If the given concrete input makes the program crash, you should provide crash_addr, and the crashing state will be found in the ‘crashed’ stash.

Parameters:
    

  * **trace** – The basic block trace.

  * **resiliency** – Should we continue to step forward even if qemu and angr disagree?

  * **keep_predecessors** – Number of states before the final state we should log.

  * **crash_addr** – If the trace resulted in a crash, provide the crashing instruction pointer here, and the ‘crashed’ stash will be populated with the crashing state.

  * **syscall_data** – Data related to various syscalls recorded by tracer for replaying

  * **copy_states** – Whether COPY_STATES should be enabled for the tracing state. It is off by default because most tracing workloads benefit greatly from not performing copying. You want to enable it if you want to see the missed states. It will be re-added for the last 2% of the trace in order to set the predecessors list correctly. If you turn this on you may want to enable the LAZY_SOLVES option.

  * **mode** – Tracing mode.

  * **aslr** – Whether there are aslr slides. if not, tracer uses trace address as state address.

  * **follow_unsat** – Whether unsatisfiable states should be treated as potential successors or not.

Variables:
    

**predecessors** – A list of states in the history before the final state.

__init__(_trace =None_, _resiliency =False_, _keep_predecessors =1_, _crash_addr =None_, _syscall_data =None_, _copy_states =False_, _fast_forward_to_entry =True_, _mode ='strict'_, _aslr =True_, _follow_unsat =False_)¶
    

set_fd_data(_fd_data_)¶
    

Set concrete bytes of various fds read by the program

Parameters:
    

**fd_data** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") _]_)

setup(_simgr_)¶
    

Perform any initialization on this manager you might need to do.

Parameters:
    

**simgr** (_angr.SimulationManager_) – The simulation manager to which you have just been added

complete(_simgr_)¶
    

Return whether or not this manager has reached a “completed” state, i.e. `SimulationManager.run()` should halt.

This is the one hook which is _not_ subject to the nesting rules of hooks. You should _not_ call `simgr.complete`, you should make your own decision and return True or False. Each of the techniques’ completion checkers will be called and the final result will be compted with `simgr.completion_mode`.

Parameters:
    

**simgr** (_angr.SimulationManager_)

filter(_simgr_ , _state_ , _** kwargs_)¶
    

Perform filtering on which stash a state should be inserted into.

If the state should be filtered, return the name of the stash to move the state to. If you want to modify the state before filtering it, return a tuple of the stash to move the state to and the modified state. To defer to the original categorization procedure, return the result of `simgr.filter(state, **kwargs)`

If the user provided a `filter_func` in their step or run command, it will appear here.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

step(_simgr_ , _stash ='active'_, _** kwargs_)¶
    

Hook the process of stepping a stash forward. Should call `simgr.step(stash, **kwargs)` in order to do the actual processing.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

step_state(_simgr_ , _state_ , _** kwargs_)¶
    

Determine the categorization of state successors into stashes. The result should be a dict mapping stash names to the list of successor states that fall into that stash, or None as a stash name to use the original stash name.

If you would like to directly work with a SimSuccessors object, you can obtain it with `simgr.successors(state, **kwargs)`. This is not recommended, as it denies other hooks the opportunity to look at the successors. Therefore, the usual technique is to call `simgr.step_state(state, **kwargs)` and then mutate the returned dict before returning it yourself.

..note:: This takes precedence over the filter hook - filter is only applied to states returned from here in the None stash.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

_classmethod _crash_windup(_state_ , _crash_addr_)¶
    

_class _angr.exploration_techniques.UniqueSearch(_similarity_func =None_, _deferred_stash ='deferred'_)¶
    

Bases: `ExplorationTechnique`

Unique Search.

Will only keep one path active at a time, any others will be deferred. The state that is explored depends on how unique it is relative to the other deferred states. A path’s uniqueness is determined by its average similarity between the other (deferred) paths. Similarity is calculated based on the supplied similarity_func, which by default is: The (L2) distance between the counts of the state addresses in the history of the path.

__init__(_similarity_func =None_, _deferred_stash ='deferred'_)¶
    

Parameters:
    

  * **similarity_func** – How to calculate similarity between two states.

  * **deferred_stash** – Where to store the deferred states.

setup(_simgr_)¶
    

Perform any initialization on this manager you might need to do.

Parameters:
    

**simgr** (_angr.SimulationManager_) – The simulation manager to which you have just been added

step(_simgr_ , _stash ='active'_, _** kwargs_)¶
    

Hook the process of stepping a stash forward. Should call `simgr.step(stash, **kwargs)` in order to do the actual processing.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_static _similarity(_state_a_ , _state_b_)¶
    

The (L2) distance between the counts of the state addresses in the history of the path. :type state_a: :param state_a: The first state to compare :type state_b: :param state_b: The second state to compare

_static _sequence_matcher_similarity(_state_a_ , _state_b_)¶
    

The difflib.SequenceMatcher ratio between the state addresses in the history of the path. :type state_a: :param state_a: The first state to compare :type state_b: :param state_b: The second state to compare

_class _angr.exploration_techniques.Veritesting(_** options_)¶
    

Bases: `ExplorationTechnique`

Enable veritesting. This technique, described in a paper[1] from CMU, attempts to address the problem of state explosions in loops by performing smart merging.

[1] <https://users.ece.cmu.edu/~aavgerin/papers/veritesting-icse-2014.pdf>

__init__(_** options_)¶
    

step_state(_simgr_ , _state_ , _successor_func =None_, _** kwargs_)¶
    

Determine the categorization of state successors into stashes. The result should be a dict mapping stash names to the list of successor states that fall into that stash, or None as a stash name to use the original stash name.

If you would like to directly work with a SimSuccessors object, you can obtain it with `simgr.successors(state, **kwargs)`. This is not recommended, as it denies other hooks the opportunity to look at the successors. Therefore, the usual technique is to call `simgr.step_state(state, **kwargs)` and then mutate the returned dict before returning it yourself.

..note:: This takes precedence over the filter hook - filter is only applied to states returned from here in the None stash.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

_class _angr.exploration_techniques.timeout.Timeout(_timeout =None_)¶
    

Bases: `ExplorationTechnique`

Timeout exploration technique that stops an active exploration if the run time exceeds a predefined timeout

__init__(_timeout =None_)¶
    

setup(_simgr_)¶
    

Perform any initialization on this manager you might need to do.

Parameters:
    

**simgr** (_angr.SimulationManager_) – The simulation manager to which you have just been added

step(_simgr_ , _stash ='active'_, _** kwargs_)¶
    

Hook the process of stepping a stash forward. Should call `simgr.step(stash, **kwargs)` in order to do the actual processing.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.exploration_techniques.dfs.DFS(_deferred_stash ='deferred'_)¶
    

Bases: `ExplorationTechnique`

Depth-first search.

Will only keep one path active at a time, any others will be stashed in the ‘deferred’ stash. When we run out of active paths to step, we take the longest one from deferred and continue.

__init__(_deferred_stash ='deferred'_)¶
    

setup(_simgr_)¶
    

Perform any initialization on this manager you might need to do.

Parameters:
    

**simgr** (_angr.SimulationManager_) – The simulation manager to which you have just been added

step(_simgr_ , _stash ='active'_, _** kwargs_)¶
    

Hook the process of stepping a stash forward. Should call `simgr.step(stash, **kwargs)` in order to do the actual processing.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.exploration_techniques.explorer.Explorer(_find =None_, _avoid =None_, _find_stash ='found'_, _avoid_stash ='avoid'_, _cfg =None_, _num_find =1_, _avoid_priority =False_)¶
    

Bases: `ExplorationTechnique`

Search for up to “num_find” paths that satisfy condition “find”, avoiding condition “avoid”. Stashes found paths into “find_stash’ and avoided paths into “avoid_stash”.

The “find” and “avoid” parameters may be any of:

  * An address to find

  * A set or list of addresses to find

  * A function that takes a path and returns whether or not it matches.

If an angr CFG is passed in as the “cfg” parameter and “find” is either a number or a list or a set, then any paths which cannot possibly reach a success state without going through a failure state will be preemptively avoided.

If either the “find” or “avoid” parameter is a function returning a boolean, and a path triggers both conditions, it will be added to the find stash, unless “avoid_priority” is set to True.

__init__(_find =None_, _avoid =None_, _find_stash ='found'_, _avoid_stash ='avoid'_, _cfg =None_, _num_find =1_, _avoid_priority =False_)¶
    

setup(_simgr_)¶
    

Perform any initialization on this manager you might need to do.

Parameters:
    

**simgr** (_angr.SimulationManager_) – The simulation manager to which you have just been added

step(_simgr_ , _stash ='active'_, _** kwargs_)¶
    

Hook the process of stepping a stash forward. Should call `simgr.step(stash, **kwargs)` in order to do the actual processing.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

filter(_simgr_ , _state_ , _** kwargs_)¶
    

Perform filtering on which stash a state should be inserted into.

If the state should be filtered, return the name of the stash to move the state to. If you want to modify the state before filtering it, return a tuple of the stash to move the state to and the modified state. To defer to the original categorization procedure, return the result of `simgr.filter(state, **kwargs)`

If the user provided a `filter_func` in their step or run command, it will appear here.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

complete(_simgr_)¶
    

Return whether or not this manager has reached a “completed” state, i.e. `SimulationManager.run()` should halt.

This is the one hook which is _not_ subject to the nesting rules of hooks. You should _not_ call `simgr.complete`, you should make your own decision and return True or False. Each of the techniques’ completion checkers will be called and the final result will be compted with `simgr.completion_mode`.

Parameters:
    

**simgr** (_angr.SimulationManager_)

_class _angr.exploration_techniques.lengthlimiter.LengthLimiter(_max_length_ , _drop =False_)¶
    

Bases: `ExplorationTechnique`

Length limiter on paths.

__init__(_max_length_ , _drop =False_)¶
    

step(_simgr_ , _stash ='active'_, _** kwargs_)¶
    

Hook the process of stepping a stash forward. Should call `simgr.step(stash, **kwargs)` in order to do the actual processing.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.exploration_techniques.manual_mergepoint.ManualMergepoint(_address_ , _wait_counter =10_, _prune =True_)¶
    

Bases: `ExplorationTechnique`

__init__(_address_ , _wait_counter =10_, _prune =True_)¶
    

setup(_simgr_)¶
    

Perform any initialization on this manager you might need to do.

Parameters:
    

**simgr** (_angr.SimulationManager_) – The simulation manager to which you have just been added

mark_nofilter(_simgr_ , _stash_)¶
    

mark_okfilter(_simgr_ , _stash_)¶
    

step(_simgr_ , _stash ='active'_, _** kwargs_)¶
    

Hook the process of stepping a stash forward. Should call `simgr.step(stash, **kwargs)` in order to do the actual processing.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.exploration_techniques.spiller.PickledStatesBase¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

The base class of pickled states

sort()¶
    

Sort pickled states.

add(_prio_ , _sid_)¶
    

Add a newly pickled state.

Parameters:
    

  * **prio** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Priority of the state.

  * **sid** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Persistent ID of the state.

Returns:
    

None

pop_n(_n_)¶
    

Pop the top N states.

Parameters:
    

**n** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Number of states to take.

Returns:
    

A list of states.

_class _angr.exploration_techniques.spiller.PickledStatesList¶
    

Bases: `PickledStatesBase`

List-backed pickled state storage.

__init__()¶
    

sort()¶
    

Sort pickled states.

add(_prio_ , _sid_)¶
    

Add a newly pickled state.

Parameters:
    

  * **prio** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Priority of the state.

  * **sid** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Persistent ID of the state.

Returns:
    

None

pop_n(_n_)¶
    

Pop the top N states.

Parameters:
    

**n** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Number of states to take.

Returns:
    

A list of states.

_class _angr.exploration_techniques.spiller.PickledStatesDb(_db_str ='sqlite:///:memory:'_)¶
    

Bases: `PickledStatesBase`

Database-backed pickled state storage.

__init__(_db_str ='sqlite:///:memory:'_)¶
    

sort()¶
    

Sort pickled states.

add(_prio_ , _sid_ , _taken =False_, _stash ='spilled'_)¶
    

Add a newly pickled state.

Parameters:
    

  * **prio** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Priority of the state.

  * **sid** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Persistent ID of the state.

Returns:
    

None

pop_n(_n_ , _stash ='spilled'_)¶
    

Pop the top N states.

Parameters:
    

**n** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Number of states to take.

Returns:
    

A list of states.

get_recent_n(_n_ , _stash ='spilled'_)¶
    

count()¶
    

_class _angr.exploration_techniques.spiller.Spiller(_src_stash ='active'_, _min =5_, _max =10_, _staging_stash ='spill_stage'_, _staging_min =10_, _staging_max =20_, _pickle_callback =None_, _unpickle_callback =None_, _post_pickle_callback =None_, _priority_key =None_, _vault =None_, _states_collection =None_)¶
    

Bases: `ExplorationTechnique`

Automatically spill states out. It can spill out states to a different stash, spill them out to ANA, or first do the former and then (after enough states) the latter.

__init__(_src_stash ='active'_, _min =5_, _max =10_, _staging_stash ='spill_stage'_, _staging_min =10_, _staging_max =20_, _pickle_callback =None_, _unpickle_callback =None_, _post_pickle_callback =None_, _priority_key =None_, _vault =None_, _states_collection =None_)¶
    

Initializes the spiller.

Parameters:
    

  * **max** – the number of states that are _not_ spilled

  * **src_stash** – the stash from which to spill states (default: active)

  * **staging_stash** – the stash _to_ which to spill states (default: “spill_stage”)

  * **staging_max** – the number of states that can be in the staging stash before things get spilled to ANA (default: None. If staging_stash is set, then this means unlimited, and ANA will not be used).

  * **priority_key** – a function that takes a state and returns its numerical priority (MAX_INT is lowest priority). By default, self.state_priority will be used, which prioritizes by object ID.

  * **vault** – an angr.Vault object to handle storing and loading of states. If not provided, an angr.vaults.VaultShelf will be created with a temporary file.

step(_simgr_ , _stash ='active'_, _** kwargs_)¶
    

Hook the process of stepping a stash forward. Should call `simgr.step(stash, **kwargs)` in order to do the actual processing.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_static _state_priority(_state_)¶
    

_class _angr.exploration_techniques.spiller_db.PickledState(_** kwargs_)¶
    

Bases: `Base`

id¶
    

priority¶
    

taken¶
    

stash¶
    

timestamp¶
    

__init__(_** kwargs_)¶
    

A simple constructor that allows initialization from kwargs.

Sets attributes on the constructed instance using the names and values in `kwargs`.

Only keys that are present as attributes of the instance’s class are allowed. These could be, for example, any mapped columns or relationships.

_class _angr.exploration_techniques.threading.Threading(_threads =8_, _local_stash ='thread_local'_)¶
    

Bases: `ExplorationTechnique`

Enable multithreading.

This is only useful in paths where a lot of time is taken inside z3, doing constraint solving. This is because of python’s GIL, which says that only one thread at a time may be executing python code.

__init__(_threads =8_, _local_stash ='thread_local'_)¶
    

step(_simgr_ , _stash ='active'_, _error_list =None_, _target_stash =None_, _** kwargs_)¶
    

Hook the process of stepping a stash forward. Should call `simgr.step(stash, **kwargs)` in order to do the actual processing.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

inner_step(_state_ , _simgr_ , _** kwargs_)¶
    

_class _angr.exploration_techniques.veritesting.Veritesting(_** options_)¶
    

Bases: `ExplorationTechnique`

Enable veritesting. This technique, described in a paper[1] from CMU, attempts to address the problem of state explosions in loops by performing smart merging.

[1] <https://users.ece.cmu.edu/~aavgerin/papers/veritesting-icse-2014.pdf>

__init__(_** options_)¶
    

step_state(_simgr_ , _state_ , _successor_func =None_, _** kwargs_)¶
    

Determine the categorization of state successors into stashes. The result should be a dict mapping stash names to the list of successor states that fall into that stash, or None as a stash name to use the original stash name.

If you would like to directly work with a SimSuccessors object, you can obtain it with `simgr.successors(state, **kwargs)`. This is not recommended, as it denies other hooks the opportunity to look at the successors. Therefore, the usual technique is to call `simgr.step_state(state, **kwargs)` and then mutate the returned dict before returning it yourself.

..note:: This takes precedence over the filter hook - filter is only applied to states returned from here in the None stash.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

_class _angr.exploration_techniques.tracer.TracingMode¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Variables:
    

  * **Strict** – Strict mode, the default mode, where an exception is raised immediately if tracer’s path deviates from the provided trace.

  * **Permissive** – Permissive mode, where tracer attempts to force the path back to the provided trace when a deviation happens. This does not always work, especially when the cause of deviation is related to input that will later be used in exploit generation. But, it might work magically sometimes.

  * **CatchDesync** – CatchDesync mode, catch desync because of sim_procedures. It might be a sign of something interesting.

Strict _ = 'strict'_¶
    

Permissive _ = 'permissive'_¶
    

CatchDesync _ = 'catch_desync'_¶
    

_exception _angr.exploration_techniques.tracer.TracerDesyncError(_msg_ , _deviating_addr =None_, _deviating_trace_idx =None_)¶
    

Bases: `AngrTracerError`

An error class to report tracing Tracing desyncronization error

__init__(_msg_ , _deviating_addr =None_, _deviating_trace_idx =None_)¶
    

_class _angr.exploration_techniques.tracer.RepHook(_mnemonic_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Hook rep movs/stos to speed up constraint solving TODO: This should be made an exploration technique later

__init__(_mnemonic_)¶
    

run(_state_)¶
    

_class _angr.exploration_techniques.tracer.Tracer(_trace =None_, _resiliency =False_, _keep_predecessors =1_, _crash_addr =None_, _syscall_data =None_, _copy_states =False_, _fast_forward_to_entry =True_, _mode ='strict'_, _aslr =True_, _follow_unsat =False_)¶
    

Bases: `ExplorationTechnique`

An exploration technique that follows an angr path with a concrete input. The tracing result is the state at the last address of the trace, which can be found in the ‘traced’ stash.

If the given concrete input makes the program crash, you should provide crash_addr, and the crashing state will be found in the ‘crashed’ stash.

Parameters:
    

  * **trace** – The basic block trace.

  * **resiliency** – Should we continue to step forward even if qemu and angr disagree?

  * **keep_predecessors** – Number of states before the final state we should log.

  * **crash_addr** – If the trace resulted in a crash, provide the crashing instruction pointer here, and the ‘crashed’ stash will be populated with the crashing state.

  * **syscall_data** – Data related to various syscalls recorded by tracer for replaying

  * **copy_states** – Whether COPY_STATES should be enabled for the tracing state. It is off by default because most tracing workloads benefit greatly from not performing copying. You want to enable it if you want to see the missed states. It will be re-added for the last 2% of the trace in order to set the predecessors list correctly. If you turn this on you may want to enable the LAZY_SOLVES option.

  * **mode** – Tracing mode.

  * **aslr** – Whether there are aslr slides. if not, tracer uses trace address as state address.

  * **follow_unsat** – Whether unsatisfiable states should be treated as potential successors or not.

Variables:
    

**predecessors** – A list of states in the history before the final state.

__init__(_trace =None_, _resiliency =False_, _keep_predecessors =1_, _crash_addr =None_, _syscall_data =None_, _copy_states =False_, _fast_forward_to_entry =True_, _mode ='strict'_, _aslr =True_, _follow_unsat =False_)¶
    

set_fd_data(_fd_data_)¶
    

Set concrete bytes of various fds read by the program

Parameters:
    

**fd_data** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") _]_)

setup(_simgr_)¶
    

Perform any initialization on this manager you might need to do.

Parameters:
    

**simgr** (_angr.SimulationManager_) – The simulation manager to which you have just been added

complete(_simgr_)¶
    

Return whether or not this manager has reached a “completed” state, i.e. `SimulationManager.run()` should halt.

This is the one hook which is _not_ subject to the nesting rules of hooks. You should _not_ call `simgr.complete`, you should make your own decision and return True or False. Each of the techniques’ completion checkers will be called and the final result will be compted with `simgr.completion_mode`.

Parameters:
    

**simgr** (_angr.SimulationManager_)

filter(_simgr_ , _state_ , _** kwargs_)¶
    

Perform filtering on which stash a state should be inserted into.

If the state should be filtered, return the name of the stash to move the state to. If you want to modify the state before filtering it, return a tuple of the stash to move the state to and the modified state. To defer to the original categorization procedure, return the result of `simgr.filter(state, **kwargs)`

If the user provided a `filter_func` in their step or run command, it will appear here.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

step(_simgr_ , _stash ='active'_, _** kwargs_)¶
    

Hook the process of stepping a stash forward. Should call `simgr.step(stash, **kwargs)` in order to do the actual processing.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

step_state(_simgr_ , _state_ , _** kwargs_)¶
    

Determine the categorization of state successors into stashes. The result should be a dict mapping stash names to the list of successor states that fall into that stash, or None as a stash name to use the original stash name.

If you would like to directly work with a SimSuccessors object, you can obtain it with `simgr.successors(state, **kwargs)`. This is not recommended, as it denies other hooks the opportunity to look at the successors. Therefore, the usual technique is to call `simgr.step_state(state, **kwargs)` and then mutate the returned dict before returning it yourself.

..note:: This takes precedence over the filter hook - filter is only applied to states returned from here in the None stash.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

_classmethod _crash_windup(_state_ , _crash_addr_)¶
    

_class _angr.exploration_techniques.driller_core.DrillerCore(_trace_ , _fuzz_bitmap =None_)¶
    

Bases: `ExplorationTechnique`

An exploration technique that symbolically follows an input looking for new state transitions.

It has to be used with Tracer exploration technique. Results are put in ‘diverted’ stash.

__init__(_trace_ , _fuzz_bitmap =None_)¶
    

:param trace : The basic block trace. :type fuzz_bitmap: :param fuzz_bitmap: AFL’s bitmap of state transitions. Defaults to saying every transition is worth satisfying.

setup(_simgr_)¶
    

Perform any initialization on this manager you might need to do.

Parameters:
    

**simgr** (_angr.SimulationManager_) – The simulation manager to which you have just been added

step(_simgr_ , _stash ='active'_, _** kwargs_)¶
    

Hook the process of stepping a stash forward. Should call `simgr.step(stash, **kwargs)` in order to do the actual processing.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.exploration_techniques.slicecutor.Slicecutor(_annotated_cfg_ , _force_taking_exit =False_, _force_sat =False_)¶
    

Bases: `ExplorationTechnique`

The Slicecutor is an exploration that executes provided code slices.

Parameters:
    

**force_sat** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_annotated_cfg_ , _force_taking_exit =False_, _force_sat =False_)¶
    

All parameters except annotated_cfg are optional.

Parameters:
    

  * **annotated_cfg** – The AnnotatedCFG that provides the code slice.

  * **force_taking_exit** – Set to True if you want to create a successor based on our slice in case of unconstrained successors.

  * **force_sat** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If a branch specified by the slice is unsatisfiable, set this option to True if you want to force it to be satisfiable and be taken anyway.

setup(_simgr_)¶
    

Perform any initialization on this manager you might need to do.

Parameters:
    

**simgr** (_angr.SimulationManager_) – The simulation manager to which you have just been added

filter(_simgr_ , _state_ , _** kwargs_)¶
    

Perform filtering on which stash a state should be inserted into.

If the state should be filtered, return the name of the stash to move the state to. If you want to modify the state before filtering it, return a tuple of the stash to move the state to and the modified state. To defer to the original categorization procedure, return the result of `simgr.filter(state, **kwargs)`

If the user provided a `filter_func` in their step or run command, it will appear here.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

step_state(_simgr_ , _state_ , _** kwargs_)¶
    

Determine the categorization of state successors into stashes. The result should be a dict mapping stash names to the list of successor states that fall into that stash, or None as a stash name to use the original stash name.

If you would like to directly work with a SimSuccessors object, you can obtain it with `simgr.successors(state, **kwargs)`. This is not recommended, as it denies other hooks the opportunity to look at the successors. Therefore, the usual technique is to call `simgr.step_state(state, **kwargs)` and then mutate the returned dict before returning it yourself.

..note:: This takes precedence over the filter hook - filter is only applied to states returned from here in the None stash.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

successors(_simgr_ , _state_ , _** kwargs_)¶
    

Perform the process of stepping a state forward, returning a SimSuccessors object.

To defer to the original succession procedure, return the result of `simgr.successors(state, **kwargs)`. Be careful about not calling this method (e.g. calling `project.factory.successors` manually) as it denies other hooks the opportunity to instrument the step. Instead, you can mutate the kwargs for the step before calling the original, and mutate the result before returning it yourself.

If the user provided a `successor_func` in their step or run command, it will appear here.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

_class _angr.exploration_techniques.director.BaseGoal(_sort_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

REQUIRE_CFG_STATES _ = False_¶
    

__init__(_sort_)¶
    

check(_cfg_ , _state_ , _peek_blocks_)¶
    

Parameters:
    

  * **cfg** (_angr.analyses.CFGEmulated_) – An instance of CFGEmulated.

  * **state** (_angr.SimState_) – The state to check.

  * **peek_blocks** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Number of blocks to peek ahead from the current point.

Returns:
    

True if we can determine that this condition is definitely satisfiable if the path is taken, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

check_state(_state_)¶
    

Check if the current state satisfies the goal.

Parameters:
    

**state** (_angr.SimState_) – The state to check.

Returns:
    

True if it satisfies the goal, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.exploration_techniques.director.ExecuteAddressGoal(_addr_)¶
    

Bases: `BaseGoal`

A goal that prioritizes states reaching (or are likely to reach) certain address in some specific steps.

__init__(_addr_)¶
    

check(_cfg_ , _state_ , _peek_blocks_)¶
    

Check if the specified address will be executed

Parameters:
    

  * **cfg**

  * **state**

  * **peek_blocks** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

Returns:
    

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

check_state(_state_)¶
    

Check if the current address is the target address.

Parameters:
    

**state** (_angr.SimState_) – The state to check.

Returns:
    

True if the current address is the target address, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.exploration_techniques.director.CallFunctionGoal(_function_ , _arguments_)¶
    

Bases: `BaseGoal`

A goal that prioritizes states reaching certain function, and optionally with specific arguments. Note that constraints on arguments (and on function address as well) have to be identifiable on an accurate CFG. For example, you may have a CallFunctionGoal saying “call printf with the first argument being ‘Hello, world’”, and CFGEmulated must be able to figure our the first argument to printf is in fact “Hello, world”, not some symbolic strings that will be constrained to “Hello, world” during symbolic execution (or simulation, however you put it).

REQUIRE_CFG_STATES _ = True_¶
    

__init__(_function_ , _arguments_)¶
    

check(_cfg_ , _state_ , _peek_blocks_)¶
    

Check if the specified function will be reached with certain arguments.

Parameters:
    

  * **cfg**

  * **state**

  * **peek_blocks**

Returns:
    

check_state(_state_)¶
    

Check if the specific function is reached with certain arguments

Parameters:
    

**state** (_angr.SimState_) – The state to check

Returns:
    

True if the function is reached with certain arguments, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.exploration_techniques.director.Director(_peek_blocks =100_, _peek_functions =5_, _goals =None_, _cfg_keep_states =False_, _goal_satisfied_callback =None_, _num_fallback_states =5_)¶
    

Bases: `ExplorationTechnique`

An exploration technique for directed symbolic execution.

A control flow graph (using CFGEmulated) is built and refined during symbolic execution. Each time the execution reaches a block that is outside of the CFG, the CFG recovery will be triggered with that state, with a maximum recovery depth (100 by default). If we see a basic block during state stepping that is not yet in the control flow graph, we go back to control flow graph recovery and “peek” more blocks forward.

When stepping a simulation manager, all states are categorized into three different categories:

  * Might reach the destination within the peek depth. Those states are prioritized.

  * Will not reach the destination within the peek depth. Those states are de-prioritized. However, there is a little chance for those states to be explored as well in order to prevent over-fitting.

__init__(_peek_blocks =100_, _peek_functions =5_, _goals =None_, _cfg_keep_states =False_, _goal_satisfied_callback =None_, _num_fallback_states =5_)¶
    

Constructor.

step(_simgr_ , _stash ='active'_, _** kwargs_)¶
    

Parameters:
    

  * **simgr**

  * **stash**

  * **kwargs**

Returns:
    

add_goal(_goal_)¶
    

Add a goal.

Parameters:
    

**goal** (_BaseGoal_) – The goal to add.

Returns:
    

None

_class _angr.exploration_techniques.oppologist.Oppologist¶
    

Bases: `ExplorationTechnique`

The Oppologist is an exploration technique that forces uncooperative code through qemu.

__init__()¶
    

successors(_simgr_ , _state_ , _** kwargs_)¶
    

Perform the process of stepping a state forward, returning a SimSuccessors object.

To defer to the original succession procedure, return the result of `simgr.successors(state, **kwargs)`. Be careful about not calling this method (e.g. calling `project.factory.successors` manually) as it denies other hooks the opportunity to instrument the step. Instead, you can mutate the kwargs for the step before calling the original, and mutate the result before returning it yourself.

If the user provided a `successor_func` in their step or run command, it will appear here.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

_class _angr.exploration_techniques.loop_seer.LoopSeer(_cfg =None_, _functions =None_, _loops =None_, _use_header =False_, _bound =None_, _bound_reached =None_, _discard_stash ='spinning'_, _limit_concrete_loops =True_)¶
    

Bases: `ExplorationTechnique`

This exploration technique monitors exploration and maintains all loop-related data (well, currently it is just the loop trip counts, but feel free to add something else).

__init__(_cfg =None_, _functions =None_, _loops =None_, _use_header =False_, _bound =None_, _bound_reached =None_, _discard_stash ='spinning'_, _limit_concrete_loops =True_)¶
    

Parameters:
    

  * **cfg** – Normalized CFG is required.

  * **functions** – Function(s) containing the loop(s) to be analyzed.

  * **loops** – Specific group of Loop(s) to be analyzed, if this is None we run the LoopFinder analysis.

  * **use_header** – Whether to use header based trip counter to compare with the bound limit.

  * **bound** – Limit the number of iterations a loop may be executed.

  * **bound_reached** – If provided, should be a function that takes the LoopSeer and the succ_state. Will be called when loop execution reach the given bound. Default to moving states that exceed the loop limit to a discard stash.

  * **discard_stash** – Name of the stash containing states exceeding the loop limit.

  * **limit_concrete_loops** – If False, do not limit a loop back-edge if it is the only successor (Defaults to True to maintain the original behavior)

setup(_simgr_)¶
    

Perform any initialization on this manager you might need to do.

Parameters:
    

**simgr** (_angr.SimulationManager_) – The simulation manager to which you have just been added

filter(_simgr_ , _state_ , _** kwargs_)¶
    

Perform filtering on which stash a state should be inserted into.

If the state should be filtered, return the name of the stash to move the state to. If you want to modify the state before filtering it, return a tuple of the stash to move the state to and the modified state. To defer to the original categorization procedure, return the result of `simgr.filter(state, **kwargs)`

If the user provided a `filter_func` in their step or run command, it will appear here.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

successors(_simgr_ , _state_ , _** kwargs_)¶
    

Perform the process of stepping a state forward, returning a SimSuccessors object.

To defer to the original succession procedure, return the result of `simgr.successors(state, **kwargs)`. Be careful about not calling this method (e.g. calling `project.factory.successors` manually) as it denies other hooks the opportunity to instrument the step. Instead, you can mutate the kwargs for the step before calling the original, and mutate the result before returning it yourself.

If the user provided a `successor_func` in their step or run command, it will appear here.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

_class _angr.exploration_techniques.local_loop_seer.LocalLoopSeer(_bound =None_, _bound_reached =None_, _discard_stash ='spinning'_)¶
    

Bases: `ExplorationTechnique`

LocalLoopSeer monitors exploration and maintains all loop-related data without relying on a control flow graph.

__init__(_bound =None_, _bound_reached =None_, _discard_stash ='spinning'_)¶
    

Parameters:
    

  * **bound** – Limit the number of iterations a loop may be executed.

  * **bound_reached** – If provided, should be a function that takes the LoopSeer and the succ_state. Will be called when loop execution reach the given bound. Default to moving states that exceed the loop limit to a discard stash.

  * **discard_stash** – Name of the stash containing states exceeding the loop limit.

setup(_simgr_)¶
    

Perform any initialization on this manager you might need to do.

Parameters:
    

**simgr** (_angr.SimulationManager_) – The simulation manager to which you have just been added

filter(_simgr_ , _state_ , _** kwargs_)¶
    

Perform filtering on which stash a state should be inserted into.

If the state should be filtered, return the name of the stash to move the state to. If you want to modify the state before filtering it, return a tuple of the stash to move the state to and the modified state. To defer to the original categorization procedure, return the result of `simgr.filter(state, **kwargs)`

If the user provided a `filter_func` in their step or run command, it will appear here.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

successors(_simgr_ , _state_ , _** kwargs_)¶
    

Perform the process of stepping a state forward, returning a SimSuccessors object.

To defer to the original succession procedure, return the result of `simgr.successors(state, **kwargs)`. Be careful about not calling this method (e.g. calling `project.factory.successors` manually) as it denies other hooks the opportunity to instrument the step. Instead, you can mutate the kwargs for the step before calling the original, and mutate the result before returning it yourself.

If the user provided a `successor_func` in their step or run command, it will appear here.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

_class _angr.exploration_techniques.stochastic.StochasticSearch(_start_state_ , _restart_prob =0.0001_)¶
    

Bases: `ExplorationTechnique`

Stochastic Search.

Will only keep one path active at a time, any others will be discarded. Before each pass through, weights are randomly assigned to each basic block. These weights form a probability distribution for determining which state remains after splits. When we run out of active paths to step, we start again from the start state.

__init__(_start_state_ , _restart_prob =0.0001_)¶
    

Parameters:
    

  * **start_state** – The initial state from which exploration stems.

  * **restart_prob** – The probability of randomly restarting the search (default 0.0001).

step(_simgr_ , _stash ='active'_, _** kwargs_)¶
    

Hook the process of stepping a stash forward. Should call `simgr.step(stash, **kwargs)` in order to do the actual processing.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.exploration_techniques.unique.UniqueSearch(_similarity_func =None_, _deferred_stash ='deferred'_)¶
    

Bases: `ExplorationTechnique`

Unique Search.

Will only keep one path active at a time, any others will be deferred. The state that is explored depends on how unique it is relative to the other deferred states. A path’s uniqueness is determined by its average similarity between the other (deferred) paths. Similarity is calculated based on the supplied similarity_func, which by default is: The (L2) distance between the counts of the state addresses in the history of the path.

__init__(_similarity_func =None_, _deferred_stash ='deferred'_)¶
    

Parameters:
    

  * **similarity_func** – How to calculate similarity between two states.

  * **deferred_stash** – Where to store the deferred states.

setup(_simgr_)¶
    

Perform any initialization on this manager you might need to do.

Parameters:
    

**simgr** (_angr.SimulationManager_) – The simulation manager to which you have just been added

step(_simgr_ , _stash ='active'_, _** kwargs_)¶
    

Hook the process of stepping a stash forward. Should call `simgr.step(stash, **kwargs)` in order to do the actual processing.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_static _similarity(_state_a_ , _state_b_)¶
    

The (L2) distance between the counts of the state addresses in the history of the path. :type state_a: :param state_a: The first state to compare :type state_b: :param state_b: The second state to compare

_static _sequence_matcher_similarity(_state_a_ , _state_b_)¶
    

The difflib.SequenceMatcher ratio between the state addresses in the history of the path. :type state_a: :param state_a: The first state to compare :type state_b: :param state_b: The second state to compare

_class _angr.exploration_techniques.tech_builder.TechniqueBuilder(_setup =None_, _step_state =None_, _step =None_, _successors =None_, _filter =None_, _selector =None_, _complete =None_)¶
    

Bases: `ExplorationTechnique`

This meta technique could be used to hook a couple of simulation manager methods without actually creating a new exploration technique, for example:

class SomeComplexAnalysis(Analysis):

> def do_something():
>     
> 
> simgr = self.project.factory.simulation_manager() simgr.use_tech(ProxyTechnique(step_state=self._step_state)) simgr.run()
> 
> def _step_state(self, state):
>     
> 
> # Do stuff! pass

In the above example, the _step_state method can access all the necessary stuff, hidden in the analysis instance, without passing that instance to a one-shot-styled exploration technique.

__init__(_setup =None_, _step_state =None_, _step =None_, _successors =None_, _filter =None_, _selector =None_, _complete =None_)¶
    

angr.exploration_techniques.common.condition_to_lambda(_condition_ , _default =False_)¶
    

Translates an integer, set, list or function into a lambda that checks if state’s current basic block matches some condition.

Parameters:
    

  * **condition** – An integer, set, list or lambda to convert to a lambda.

  * **default** – The default return value of the lambda (in case condition is None). Default: false.

Returns:
    

A tuple of two items: a lambda that takes a state and returns the set of addresses that it matched from the condition, and a set that contains the normalized set of addresses to stop at, or None if no addresses were provided statically.

_class _angr.exploration_techniques.memory_watcher.MemoryWatcher(_min_memory =512_, _memory_stash ='lowmem'_)¶
    

Bases: `ExplorationTechnique`

Memory Watcher

Parameters:
    

  * **min_memory** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__optional_) – Minimum amount of free memory in MB before stopping execution (default: 95% memory use)

  * **memory_stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__optional_) – What to call the low memory stash (default: ‘lowmem’)

At each step, keep an eye on how much memory is left on the system. Stash off states to effectively stop execution if we’re below a given threshold.

__init__(_min_memory =512_, _memory_stash ='lowmem'_)¶
    

setup(_simgr_)¶
    

Perform any initialization on this manager you might need to do.

Parameters:
    

**simgr** (_angr.SimulationManager_) – The simulation manager to which you have just been added

step(_simgr_ , _stash ='active'_, _** kwargs_)¶
    

Hook the process of stepping a stash forward. Should call `simgr.step(stash, **kwargs)` in order to do the actual processing.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.exploration_techniques.bucketizer.Bucketizer¶
    

Bases: `ExplorationTechnique`

Loop bucketization: Pick log(n) paths out of n possible paths, and stash (or drop) everything else.

successors(_simgr_ , _state_ , _** kwargs_)¶
    

Perform the process of stepping a state forward, returning a SimSuccessors object.

To defer to the original succession procedure, return the result of `simgr.successors(state, **kwargs)`. Be careful about not calling this method (e.g. calling `project.factory.successors` manually) as it denies other hooks the opportunity to instrument the step. Instead, you can mutate the kwargs for the step before calling the original, and mutate the result before returning it yourself.

If the user provided a `successor_func` in their step or run command, it will appear here.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **state** (_angr.SimState_)

angr.exploration_techniques.suggestions.ast_weight(_ast_ , _memo =None_)¶
    

_class _angr.exploration_techniques.suggestions.Suggestions¶
    

Bases: `ExplorationTechnique`

An exploration technique which analyzes failure cases and logs suggestions for how to mitigate them in future analyses.

__init__()¶
    

step(_simgr_ , _stash ='active'_, _** kwargs_)¶
    

Hook the process of stepping a stash forward. Should call `simgr.step(stash, **kwargs)` in order to do the actual processing.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_static _report(_state_ , _event_)¶
    

## Simulation Engines¶

_class _angr.engines.HeavyResilienceMixin(_project_ , _** kwargs_)¶
    

Bases: `VEXResilienceMixin`, `ClaripyDataMixin`

_class _angr.engines.HeavyVEXMixin(_project_)¶
    

Bases: `SuccessorsEngine`, `ClaripyDataMixin`, `SimStateStorageMixin`, `VEXMixin`, `VEXLifter`

Execution engine based on VEX, Valgrind’s IR.

Responds to the following parameters to the step stack:

  * irsb: The PyVEX IRSB object to use for execution. If not provided one will be lifted.

  * skip_stmts: The number of statements to skip in processing

  * last_stmt: Do not execute any statements after this statement

  * whitelist: Only execute statements in this set

  * thumb: Whether the block should be force to be lifted in ARM’s THUMB mode.

  * extra_stop_points:
    

An extra set of points at which to break basic blocks

  * opt_level: The VEX optimization level to use.

  * insn_bytes: A string of bytes to use for the block instead of the project.

  * size: The maximum size of the block, in bytes.

  * num_inst: The maximum number of instructions.

  * traceflags: traceflags to be passed to VEX. (default: 0)

Parameters:
    

**project** (_angr.Project_)

process_successors(_successors_ , _irsb =None_, _insn_bytes =None_, _thumb =False_, _size =None_, _num_inst =None_, _extra_stop_points =None_, _opt_level =None_, _strict_block_end =None_, _** kwargs_)¶
    

Implement this function to fill out the SimSuccessors object with the results of stepping state.

In order to implement a model where multiple mixins can potentially handle a request, a mixin may implement this method and then perform a super() call if it wants to pass on handling to the next mixin.

Keep in mind python’s method resolution order when composing multiple classes implementing this method. In short: left-to-right, depth-first, but deferring any base classes which are shared by multiple subclasses (the merge point of a diamond pattern in the inheritance graph) until the last point where they would be encountered in this depth-first search. For example, if you have classes A, B(A), C(B), D(A), E(C, D), then the method resolution order will be E, C, B, D, A.

Parameters:
    

  * **state** – The state to manipulate

  * **successors** – The successors object to fill out

  * **kwargs** – Any extra arguments. Do not fail if you are passed unexpected arguments.

_class _angr.engines.HooksMixin(_project_)¶
    

Bases: `SuccessorsEngine`, `ProcedureMixin`

A SimEngine mixin which adds a SimSuccessors handler which will look into the project’s hooks and run the hook at the current address.

Will respond to the following parameters provided to the step stack:

  * procedure: A SimProcedure instance to force-run instead of consulting the current hooks

  * ret_to: An address to force-return-to at the end of the procedure

Parameters:
    

**project** (_angr.Project_)

process_successors(_successors_ , _*_ , _procedure =None_, _** kwargs_)¶
    

Implement this function to fill out the SimSuccessors object with the results of stepping state.

In order to implement a model where multiple mixins can potentially handle a request, a mixin may implement this method and then perform a super() call if it wants to pass on handling to the next mixin.

Keep in mind python’s method resolution order when composing multiple classes implementing this method. In short: left-to-right, depth-first, but deferring any base classes which are shared by multiple subclasses (the merge point of a diamond pattern in the inheritance graph) until the last point where they would be encountered in this depth-first search. For example, if you have classes A, B(A), C(B), D(A), E(C, D), then the method resolution order will be E, C, B, D, A.

Parameters:
    

  * **state** – The state to manipulate

  * **successors** – The successors object to fill out

  * **kwargs** – Any extra arguments. Do not fail if you are passed unexpected arguments.

_class _angr.engines.ProcedureEngine(_project_)¶
    

Bases: `ProcedureMixin`, `SuccessorsEngine`

A SimEngine that you may use if you only care about processing SimProcedures. _Requires_ the procedure kwarg to be passed to process.

Parameters:
    

**project** (_angr.Project_)

process_successors(_successors_ , _procedure =None_, _** kwargs_)¶
    

Implement this function to fill out the SimSuccessors object with the results of stepping state.

In order to implement a model where multiple mixins can potentially handle a request, a mixin may implement this method and then perform a super() call if it wants to pass on handling to the next mixin.

Keep in mind python’s method resolution order when composing multiple classes implementing this method. In short: left-to-right, depth-first, but deferring any base classes which are shared by multiple subclasses (the merge point of a diamond pattern in the inheritance graph) until the last point where they would be encountered in this depth-first search. For example, if you have classes A, B(A), C(B), D(A), E(C, D), then the method resolution order will be E, C, B, D, A.

Parameters:
    

  * **state** – The state to manipulate

  * **successors** – The successors object to fill out

  * **kwargs** – Any extra arguments. Do not fail if you are passed unexpected arguments.

_class _angr.engines.ProcedureMixin¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A mixin for SimEngine which adds the `process_procedure` method for calling a SimProcedure and adding its results to a SimSuccessors.

process_procedure(_state_ , _successors_ , _procedure_ , _ret_to =None_, _arguments =None_, _** kwargs_)¶
    

_class _angr.engines.SimEngine(_project_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`StateType`, `ResultType`]

A SimEngine is a type which understands how to perform execution on a state.

Parameters:
    

**project** (_angr.Project_)

state _: [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`StateType`)_¶
    

__init__(_project_)¶
    

Parameters:
    

**project** (_Project_)

_class _angr.engines.SimEngineFailure(_project_)¶
    

Bases: `SuccessorsEngine`, `ProcedureMixin`

Parameters:
    

**project** (_angr.Project_)

process_successors(_successors_ , _** kwargs_)¶
    

Implement this function to fill out the SimSuccessors object with the results of stepping state.

In order to implement a model where multiple mixins can potentially handle a request, a mixin may implement this method and then perform a super() call if it wants to pass on handling to the next mixin.

Keep in mind python’s method resolution order when composing multiple classes implementing this method. In short: left-to-right, depth-first, but deferring any base classes which are shared by multiple subclasses (the merge point of a diamond pattern in the inheritance graph) until the last point where they would be encountered in this depth-first search. For example, if you have classes A, B(A), C(B), D(A), E(C, D), then the method resolution order will be E, C, B, D, A.

Parameters:
    

  * **state** – The state to manipulate

  * **successors** – The successors object to fill out

  * **kwargs** – Any extra arguments. Do not fail if you are passed unexpected arguments.

_class _angr.engines.SimEngineSyscall(_project_)¶
    

Bases: `SuccessorsEngine`, `ProcedureMixin`

A SimEngine mixin which adds a successors handling step that checks if a syscall was just requested and if so handles it as a step.

Parameters:
    

**project** (_angr.Project_)

process_successors(_successors_ , _** kwargs_)¶
    

Implement this function to fill out the SimSuccessors object with the results of stepping state.

In order to implement a model where multiple mixins can potentially handle a request, a mixin may implement this method and then perform a super() call if it wants to pass on handling to the next mixin.

Keep in mind python’s method resolution order when composing multiple classes implementing this method. In short: left-to-right, depth-first, but deferring any base classes which are shared by multiple subclasses (the merge point of a diamond pattern in the inheritance graph) until the last point where they would be encountered in this depth-first search. For example, if you have classes A, B(A), C(B), D(A), E(C, D), then the method resolution order will be E, C, B, D, A.

Parameters:
    

  * **state** – The state to manipulate

  * **successors** – The successors object to fill out

  * **kwargs** – Any extra arguments. Do not fail if you are passed unexpected arguments.

_class _angr.engines.SimEngineUnicorn(_project_)¶
    

Bases: `SuccessorsEngine`

Concrete execution in the Unicorn Engine, a fork of qemu.

Responds to the following parameters in the step stack:

  * step: How many basic blocks we want to execute

  * extra_stop_points: A collection of addresses at which execution should halt

Parameters:
    

**project** (_angr.Project_)

__init__(_project_)¶
    

Parameters:
    

**project** (_Project_)

process_successors(_successors_ , _** kwargs_)¶
    

Implement this function to fill out the SimSuccessors object with the results of stepping state.

In order to implement a model where multiple mixins can potentially handle a request, a mixin may implement this method and then perform a super() call if it wants to pass on handling to the next mixin.

Keep in mind python’s method resolution order when composing multiple classes implementing this method. In short: left-to-right, depth-first, but deferring any base classes which are shared by multiple subclasses (the merge point of a diamond pattern in the inheritance graph) until the last point where they would be encountered in this depth-first search. For example, if you have classes A, B(A), C(B), D(A), E(C, D), then the method resolution order will be E, C, B, D, A.

Parameters:
    

  * **state** – The state to manipulate

  * **successors** – The successors object to fill out

  * **kwargs** – Any extra arguments. Do not fail if you are passed unexpected arguments.

_class _angr.engines.SimInspectMixin(_project_ , _** kwargs_)¶
    

Bases: `VEXMixin`

handle_vex_block(_irsb_)¶
    

_class _angr.engines.SimSuccessors(_addr_ , _initial_state_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

This class serves as a categorization of all the kinds of result states that can come from a SimEngine run.

Variables:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address at which execution is taking place, as a python int

  * **initial_state** – The initial state for which execution produced these successors

  * **engine** – The engine that produced these successors

  * **sort** – A string identifying the type of engine that produced these successors

  * **processed** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether or not the processing succeeded

  * **description** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – A textual description of the execution step

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__SootAddressDescriptor_ _|__None_)

  * **initial_state** (_HeavyState_ _|__None_)

The successor states produced by this run are categorized into several lists:

Variables:
    

  * **artifacts** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")) – Any analysis byproducts (for example, an IRSB) that were produced during execution

  * **successors** – The “normal” successors. IP may be symbolic, but must have reasonable number of solutions

  * **unsat_successors** – Any successor which is unsatisfiable after its guard condition is added.

  * **all_successors** – successors + unsat_successors

  * **flat_successors** – The normal successors, but any symbolic IPs have been concretized. There is one state in this list for each possible value an IP may be concretized to for each successor state.

  * **unconstrained_successors** – Any state for which during the flattening process we find too many solutions.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__SootAddressDescriptor_ _|__None_)

  * **initial_state** (_HeavyState_ _|__None_)

A more detailed description of the successor lists may be found here: <https://docs.angr.io/core-concepts/simulation#simsuccessors>

__init__(_addr_ , _initial_state_)¶
    

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_SootAddressDescriptor_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_soot.SootAddressDescriptor "\(in archinfo\)") _|__None_)

  * **initial_state** (_SimState_ _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_SootAddressDescriptor_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_soot.SootAddressDescriptor "\(in archinfo\)") _,_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _|_[_SootAddressDescriptor_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_soot.SootAddressDescriptor "\(in archinfo\)") _]__|__None_)

_property _is_empty¶
    

add_successor(_state_ , _target_ , _guard_ , _jumpkind_ , _add_guard =True_, _exit_stmt_idx =None_, _exit_ins_addr =None_, _source =None_)¶
    

Add a successor state of the SimRun. This procedure stores method parameters into state.scratch, does some housekeeping, and calls out to helper functions to prepare the state and categorize it into the appropriate successor lists.

Parameters:
    

  * **state** (_SimState_) – The successor state.

  * **target** – The target (of the jump/call/ret).

  * **guard** – The guard expression.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind (call, ret, jump, or whatnot).

  * **add_guard** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether to add the guard constraint (default: True).

  * **exit_stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The ID of the exit statement, an integer by default. ‘default’ stands for the default exit, and None means it’s not from a statement (for example, from a SimProcedure).

  * **exit_ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The instruction pointer of this exit, which is an integer by default.

  * **source** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The source of the jump (i.e., the address of the basic block).

_class _angr.engines.SootMixin(_project_)¶
    

Bases: `SuccessorsEngine`, `ProcedureMixin`

Execution engine based on Soot.

Parameters:
    

**project** (_angr.Project_)

lift_soot(_addr =None_, _the_binary =None_, _** kwargs_)¶
    

process_successors(_successors_ , _** kwargs_)¶
    

Implement this function to fill out the SimSuccessors object with the results of stepping state.

In order to implement a model where multiple mixins can potentially handle a request, a mixin may implement this method and then perform a super() call if it wants to pass on handling to the next mixin.

Keep in mind python’s method resolution order when composing multiple classes implementing this method. In short: left-to-right, depth-first, but deferring any base classes which are shared by multiple subclasses (the merge point of a diamond pattern in the inheritance graph) until the last point where they would be encountered in this depth-first search. For example, if you have classes A, B(A), C(B), D(A), E(C, D), then the method resolution order will be E, C, B, D, A.

Parameters:
    

  * **state** – The state to manipulate

  * **successors** – The successors object to fill out

  * **kwargs** – Any extra arguments. Do not fail if you are passed unexpected arguments.

get_unconstrained_simprocedure()¶
    

_classmethod _setup_callsite(_state_ , _args_ , _ret_addr_ , _ret_var =None_)¶
    

_static _setup_arguments(_state_ , _args_)¶
    

_static _prepare_return_state(_state_ , _ret_value =None_)¶
    

_static _terminate_execution(_statement_ , _state_ , _successors_)¶
    

_static _prepare_native_return_state(_native_state_)¶
    

Hook target for native function call returns.

Recovers and stores the return value from native memory and toggles the state, s.t. execution continues in the Soot engine.

_class _angr.engines.SuccessorsEngine(_project_)¶
    

Bases: `SimEngine`[`SimState`[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`SootAddressDescriptor`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_soot.SootAddressDescriptor "\(in archinfo\)"), [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`SootAddressDescriptor`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_soot.SootAddressDescriptor "\(in archinfo\)")], `SimSuccessors`]

A mixin for SimEngine which implements `process` to perform common operations related to symbolic execution and dispatches to a `process_successors` method to fill a SimSuccessors object with the results.

Parameters:
    

**project** (_angr.Project_)

__init__(_project_)¶
    

Parameters:
    

**project** (_Project_)

process(_state_ , _** kwargs_)¶
    

Perform execution with a state.

You should only override this method in a subclass in order to provide the correct method signature and docstring. You should override the `_process` method to do your actual execution.

Parameters:
    

  * **state** (`SimState`[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`SootAddressDescriptor`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_soot.SootAddressDescriptor "\(in archinfo\)"), [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`SootAddressDescriptor`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_soot.SootAddressDescriptor "\(in archinfo\)")]) – The state with which to execute. This state will be copied before modification.

  * **inline** – This is an inline execution. Do not bother copying the state.

  * **force_addr** – Force execution to pretend that we’re working at this concrete address

Return type:
    

`SimSuccessors`

Returns:
    

A SimSuccessors object categorizing the execution’s successor states

process_successors(_successors_ , _** kwargs_)¶
    

Implement this function to fill out the SimSuccessors object with the results of stepping state.

In order to implement a model where multiple mixins can potentially handle a request, a mixin may implement this method and then perform a super() call if it wants to pass on handling to the next mixin.

Keep in mind python’s method resolution order when composing multiple classes implementing this method. In short: left-to-right, depth-first, but deferring any base classes which are shared by multiple subclasses (the merge point of a diamond pattern in the inheritance graph) until the last point where they would be encountered in this depth-first search. For example, if you have classes A, B(A), C(B), D(A), E(C, D), then the method resolution order will be E, C, B, D, A.

Parameters:
    

  * **state** – The state to manipulate

  * **successors** – The successors object to fill out

  * **kwargs** – Any extra arguments. Do not fail if you are passed unexpected arguments.

_class _angr.engines.SuperFastpathMixin(_* args_, _** kwargs_)¶
    

Bases: `VEXSlicingMixin`

This mixin implements the superfastpath execution mode, which skips all but the last four instructions.

handle_vex_block(_irsb_)¶
    

_class _angr.engines.TrackActionsMixin(_* args_, _** kwargs_)¶
    

Bases: `HeavyVEXMixin`

__init__(_* args_, _** kwargs_)¶
    

handle_vex_block(_irsb_)¶
    

_class _angr.engines.UberEngine(_project_)¶
    

Bases: `SimEngineFailure`, `SimEngineSyscall`, `HooksMixin`, `SimEngineUnicorn`, `SuperFastpathMixin`, `TrackActionsMixin`, `SimInspectMixin`, `HeavyResilienceMixin`, `SootMixin`, `HeavyVEXMixin`

The default execution engine for angr. This engine includes mixins for most common functionality in angr, including VEX IR, unicorn, syscall handling, and simprocedure handling.

For some performance-sensitive applications, you may want to create a custom engine with only the necessary mixins.

Parameters:
    

**project** (_angr.Project_)

_class _angr.engines.UberEnginePcode(_* args_, _** kwargs_)¶
    

Bases: `SimEngineFailure`, `SimEngineSyscall`, `HooksMixin`, `HeavyPcodeMixin`

_class _angr.engines.engine.SimEngine(_project_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`StateType`, `ResultType`]

A SimEngine is a type which understands how to perform execution on a state.

Parameters:
    

**project** (_angr.Project_)

state _: [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`StateType`)_¶
    

__init__(_project_)¶
    

Parameters:
    

**project** (_Project_)

_class _angr.engines.successors.SimSuccessors(_addr_ , _initial_state_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

This class serves as a categorization of all the kinds of result states that can come from a SimEngine run.

Variables:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address at which execution is taking place, as a python int

  * **initial_state** – The initial state for which execution produced these successors

  * **engine** – The engine that produced these successors

  * **sort** – A string identifying the type of engine that produced these successors

  * **processed** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether or not the processing succeeded

  * **description** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – A textual description of the execution step

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__SootAddressDescriptor_ _|__None_)

  * **initial_state** (_HeavyState_ _|__None_)

The successor states produced by this run are categorized into several lists:

Variables:
    

  * **artifacts** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")) – Any analysis byproducts (for example, an IRSB) that were produced during execution

  * **successors** – The “normal” successors. IP may be symbolic, but must have reasonable number of solutions

  * **unsat_successors** – Any successor which is unsatisfiable after its guard condition is added.

  * **all_successors** – successors + unsat_successors

  * **flat_successors** – The normal successors, but any symbolic IPs have been concretized. There is one state in this list for each possible value an IP may be concretized to for each successor state.

  * **unconstrained_successors** – Any state for which during the flattening process we find too many solutions.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__SootAddressDescriptor_ _|__None_)

  * **initial_state** (_HeavyState_ _|__None_)

A more detailed description of the successor lists may be found here: <https://docs.angr.io/core-concepts/simulation#simsuccessors>

__init__(_addr_ , _initial_state_)¶
    

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_SootAddressDescriptor_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_soot.SootAddressDescriptor "\(in archinfo\)") _|__None_)

  * **initial_state** (_SimState_ _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_SootAddressDescriptor_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_soot.SootAddressDescriptor "\(in archinfo\)") _,_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _|_[_SootAddressDescriptor_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_soot.SootAddressDescriptor "\(in archinfo\)") _]__|__None_)

_property _is_empty¶
    

add_successor(_state_ , _target_ , _guard_ , _jumpkind_ , _add_guard =True_, _exit_stmt_idx =None_, _exit_ins_addr =None_, _source =None_)¶
    

Add a successor state of the SimRun. This procedure stores method parameters into state.scratch, does some housekeeping, and calls out to helper functions to prepare the state and categorize it into the appropriate successor lists.

Parameters:
    

  * **state** (_SimState_) – The successor state.

  * **target** – The target (of the jump/call/ret).

  * **guard** – The guard expression.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind (call, ret, jump, or whatnot).

  * **add_guard** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether to add the guard constraint (default: True).

  * **exit_stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The ID of the exit statement, an integer by default. ‘default’ stands for the default exit, and None means it’s not from a statement (for example, from a SimProcedure).

  * **exit_ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The instruction pointer of this exit, which is an integer by default.

  * **source** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The source of the jump (i.e., the address of the basic block).

_class _angr.engines.successors.SuccessorsEngine(_project_)¶
    

Bases: `SimEngine`[`SimState`[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`SootAddressDescriptor`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_soot.SootAddressDescriptor "\(in archinfo\)"), [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`SootAddressDescriptor`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_soot.SootAddressDescriptor "\(in archinfo\)")], `SimSuccessors`]

A mixin for SimEngine which implements `process` to perform common operations related to symbolic execution and dispatches to a `process_successors` method to fill a SimSuccessors object with the results.

Parameters:
    

**project** (_angr.Project_)

__init__(_project_)¶
    

Parameters:
    

**project** (_Project_)

process(_state_ , _** kwargs_)¶
    

Perform execution with a state.

You should only override this method in a subclass in order to provide the correct method signature and docstring. You should override the `_process` method to do your actual execution.

Parameters:
    

  * **state** (`SimState`[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`SootAddressDescriptor`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_soot.SootAddressDescriptor "\(in archinfo\)"), [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`SootAddressDescriptor`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_soot.SootAddressDescriptor "\(in archinfo\)")]) – The state with which to execute. This state will be copied before modification.

  * **inline** – This is an inline execution. Do not bother copying the state.

  * **force_addr** – Force execution to pretend that we’re working at this concrete address

Return type:
    

`SimSuccessors`

Returns:
    

A SimSuccessors object categorizing the execution’s successor states

process_successors(_successors_ , _** kwargs_)¶
    

Implement this function to fill out the SimSuccessors object with the results of stepping state.

In order to implement a model where multiple mixins can potentially handle a request, a mixin may implement this method and then perform a super() call if it wants to pass on handling to the next mixin.

Keep in mind python’s method resolution order when composing multiple classes implementing this method. In short: left-to-right, depth-first, but deferring any base classes which are shared by multiple subclasses (the merge point of a diamond pattern in the inheritance graph) until the last point where they would be encountered in this depth-first search. For example, if you have classes A, B(A), C(B), D(A), E(C, D), then the method resolution order will be E, C, B, D, A.

Parameters:
    

  * **state** – The state to manipulate

  * **successors** – The successors object to fill out

  * **kwargs** – Any extra arguments. Do not fail if you are passed unexpected arguments.

_class _angr.engines.procedure.ProcedureMixin¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A mixin for SimEngine which adds the `process_procedure` method for calling a SimProcedure and adding its results to a SimSuccessors.

process_procedure(_state_ , _successors_ , _procedure_ , _ret_to =None_, _arguments =None_, _** kwargs_)¶
    

_class _angr.engines.procedure.ProcedureEngine(_project_)¶
    

Bases: `ProcedureMixin`, `SuccessorsEngine`

A SimEngine that you may use if you only care about processing SimProcedures. _Requires_ the procedure kwarg to be passed to process.

Parameters:
    

**project** (_angr.Project_)

process_successors(_successors_ , _procedure =None_, _** kwargs_)¶
    

Implement this function to fill out the SimSuccessors object with the results of stepping state.

In order to implement a model where multiple mixins can potentially handle a request, a mixin may implement this method and then perform a super() call if it wants to pass on handling to the next mixin.

Keep in mind python’s method resolution order when composing multiple classes implementing this method. In short: left-to-right, depth-first, but deferring any base classes which are shared by multiple subclasses (the merge point of a diamond pattern in the inheritance graph) until the last point where they would be encountered in this depth-first search. For example, if you have classes A, B(A), C(B), D(A), E(C, D), then the method resolution order will be E, C, B, D, A.

Parameters:
    

  * **state** – The state to manipulate

  * **successors** – The successors object to fill out

  * **kwargs** – Any extra arguments. Do not fail if you are passed unexpected arguments.

_class _angr.engines.hook.HooksMixin(_project_)¶
    

Bases: `SuccessorsEngine`, `ProcedureMixin`

A SimEngine mixin which adds a SimSuccessors handler which will look into the project’s hooks and run the hook at the current address.

Will respond to the following parameters provided to the step stack:

  * procedure: A SimProcedure instance to force-run instead of consulting the current hooks

  * ret_to: An address to force-return-to at the end of the procedure

Parameters:
    

**project** (_angr.Project_)

process_successors(_successors_ , _*_ , _procedure =None_, _** kwargs_)¶
    

Implement this function to fill out the SimSuccessors object with the results of stepping state.

In order to implement a model where multiple mixins can potentially handle a request, a mixin may implement this method and then perform a super() call if it wants to pass on handling to the next mixin.

Keep in mind python’s method resolution order when composing multiple classes implementing this method. In short: left-to-right, depth-first, but deferring any base classes which are shared by multiple subclasses (the merge point of a diamond pattern in the inheritance graph) until the last point where they would be encountered in this depth-first search. For example, if you have classes A, B(A), C(B), D(A), E(C, D), then the method resolution order will be E, C, B, D, A.

Parameters:
    

  * **state** – The state to manipulate

  * **successors** – The successors object to fill out

  * **kwargs** – Any extra arguments. Do not fail if you are passed unexpected arguments.

_class _angr.engines.syscall.SimEngineSyscall(_project_)¶
    

Bases: `SuccessorsEngine`, `ProcedureMixin`

A SimEngine mixin which adds a successors handling step that checks if a syscall was just requested and if so handles it as a step.

Parameters:
    

**project** (_angr.Project_)

process_successors(_successors_ , _** kwargs_)¶
    

Implement this function to fill out the SimSuccessors object with the results of stepping state.

In order to implement a model where multiple mixins can potentially handle a request, a mixin may implement this method and then perform a super() call if it wants to pass on handling to the next mixin.

Keep in mind python’s method resolution order when composing multiple classes implementing this method. In short: left-to-right, depth-first, but deferring any base classes which are shared by multiple subclasses (the merge point of a diamond pattern in the inheritance graph) until the last point where they would be encountered in this depth-first search. For example, if you have classes A, B(A), C(B), D(A), E(C, D), then the method resolution order will be E, C, B, D, A.

Parameters:
    

  * **state** – The state to manipulate

  * **successors** – The successors object to fill out

  * **kwargs** – Any extra arguments. Do not fail if you are passed unexpected arguments.

_class _angr.engines.failure.SimEngineFailure(_project_)¶
    

Bases: `SuccessorsEngine`, `ProcedureMixin`

Parameters:
    

**project** (_angr.Project_)

process_successors(_successors_ , _** kwargs_)¶
    

Implement this function to fill out the SimSuccessors object with the results of stepping state.

In order to implement a model where multiple mixins can potentially handle a request, a mixin may implement this method and then perform a super() call if it wants to pass on handling to the next mixin.

Keep in mind python’s method resolution order when composing multiple classes implementing this method. In short: left-to-right, depth-first, but deferring any base classes which are shared by multiple subclasses (the merge point of a diamond pattern in the inheritance graph) until the last point where they would be encountered in this depth-first search. For example, if you have classes A, B(A), C(B), D(A), E(C, D), then the method resolution order will be E, C, B, D, A.

Parameters:
    

  * **state** – The state to manipulate

  * **successors** – The successors object to fill out

  * **kwargs** – Any extra arguments. Do not fail if you are passed unexpected arguments.

_class _angr.engines.vex.ClaripyDataMixin(_project_ , _** kwargs_)¶
    

Bases: `VEXMixin`

This mixin provides methods that makes the vex engine process guest code using claripy ASTs as the data domain.

_class _angr.engines.vex.HeavyResilienceMixin(_project_ , _** kwargs_)¶
    

Bases: `VEXResilienceMixin`, `ClaripyDataMixin`

_class _angr.engines.vex.HeavyVEXMixin(_project_)¶
    

Bases: `SuccessorsEngine`, `ClaripyDataMixin`, `SimStateStorageMixin`, `VEXMixin`, `VEXLifter`

Execution engine based on VEX, Valgrind’s IR.

Responds to the following parameters to the step stack:

  * irsb: The PyVEX IRSB object to use for execution. If not provided one will be lifted.

  * skip_stmts: The number of statements to skip in processing

  * last_stmt: Do not execute any statements after this statement

  * whitelist: Only execute statements in this set

  * thumb: Whether the block should be force to be lifted in ARM’s THUMB mode.

  * extra_stop_points:
    

An extra set of points at which to break basic blocks

  * opt_level: The VEX optimization level to use.

  * insn_bytes: A string of bytes to use for the block instead of the project.

  * size: The maximum size of the block, in bytes.

  * num_inst: The maximum number of instructions.

  * traceflags: traceflags to be passed to VEX. (default: 0)

Parameters:
    

**project** (_angr.Project_)

process_successors(_successors_ , _irsb =None_, _insn_bytes =None_, _thumb =False_, _size =None_, _num_inst =None_, _extra_stop_points =None_, _opt_level =None_, _strict_block_end =None_, _** kwargs_)¶
    

Implement this function to fill out the SimSuccessors object with the results of stepping state.

In order to implement a model where multiple mixins can potentially handle a request, a mixin may implement this method and then perform a super() call if it wants to pass on handling to the next mixin.

Keep in mind python’s method resolution order when composing multiple classes implementing this method. In short: left-to-right, depth-first, but deferring any base classes which are shared by multiple subclasses (the merge point of a diamond pattern in the inheritance graph) until the last point where they would be encountered in this depth-first search. For example, if you have classes A, B(A), C(B), D(A), E(C, D), then the method resolution order will be E, C, B, D, A.

Parameters:
    

  * **state** – The state to manipulate

  * **successors** – The successors object to fill out

  * **kwargs** – Any extra arguments. Do not fail if you are passed unexpected arguments.

_class _angr.engines.vex.SimInspectMixin(_project_ , _** kwargs_)¶
    

Bases: `VEXMixin`

handle_vex_block(_irsb_)¶
    

_class _angr.engines.vex.SuperFastpathMixin(_* args_, _** kwargs_)¶
    

Bases: `VEXSlicingMixin`

This mixin implements the superfastpath execution mode, which skips all but the last four instructions.

handle_vex_block(_irsb_)¶
    

_class _angr.engines.vex.TrackActionsMixin(_* args_, _** kwargs_)¶
    

Bases: `HeavyVEXMixin`

__init__(_* args_, _** kwargs_)¶
    

handle_vex_block(_irsb_)¶
    

_class _angr.engines.vex.VEXLifter(_project_ , _use_cache =None_, _cache_size =50000_, _default_opt_level =1_, _selfmodifying_code =None_, _single_step =False_, _default_strict_block_end =False_, _** kwargs_)¶
    

Bases: `SimEngine`

Implements the VEX lifter engine mixin.

__init__(_project_ , _use_cache =None_, _cache_size =50000_, _default_opt_level =1_, _selfmodifying_code =None_, _single_step =False_, _default_strict_block_end =False_, _** kwargs_)¶
    

clear_cache()¶
    

lift_vex(_addr =None_, _state =None_, _clemory =None_, _insn_bytes =None_, _offset =None_, _arch =None_, _size =None_, _num_inst =None_, _traceflags =0_, _thumb =False_, _extra_stop_points =None_, _opt_level =None_, _strict_block_end =None_, _skip_stmts =False_, _collect_data_refs =False_, _cross_insn_opt =None_, _load_from_ro_regions =False_, _const_prop =False_)¶
    

Lift an IRSB.

There are many possible valid sets of parameters. You at the very least must pass some source of data, some source of an architecture, and some source of an address.

Sources of data in order of priority: insn_bytes, clemory, state

Sources of an address, in order of priority: addr, state

Sources of an architecture, in order of priority: arch, clemory, state

Parameters:
    

  * **state** – A state to use as a data source.

  * **clemory** ([`Union`](https://docs.python.org/3/library/typing.html#typing.Union "\(in Python v3.13\)")[[`Clemory`](https://docs.angr.io/projects/cle/en/latest/api/utils.html#cle.memory.Clemory "\(in cle\)"), `ClemoryReadOnlyView`, [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")]) – A cle.memory.Clemory object to use as a data source.

  * **addr** – The address at which to start the block.

  * **thumb** – Whether the block should be lifted in ARM’s THUMB mode.

  * **opt_level** – The VEX optimization level to use. The final IR optimization level is determined by (ordered by priority): \- Argument opt_level \- opt_level is set to 1 if OPTIMIZE_IR exists in state options \- self._default_opt_level

  * **insn_bytes** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)")]) – A string of bytes to use as a data source.

  * **offset** – If using insn_bytes, the number of bytes in it to skip over.

  * **size** – The maximum size of the block, in bytes.

  * **num_inst** – The maximum number of instructions.

  * **traceflags** – traceflags to be passed to VEX. (default: 0)

  * **strict_block_end** – Whether to force blocks to end at all conditional branches (default: false)

Return type:
    

[`IRSB`](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.block.IRSB "\(in pyvex\)")

_class _angr.engines.vex.VEXMixin(_project_ , _** kwargs_)¶
    

Bases: `SimEngine`

__init__(_project_ , _** kwargs_)¶
    

handle_vex_block(_irsb_)¶
    

Parameters:
    

**irsb** ([_IRSB_](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.block.IRSB "\(in pyvex\)"))

_class _angr.engines.vex.VEXResilienceMixin(_project_ , _** kwargs_)¶
    

Bases: `VEXMixin`

_class _angr.engines.vex.VEXSlicingMixin(_* args_, _** kwargs_)¶
    

Bases: `VEXMixin`

__init__(_* args_, _** kwargs_)¶
    

process(_state_ , _block =None_, _skip_stmts =0_, _last_stmt =None_, _whitelist =None_, _** kwargs_)¶
    

handle_vex_block(_irsb_)¶
    

_class _angr.engines.soot.SootMixin(_project_)¶
    

Bases: `SuccessorsEngine`, `ProcedureMixin`

Execution engine based on Soot.

Parameters:
    

**project** (_angr.Project_)

lift_soot(_addr =None_, _the_binary =None_, _** kwargs_)¶
    

process_successors(_successors_ , _** kwargs_)¶
    

Implement this function to fill out the SimSuccessors object with the results of stepping state.

In order to implement a model where multiple mixins can potentially handle a request, a mixin may implement this method and then perform a super() call if it wants to pass on handling to the next mixin.

Keep in mind python’s method resolution order when composing multiple classes implementing this method. In short: left-to-right, depth-first, but deferring any base classes which are shared by multiple subclasses (the merge point of a diamond pattern in the inheritance graph) until the last point where they would be encountered in this depth-first search. For example, if you have classes A, B(A), C(B), D(A), E(C, D), then the method resolution order will be E, C, B, D, A.

Parameters:
    

  * **state** – The state to manipulate

  * **successors** – The successors object to fill out

  * **kwargs** – Any extra arguments. Do not fail if you are passed unexpected arguments.

get_unconstrained_simprocedure()¶
    

_classmethod _setup_callsite(_state_ , _args_ , _ret_addr_ , _ret_var =None_)¶
    

_static _setup_arguments(_state_ , _args_)¶
    

_static _prepare_return_state(_state_ , _ret_value =None_)¶
    

_static _terminate_execution(_statement_ , _state_ , _successors_)¶
    

_static _prepare_native_return_state(_native_state_)¶
    

Hook target for native function call returns.

Recovers and stores the return value from native memory and toggles the state, s.t. execution continues in the Soot engine.

_class _angr.engines.soot.engine.SootMixin(_project_)¶
    

Bases: `SuccessorsEngine`, `ProcedureMixin`

Execution engine based on Soot.

Parameters:
    

**project** (_angr.Project_)

lift_soot(_addr =None_, _the_binary =None_, _** kwargs_)¶
    

process_successors(_successors_ , _** kwargs_)¶
    

Implement this function to fill out the SimSuccessors object with the results of stepping state.

In order to implement a model where multiple mixins can potentially handle a request, a mixin may implement this method and then perform a super() call if it wants to pass on handling to the next mixin.

Keep in mind python’s method resolution order when composing multiple classes implementing this method. In short: left-to-right, depth-first, but deferring any base classes which are shared by multiple subclasses (the merge point of a diamond pattern in the inheritance graph) until the last point where they would be encountered in this depth-first search. For example, if you have classes A, B(A), C(B), D(A), E(C, D), then the method resolution order will be E, C, B, D, A.

Parameters:
    

  * **state** – The state to manipulate

  * **successors** – The successors object to fill out

  * **kwargs** – Any extra arguments. Do not fail if you are passed unexpected arguments.

get_unconstrained_simprocedure()¶
    

_classmethod _setup_callsite(_state_ , _args_ , _ret_addr_ , _ret_var =None_)¶
    

_static _setup_arguments(_state_ , _args_)¶
    

_static _prepare_return_state(_state_ , _ret_value =None_)¶
    

_static _terminate_execution(_statement_ , _state_ , _successors_)¶
    

_static _prepare_native_return_state(_native_state_)¶
    

Hook target for native function call returns.

Recovers and stores the return value from native memory and toggles the state, s.t. execution continues in the Soot engine.

_class _angr.engines.unicorn.SimEngineUnicorn(_project_)¶
    

Bases: `SuccessorsEngine`

Concrete execution in the Unicorn Engine, a fork of qemu.

Responds to the following parameters in the step stack:

  * step: How many basic blocks we want to execute

  * extra_stop_points: A collection of addresses at which execution should halt

Parameters:
    

**project** (_angr.Project_)

__init__(_project_)¶
    

Parameters:
    

**project** (_Project_)

process_successors(_successors_ , _** kwargs_)¶
    

Implement this function to fill out the SimSuccessors object with the results of stepping state.

In order to implement a model where multiple mixins can potentially handle a request, a mixin may implement this method and then perform a super() call if it wants to pass on handling to the next mixin.

Keep in mind python’s method resolution order when composing multiple classes implementing this method. In short: left-to-right, depth-first, but deferring any base classes which are shared by multiple subclasses (the merge point of a diamond pattern in the inheritance graph) until the last point where they would be encountered in this depth-first search. For example, if you have classes A, B(A), C(B), D(A), E(C, D), then the method resolution order will be E, C, B, D, A.

Parameters:
    

  * **state** – The state to manipulate

  * **successors** – The successors object to fill out

  * **kwargs** – Any extra arguments. Do not fail if you are passed unexpected arguments.

_class _angr.engines.concrete.ConcreteEngine(_project_)¶
    

Bases: `SuccessorsEngine`

ConcreteEngine extends SuccessorsEngine and adds APIs for managing breakpoints.

Parameters:
    

**project** (_angr.Project_)

_abstract _get_breakpoints()¶
    

Return the set of currently set breakpoints.

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]

_abstract _add_breakpoint(_addr_)¶
    

Add a breakpoint at the given address.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_abstract _remove_breakpoint(_addr_)¶
    

Remove a breakpoint at the given address, if present.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_abstract _process_concrete(_state_ , _num_inst =None_)¶
    

Process the concrete state and return a HeavyState object.

Parameters:
    

  * **state** (`SimState`[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – The concrete state to process.

  * **num_inst** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

Return type:
    

`SimState`[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]

Returns:
    

A HeavyState object representing the processed state.

process_successors(_successors_ , _*_ , _num_inst =None_, _** kwargs_)¶
    

Implement this function to fill out the SimSuccessors object with the results of stepping state.

In order to implement a model where multiple mixins can potentially handle a request, a mixin may implement this method and then perform a super() call if it wants to pass on handling to the next mixin.

Keep in mind python’s method resolution order when composing multiple classes implementing this method. In short: left-to-right, depth-first, but deferring any base classes which are shared by multiple subclasses (the merge point of a diamond pattern in the inheritance graph) until the last point where they would be encountered in this depth-first search. For example, if you have classes A, B(A), C(B), D(A), E(C, D), then the method resolution order will be E, C, B, D, A.

Parameters:
    

  * **state** – The state to manipulate

  * **successors** (`SimSuccessors`) – The successors object to fill out

  * **kwargs** ([`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]) – Any extra arguments. Do not fail if you are passed unexpected arguments.

  * **num_inst** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

_class _angr.engines.pcode.HeavyPcodeMixin(_* args_, _** kwargs_)¶
    

Bases: `SuccessorsEngine`, `PcodeLifterEngineMixin`, `PcodeEmulatorMixin`

Execution engine based on P-code, Ghidra’s IR.

Responds to the following parameters to the step stack:

  * irsb: The P-Code IRSB object to use for execution. If not provided one will be lifted.

  * skip_stmts: The number of statements to skip in processing

  * last_stmt: Do not execute any statements after this statement

  * thumb: Whether the block should be force to be lifted in ARM’s THUMB mode. (FIXME)

  * extra_stop_points:
    

An extra set of points at which to break basic blocks

  * insn_bytes: A string of bytes to use for the block instead of the project.

  * size: The maximum size of the block, in bytes.

  * num_inst: The maximum number of instructions.

__init__(_* args_, _** kwargs_)¶
    

process_successors(_successors_ , _irsb =None_, _insn_bytes =None_, _thumb =False_, _size =None_, _num_inst =None_, _extra_stop_points =None_, _** kwargs_)¶
    

Implement this function to fill out the SimSuccessors object with the results of stepping state.

In order to implement a model where multiple mixins can potentially handle a request, a mixin may implement this method and then perform a super() call if it wants to pass on handling to the next mixin.

Keep in mind python’s method resolution order when composing multiple classes implementing this method. In short: left-to-right, depth-first, but deferring any base classes which are shared by multiple subclasses (the merge point of a diamond pattern in the inheritance graph) until the last point where they would be encountered in this depth-first search. For example, if you have classes A, B(A), C(B), D(A), E(C, D), then the method resolution order will be E, C, B, D, A.

Parameters:
    

  * **state** – The state to manipulate

  * **successors** (`SimSuccessors`) – The successors object to fill out

  * **kwargs** – Any extra arguments. Do not fail if you are passed unexpected arguments.

  * **irsb** (_IRSB_ _|__None_)

  * **insn_bytes** ([_bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") _|__None_)

  * **thumb** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **num_inst** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **extra_stop_points** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

angr.engines.pcode.register_pcode_arch_default_cc(_arch_)¶
    

Parameters:
    

**arch** ([_ArchPcode_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_pcode.ArchPcode "\(in archinfo\)"))

_class _angr.engines.pcode.engine.HeavyPcodeMixin(_* args_, _** kwargs_)¶
    

Bases: `SuccessorsEngine`, `PcodeLifterEngineMixin`, `PcodeEmulatorMixin`

Execution engine based on P-code, Ghidra’s IR.

Responds to the following parameters to the step stack:

  * irsb: The P-Code IRSB object to use for execution. If not provided one will be lifted.

  * skip_stmts: The number of statements to skip in processing

  * last_stmt: Do not execute any statements after this statement

  * thumb: Whether the block should be force to be lifted in ARM’s THUMB mode. (FIXME)

  * extra_stop_points:
    

An extra set of points at which to break basic blocks

  * insn_bytes: A string of bytes to use for the block instead of the project.

  * size: The maximum size of the block, in bytes.

  * num_inst: The maximum number of instructions.

__init__(_* args_, _** kwargs_)¶
    

process_successors(_successors_ , _irsb =None_, _insn_bytes =None_, _thumb =False_, _size =None_, _num_inst =None_, _extra_stop_points =None_, _** kwargs_)¶
    

Implement this function to fill out the SimSuccessors object with the results of stepping state.

In order to implement a model where multiple mixins can potentially handle a request, a mixin may implement this method and then perform a super() call if it wants to pass on handling to the next mixin.

Keep in mind python’s method resolution order when composing multiple classes implementing this method. In short: left-to-right, depth-first, but deferring any base classes which are shared by multiple subclasses (the merge point of a diamond pattern in the inheritance graph) until the last point where they would be encountered in this depth-first search. For example, if you have classes A, B(A), C(B), D(A), E(C, D), then the method resolution order will be E, C, B, D, A.

Parameters:
    

  * **state** – The state to manipulate

  * **successors** (`SimSuccessors`) – The successors object to fill out

  * **kwargs** – Any extra arguments. Do not fail if you are passed unexpected arguments.

  * **irsb** (_IRSB_ _|__None_)

  * **insn_bytes** ([_bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") _|__None_)

  * **thumb** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **num_inst** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **extra_stop_points** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

_class _angr.engines.pcode.lifter.ExitStatement(_dst_ , _jumpkind_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

This class exists to ease compatibility with CFGFast’s processing of exit_statements. See _scan_irsb method.

Parameters:
    

  * **dst** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

__init__(_dst_ , _jumpkind_)¶
    

Parameters:
    

  * **dst** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

dst _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

jumpkind _: [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.lifter.PcodeDisassemblerBlock(_addr_ , _insns_ , _thumb_ , _arch_)¶
    

Bases: `DisassemblerBlock`

Helper class to represent a block of disassembled target architecture instructions

addr¶
    

arch¶
    

insns¶
    

thumb¶
    

_class _angr.engines.pcode.lifter.PcodeDisassemblerInsn(_pcode_insn_)¶
    

Bases: `DisassemblerInsn`

Helper class to represent a disassembled target architecture instruction

__init__(_pcode_insn_)¶
    

_property _size _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_property _address _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_property _mnemonic _: [str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")_¶
    

_property _op_str _: [str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.lifter.IRSB(_data_ , _mem_addr_ , _arch_ , _max_inst =None_, _max_bytes =None_, _bytes_offset =0_, _traceflags =0_, _opt_level =1_, _num_inst =None_, _num_bytes =None_, _strict_block_end =False_, _skip_stmts =False_, _collect_data_refs =False_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

IRSB stands for _Intermediate Representation Super-Block_. An IRSB in is a single-entry, multiple-exit code block.

Variables:
    

  * **arch** ([`archinfo.Arch`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)")) – The architecture this block is lifted under

  * **statements** (list of `IRStmt`) – The statements in this block

  * **next** (`IRExpr`) – The expression for the default exit target of this block

  * **offsIP** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The offset of the instruction pointer in the VEX guest state

  * **stmts_used** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The number of statements in this IRSB

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The type of this block’s default jump (call, boring, syscall, etc) as a VEX enum string

  * **direct_next** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether this block ends with a direct (not indirect) jump or branch

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The size of this block in bytes

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address of this basic block, i.e. the address in the first IMark

Parameters:
    

  * **data** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|_[_bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") _|__None_)

  * **mem_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)"))

  * **max_inst** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **max_bytes** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **bytes_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **traceflags** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **opt_level** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **num_inst** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **num_bytes** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **strict_block_end** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **skip_stmts** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **collect_data_refs** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

MAX_EXITS _ = 400_¶
    

MAX_DATA_REFS _ = 2000_¶
    

__init__(_data_ , _mem_addr_ , _arch_ , _max_inst =None_, _max_bytes =None_, _bytes_offset =0_, _traceflags =0_, _opt_level =1_, _num_inst =None_, _num_bytes =None_, _strict_block_end =False_, _skip_stmts =False_, _collect_data_refs =False_)¶
    

Parameters:
    

  * **data** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")) – The bytes to lift. Can be either a string of bytes or a cffi buffer object. You may also pass None to initialize an empty IRSB.

  * **mem_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address to lift the data at.

  * **arch** ([`Arch`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)")) – The architecture to lift the data as.

  * **max_inst** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – The maximum number of instructions to lift. (See note below)

  * **max_bytes** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – The maximum number of bytes to use.

  * **num_inst** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – Replaces max_inst if max_inst is None. If set to None as well, no instruction limit is used.

  * **num_bytes** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – Replaces max_bytes if max_bytes is None. If set to None as well, no byte limit is used.

  * **bytes_offset** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The offset into data to start lifting at. Note that for ARM THUMB mode, both mem_addr and bytes_offset must be odd (typically bytes_offset is set to 1).

  * **traceflags** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Unused by P-Code lifter

  * **opt_level** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Unused by P-Code lifter

  * **strict_block_end** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Unused by P-Code lifter

  * **skip_stmts** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **collect_data_refs** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Return type:
    

None

Note

Explicitly specifying the number of instructions to lift (max_inst) may not always work exactly as expected. For example, on MIPS, it is meaningless to lift a branch or jump instruction without its delay slot. VEX attempts to Do The Right Thing by possibly decoding fewer instructions than requested. Specifically, this means that lifting a branch or jump on MIPS as a single instruction (max_inst=1) will result in an empty IRSB, and subsequent attempts to run this block will raise SimIRSBError(‘Empty IRSB passed to SimIRSB.’).

Note

If no instruction and byte limit is used, the lifter will continue lifting the block until the block ends properly or until it runs out of data to lift.

addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

arch _: [`Arch`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)")_¶
    

behaviors _: `BehaviorFactory` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

data_refs _: [`Sequence`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence "\(in Python v3.13\)")_¶
    

const_vals _: [`Sequence`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence "\(in Python v3.13\)")_¶
    

default_exit_target _: [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")_¶
    

jumpkind _: [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

next _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

_static _empty_block(_arch_ , _addr_ , _statements =None_, _nxt =None_, _tyenv =None_, _jumpkind =None_, _direct_next =None_, _size =None_)¶
    

Return type:
    

`IRSB`

Parameters:
    

  * **arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)"))

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **statements** ([_Sequence_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence "\(in Python v3.13\)") _|__None_)

  * **nxt** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **direct_next** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

_property _has_statements _: [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

_property _exit_statements _: [Sequence](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence "\(in Python v3.13\)")[[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), ExitStatement]]_¶
    

copy()¶
    

Copy by creating an empty IRSB and then filling in the leftover attributes. Copy is made as deep as possible

Return type:
    

`IRSB`

extend(_extendwith_)¶
    

Appends an irsb to the current irsb. The irsb that is appended is invalidated. The appended irsb’s jumpkind and default exit are used. :type extendwith: `IRSB` :param extendwith: The IRSB to append to this IRSB

Return type:
    

`IRSB`

Parameters:
    

**extendwith** (_IRSB_)

invalidate_direct_next()¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

pp()¶
    

Pretty-print the IRSB to stdout.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

_property _tyenv¶
    

_property _stmts_used _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_property _offsIP _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

_property _direct_next _: [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

_property _expressions¶
    

Return an iterator of all expressions contained in the IRSB.

_property _instructions _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

The number of instructions in this block

_property _instruction_addresses _: [Sequence](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]_¶
    

Addresses of instructions in this block.

_property _size _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

The size of this block, in bytes

_property _operations¶
    

A list of all operations done by the IRSB, as libVEX enum names

_property _all_constants¶
    

Returns all constants in the block (including incrementing of the program counter) as [`pyvex.const.IRConst`](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.const.IRConst "\(in pyvex\)").

_property _constants¶
    

The constants (excluding updates of the program counter) in the IRSB as [`pyvex.const.IRConst`](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.const.IRConst "\(in pyvex\)").

_property _constant_jump_targets¶
    

A set of the static jump targets of the basic block.

_property _constant_jump_targets_and_jumpkinds¶
    

A dict of the static jump targets of the basic block to their jumpkind.

_property _is_noop_block _: [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

Returns True if this block is a no-op block (i.e. it has no instructions and no jumps).

_property _statements _: [list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")_¶
    

_property _disassembly _: PcodeDisassemblerBlock_¶
    

_class _angr.engines.pcode.lifter.Lifter(_arch_ , _addr_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A lifter is a class of methods for processing a block.

Variables:
    

  * **data** – The bytes to lift as either a python string of bytes or a cffi buffer object.

  * **bytes_offset** – The offset into data to start lifting at.

  * **max_bytes** – The maximum number of bytes to lift. If set to None, no byte limit is used.

  * **max_inst** – The maximum number of instructions to lift. If set to None, no instruction limit is used.

  * **opt_level** – Unused by P-Code lifter

  * **traceflags** – Unused by P-Code lifter

  * **allow_arch_optimizations** – Unused by P-Code lifter

  * **strict_block_end** – Unused by P-Code lifter

  * **skip_stmts** – Unused by P-Code lifter

Parameters:
    

  * **arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)"))

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

REQUIRE_DATA_C _ = False_¶
    

REQUIRE_DATA_PY _ = False_¶
    

__init__(_arch_ , _addr_)¶
    

Parameters:
    

  * **arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)"))

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

arch _: [`Arch`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)")_¶
    

addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

data _: [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

bytes_offset _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

opt_level _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

traceflags _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

allow_arch_optimizations _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

strict_block_end _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

collect_data_refs _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

max_inst _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

max_bytes _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

skip_stmts _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

irsb _: `IRSB`_¶
    

lift()¶
    

Lifts the data using the information passed into _lift. Should be overridden in child classes.

Should set the lifted IRSB to self.irsb. If a lifter raises a LiftingException on the data, this signals that the lifter cannot lift this data and arch and the lifter is skipped. If a lifter can lift any amount of data, it should lift it and return the lifted block with a jumpkind of Ijk_NoDecode, signalling to pyvex that other lifters should be used on the undecodable data.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

angr.engines.pcode.lifter.lift(_data_ , _addr_ , _arch_ , _max_bytes =None_, _max_inst =None_, _bytes_offset =0_, _opt_level =1_, _traceflags =0_, _strict_block_end =True_, _inner =False_, _skip_stmts =False_, _collect_data_refs =False_)¶
    

Lift machine code in data to a P-code IRSB.

If a lifter raises a LiftingException on the data, it is skipped. If it succeeds and returns a block with a jumpkind of Ijk_NoDecode, all of the lifters are tried on the rest of the data and if they work, their output is appended to the first block.

Parameters:
    

  * **arch** ([`Arch`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)")) – The arch to lift the data as.

  * **addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The starting address of the block. Effects the IMarks.

  * **data** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")) – The bytes to lift as either a python string of bytes or a cffi buffer object.

  * **max_bytes** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – The maximum number of bytes to lift. If set to None, no byte limit is used.

  * **max_inst** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – The maximum number of instructions to lift. If set to None, no instruction limit is used.

  * **bytes_offset** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The offset into data to start lifting at.

  * **opt_level** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Unused by P-Code lifter

  * **traceflags** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Unused by P-Code lifter

  * **strict_block_end** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **inner** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **skip_stmts** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **collect_data_refs** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Return type:
    

`IRSB`

Note

Explicitly specifying the number of instructions to lift (max_inst) may not always work exactly as expected. For example, on MIPS, it is meaningless to lift a branch or jump instruction without its delay slot. VEX attempts to Do The Right Thing by possibly decoding fewer instructions than requested. Specifically, this means that lifting a branch or jump on MIPS as a single instruction (max_inst=1) will result in an empty IRSB, and subsequent attempts to run this block will raise SimIRSBError(‘Empty IRSB passed to SimIRSB.’).

Note

If no instruction and byte limit is used, the lifter will continue lifting the block until the block ends properly or until it runs out of data to lift.

_class _angr.engines.pcode.lifter.PcodeBasicBlockLifter(_arch_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Lifts basic blocks to P-code

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

__init__(_arch_)¶
    

Parameters:
    

**arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)"))

context _: [`Context`](https://docs.angr.io/projects/pypcode/en/latest/api.html#pypcode.Context "\(in pypcode\)")_¶
    

behaviors _: `BehaviorFactory`_¶
    

lift(_irsb_ , _baseaddr_ , _data_ , _bytes_offset =0_, _max_bytes =None_, _max_inst =None_, _branch_delay_slot =False_, _is_sparc32 =False_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **irsb** (_IRSB_)

  * **baseaddr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **data** ([_bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") _|_[_bytearray_](https://docs.python.org/3/library/stdtypes.html#bytearray "\(in Python v3.13\)"))

  * **bytes_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **max_bytes** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **max_inst** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **branch_delay_slot** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **is_sparc32** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

_class _angr.engines.pcode.lifter.PcodeLifter(_arch_ , _addr_)¶
    

Bases: `Lifter`

Handles calling into pypcode to lift a block

Parameters:
    

  * **arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)"))

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

allow_arch_optimizations _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

arch _: [`Arch`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)")_¶
    

bytes_offset _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

collect_data_refs _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

data _: [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

irsb _: `IRSB`_¶
    

max_bytes _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

max_inst _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

opt_level _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

skip_stmts _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

strict_block_end _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

traceflags _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

lift()¶
    

Lifts the data using the information passed into _lift. Should be overridden in child classes.

Should set the lifted IRSB to self.irsb. If a lifter raises a LiftingException on the data, this signals that the lifter cannot lift this data and arch and the lifter is skipped. If a lifter can lift any amount of data, it should lift it and return the lifted block with a jumpkind of Ijk_NoDecode, signalling to pyvex that other lifters should be used on the undecodable data.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

_class _angr.engines.pcode.lifter.PcodeLifterEngineMixin(_project =None_, _use_cache =None_, _cache_size =50000_, _default_opt_level =1_, _selfmodifying_code =None_, _single_step =False_, _default_strict_block_end =False_, _** kwargs_)¶
    

Bases: `SimEngine`

Lifter mixin to lift from machine code to P-Code.

Parameters:
    

  * **use_cache** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **cache_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **default_opt_level** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **selfmodifying_code** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **single_step** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **default_strict_block_end** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_project =None_, _use_cache =None_, _cache_size =50000_, _default_opt_level =1_, _selfmodifying_code =None_, _single_step =False_, _default_strict_block_end =False_, _** kwargs_)¶
    

Parameters:
    

  * **use_cache** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **cache_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **default_opt_level** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **selfmodifying_code** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **single_step** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **default_strict_block_end** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

clear_cache()¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

lift_vex(_addr =None_, _state =None_, _clemory =None_, _insn_bytes =None_, _arch =None_, _size =None_, _num_inst =None_, _traceflags =0_, _thumb =False_, _extra_stop_points =None_, _opt_level =None_, _strict_block_end =None_, _skip_stmts =False_, _collect_data_refs =False_, _load_from_ro_regions =False_, _cross_insn_opt =None_, _const_prop =None_)¶
    

Temporary compatibility interface for integration with block code.

Return type:
    

`IRSB`

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **state** (_SimState_ _|__None_)

  * **clemory** ([_Clemory_](https://docs.angr.io/projects/cle/en/latest/api/utils.html#cle.memory.Clemory "\(in cle\)") _|__ClemoryReadOnlyView_ _|__None_)

  * **insn_bytes** ([_bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") _|__None_)

  * **arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)") _|__None_)

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **num_inst** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **traceflags** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **thumb** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **extra_stop_points** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **opt_level** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **strict_block_end** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **skip_stmts** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **collect_data_refs** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **load_from_ro_regions** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **cross_insn_opt** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **const_prop** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

lift_pcode(_addr =None_, _state =None_, _clemory =None_, _insn_bytes =None_, _arch =None_, _size =None_, _num_inst =None_, _traceflags =0_, _thumb =False_, _extra_stop_points =None_, _opt_level =None_, _strict_block_end =None_, _skip_stmts =False_, _collect_data_refs =False_, _load_from_ro_regions =False_, _cross_insn_opt =None_, _const_prop =None_)¶
    

Lift an IRSB.

There are many possible valid sets of parameters. You at the very least must pass some source of data, some source of an architecture, and some source of an address.

Sources of data in order of priority: insn_bytes, clemory, state

Sources of an address, in order of priority: addr, state

Sources of an architecture, in order of priority: arch, clemory, state

Parameters:
    

  * **state** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[`SimState`]) – A state to use as a data source.

  * **clemory** ([`Union`](https://docs.python.org/3/library/typing.html#typing.Union "\(in Python v3.13\)")[[`Clemory`](https://docs.angr.io/projects/cle/en/latest/api/utils.html#cle.memory.Clemory "\(in cle\)"), `ClemoryReadOnlyView`, [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")]) – A cle.memory.Clemory object to use as a data source.

  * **addr** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – The address at which to start the block.

  * **thumb** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether the block should be lifted in ARM’s THUMB mode.

  * **opt_level** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – Unused for P-Code lifter

  * **insn_bytes** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)")]) – A string of bytes to use as a data source.

  * **size** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – The maximum size of the block, in bytes.

  * **num_inst** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – The maximum number of instructions.

  * **traceflags** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Unused by P-Code lifter

  * **strict_block_end** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")]) – Unused by P-Code lifter

  * **load_from_ro_regions** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Unused by P-Code lifter

  * **arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)") _|__None_)

  * **extra_stop_points** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **skip_stmts** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **collect_data_refs** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **cross_insn_opt** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **const_prop** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

Return type:
    

`IRSB`

_class _angr.engines.pcode.emulate.PcodeEmulatorMixin(_* args_, _** kwargs_)¶
    

Bases: `SimEngine`

Mixin for p-code execution.

__init__(_* args_, _** kwargs_)¶
    

handle_pcode_block(_irsb_)¶
    

Execute a single P-Code IRSB.

Parameters:
    

**irsb** (`IRSB`) – Block to be executed.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

angr.engines.pcode.behavior.make_bv_sizes_equal(_bv1_ , _bv2_)¶
    

Makes two BVs equal in length through sign extension.

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"), [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")]

Parameters:
    

  * **bv1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **bv2** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

_class _angr.engines.pcode.behavior.OpBehavior(_opcode_ , _is_unary_ , _is_special =False_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Base class for all operation behaviors.

Parameters:
    

  * **opcode** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **is_unary** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **is_special** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_opcode_ , _is_unary_ , _is_special =False_)¶
    

Parameters:
    

  * **opcode** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **is_unary** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **is_special** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Return type:
    

None

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

evaluate_unary(_size_out_ , _size_in_ , _in1_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

evaluate_binary(_size_out_ , _size_in_ , _in1_ , _in2_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **in2** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

_static _generic_compare(_args_ , _comparison_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **args** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _]_)

  * **comparison** ([_Callable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)") _[__[_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _,_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _]__,_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _]_)

_classmethod _booleanize(_in1_)¶
    

Reduce input BV to a single bit of truth: out <\- 1 if (in1 != 0) else 0.

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

**in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

_class _angr.engines.pcode.behavior.OpBehaviorCopy¶
    

Bases: `OpBehavior`

Behavior for the COPY operation.

__init__()¶
    

evaluate_unary(_size_out_ , _size_in_ , _in1_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorEqual¶
    

Bases: `OpBehavior`

Behavior for the INT_EQUAL operation.

__init__()¶
    

evaluate_binary(_size_out_ , _size_in_ , _in1_ , _in2_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **in2** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorNotEqual¶
    

Bases: `OpBehavior`

Behavior for the INT_NOTEQUAL operation.

__init__()¶
    

evaluate_binary(_size_out_ , _size_in_ , _in1_ , _in2_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **in2** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorIntSless¶
    

Bases: `OpBehavior`

Behavior for the INT_SLESS operation.

__init__()¶
    

evaluate_binary(_size_out_ , _size_in_ , _in1_ , _in2_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **in2** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorIntSlessEqual¶
    

Bases: `OpBehavior`

Behavior for the INT_SLESSEQUAL operation.

__init__()¶
    

evaluate_binary(_size_out_ , _size_in_ , _in1_ , _in2_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **in2** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorIntLess¶
    

Bases: `OpBehavior`

Behavior for the INT_LESS operation.

__init__()¶
    

evaluate_binary(_size_out_ , _size_in_ , _in1_ , _in2_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **in2** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorIntLessEqual¶
    

Bases: `OpBehavior`

Behavior for the INT_LESSEQUAL operation.

__init__()¶
    

evaluate_binary(_size_out_ , _size_in_ , _in1_ , _in2_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **in2** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorIntZext¶
    

Bases: `OpBehavior`

Behavior for the INT_ZEXT operation.

__init__()¶
    

evaluate_unary(_size_out_ , _size_in_ , _in1_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorIntSext¶
    

Bases: `OpBehavior`

Behavior for the INT_SEXT operation.

__init__()¶
    

evaluate_unary(_size_out_ , _size_in_ , _in1_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorIntAdd¶
    

Bases: `OpBehavior`

Behavior for the INT_ADD operation.

__init__()¶
    

evaluate_binary(_size_out_ , _size_in_ , _in1_ , _in2_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **in2** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorIntSub¶
    

Bases: `OpBehavior`

Behavior for the INT_SUB operation.

__init__()¶
    

evaluate_binary(_size_out_ , _size_in_ , _in1_ , _in2_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **in2** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorIntCarry¶
    

Bases: `OpBehavior`

Behavior for the INT_CARRY operation.

__init__()¶
    

evaluate_binary(_size_out_ , _size_in_ , _in1_ , _in2_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **in2** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorIntScarry¶
    

Bases: `OpBehavior`

Behavior for the INT_SCARRY operation.

__init__()¶
    

evaluate_binary(_size_out_ , _size_in_ , _in1_ , _in2_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **in2** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorIntSborrow¶
    

Bases: `OpBehavior`

Behavior for the INT_SBORROW operation.

__init__()¶
    

evaluate_binary(_size_out_ , _size_in_ , _in1_ , _in2_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **in2** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorInt2Comp¶
    

Bases: `OpBehavior`

Behavior for the INT_2COMP operation.

__init__()¶
    

evaluate_unary(_size_out_ , _size_in_ , _in1_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorIntNegate¶
    

Bases: `OpBehavior`

Behavior for the INT_NEGATE operation.

__init__()¶
    

evaluate_unary(_size_out_ , _size_in_ , _in1_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorIntXor¶
    

Bases: `OpBehavior`

Behavior for the INT_XOR operation.

__init__()¶
    

evaluate_binary(_size_out_ , _size_in_ , _in1_ , _in2_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **in2** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorIntAnd¶
    

Bases: `OpBehavior`

Behavior for the INT_AND operation.

__init__()¶
    

evaluate_binary(_size_out_ , _size_in_ , _in1_ , _in2_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **in2** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorIntOr¶
    

Bases: `OpBehavior`

Behavior for the INT_OR operation.

__init__()¶
    

evaluate_binary(_size_out_ , _size_in_ , _in1_ , _in2_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **in2** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorIntLeft¶
    

Bases: `OpBehavior`

Behavior for the INT_LEFT operation.

__init__()¶
    

evaluate_binary(_size_out_ , _size_in_ , _in1_ , _in2_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **in2** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorIntRight¶
    

Bases: `OpBehavior`

Behavior for the INT_RIGHT operation.

__init__()¶
    

evaluate_binary(_size_out_ , _size_in_ , _in1_ , _in2_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **in2** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorIntSright¶
    

Bases: `OpBehavior`

Behavior for the INT_SRIGHT operation.

__init__()¶
    

evaluate_binary(_size_out_ , _size_in_ , _in1_ , _in2_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **in2** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorIntMult¶
    

Bases: `OpBehavior`

Behavior for the INT_MULT operation.

__init__()¶
    

evaluate_binary(_size_out_ , _size_in_ , _in1_ , _in2_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **in2** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorIntDiv¶
    

Bases: `OpBehavior`

Behavior for the INT_DIV operation.

__init__()¶
    

evaluate_binary(_size_out_ , _size_in_ , _in1_ , _in2_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **in2** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorIntSdiv¶
    

Bases: `OpBehavior`

Behavior for the INT_SDIV operation.

__init__()¶
    

evaluate_binary(_size_out_ , _size_in_ , _in1_ , _in2_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **in2** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorIntRem¶
    

Bases: `OpBehavior`

Behavior for the INT_REM operation.

__init__()¶
    

evaluate_binary(_size_out_ , _size_in_ , _in1_ , _in2_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **in2** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorIntSrem¶
    

Bases: `OpBehavior`

Behavior for the INT_SREM operation.

__init__()¶
    

evaluate_binary(_size_out_ , _size_in_ , _in1_ , _in2_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **in2** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorBoolNegate¶
    

Bases: `OpBehavior`

Behavior for the BOOL_NEGATE operation.

__init__()¶
    

evaluate_unary(_size_out_ , _size_in_ , _in1_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorBoolXor¶
    

Bases: `OpBehavior`

Behavior for the BOOL_XOR operation.

__init__()¶
    

evaluate_binary(_size_out_ , _size_in_ , _in1_ , _in2_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **in2** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorBoolAnd¶
    

Bases: `OpBehavior`

Behavior for the BOOL_AND operation.

__init__()¶
    

evaluate_binary(_size_out_ , _size_in_ , _in1_ , _in2_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **in2** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorBoolOr¶
    

Bases: `OpBehavior`

Behavior for the BOOL_OR operation.

__init__()¶
    

evaluate_binary(_size_out_ , _size_in_ , _in1_ , _in2_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **in2** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorFloatEqual¶
    

Bases: `OpBehavior`

Behavior for the FLOAT_EQUAL operation.

__init__()¶
    

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorFloatNotEqual¶
    

Bases: `OpBehavior`

Behavior for the FLOAT_NOTEQUAL operation.

__init__()¶
    

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorFloatLess¶
    

Bases: `OpBehavior`

Behavior for the FLOAT_LESS operation.

__init__()¶
    

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorFloatLessEqual¶
    

Bases: `OpBehavior`

Behavior for the FLOAT_LESSEQUAL operation.

__init__()¶
    

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorFloatNan¶
    

Bases: `OpBehavior`

Behavior for the FLOAT_NAN operation.

__init__()¶
    

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorFloatAdd¶
    

Bases: `OpBehavior`

Behavior for the FLOAT_ADD operation.

__init__()¶
    

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorFloatDiv¶
    

Bases: `OpBehavior`

Behavior for the FLOAT_DIV operation.

__init__()¶
    

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorFloatMult¶
    

Bases: `OpBehavior`

Behavior for the FLOAT_MULT operation.

__init__()¶
    

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorFloatSub¶
    

Bases: `OpBehavior`

Behavior for the FLOAT_SUB operation.

__init__()¶
    

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorFloatNeg¶
    

Bases: `OpBehavior`

Behavior for the FLOAT_NEG operation.

__init__()¶
    

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorFloatAbs¶
    

Bases: `OpBehavior`

Behavior for the FLOAT_ABS operation.

__init__()¶
    

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorFloatSqrt¶
    

Bases: `OpBehavior`

Behavior for the FLOAT_SQRT operation.

__init__()¶
    

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorFloatInt2Float¶
    

Bases: `OpBehavior`

Behavior for the FLOAT_INT2FLOAT operation.

__init__()¶
    

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorFloatFloat2Float¶
    

Bases: `OpBehavior`

Behavior for the FLOAT_FLOAT2FLOAT operation.

__init__()¶
    

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorFloatTrunc¶
    

Bases: `OpBehavior`

Behavior for the FLOAT_TRUNC operation.

__init__()¶
    

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorFloatCeil¶
    

Bases: `OpBehavior`

Behavior for the FLOAT_CEIL operation.

__init__()¶
    

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorFloatFloor¶
    

Bases: `OpBehavior`

Behavior for the FLOAT_FLOOR operation.

__init__()¶
    

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorFloatRound¶
    

Bases: `OpBehavior`

Behavior for the FLOAT_ROUND operation.

__init__()¶
    

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorPiece¶
    

Bases: `OpBehavior`

Behavior for the PIECE operation.

__init__()¶
    

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorSubpiece¶
    

Bases: `OpBehavior`

Behavior for the SUBPIECE operation.

__init__()¶
    

evaluate_binary(_size_out_ , _size_in_ , _in1_ , _in2_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **in2** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorPopcount¶
    

Bases: `OpBehavior`

Behavior for the POPCOUNT operation.

__init__()¶
    

evaluate_unary(_size_out_ , _size_in_ , _in1_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.OpBehaviorLzcount¶
    

Bases: `OpBehavior`

Behavior for the LZCOUNT operation.

__init__()¶
    

evaluate_unary(_size_out_ , _size_in_ , _in1_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **size_out** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size_in** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **in1** ([_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

is_special _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

is_unary _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

opcode _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.engines.pcode.behavior.BehaviorFactory¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Returns the behavior object for a given opcode.

__init__()¶
    

get_behavior_for_opcode(_opcode_)¶
    

Return type:
    

`OpBehavior`

Parameters:
    

**opcode** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_class _angr.engines.pcode.cc.SimCCM68k(_arch_)¶
    

Bases: `SimCC`

Default CC for M68k

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARG_REGS _: list[str]__ = []_¶
    

FP_ARG_REGS _: list[str]__ = []_¶
    

STACKARG_SP_DIFF _ = 4_¶
    

RETURN_VAL _: SimFunctionArgument | None_ _ = <d0>_¶
    

RETURN_ADDR _: SimFunctionArgument | None_ _ = [0x0]_¶
    

_class _angr.engines.pcode.cc.SimCCRISCV(_arch_)¶
    

Bases: `SimCC`

Default CC for RISCV

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARG_REGS _: list[str]__ = ['a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7']_¶
    

RETURN_ADDR _: SimFunctionArgument | None_ _ = <ra>_¶
    

RETURN_VAL _: SimFunctionArgument | None_ _ = <a0>_¶
    

_class _angr.engines.pcode.cc.SimCCSPARC(_arch_)¶
    

Bases: `SimCC`

Default CC for SPARC

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARG_REGS _: list[str]__ = ['o0', 'o1', 'o2', 'o3', 'o4', 'o5']_¶
    

RETURN_VAL _: SimFunctionArgument | None_ _ = <o0>_¶
    

RETURN_ADDR _: SimFunctionArgument | None_ _ = <o7>_¶
    

_class _angr.engines.pcode.cc.SimCCSH4(_arch_)¶
    

Bases: `SimCC`

Default CC for SH4

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARG_REGS _: list[str]__ = ['r4', 'r5']_¶
    

RETURN_VAL _: SimFunctionArgument | None_ _ = <r0>_¶
    

RETURN_ADDR _: SimFunctionArgument | None_ _ = <pr>_¶
    

_class _angr.engines.pcode.cc.SimCCPARISC(_arch_)¶
    

Bases: `SimCC`

Default CC for PARISC

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARG_REGS _: list[str]__ = ['r26', 'r25']_¶
    

RETURN_VAL _: SimFunctionArgument | None_ _ = <r28>_¶
    

RETURN_ADDR _: SimFunctionArgument | None_ _ = <rp>_¶
    

_class _angr.engines.pcode.cc.SimCCPowerPC(_arch_)¶
    

Bases: `SimCC`

Default CC for PowerPC

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARG_REGS _: list[str]__ = ['r3', 'r4', 'r5', 'r6', 'r7', 'r8', 'r9', 'r10']_¶
    

FP_ARG_REGS _: list[str]__ = []_¶
    

STACKARG_SP_BUFF _ = 8_¶
    

RETURN_ADDR _: SimFunctionArgument | None_ _ = <lr>_¶
    

RETURN_VAL _: SimFunctionArgument | None_ _ = <r3>_¶
    

_class _angr.engines.pcode.cc.SimCCXtensa(_arch_)¶
    

Bases: `SimCC`

Default CC for Xtensa

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARG_REGS _: list[str]__ = ['i2', 'i3', 'i4', 'i5', 'i6', 'i7']_¶
    

FP_ARG_REGS _: list[str]__ = []_¶
    

RETURN_ADDR _: SimFunctionArgument | None_ _ = <a0>_¶
    

RETURN_VAL _: SimFunctionArgument | None_ _ = <o2>_¶
    

angr.engines.pcode.cc.register_pcode_arch_default_cc(_arch_)¶
    

Parameters:
    

**arch** ([_ArchPcode_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_pcode.ArchPcode "\(in archinfo\)"))

## Simulation Logging¶

_class _angr.state_plugins.sim_action.SimAction(_state_ , _region_type_)¶
    

Bases: `SimEvent`

A SimAction represents a semantic action that an analyzed program performs.

TMP _ = 'tmp'_¶
    

REG _ = 'reg'_¶
    

MEM _ = 'mem'_¶
    

__init__(_state_ , _region_type_)¶
    

Initializes the SimAction.

Parameters:
    

**state** – the state that’s the SimAction is taking place in.

_property _all_objects¶
    

_property _is_symbolic¶
    

_property _tmp_deps¶
    

_property _reg_deps¶
    

copy()¶
    

downsize()¶
    

Clears some low-level details (that take up memory) out of the SimAction.

_class _angr.state_plugins.sim_action.SimActionExit(_state_ , _target_ , _condition =None_, _exit_type =None_)¶
    

Bases: `SimAction`

An Exit action represents a (possibly conditional) jump.

CONDITIONAL _ = 'conditional'_¶
    

DEFAULT _ = 'default'_¶
    

__init__(_state_ , _target_ , _condition =None_, _exit_type =None_)¶
    

Initializes the SimAction.

Parameters:
    

**state** – the state that’s the SimAction is taking place in.

_property _all_objects¶
    

_property _is_symbolic¶
    

_class _angr.state_plugins.sim_action.SimActionConstraint(_state_ , _constraint_ , _condition =None_)¶
    

Bases: `SimAction`

A constraint action represents an extra constraint added during execution of a path.

__init__(_state_ , _constraint_ , _condition =None_)¶
    

Initializes the SimAction.

Parameters:
    

**state** – the state that’s the SimAction is taking place in.

_property _all_objects¶
    

_property _is_symbolic¶
    

_class _angr.state_plugins.sim_action.SimActionOperation(_state_ , _op_ , _exprs_ , _result_)¶
    

Bases: `SimAction`

An action representing an operation between variables and/or constants.

__init__(_state_ , _op_ , _exprs_ , _result_)¶
    

Initializes the SimAction.

Parameters:
    

**state** – the state that’s the SimAction is taking place in.

_property _all_objects¶
    

_property _is_symbolic¶
    

_class _angr.state_plugins.sim_action.SimActionData(_state_ , _region_type_ , _action_ , _tmp =None_, _addr =None_, _size =None_, _data =None_, _condition =None_, _fallback =None_, _fd =None_)¶
    

Bases: `SimAction`

A Data action represents a read or a write from memory, registers or a file.

READ _ = 'read'_¶
    

WRITE _ = 'write'_¶
    

OPERATE _ = 'operate'_¶
    

__init__(_state_ , _region_type_ , _action_ , _tmp =None_, _addr =None_, _size =None_, _data =None_, _condition =None_, _fallback =None_, _fd =None_)¶
    

Initializes the SimAction.

Parameters:
    

**state** – the state that’s the SimAction is taking place in.

downsize()¶
    

Clears some low-level details (that take up memory) out of the SimAction.

_property _all_objects¶
    

_property _is_symbolic¶
    

_property _tmp_deps¶
    

_property _reg_deps¶
    

_property _storage¶
    

angr.state_plugins.sim_action_object.ast_preserving_op(_f_ , _* args_)¶
    

angr.state_plugins.sim_action_object.ast_stripping_decorator(_f_)¶
    

_class _angr.state_plugins.sim_action_object.SimActionObject(_ast_ , _reg_deps =frozenset({})_, _tmp_deps =frozenset({})_, _deps =frozenset({})_, _state =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A SimActionObject tracks an AST and its dependencies.

Parameters:
    

  * **ast** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

  * **reg_deps** ([_frozenset_](https://docs.python.org/3/library/stdtypes.html#frozenset "\(in Python v3.13\)") _[__SimActionData_ _|__SimActionOperation_ _]_)

  * **tmp_deps** ([_frozenset_](https://docs.python.org/3/library/stdtypes.html#frozenset "\(in Python v3.13\)") _[__SimActionData_ _|__SimActionOperation_ _]_)

  * **deps** ([_frozenset_](https://docs.python.org/3/library/stdtypes.html#frozenset "\(in Python v3.13\)"))

  * **state** (_SimState_ _|__None_)

__init__(_ast_ , _reg_deps =frozenset({})_, _tmp_deps =frozenset({})_, _deps =frozenset({})_, _state =None_)¶
    

Parameters:
    

  * **ast** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

  * **reg_deps** ([_frozenset_](https://docs.python.org/3/library/stdtypes.html#frozenset "\(in Python v3.13\)") _[__SimActionData_ _|__SimActionOperation_ _]_)

  * **tmp_deps** ([_frozenset_](https://docs.python.org/3/library/stdtypes.html#frozenset "\(in Python v3.13\)") _[__SimActionData_ _|__SimActionOperation_ _]_)

  * **deps** ([_frozenset_](https://docs.python.org/3/library/stdtypes.html#frozenset "\(in Python v3.13\)"))

  * **state** (_SimState_ _|__None_)

ast _: [`Base`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)")_¶
    

reg_deps _: [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset "\(in Python v3.13\)")[`SimActionData` | `SimActionOperation`]_¶
    

tmp_deps _: [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset "\(in Python v3.13\)")[`SimActionData` | `SimActionOperation`]_¶
    

to_claripy()¶
    

Return type:
    

[`Base`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)")

copy()¶
    

Return type:
    

`SimActionObject`

is_leaf()¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_property _op _: [str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")_¶
    

_property _args _: [tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[ArgType, ...]_¶
    

_property _length _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

_property _variables _: [frozenset](https://docs.python.org/3/library/stdtypes.html#frozenset "\(in Python v3.13\)")[[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]_¶
    

_property _symbolic _: [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

_property _annotations _: [tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[Annotation](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.annotation.Annotation "\(in claripy\)"), ...]_¶
    

_property _depth _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

SDiv(_other_)¶
    

Return type:
    

`SimActionObject`

SMod(_other_)¶
    

Return type:
    

`SimActionObject`

union(_other_)¶
    

Return type:
    

`SimActionObject`

intersection(_other_)¶
    

Return type:
    

`SimActionObject`

widen(_other_)¶
    

Return type:
    

`SimActionObject`

raw_to_bv()¶
    

Return type:
    

`SimActionObject`

bv_to_fp()¶
    

Return type:
    

`SimActionObject`

_class _angr.state_plugins.sim_event.SimEvent(_state_ , _event_type_ , _** kwargs_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A SimEvent is a log entry for some notable event during symbolic execution. It logs the location it was generated (ins_addr, bbl_addr, stmt_idx, and sim_procedure) as well as arbitrary tags (objects).

You may also be interested in SimAction, which is a specialization of SimEvent for CPU events.

__init__(_state_ , _event_type_ , _** kwargs_)¶
    

angr.state_plugins.sim_event.resource_event(_state_ , _exception_)¶
    

## Procedures¶

_class _angr.sim_procedure.SimProcedure(_project =None_, _cc =None_, _prototype =None_, _symbolic_return =None_, _returns =None_, _is_syscall =False_, _is_stub =False_, _num_args =None_, _display_name =None_, _library_name =None_, _is_function =None_, _** kwargs_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A SimProcedure is a wonderful object which describes a procedure to run on a state.

You may subclass SimProcedure and override `run()`, replacing it with mutating `self.state` however you like, and then either returning a value or jumping away somehow.

A detailed discussion of programming SimProcedures may be found at <https://docs.angr.io/extending-angr/simprocedures>

Parameters:
    

  * **arch** – The architecture to use for this procedure

  * **project** (_Project_)

  * **cc** (_SimCC_)

  * **prototype** (_SimTypeFunction_)

The following parameters are optional:

Parameters:
    

  * **symbolic_return** – Whether the procedure’s return value should be stubbed into a single symbolic variable constratined to the real return value

  * **returns** – Whether the procedure should return to its caller afterwards

  * **is_syscall** – Whether this procedure is a syscall

  * **num_args** – The number of arguments this procedure should extract

  * **display_name** – The name to use when displaying this procedure

  * **library_name** – The name of the library from which the function we’re emulating comes

  * **cc** – The SimCC to use for this procedure

  * **sim_kwargs** – Additional keyword arguments to be passed to run()

  * **is_function** – Whether this procedure emulates a function

  * **project** (_Project_)

  * **prototype** (_SimTypeFunction_)

The following class variables should be set if necessary when implementing a new SimProcedure:

Variables:
    

  * **NO_RET** – Set this to true if control flow will never return from this function

  * **DYNAMIC_RET** – Set this to true if whether the control flow returns from this function or not depends on the context (e.g., libc’s error() call). Must implement dynamic_returns() method.

  * **ADDS_EXITS** – Set this to true if you do any control flow other than returning

  * **IS_FUNCTION** – Does this procedure simulate a function? True by default

  * **ARGS_MISMATCH** – Does this procedure have a different list of arguments than what is provided in the function specification? This may happen when we manually extract arguments in the run() method of a SimProcedure. False by default.

  * **local_vars** – If you use `self.call()`, set this to a list of all the local variable names in your class. They will be restored on return.

Parameters:
    

  * **project** (_Project_)

  * **cc** (_SimCC_)

  * **prototype** (_SimTypeFunction_)

The following instance variables are available when working with simprocedures from the inside or the outside:

Variables:
    

  * **project** – The associated angr project

  * **arch** – The associated architecture

  * **addr** – The linear address at which the procedure is executing

  * **cc** – The calling convention in use for engaging with the ABI

  * **canonical** – The canonical version of this SimProcedure. Procedures are deepcopied for many reasons, including to be able to store state related to a specific run and to be able to hook continuations.

  * **kwargs** – Any extra keyword arguments used to construct the procedure; will be passed to `run`

  * **display_name** – See the eponymous parameter

  * **library_name** – See the eponymous parameter

  * **abi** – If this is a syscall simprocedure, which ABI are we using to map the syscall numbers?

  * **symbolic_return** – See the eponymous parameter

  * **syscall_number** – If this procedure is a syscall, the number will be populated here.

  * **returns** – See eponymous parameter and NO_RET cvar

  * **is_syscall** – See eponymous parameter

  * **is_function** – See eponymous parameter and cvar

  * **is_stub** – See eponymous parameter

  * **is_continuation** – Whether this procedure is the original or a continuation resulting from `self.call()`

  * **continuations** – A mapping from name to each known continuation

  * **run_func** – The name of the function implementing the procedure. “run” by default, but different in continuations.

  * **num_args** – The number of arguments to the procedure. If not provided in the parameter, extracted from the definition of `self.run`

Parameters:
    

  * **project** (_Project_)

  * **cc** (_SimCC_)

  * **prototype** (_SimTypeFunction_)

The following instance variables are only used in a copy of the procedure that is actually executing on a state:

Variables:
    

  * **state** – The SimState we should be mutating to perform the procedure

  * **successors** – The SimSuccessors associated with the current step

  * **arguments** – The function arguments, deserialized from the state

  * **arg_session** – The ArgSession that was used to parse arguments out of the state, in case you need it for varargs

  * **use_state_arguments** – Whether we’re using arguments extracted from the state or manually provided

  * **ret_to** – The current return address

  * **ret_expr** – The computed return value

  * **call_ret_expr** – The return value from having used `self.call()`

  * **inhibit_autoret** – Whether we should avoid automatically adding an exit for returning once the run function ends

  * **arg_session** – The ArgSession object that was used to extract the runtime argument values. Useful for if you want to extract variadic args.

Parameters:
    

  * **project** (_Project_)

  * **cc** (_SimCC_)

  * **prototype** (_SimTypeFunction_)

__init__(_project =None_, _cc =None_, _prototype =None_, _symbolic_return =None_, _returns =None_, _is_syscall =False_, _is_stub =False_, _num_args =None_, _display_name =None_, _library_name =None_, _is_function =None_, _** kwargs_)¶
    

project _: `Project`_¶
    

arch _: [`Arch`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)")_¶
    

cc _: `SimCC`_¶
    

prototype _: `SimTypeFunction`_¶
    

state _: `SimState`_¶
    

arg_session _: [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") | `ArgSession` | [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

execute(_state_ , _successors =None_, _arguments =None_, _ret_to =None_)¶
    

Call this method with a SimState and a SimSuccessors to execute the procedure.

Alternately, successors may be none if this is an inline call. In that case, you should provide arguments to the function.

make_continuation(_name_)¶
    

NO_RET _ = False_¶
    

DYNAMIC_RET _ = False_¶
    

ADDS_EXITS _ = False_¶
    

IS_FUNCTION _ = True_¶
    

ARGS_MISMATCH _ = False_¶
    

ALT_NAMES _ = None_¶
    

local_vars _: [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"), [`...`](https://docs.python.org/3/library/constants.html#Ellipsis "\(in Python v3.13\)")]__ = ()_¶
    

run(_* args_, _** kwargs_)¶
    

Implement the actual procedure here!

Return type:
    

[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")

static_exits(_blocks_ , _** kwargs_)¶
    

Get new exits by performing static analysis and heuristics. This is a fast and best-effort approach to get new exits for scenarios where states are not available (e.g. when building a fast CFG).

Parameters:
    

**blocks** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – Blocks that are executed before reaching this SimProcedure.

Returns:
    

A list of dicts. Each dict should contain the following entries: ‘address’, ‘jumpkind’, and ‘namehint’.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

dynamic_returns(_blocks_ , _** kwargs_)¶
    

Determines if a call to this function returns or not by performing static analysis and heuristics.

Parameters:
    

**blocks** – Blocks that are executed before reaching this SimProcedure.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

True if the call returns, False otherwise.

_property _should_add_successors¶
    

set_args(_args_)¶
    

va_arg(_ty_ , _index =None_)¶
    

inline_call(_procedure_ , _* arguments_, _** kwargs_)¶
    

Call another SimProcedure in-line to retrieve its return value. Returns an instance of the procedure with the ret_expr property set.

Parameters:
    

  * **procedure** – The class of the procedure to execute

  * **arguments** – Any additional positional args will be used as arguments to the procedure call

  * **sim_kwargs** – Any additional keyword args will be passed as sim_kwargs to the procedure constructor

fix_prototype_returnty(_ret_size_)¶
    

ret(_expr =None_)¶
    

Add an exit representing a return from this function. If this is not an inline call, grab a return address from the state and jump to it. If this is not an inline call, set a return expression with the calling convention.

call(_addr_ , _args_ , _continue_at_ , _cc =None_, _prototype =None_, _jumpkind ='Ijk_Call'_)¶
    

Add an exit representing calling another function via pointer.

Parameters:
    

  * **addr** – The address of the function to call

  * **args** – The list of arguments to call the function with

  * **continue_at** – Later, when the called function returns, execution of the current procedure will continue in the named method.

  * **cc** – Optional: use this calling convention for calling the new function. Default is to use the current convention.

  * **prototype** – Optional: The prototype to use for the call. Will default to all-ints.

jump(_addr_ , _jumpkind ='Ijk_Boring'_)¶
    

Add an exit representing jumping to an address.

exit(_exit_code_)¶
    

Add an exit representing terminating the program.

ty_ptr(_ty_)¶
    

_property _is_java¶
    

_property _argument_types¶
    

_property _return_type¶
    

_class _angr.procedures.stubs.format_parser.FormatString(_parser_ , _components_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Describes a format string.

SCANF_DELIMITERS _ = [b'\t', b'\n', b'\x0b', b'\r', b' ']_¶
    

__init__(_parser_ , _components_)¶
    

Takes a list of components which are either just strings or a FormatSpecifier.

_property _state¶
    

replace(_va_arg_)¶
    

Implement printf - based on the stored format specifier information, format the values from the arg getter function args into a string.

Parameters:
    

**va_arg** – A function which takes a type and returns the next argument of that type

Returns:
    

The result formatted string

interpret(_va_arg_ , _addr =None_, _simfd =None_)¶
    

implement scanf - extract formatted data from memory or a file according to the stored format specifiers and store them into the pointers extracted from args.

Parameters:
    

  * **va_arg** – A function which, given a type, returns the next argument of that type

  * **addr** – The address in the memory to extract data from, or…

  * **simfd** – A file descriptor to use for reading data from

Returns:
    

The number of arguments parsed

_class _angr.procedures.stubs.format_parser.FormatSpecifier(_string_ , _length_spec_ , _pad_chr_ , _size_ , _signed_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Describes a format specifier within a format string.

__init__(_string_ , _length_spec_ , _pad_chr_ , _size_ , _signed_)¶
    

string¶
    

size¶
    

signed¶
    

length_spec¶
    

pad_chr¶
    

_property _spec_type¶
    

_class _angr.procedures.stubs.format_parser.FormatParser(_project =None_, _cc =None_, _prototype =None_, _symbolic_return =None_, _returns =None_, _is_syscall =False_, _is_stub =False_, _num_args =None_, _display_name =None_, _library_name =None_, _is_function =None_, _** kwargs_)¶
    

Bases: `SimProcedure`

For SimProcedures relying on printf-style format strings.

Parameters:
    

  * **project** (_Project_)

  * **cc** (_SimCC_)

  * **prototype** (_SimTypeFunction_)

ARGS_MISMATCH _ = True_¶
    

basic_spec _ = {b'A': double, b'E': double, b'F': double, b'G': double, b'X': unsigned int, b'a': double, b'c': char, b'd': int, b'e': double, b'f': double, b'g': double, b'i': int, b'n': unsigned int*, b'o': unsigned int, b'p': unsigned int*, b's': char*, b'u': unsigned int, b'x': unsigned int}_¶
    

int_sign _ = {'signed': [b'd', b'i'], 'unsigned': [b'o', b'u', b'x', b'X']}_¶
    

int_len_mod _ = {b'h': (short, unsigned short), b'hh': (char, char), b'j': (long long, unsigned long long), b'l': (long, unsigned long), b'll': (long long, unsigned long long), b't': (long, long), b'z': (size_t, size_t)}_¶
    

other_types _ = {('string',): <function FormatParser.<lambda>>}_¶
    

flags _ = ['#', '0', '\\\\-', ' ', '\\\\+', "\\\'", 'I']_¶
    

extract_components(_fmt_)¶
    

Extract the actual formats from the format string fmt.

Parameters:
    

**fmt** ([`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A list of format chars.

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

Returns:
    

a FormatString object

_class _angr.procedures.stubs.format_parser.ScanfFormatParser(_project =None_, _cc =None_, _prototype =None_, _symbolic_return =None_, _returns =None_, _is_syscall =False_, _is_stub =False_, _num_args =None_, _display_name =None_, _library_name =None_, _is_function =None_, _** kwargs_)¶
    

Bases: `FormatParser`

For SimProcedures relying on scanf-style format strings.

basic_spec _ = {b'A': float, b'E': float, b'F': float, b'G': float, b'X': unsigned int, b'a': float, b'c': char, b'd': int, b'e': float, b'f': float, b'g': float, b'i': int, b'n': unsigned int*, b'o': unsigned int, b'p': unsigned int*, b's': char*, b'u': unsigned int, b'x': unsigned int}_¶
    

float_spec _ = [b'e', b'E', b'f', b'F', b'g', b'G', b'a', b'A']_¶
    

float_len_mod _ = {b'l': <class 'angr.sim_type.SimTypeDouble'>, b'll': <class 'angr.sim_type.SimTypeDouble'>}_¶
    

_class _angr.procedures.definitions.SimTypeCollection¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A type collection is the mechanism for describing types. Types in a type collection can be referenced using

__init__()¶
    

set_names(_* names_)¶
    

Parameters:
    

**names** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

add(_name_ , _t_)¶
    

Add a type to the collection.

Parameters:
    

  * **name** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of the type to add.

  * **t** (`SimType`) – The SimType object to add to the collection.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

get(_name_ , _bottom_on_missing =False_)¶
    

Get a SimType object from the collection as identified by the name.

Parameters:
    

  * **name** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of the type to get.

  * **bottom_on_missing** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Return a SimTypeBottom object if the required type does not exist.

Return type:
    

`SimType`

Returns:
    

The SimType object.

init_str()¶
    

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

_class _angr.procedures.definitions.SimLibrary¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A SimLibrary is the mechanism for describing a dynamic library’s API, its functions and metadata.

Any instance of this class (or its subclasses) found in the `angr.procedures.definitions` package will be automatically picked up and added to `angr.SIM_LIBRARIES` via all its names.

Variables:
    

  * **fallback_cc** – A mapping from architecture to the default calling convention that should be used if no other information is present. Contains some sane defaults for linux.

  * **fallback_proc** – A SimProcedure class that should be used to provide stub procedures. By default, `ReturnUnconstrained`.

__init__()¶
    

copy()¶
    

Make a copy of this SimLibrary, allowing it to be mutated without affecting the global version.

Returns:
    

A new SimLibrary object with the same library references but different dict/list references

update(_other_)¶
    

Augment this SimLibrary with the information from another SimLibrary

Parameters:
    

**other** (`SimLibrary`) – The other SimLibrary

_property _name¶
    

The first common name of this library, e.g. libc.so.6, or ‘??????’ if none are known.

set_library_names(_* names_)¶
    

Set some common names of this library by which it may be referred during linking

Parameters:
    

**names** – Any number of string library names may be passed as varargs.

set_default_cc(_arch_name_ , _cc_cls_)¶
    

Set the default calling convention used for this library under a given architecture

Parameters:
    

**arch_name** – The string name of the architecture, i.e. the `.name` field from archinfo.

Parm cc_cls:
    

The SimCC class (not an instance!) to use

set_non_returning(_* names_)¶
    

Mark some functions in this class as never returning, i.e. loops forever or terminates execution

Parameters:
    

**names** – Any number of string function names may be passed as varargs

set_prototype(_name_ , _proto_)¶
    

Set the prototype of a function in the form of a SimTypeFunction containing argument and return types

Parameters:
    

  * **name** – The name of the function as a string

  * **proto** – The prototype of the function as a SimTypeFunction

set_prototypes(_protos_)¶
    

Set the prototypes of many functions

Parameters:
    

**protos** – Dictionary mapping function names to SimTypeFunction objects

set_c_prototype(_c_decl_)¶
    

Set the prototype of a function in the form of a C-style function declaration.

Parameters:
    

**c_decl** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The C-style declaration of the function.

Returns:
    

A tuple of (function name, function prototype)

Return type:
    

[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

add(_name_ , _proc_cls_ , _** kwargs_)¶
    

Add a function implementation to the library.

Parameters:
    

  * **name** – The name of the function as a string

  * **proc_cls** – The implementation of the function as a SimProcedure _class_, not instance

  * **kwargs** – Any additional parameters to the procedure class constructor may be passed as kwargs

add_all_from_dict(_dictionary_ , _** kwargs_)¶
    

Batch-add function implementations to the library.

Parameters:
    

  * **dictionary** – A mapping from name to procedure class, i.e. the first two arguments to add()

  * **kwargs** – Any additional kwargs will be passed to the constructors of _each_ procedure class

add_alias(_name_ , _* alt_names_)¶
    

Add some duplicate names for a given function. The original function’s implementation must already be registered.

Parameters:
    

  * **name** – The name of the function for which an implementation is already present

  * **alt_names** – Any number of alternate names may be passed as varargs

get(_name_ , _arch_)¶
    

Get an implementation of the given function specialized for the given arch, or a stub procedure if none exists.

Parameters:
    

  * **name** – The name of the function as a string

  * **arch** – The architecure to use, as either a string or an archinfo.Arch instance

Returns:
    

A SimProcedure instance representing the function as found in the library

get_stub(_name_ , _arch_)¶
    

Get a stub procedure for the given function, regardless of if a real implementation is available. This will apply any metadata, such as a default calling convention or a function prototype.

By stub, we pretty much always mean a `ReturnUnconstrained` SimProcedure with the appropriate display name and metadata set. This will appear in `state.history.descriptions` as `<SimProcedure display_name (stub)>`

Parameters:
    

  * **name** – The name of the function as a string

  * **arch** – The architecture to use, as either a string or an archinfo.Arch instance

Returns:
    

A SimProcedure instance representing a plausable stub as could be found in the library.

get_prototype(_name_ , _arch =None_)¶
    

Get a prototype of the given function name, optionally specialize the prototype to a given architecture.

Parameters:
    

  * **name** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of the function.

  * **arch** – The architecture to specialize to.

Return type:
    

`SimTypeFunction` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

Prototype of the function, or None if the prototype does not exist.

has_metadata(_name_)¶
    

Check if a function has either an implementation or any metadata associated with it

Parameters:
    

**name** – The name of the function as a string

Returns:
    

A bool indicating if anything is known about the function

has_implementation(_name_)¶
    

Check if a function has an implementation associated with it

Parameters:
    

**name** – The name of the function as a string

Returns:
    

A bool indicating if an implementation of the function is available

has_prototype(_func_name_)¶
    

Check if a function has a prototype associated with it.

Parameters:
    

**func_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The name of the function.

Returns:
    

A bool indicating if a prototype of the function is available.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.procedures.definitions.SimCppLibrary¶
    

Bases: `SimLibrary`

SimCppLibrary is a specialized version of SimLibrary that will demangle C++ function names before looking for an implementation or prototype for it.

get(_name_ , _arch_)¶
    

Get an implementation of the given function specialized for the given arch, or a stub procedure if none exists. Demangle the function name if it is a mangled C++ name.

Parameters:
    

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The name of the function as a string

  * **arch** – The architecure to use, as either a string or an archinfo.Arch instance

Returns:
    

A SimProcedure instance representing the function as found in the library

get_stub(_name_ , _arch_)¶
    

Get a stub procedure for the given function, regardless of if a real implementation is available. This will apply any metadata, such as a default calling convention or a function prototype. Demangle the function name if it is a mangled C++ name.

Parameters:
    

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The name of the function as a string

  * **arch** – The architecture to use, as either a string or an archinfo.Arch instance

Returns:
    

A SimProcedure instance representing a plausable stub as could be found in the library.

get_prototype(_name_ , _arch =None_)¶
    

Get a prototype of the given function name, optionally specialize the prototype to a given architecture. The function name will be demangled first.

Parameters:
    

  * **name** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of the function.

  * **arch** – The architecture to specialize to.

Return type:
    

`SimTypeFunction` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

Prototype of the function, or None if the prototype does not exist.

has_metadata(_name_)¶
    

Check if a function has either an implementation or any metadata associated with it. Demangle the function name if it is a mangled C++ name.

Parameters:
    

**name** – The name of the function as a string

Returns:
    

A bool indicating if anything is known about the function

has_implementation(_name_)¶
    

Check if a function has an implementation associated with it. Demangle the function name if it is a mangled C++ name.

Parameters:
    

**name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – A mangled function name.

Returns:
    

bool

has_prototype(_func_name_)¶
    

Check if a function has a prototype associated with it. Demangle the function name if it is a mangled C++ name.

Parameters:
    

**name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – A mangled function name.

Returns:
    

bool

_class _angr.procedures.definitions.SimSyscallLibrary¶
    

Bases: `SimLibrary`

SimSyscallLibrary is a specialized version of SimLibrary for dealing not with a dynamic library’s API but rather an operating system’s syscall API. Because this interface is inherently lower-level than a dynamic library, many parts of this class has been changed to store data based on an “ABI name” (ABI = application binary interface, like an API but for when there’s no programming language) instead of an architecture. An ABI name is just an arbitrary string with which a calling convention and a syscall numbering is associated.

All the SimLibrary methods for adding functions still work, but now there’s an additional layer on top that associates them with numbers.

__init__()¶
    

copy()¶
    

Make a copy of this SimLibrary, allowing it to be mutated without affecting the global version.

Returns:
    

A new SimLibrary object with the same library references but different dict/list references

update(_other_)¶
    

Augment this SimLibrary with the information from another SimLibrary

Parameters:
    

**other** – The other SimLibrary

minimum_syscall_number(_abi_)¶
    

Parameters:
    

**abi** – The abi to evaluate

Returns:
    

The smallest syscall number known for the given abi

maximum_syscall_number(_abi_)¶
    

Parameters:
    

**abi** – The abi to evaluate

Returns:
    

The largest syscall number known for the given abi

add_number_mapping(_abi_ , _number_ , _name_)¶
    

Associate a syscall number with the name of a function present in the underlying SimLibrary

Parameters:
    

  * **abi** – The abi for which this mapping applies

  * **number** – The syscall number

  * **name** – The name of the function

add_number_mapping_from_dict(_abi_ , _mapping_)¶
    

Batch-associate syscall numbers with names of functions present in the underlying SimLibrary

Parameters:
    

  * **abi** – The abi for which this mapping applies

  * **mapping** – A dict mapping syscall numbers to function names

set_abi_cc(_abi_ , _cc_cls_)¶
    

Set the default calling convention for an abi

Parameters:
    

  * **abi** – The name of the abi

  * **cc_cls** – A SimCC _class_, not an instance, that should be used for syscalls using the abi

set_prototype(_abi_ , _name_ , _proto_)¶
    

Set the prototype of a function in the form of a SimTypeFunction containing argument and return types

Parameters:
    

  * **abi** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – ABI of the syscall.

  * **name** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The name of the syscall as a string

  * **proto** (`SimTypeFunction`) – The prototype of the syscall as a SimTypeFunction

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

set_prototypes(_abi_ , _protos_)¶
    

Set the prototypes of many syscalls.

Parameters:
    

  * **abi** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – ABI of the syscalls.

  * **protos** ([`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"), `SimTypeFunction`]) – Dictionary mapping syscall names to SimTypeFunction objects

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

get(_number_ , _arch_ , _abi_list =()_)¶
    

The get() function for SimSyscallLibrary looks a little different from its original version.

Instead of providing a name, you provide a number, and you additionally provide a list of abi names that are applicable. The first abi for which the number is present in the mapping will be chosen. This allows for the easy abstractions of architectures like ARM or MIPS linux for which there are many ABIs that can be used at any time by using syscall numbers from various ranges. If no abi knows about the number, the stub procedure with the name “sys_%d” will be used.

Parameters:
    

  * **number** – The syscall number

  * **arch** – The architecture being worked with, as either a string name or an archinfo.Arch

  * **abi_list** – A list of ABI names that could be used

Returns:
    

A SimProcedure representing the implementation of the given syscall, or a stub if no implementation is available

get_stub(_number_ , _arch_ , _abi_list =()_)¶
    

Pretty much the intersection of SimLibrary.get_stub() and SimSyscallLibrary.get().

Parameters:
    

  * **number** – The syscall number

  * **arch** – The architecture being worked with, as either a string name or an archinfo.Arch

  * **abi_list** – A list of ABI names that could be used

Returns:
    

A SimProcedure representing a plausable stub that could model the syscall

get_prototype(_abi_ , _name_ , _arch =None_)¶
    

Get a prototype of the given syscall name and its ABI, optionally specialize the prototype to a given architecture.

Parameters:
    

  * **abi** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – ABI of the prototype to get.

  * **name** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of the syscall.

  * **arch** – The architecture to specialize to.

Return type:
    

`SimTypeFunction` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

Prototype of the syscall, or None if the prototype does not exist.

has_metadata(_number_ , _arch_ , _abi_list =()_)¶
    

Pretty much the intersection of SimLibrary.has_metadata() and SimSyscallLibrary.get().

Parameters:
    

  * **number** – The syscall number

  * **arch** – The architecture being worked with, as either a string name or an archinfo.Arch

  * **abi_list** – A list of ABI names that could be used

Returns:
    

A bool of whether or not any implementation or metadata is known about the given syscall

has_implementation(_number_ , _arch_ , _abi_list =()_)¶
    

Pretty much the intersection of SimLibrary.has_implementation() and SimSyscallLibrary.get().

Parameters:
    

  * **number** – The syscall number

  * **arch** – The architecture being worked with, as either a string name or an archinfo.Arch

  * **abi_list** – A list of ABI names that could be used

Returns:
    

A bool of whether or not an implementation of the syscall is available

has_prototype(_abi_ , _name_)¶
    

Check if a function has a prototype associated with it. Demangle the function name if it is a mangled C++ name.

Parameters:
    

  * **abi** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of the ABI.

  * **name** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The syscall name.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

bool

angr.procedures.definitions.load_type_collections(_skip =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

angr.procedures.definitions.load_win32_type_collections()¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

angr.procedures.definitions.load_external_definitions()¶
    

Load library definitions from specific directories. By default it parses ANGR_EXTERNAL_DEFINITIONS_DIRS as a semicolon separated list of directory paths. Then it loads all .py files in each directory. These .py files should declare SimLibrary() objects and call .set_library_names() to register themselves in angr.SIM_LIBRARIES.

angr.procedures.definitions.load_win32api_definitions()¶
    

angr.procedures.definitions.load_all_definitions()¶
    

## Calling Conventions and Types¶

_class _angr.calling_conventions.PointerWrapper(_value_ , _buffer =False_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_value_ , _buffer =False_)¶
    

_class _angr.calling_conventions.AllocHelper(_ptrsize_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_ptrsize_)¶
    

alloc(_size_)¶
    

dump(_val_ , _state_ , _loc =None_)¶
    

translate(_val_ , _base_)¶
    

apply(_state_ , _base_)¶
    

size()¶
    

_classmethod _calc_size(_val_ , _arch_)¶
    

_classmethod _stack_loc(_val_ , _arch_ , _offset =0_)¶
    

angr.calling_conventions.refine_locs_with_struct_type(_arch_ , _locs_ , _arg_type_ , _offset =0_, _treat_bot_as_int =True_, _treat_unsupported_as_int =True_)¶
    

Parameters:
    

  * **arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)"))

  * **locs** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)"))

  * **arg_type** (_SimType_)

  * **offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_class _angr.calling_conventions.SerializableIterator¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

getstate()¶
    

setstate(_state_)¶
    

_class _angr.calling_conventions.SerializableListIterator(_lst_)¶
    

Bases: `SerializableIterator`

__init__(_lst_)¶
    

getstate()¶
    

setstate(_state_)¶
    

_class _angr.calling_conventions.SerializableCounter(_start_ , _stride_ , _mapping= <function SerializableCounter.<lambda>>_)¶
    

Bases: `SerializableIterator`

__init__(_start_ , _stride_ , _mapping= <function SerializableCounter.<lambda>>_)¶
    

getstate()¶
    

setstate(_state_)¶
    

_class _angr.calling_conventions.SimFunctionArgument(_size_ , _is_fp =False_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Represent a generic function argument.

Variables:
    

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The size of the argument, in number of bytes.

  * **is_fp** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether loads from this location should return a floating point bitvector

Parameters:
    

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **is_fp** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_size_ , _is_fp =False_)¶
    

Parameters:
    

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **is_fp** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

check_value_set(_value_ , _arch_)¶
    

check_value_get(_value_)¶
    

set_value(_state_ , _value_ , _** kwargs_)¶
    

get_value(_state_ , _** kwargs_)¶
    

refine(_size_ , _arch =None_, _offset =None_, _is_fp =None_)¶
    

get_footprint()¶
    

Return a list of SimRegArg and SimStackArgs that are the base components used for this location

Return type:
    

[`Iterable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)")[`SimRegArg` | `SimStackArg`]

_class _angr.calling_conventions.SimRegArg(_reg_name_ , _size_ , _reg_offset =0_, _is_fp =False_, _clear_entire_reg =False_)¶
    

Bases: `SimFunctionArgument`

Represents a function argument that has been passed in a register.

Variables:
    

  * **reg_name** (_string_) – The name of the represented register.

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The size of the data to store, in number of bytes.

  * **reg_offset** – The offset into the register to start storing data.

  * **clear_entire_reg** – Whether a store to this register should zero the unused parts of the register.

  * **is_fp** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether loads from this location should return a floating point bitvector

Parameters:
    

  * **reg_name** (_RegisterName_)

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_reg_name_ , _size_ , _reg_offset =0_, _is_fp =False_, _clear_entire_reg =False_)¶
    

Parameters:
    

  * **reg_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_footprint()¶
    

Return a list of SimRegArg and SimStackArgs that are the base components used for this location

check_offset(_arch_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

set_value(_state_ , _value_ , _** kwargs_)¶
    

get_value(_state_ , _** kwargs_)¶
    

refine(_size_ , _arch =None_, _offset =None_, _is_fp =None_)¶
    

sse_extend()¶
    

_class _angr.calling_conventions.SimStackArg(_stack_offset_ , _size_ , _is_fp =False_)¶
    

Bases: `SimFunctionArgument`

Represents a function argument that has been passed on the stack.

Variables:
    

  * **stack_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The position of the argument relative to the stack pointer after the function prelude.

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The size of the argument, in number of bytes.

  * **is_fp** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether loads from this location should return a floating point bitvector

Parameters:
    

  * **stack_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **is_fp** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_stack_offset_ , _size_ , _is_fp =False_)¶
    

Parameters:
    

  * **stack_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **is_fp** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

get_footprint()¶
    

Return a list of SimRegArg and SimStackArgs that are the base components used for this location

set_value(_state_ , _value_ , _stack_base =None_, _** kwargs_)¶
    

get_value(_state_ , _stack_base =None_, _** kwargs_)¶
    

refine(_size_ , _arch =None_, _offset =None_, _is_fp =None_)¶
    

_class _angr.calling_conventions.SimComboArg(_locations_ , _is_fp =False_)¶
    

Bases: `SimFunctionArgument`, [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`T`]

An argument which spans multiple storage locations. Locations should be given least-significant first.

Parameters:
    

**locations** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__T_ _]_)

__init__(_locations_ , _is_fp =False_)¶
    

Parameters:
    

**locations** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__T_ _]_)

get_footprint()¶
    

Return a list of SimRegArg and SimStackArgs that are the base components used for this location

set_value(_state_ , _value_ , _** kwargs_)¶
    

get_value(_state_ , _** kwargs_)¶
    

_class _angr.calling_conventions.SimStructArg(_struct_ , _locs_)¶
    

Bases: `SimFunctionArgument`

An argument which de/serializes a struct from a list of storage locations

Variables:
    

  * **struct** – The simtype describing the structure

  * **locs** – The storage locations to use

Parameters:
    

  * **struct** (_SimStruct_)

  * **locs** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__SimFunctionArgument_ _]_)

__init__(_struct_ , _locs_)¶
    

Parameters:
    

  * **struct** (_SimStruct_)

  * **locs** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__SimFunctionArgument_ _]_)

get_footprint()¶
    

Return a list of SimRegArg and SimStackArgs that are the base components used for this location

get_single_footprint()¶
    

Return type:
    

`SimStackArg` | `SimRegArg` | `SimComboArg`

get_value(_state_ , _** kwargs_)¶
    

set_value(_state_ , _value_ , _** kwargs_)¶
    

_class _angr.calling_conventions.SimArrayArg(_locs_)¶
    

Bases: `SimFunctionArgument`

__init__(_locs_)¶
    

get_footprint()¶
    

Return a list of SimRegArg and SimStackArgs that are the base components used for this location

get_value(_state_ , _** kwargs_)¶
    

set_value(_state_ , _value_ , _** kwargs_)¶
    

_class _angr.calling_conventions.SimReferenceArgument(_ptr_loc_ , _main_loc_)¶
    

Bases: `SimFunctionArgument`

A function argument which is passed by reference.

Variables:
    

  * **ptr_loc** – The location the reference’s pointer is stored

  * **main_loc** – A SimStackArgument describing how to load the argument’s value as if it were stored at offset zero on the stack. It will be passed `stack_base=ptr_loc.get_value(state)`

Parameters:
    

  * **ptr_loc** (_SimFunctionArgument_)

  * **main_loc** (_SimFunctionArgument_)

__init__(_ptr_loc_ , _main_loc_)¶
    

Parameters:
    

  * **ptr_loc** (_SimFunctionArgument_)

  * **main_loc** (_SimFunctionArgument_)

get_footprint()¶
    

Return a list of SimRegArg and SimStackArgs that are the base components used for this location

get_value(_state_ , _** kwargs_)¶
    

set_value(_state_ , _value_ , _** kwargs_)¶
    

_class _angr.calling_conventions.ArgSession(_cc_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A class to keep track of the state accumulated in laying parameters out into memory

__init__(_cc_)¶
    

cc¶
    

fp_iter¶
    

int_iter¶
    

both_iter¶
    

getstate()¶
    

setstate(_state_)¶
    

_class _angr.calling_conventions.UsercallArgSession(_cc_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

An argsession for use with SimCCUsercall

__init__(_cc_)¶
    

cc¶
    

real_args¶
    

getstate()¶
    

setstate(_state_)¶
    

_class _angr.calling_conventions.SimCC(_arch_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A calling convention allows you to extract from a state the data passed from function to function by calls and returns. Most of the methods provided by SimCC that operate on a state assume that the program is just after a call but just before stack frame allocation, though this may be overridden with the stack_base parameter to each individual method.

This is the base class for all calling conventions.

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

__init__(_arch_)¶
    

Parameters:
    

**arch** ([`Arch`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)")) – The Archinfo arch for this CC

ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = []_¶
    

FP_ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = []_¶
    

STACKARG_SP_BUFF _ = 0_¶
    

STACKARG_SP_DIFF _ = 0_¶
    

CALLER_SAVED_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = []_¶
    

RETURN_ADDR _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

OVERFLOW_RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

FP_RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

ARCH _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[[`Arch`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)")] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

EXTRA_ARCHES _: [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[[`Arch`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)")], [`...`](https://docs.python.org/3/library/constants.html#Ellipsis "\(in Python v3.13\)")]__ = ()_¶
    

CALLEE_CLEANUP _ = False_¶
    

STACK_ALIGNMENT _ = 1_¶
    

_property _int_args¶
    

Iterate through all the possible arg positions that can only be used to store integer or pointer values.

Returns an iterator of SimFunctionArguments

_property _memory_args¶
    

Iterate through all the possible arg positions that can be used to store any kind of argument.

Returns an iterator of SimFunctionArguments

_property _fp_args¶
    

Iterate through all the possible arg positions that can only be used to store floating point values.

Returns an iterator of SimFunctionArguments

is_fp_arg(_arg_)¶
    

This should take a SimFunctionArgument instance and return whether or not that argument is a floating-point argument.

Returns True for MUST be a floating point arg,
    

False for MUST NOT be a floating point arg, None for when it can be either.

_class _ArgSession(_cc_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A class to keep track of the state accumulated in laying parameters out into memory

both_iter¶
    

cc¶
    

fp_iter¶
    

int_iter¶
    

__init__(_cc_)¶
    

getstate()¶
    

setstate(_state_)¶
    

arg_session(_ret_ty_)¶
    

Return an arg session.

A session provides the control interface necessary to describe how integral and floating-point arguments are laid out into memory. The default behavior is that there are a finite list of int-only and fp-only argument slots, and an infinite number of generic slots, and when an argument of a given type is requested, the most slot available is used. If you need different behavior, subclass ArgSession.

You need to provide the return type of the function in order to kick off an arg layout session.

Parameters:
    

**ret_ty** (_SimType_ _|__None_)

return_in_implicit_outparam(_ty_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

stack_space(_args_)¶
    

Parameters:
    

**args** – A list of SimFunctionArguments

Returns:
    

The number of bytes that should be allocated on the stack to store all these args, NOT INCLUDING the return address.

return_val(_ty_ , _perspective_returned =False_)¶
    

The location the return value is stored, based on its type.

_property _return_addr¶
    

The location the return address is stored.

next_arg(_session_ , _arg_type_)¶
    

Parameters:
    

  * **session** (_ArgSession_)

  * **arg_type** (_SimType_)

_static _is_fp_value(_val_)¶
    

_static _guess_prototype(_args_ , _prototype =None_)¶
    

Come up with a plausible SimTypeFunction for the given args (as would be passed to e.g. setup_callsite).

You can pass a variadic function prototype in the base_type parameter and all its arguments will be used, only guessing types for the variadic arguments.

arg_locs(_prototype_)¶
    

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`SimFunctionArgument`]

get_args(_state_ , _prototype_ , _stack_base =None_)¶
    

set_return_val(_state_ , _val_ , _ty_ , _stack_base =None_, _perspective_returned =False_)¶
    

setup_callsite(_state_ , _ret_addr_ , _args_ , _prototype_ , _stack_base =None_, _alloc_base =None_, _grow_like_stack =True_)¶
    

This function performs the actions of the caller getting ready to jump into a function.

Parameters:
    

  * **state** – The SimState to operate on

  * **ret_addr** – The address to return to when the called function finishes

  * **args** – The list of arguments that that the called function will see

  * **prototype** – The signature of the call you’re making. Should include variadic args concretely.

  * **stack_base** – An optional pointer to use as the top of the stack, circa the function entry point

  * **alloc_base** – An optional pointer to use as the place to put excess argument data

  * **grow_like_stack** – When allocating data at alloc_base, whether to allocate at decreasing addresses

The idea here is that you can provide almost any kind of python type in args and it’ll be translated to a binary format to be placed into simulated memory. Lists (representing arrays) must be entirely elements of the same type and size, while tuples (representing structs) can be elements of any type and size. If you’d like there to be a pointer to a given value, wrap the value in a PointerWrapper.

If stack_base is not provided, the current stack pointer will be used, and it will be updated. If alloc_base is not provided, the stack base will be used and grow_like_stack will implicitly be True.

grow_like_stack controls the behavior of allocating data at alloc_base. When data from args needs to be wrapped in a pointer, the pointer needs to point somewhere, so that data is dumped into memory at alloc_base. If you set alloc_base to point to somewhere other than the stack, set grow_like_stack to False so that sequential allocations happen at increasing addresses.

teardown_callsite(_state_ , _return_val =None_, _prototype =None_, _force_callee_cleanup =False_)¶
    

This function performs the actions of the callee as it’s getting ready to return. It returns the address to return to.

Parameters:
    

  * **state** – The state to mutate

  * **return_val** – The value to return

  * **prototype** – The prototype of the given function

  * **force_callee_cleanup** – If we should clean up the stack allocation for the arguments even if it’s not the callee’s job to do so

TODO: support the stack_base parameter from setup_callsite…? Does that make sense in this context? Maybe it could make sense by saying that you pass it in as something like the “saved base pointer” value?

_static _find_cc(_arch_ , _args_ , _sp_delta_ , _platform ='Linux'_)¶
    

Pinpoint the best-fit calling convention and return the corresponding SimCC instance, or None if no fit is found.

Parameters:
    

  * **arch** ([`Arch`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)")) – An ArchX instance. Can be obtained from archinfo.

  * **args** ([`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`SimRegArg` | `SimStackArg`]) – A list of arguments. It may be updated by the first matched calling convention to remove non-argument arguments.

  * **sp_delta** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The change of stack pointer before and after the call is made.

  * **platform** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

Return type:
    

`SimCC` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

A calling convention instance, or None if none of the SimCC subclasses seems to fit the arguments provided.

_classmethod _arches()¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[[`Arch`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)")], [`...`](https://docs.python.org/3/library/constants.html#Ellipsis "\(in Python v3.13\)")]

get_arg_info(_state_ , _prototype_)¶
    

This is just a simple wrapper that collects the information from various locations prototype is as passed to self.arg_locs and self.get_args :param angr.SimState state: The state to evaluate and extract the values from :return: A list of tuples, where the nth tuple is (type, name, location, value) of the nth argument

_class _angr.calling_conventions.SimLyingRegArg(_name_ , _size =8_)¶
    

Bases: `SimRegArg`

A register that LIES about the types it holds

__init__(_name_ , _size =8_)¶
    

get_value(_state_ , _** kwargs_)¶
    

set_value(_state_ , _value_ , _** kwargs_)¶
    

refine(_size_ , _arch =None_, _offset =None_, _is_fp =None_)¶
    

_class _angr.calling_conventions.SimCCUsercall(_arch_ , _args_ , _ret_loc_)¶
    

Bases: `SimCC`

__init__(_arch_ , _args_ , _ret_loc_)¶
    

Parameters:
    

**arch** – The Archinfo arch for this CC

ArgSession¶
    

alias of `UsercallArgSession`

next_arg(_session_ , _arg_type_)¶
    

Parameters:
    

**session** (_UsercallArgSession_)

return_val(_ty_ , _** kwargs_)¶
    

The location the return value is stored, based on its type.

_class _angr.calling_conventions.SimCCCdecl(_arch_)¶
    

Bases: `SimCC`

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = []_¶
    

FP_ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = []_¶
    

STACKARG_SP_DIFF _ = 4_¶
    

CALLER_SAVED_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['eax', 'ecx', 'edx']_¶
    

RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <eax>_¶
    

OVERFLOW_RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <edx>_¶
    

FP_RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <st0>_¶
    

RETURN_ADDR _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = [0x0]_¶
    

ARCH¶
    

alias of [`ArchX86`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_x86.ArchX86 "\(in archinfo\)")

next_arg(_session_ , _arg_type_)¶
    

STRUCT_RETURN_THRESHOLD _ = 32_¶
    

return_val(_ty_ , _perspective_returned =False_)¶
    

The location the return value is stored, based on its type.

return_in_implicit_outparam(_ty_)¶
    

_class _angr.calling_conventions.SimCCMicrosoftCdecl(_arch_)¶
    

Bases: `SimCCCdecl`

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

STRUCT_RETURN_THRESHOLD _ = 64_¶
    

_class _angr.calling_conventions.SimCCMicrosoftThiscall(_arch_)¶
    

Bases: `SimCCCdecl`

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

CALLEE_CLEANUP _ = True_¶
    

ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['ecx']_¶
    

CALLER_SAVED_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['eax', 'ecx', 'edx']_¶
    

STRUCT_RETURN_THRESHOLD _ = 64_¶
    

arg_locs(_prototype_)¶
    

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`SimFunctionArgument`]

_class _angr.calling_conventions.SimCCStdcall(_arch_)¶
    

Bases: `SimCCMicrosoftCdecl`

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

CALLEE_CLEANUP _ = True_¶
    

_class _angr.calling_conventions.SimCCMicrosoftFastcall(_arch_)¶
    

Bases: `SimCC`

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['ecx', 'edx']_¶
    

STACKARG_SP_DIFF _ = 4_¶
    

RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <eax>_¶
    

RETURN_ADDR _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = [0x0]_¶
    

ARCH¶
    

alias of [`ArchX86`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_x86.ArchX86 "\(in archinfo\)")

_class _angr.calling_conventions.MicrosoftAMD64ArgSession(_cc_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_cc_)¶
    

_class _angr.calling_conventions.SimCCMicrosoftAMD64(_arch_)¶
    

Bases: `SimCC`

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['rcx', 'rdx', 'r8', 'r9']_¶
    

FP_ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['xmm0', 'xmm1', 'xmm2', 'xmm3']_¶
    

STACKARG_SP_DIFF _ = 8_¶
    

STACKARG_SP_BUFF _ = 32_¶
    

RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <rax>_¶
    

OVERFLOW_RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <rdx>_¶
    

FP_RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <xmm0>_¶
    

RETURN_ADDR _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = [0x0]_¶
    

ARCH¶
    

alias of [`ArchAMD64`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_amd64.ArchAMD64 "\(in archinfo\)")

STACK_ALIGNMENT _ = 16_¶
    

ArgSession¶
    

alias of `MicrosoftAMD64ArgSession`

STRUCT_RETURN_THRESHOLD _ = 64_¶
    

next_arg(_session_ , _arg_type_)¶
    

return_in_implicit_outparam(_ty_)¶
    

return_val(_ty_ , _perspective_returned =False_)¶
    

The location the return value is stored, based on its type.

_class _angr.calling_conventions.SimCCSyscall(_arch_)¶
    

Bases: `SimCC`

The base class of all syscall CCs.

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ERROR_REG _: `SimRegArg`_ _ = None_¶
    

SYSCALL_ERRNO_START _ = None_¶
    

_static _syscall_num(_state_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

linux_syscall_update_error_reg(_state_ , _expr_)¶
    

set_return_val(_state_ , _val_ , _ty_ , _** kwargs_)¶
    

_class _angr.calling_conventions.SimCCX86LinuxSyscall(_arch_)¶
    

Bases: `SimCCSyscall`

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['ebx', 'ecx', 'edx', 'esi', 'edi', 'ebp']_¶
    

FP_ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = []_¶
    

RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <eax>_¶
    

RETURN_ADDR _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <ip_at_syscall>_¶
    

ARCH¶
    

alias of [`ArchX86`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_x86.ArchX86 "\(in archinfo\)")

_static _syscall_num(_state_)¶
    

_class _angr.calling_conventions.SimCCX86WindowsSyscall(_arch_)¶
    

Bases: `SimCCSyscall`

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['ecx']_¶
    

FP_ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = []_¶
    

RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <eax>_¶
    

RETURN_ADDR _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <ip_at_syscall>_¶
    

ARCH¶
    

alias of [`ArchX86`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_x86.ArchX86 "\(in archinfo\)")

_static _syscall_num(_state_)¶
    

_class _angr.calling_conventions.SimCCSystemVAMD64(_arch_)¶
    

Bases: `SimCC`

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['rdi', 'rsi', 'rdx', 'rcx', 'r8', 'r9']_¶
    

FP_ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['xmm0', 'xmm1', 'xmm2', 'xmm3', 'xmm4', 'xmm5', 'xmm6', 'xmm7']_¶
    

STACKARG_SP_DIFF _ = 8_¶
    

CALLER_SAVED_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['rdi', 'rsi', 'rdx', 'rcx', 'r8', 'r9', 'r10', 'r11', 'rax']_¶
    

RETURN_ADDR _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = [0x0]_¶
    

RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <rax>_¶
    

OVERFLOW_RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <rdx>_¶
    

FP_RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <xmm0>_¶
    

OVERFLOW_FP_RETURN_VAL _ = <xmm1>_¶
    

ARCH¶
    

alias of [`ArchAMD64`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_amd64.ArchAMD64 "\(in archinfo\)")

STACK_ALIGNMENT _ = 16_¶
    

next_arg(_session_ , _arg_type_)¶
    

return_val(_ty_ , _perspective_returned =False_)¶
    

The location the return value is stored, based on its type.

Parameters:
    

**ty** (_SimType_ _|__None_)

return_in_implicit_outparam(_ty_)¶
    

_class _angr.calling_conventions.SimCCAMD64LinuxSyscall(_arch_)¶
    

Bases: `SimCCSyscall`

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['rdi', 'rsi', 'rdx', 'r10', 'r8', 'r9']_¶
    

RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <rax>_¶
    

RETURN_ADDR _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <ip_at_syscall>_¶
    

ARCH¶
    

alias of [`ArchAMD64`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_amd64.ArchAMD64 "\(in archinfo\)")

CALLER_SAVED_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['rax', 'rcx', 'r11']_¶
    

_static _syscall_num(_state_)¶
    

_class _angr.calling_conventions.SimCCAMD64WindowsSyscall(_arch_)¶
    

Bases: `SimCCSyscall`

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['rcx']_¶
    

FP_ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = []_¶
    

RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <rax>_¶
    

RETURN_ADDR _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <ip_at_syscall>_¶
    

ARCH¶
    

alias of [`ArchAMD64`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_amd64.ArchAMD64 "\(in archinfo\)")

_static _syscall_num(_state_)¶
    

_class _angr.calling_conventions.SimCCARM(_arch_)¶
    

Bases: `SimCC`

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['r0', 'r1', 'r2', 'r3']_¶
    

FP_ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = []_¶
    

CALLER_SAVED_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['r0', 'r1', 'r2', 'r3']_¶
    

RETURN_ADDR _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <lr>_¶
    

RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <r0>_¶
    

OVERFLOW_RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <r1>_¶
    

ARCH¶
    

alias of [`ArchARM`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_arm.ArchARM "\(in archinfo\)")

next_arg(_session_ , _arg_type_)¶
    

_class _angr.calling_conventions.SimCCARMHF(_arch_)¶
    

Bases: `SimCCARM`

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['r0', 'r1', 'r2', 'r3']_¶
    

FP_ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['s0', 's1', 's2', 's3', 's4', 's5', 's6', 's7', 's8', 's9', 's10', 's11', 's12', 's13', 's14', 's15']_¶
    

FP_RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <s0>_¶
    

CALLER_SAVED_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = []_¶
    

RETURN_ADDR _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <lr>_¶
    

RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <r0>_¶
    

OVERFLOW_RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <r1>_¶
    

ARCH¶
    

alias of [`ArchARMHF`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_arm.ArchARMHF "\(in archinfo\)")

EXTRA_ARCHES _: [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[[`Arch`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)")], [`...`](https://docs.python.org/3/library/constants.html#Ellipsis "\(in Python v3.13\)")]__ = (<class 'archinfo.arch_arm.ArchARMCortexM'>,)_¶
    

next_arg(_session_ , _arg_type_)¶
    

_class _angr.calling_conventions.SimCCARMLinuxSyscall(_arch_)¶
    

Bases: `SimCCSyscall`

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['r0', 'r1', 'r2', 'r3']_¶
    

FP_ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = []_¶
    

RETURN_ADDR _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <ip_at_syscall>_¶
    

RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <r0>_¶
    

ARCH¶
    

alias of [`ArchARM`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_arm.ArchARM "\(in archinfo\)")

_static _syscall_num(_state_)¶
    

_class _angr.calling_conventions.SimCCAArch64(_arch_)¶
    

Bases: `SimCC`

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['x0', 'x1', 'x2', 'x3', 'x4', 'x5', 'x6', 'x7']_¶
    

FP_ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = []_¶
    

RETURN_ADDR _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <lr>_¶
    

RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <x0>_¶
    

ARCH¶
    

alias of [`ArchAArch64`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_aarch64.ArchAArch64 "\(in archinfo\)")

_class _angr.calling_conventions.SimCCAArch64LinuxSyscall(_arch_)¶
    

Bases: `SimCCSyscall`

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['x0', 'x1', 'x2', 'x3', 'x4', 'x5', 'x6', 'x7']_¶
    

FP_ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = []_¶
    

RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <x0>_¶
    

RETURN_ADDR _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <ip_at_syscall>_¶
    

ARCH¶
    

alias of [`ArchAArch64`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_aarch64.ArchAArch64 "\(in archinfo\)")

_static _syscall_num(_state_)¶
    

_class _angr.calling_conventions.SimCCRISCV64LinuxSyscall(_arch_)¶
    

Bases: `SimCCSyscall`

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7']_¶
    

FP_ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = []_¶
    

RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <a0>_¶
    

RETURN_ADDR _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <ip_at_syscall>_¶
    

ARCH¶
    

alias of [`ArchRISCV64`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.ArchRISCV64 "\(in archinfo\)")

_static _syscall_num(_state_)¶
    

_class _angr.calling_conventions.SimCCO32(_arch_)¶
    

Bases: `SimCC`

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['a0', 'a1', 'a2', 'a3']_¶
    

FP_ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['f12', 'f13', 'f14', 'f15']_¶
    

STACKARG_SP_BUFF _ = 16_¶
    

CALLER_SAVED_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['t9', 'gp']_¶
    

RETURN_ADDR _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <ra>_¶
    

RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <v0>_¶
    

OVERFLOW_RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <v1>_¶
    

ARCH¶
    

alias of [`ArchMIPS32`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_mips32.ArchMIPS32 "\(in archinfo\)")

next_arg(_session_ , _arg_type_)¶
    

_class _angr.calling_conventions.SimCCO32LinuxSyscall(_arch_)¶
    

Bases: `SimCCSyscall`

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['a0', 'a1', 'a2', 'a3']_¶
    

FP_ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = []_¶
    

RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <v0>_¶
    

RETURN_ADDR _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <ip_at_syscall>_¶
    

ARCH¶
    

alias of [`ArchMIPS32`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_mips32.ArchMIPS32 "\(in archinfo\)")

ERROR_REG _: `SimRegArg`_ _ = <a3>_¶
    

SYSCALL_ERRNO_START _ = -1133_¶
    

_static _syscall_num(_state_)¶
    

_class _angr.calling_conventions.SimCCN64(_arch_)¶
    

Bases: `SimCC`

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7']_¶
    

CALLER_SAVED_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['t9', 'gp']_¶
    

FP_ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = []_¶
    

STACKARG_SP_BUFF _ = 32_¶
    

RETURN_ADDR _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <ra>_¶
    

RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <v0>_¶
    

ARCH¶
    

alias of [`ArchMIPS64`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_mips64.ArchMIPS64 "\(in archinfo\)")

angr.calling_conventions.SimCCO64¶
    

alias of `SimCCN64`

_class _angr.calling_conventions.SimCCN64LinuxSyscall(_arch_)¶
    

Bases: `SimCCSyscall`

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7']_¶
    

FP_ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = []_¶
    

RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <v0>_¶
    

RETURN_ADDR _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <ip_at_syscall>_¶
    

ARCH¶
    

alias of [`ArchMIPS64`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_mips64.ArchMIPS64 "\(in archinfo\)")

ERROR_REG _: `SimRegArg`_ _ = <a3>_¶
    

SYSCALL_ERRNO_START _ = -1133_¶
    

_static _syscall_num(_state_)¶
    

_class _angr.calling_conventions.SimCCPowerPC(_arch_)¶
    

Bases: `SimCC`

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['r3', 'r4', 'r5', 'r6', 'r7', 'r8', 'r9', 'r10']_¶
    

FP_ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = []_¶
    

STACKARG_SP_BUFF _ = 8_¶
    

RETURN_ADDR _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <lr>_¶
    

RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <r3>_¶
    

OVERFLOW_RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <r4>_¶
    

ARCH¶
    

alias of [`ArchPPC32`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_ppc32.ArchPPC32 "\(in archinfo\)")

_class _angr.calling_conventions.SimCCPowerPCLinuxSyscall(_arch_)¶
    

Bases: `SimCCSyscall`

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['r3', 'r4', 'r5', 'r6', 'r7', 'r8', 'r9', 'r10']_¶
    

FP_ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = []_¶
    

RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <r3>_¶
    

RETURN_ADDR _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <ip_at_syscall>_¶
    

ARCH¶
    

alias of [`ArchPPC32`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_ppc32.ArchPPC32 "\(in archinfo\)")

ERROR_REG _: `SimRegArg`_ _ = <cr0_0>_¶
    

SYSCALL_ERRNO_START _ = -515_¶
    

_static _syscall_num(_state_)¶
    

_class _angr.calling_conventions.SimCCPowerPC64(_arch_)¶
    

Bases: `SimCC`

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['r3', 'r4', 'r5', 'r6', 'r7', 'r8', 'r9', 'r10']_¶
    

FP_ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = []_¶
    

STACKARG_SP_BUFF _ = 112_¶
    

RETURN_ADDR _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <lr>_¶
    

RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <r3>_¶
    

ARCH¶
    

alias of [`ArchPPC64`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_ppc64.ArchPPC64 "\(in archinfo\)")

_class _angr.calling_conventions.SimCCPowerPC64LinuxSyscall(_arch_)¶
    

Bases: `SimCCSyscall`

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['r3', 'r4', 'r5', 'r6', 'r7', 'r8', 'r9', 'r10']_¶
    

FP_ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = []_¶
    

RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <r3>_¶
    

RETURN_ADDR _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <ip_at_syscall>_¶
    

ARCH¶
    

alias of [`ArchPPC64`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_ppc64.ArchPPC64 "\(in archinfo\)")

ERROR_REG _: `SimRegArg`_ _ = <cr0_0>_¶
    

SYSCALL_ERRNO_START _ = -515_¶
    

_static _syscall_num(_state_)¶
    

_class _angr.calling_conventions.SimCCSoot(_arch_)¶
    

Bases: `SimCC`

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARCH¶
    

alias of [`ArchSoot`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_soot.ArchSoot "\(in archinfo\)")

ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = []_¶
    

setup_callsite(_state_ , _ret_addr_ , _args_ , _prototype_ , _stack_base =None_, _alloc_base =None_, _grow_like_stack =True_)¶
    

This function performs the actions of the caller getting ready to jump into a function.

Parameters:
    

  * **state** – The SimState to operate on

  * **ret_addr** – The address to return to when the called function finishes

  * **args** – The list of arguments that that the called function will see

  * **prototype** – The signature of the call you’re making. Should include variadic args concretely.

  * **stack_base** – An optional pointer to use as the top of the stack, circa the function entry point

  * **alloc_base** – An optional pointer to use as the place to put excess argument data

  * **grow_like_stack** – When allocating data at alloc_base, whether to allocate at decreasing addresses

The idea here is that you can provide almost any kind of python type in args and it’ll be translated to a binary format to be placed into simulated memory. Lists (representing arrays) must be entirely elements of the same type and size, while tuples (representing structs) can be elements of any type and size. If you’d like there to be a pointer to a given value, wrap the value in a PointerWrapper.

If stack_base is not provided, the current stack pointer will be used, and it will be updated. If alloc_base is not provided, the stack base will be used and grow_like_stack will implicitly be True.

grow_like_stack controls the behavior of allocating data at alloc_base. When data from args needs to be wrapped in a pointer, the pointer needs to point somewhere, so that data is dumped into memory at alloc_base. If you set alloc_base to point to somewhere other than the stack, set grow_like_stack to False so that sequential allocations happen at increasing addresses.

_static _guess_prototype(_args_ , _prototype =None_)¶
    

Come up with a plausible SimTypeFunction for the given args (as would be passed to e.g. setup_callsite).

You can pass a variadic function prototype in the base_type parameter and all its arguments will be used, only guessing types for the variadic arguments.

_class _angr.calling_conventions.SimCCUnknown(_arch_)¶
    

Bases: `SimCC`

Represent an unknown calling convention.

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

_class _angr.calling_conventions.SimCCS390X(_arch_)¶
    

Bases: `SimCC`

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['r2', 'r3', 'r4', 'r5', 'r6']_¶
    

FP_ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['f0', 'f2', 'f4', 'f6']_¶
    

STACKARG_SP_BUFF _ = 160_¶
    

RETURN_ADDR _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <r14>_¶
    

RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <r2>_¶
    

ARCH¶
    

alias of [`ArchS390X`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_s390x.ArchS390X "\(in archinfo\)")

_class _angr.calling_conventions.SimCCS390XLinuxSyscall(_arch_)¶
    

Bases: `SimCCSyscall`

Parameters:
    

**arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = ['r2', 'r3', 'r4', 'r5', 'r6', 'r7']_¶
    

FP_ARG_REGS _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]__ = []_¶
    

RETURN_VAL _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <r2>_¶
    

RETURN_ADDR _: `SimFunctionArgument` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = <ip_at_syscall>_¶
    

ARCH¶
    

alias of [`ArchS390X`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_s390x.ArchS390X "\(in archinfo\)")

_static _syscall_num(_state_)¶
    

angr.calling_conventions.register_default_cc(_arch_ , _cc_ , _platform ='Linux'_)¶
    

Parameters:
    

  * **arch** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **cc** ([_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__SimCC_ _]_)

  * **platform** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

angr.calling_conventions.default_cc(_arch_ , _platform ='Linux'_, _language =None_, _syscall =False_, _default =None_)¶
    

Return the default calling convention for a given architecture, platform, and language combination.

Parameters:
    

  * **arch** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The architecture name.

  * **platform** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")) – The platform name (e.g., “Linux” or “Win32”).

  * **language** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]) – The programming language name (e.g., “go”).

  * **syscall** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Return syscall convention (True), or normal calling convention (False, default).

  * **default** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`SimCC`]]) – The default calling convention to return if nothing fits.

Return type:
    

[`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`SimCC`] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

A default calling convention class if we can find one for the architecture, platform, and language combination, or the default if nothing fits.

angr.calling_conventions.unify_arch_name(_arch_)¶
    

Return the unified architecture name.

Parameters:
    

**arch** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The architecture name.

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

Returns:
    

A unified architecture name.

angr.calling_conventions.register_syscall_cc(_arch_ , _os_ , _cc_)¶
    

_class _angr.sim_variable.SimVariable(_size_ , _ident =None_, _name =None_, _region =None_, _category =None_)¶
    

Bases: `Serializable`

The base class for all other classes of variables.

Parameters:
    

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **ident** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **region** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_size_ , _ident =None_, _name =None_, _region =None_, _category =None_)¶
    

Parameters:
    

  * **ident** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]) – A unique identifier provided by user or the program. Usually a string.

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of this variable.

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **region** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

ident¶
    

name¶
    

region _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

category _: [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

renamed¶
    

candidate_names¶
    

size¶
    

copy()¶
    

loc_repr(_arch_)¶
    

The representation that shows up in a GUI

Parameters:
    

**arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)"))

_property _is_function_argument¶
    

_property _bits _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_property _key _: [tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)"), ...]_¶
    

_class _angr.sim_variable.SimConstantVariable(_size_ , _ident =None_, _value =None_, _region =None_)¶
    

Bases: `SimVariable`

Describes a constant variable.

Parameters:
    

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **region** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_size_ , _ident =None_, _value =None_, _region =None_)¶
    

Parameters:
    

  * **ident** – A unique identifier provided by user or the program. Usually a string.

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of this variable.

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

value¶
    

loc_repr(_arch_)¶
    

The representation that shows up in a GUI

copy()¶
    

Return type:
    

`SimConstantVariable`

_property _key _: [tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)"), ...]_¶
    

_class _angr.sim_variable.SimTemporaryVariable(_tmp_id_ , _size_)¶
    

Bases: `SimVariable`

Describes a temporary variable.

Parameters:
    

  * **tmp_id** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_tmp_id_ , _size_)¶
    

Parameters:
    

  * **ident** – A unique identifier provided by user or the program. Usually a string.

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of this variable.

  * **tmp_id** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

tmp_id¶
    

loc_repr(_arch_)¶
    

The representation that shows up in a GUI

copy()¶
    

Return type:
    

`SimTemporaryVariable`

_property _key _: [tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)"), ...]_¶
    

serialize_to_cmessage()¶
    

Serialize the class object and returns a protobuf cmessage object.

Returns:
    

A protobuf cmessage object.

Return type:
    

protobuf.cmessage

_classmethod _parse_from_cmessage(_cmsg_ , _** kwargs_)¶
    

Parse a protobuf cmessage and create a class object.

Parameters:
    

**cmsg** – The probobuf cmessage object.

Returns:
    

A unserialized class object.

Return type:
    

cls

_class _angr.sim_variable.SimRegisterVariable(_reg_offset_ , _size_ , _ident =None_, _name =None_, _region =None_, _category =None_)¶
    

Bases: `SimVariable`

Describes a register variable.

Parameters:
    

  * **reg_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **region** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **category** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

__init__(_reg_offset_ , _size_ , _ident =None_, _name =None_, _region =None_, _category =None_)¶
    

Parameters:
    

  * **ident** – A unique identifier provided by user or the program. Usually a string.

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of this variable.

  * **reg_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

reg¶
    

loc_repr(_arch_)¶
    

The representation that shows up in a GUI

_property _key _: [tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)"), ...]_¶
    

copy()¶
    

Return type:
    

`SimRegisterVariable`

serialize_to_cmessage()¶
    

Serialize the class object and returns a protobuf cmessage object.

Returns:
    

A protobuf cmessage object.

Return type:
    

protobuf.cmessage

_classmethod _parse_from_cmessage(_cmsg_ , _** kwargs_)¶
    

Parse a protobuf cmessage and create a class object.

Parameters:
    

**cmsg** – The probobuf cmessage object.

Returns:
    

A unserialized class object.

Return type:
    

cls

_class _angr.sim_variable.SimMemoryVariable(_addr_ , _size_ , _ident =None_, _name =None_, _region =None_, _category =None_)¶
    

Bases: `SimVariable`

Describes a memory variable; the base class for other types of memory variables.

Parameters:
    

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **region** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **category** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

__init__(_addr_ , _size_ , _ident =None_, _name =None_, _region =None_, _category =None_)¶
    

Parameters:
    

  * **ident** – A unique identifier provided by user or the program. Usually a string.

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of this variable.

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

addr¶
    

loc_repr(_arch_)¶
    

The representation that shows up in a GUI

copy()¶
    

Return type:
    

`SimMemoryVariable`

_property _key _: [tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)"), ...]_¶
    

serialize_to_cmessage()¶
    

Serialize the class object and returns a protobuf cmessage object.

Returns:
    

A protobuf cmessage object.

Return type:
    

protobuf.cmessage

_classmethod _parse_from_cmessage(_cmsg_ , _** kwargs_)¶
    

Parse a protobuf cmessage and create a class object.

Parameters:
    

**cmsg** – The probobuf cmessage object.

Returns:
    

A unserialized class object.

Return type:
    

cls

_class _angr.sim_variable.SimStackVariable(_offset_ , _size_ , _base ='sp'_, _base_addr =None_, _ident =None_, _name =None_, _region =None_, _category =None_)¶
    

Bases: `SimMemoryVariable`

Describes a stack variable.

Parameters:
    

  * **offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **region** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **category** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

__init__(_offset_ , _size_ , _base ='sp'_, _base_addr =None_, _ident =None_, _name =None_, _region =None_, _category =None_)¶
    

Parameters:
    

  * **ident** – A unique identifier provided by user or the program. Usually a string.

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of this variable.

  * **offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

base¶
    

offset¶
    

base_addr¶
    

loc_repr(_arch_)¶
    

The representation that shows up in a GUI

copy()¶
    

Return type:
    

`SimStackVariable`

_property _key _: [tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)"), ...]_¶
    

serialize_to_cmessage()¶
    

Serialize the class object and returns a protobuf cmessage object.

Returns:
    

A protobuf cmessage object.

Return type:
    

protobuf.cmessage

_classmethod _parse_from_cmessage(_cmsg_ , _** kwargs_)¶
    

Parse a protobuf cmessage and create a class object.

Parameters:
    

**cmsg** – The probobuf cmessage object.

Returns:
    

A unserialized class object.

Return type:
    

cls

_class _angr.sim_type.SimType(_label =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

SimType exists to track type information for SimProcedures.

base _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_ _ = True_¶
    

__init__(_label =None_)¶
    

Parameters:
    

**label** – the type label.

_property _size _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

The size of the type in bits, or None if no size is computable.

_property _alignment¶
    

The alignment of the type in bytes.

with_arch(_arch_)¶
    

Parameters:
    

**arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)") _|__None_)

c_repr(_name =None_, _full =0_, _memo =None_, _indent =0_, _name_parens =True_)¶
    

Parameters:
    

  * **indent** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **name_parens** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

copy()¶
    

extract(_state_ , _addr_ , _concrete =False_)¶
    

Return type:
    

[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")

Parameters:
    

  * **state** (_SimState_)

  * **concrete** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

store(_state_ , _addr_ , _value_)¶
    

Parameters:
    

  * **state** (_SimState_)

  * **value** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

extract_claripy(_bits_)¶
    

Given a bitvector bits which was loaded from memory in a big-endian fashion, return a more appropriate or structured representation of the data.

A type must have an arch associated in order to use this method.

Return type:
    

[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")

_class _angr.sim_type.TypeRef(_name_ , _ty_)¶
    

Bases: `SimType`

A TypeRef is a reference to a type with a name. This allows for interactivity in type analysis, by storing a type and having the option to update it later and have all references to it automatically update as well.

__init__(_name_ , _ty_)¶
    

Parameters:
    

**label** – the type label.

_property _type¶
    

_property _name¶
    

This is a read-only property because it is desirable to store typerefs in a mapping from name to type, and we want the mapping to be in the loop for any updates.

_property _size¶
    

The size of the type in bits, or None if no size is computable.

_property _alignment¶
    

The alignment of the type in bytes.

with_arch(_arch_)¶
    

c_repr(_name =None_, _full =0_, _memo =None_, _indent =0_, _name_parens =True_)¶
    

Parameters:
    

**name_parens** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

copy()¶
    

_class _angr.sim_type.NamedTypeMixin(_* args_, _name =None_, _** kwargs_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

SimType classes with this mixin in the class hierarchy allows setting custom class names. A typical use case is to represent same or similar type classes with different qualified names, such as “std::basic_string” vs “std::__cxx11::basic_string”. In such cases, .name stores the qualified name, and .unqualified_name() returns the unqualified name of the type.

Parameters:
    

**name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

__init__(_* args_, _name =None_, _** kwargs_)¶
    

Parameters:
    

**name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

_property _name _: [str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")_¶
    

unqualified_name(_lang ='c++'_)¶
    

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

Parameters:
    

**lang** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.sim_type.SimTypeBottom(_label =None_)¶
    

Bases: `SimType`

SimTypeBottom basically represents a type error.

c_repr(_name =None_, _full =0_, _memo =None_, _indent =0_, _name_parens =True_)¶
    

Parameters:
    

**name_parens** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

copy()¶
    

_class _angr.sim_type.SimTypeTop(_size =None_, _label =None_)¶
    

Bases: `SimType`

SimTypeTop represents any type (mostly used with a pointer for void*).

Parameters:
    

**size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_size =None_, _label =None_)¶
    

Parameters:
    

  * **label** – the type label.

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

copy()¶
    

_class _angr.sim_type.SimTypeReg(_size_ , _label =None_)¶
    

Bases: `SimType`

SimTypeReg is the base type for all types that are register-sized.

Parameters:
    

**size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_size_ , _label =None_)¶
    

Parameters:
    

  * **label** – the type label.

  * **size** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")) – the size of the type (e.g. 32bit, 8bit, etc.).

store(_state_ , _addr_ , _value_)¶
    

Parameters:
    

**value** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

copy()¶
    

_class _angr.sim_type.SimTypeNum(_size_ , _signed =True_, _label =None_)¶
    

Bases: `SimType`

SimTypeNum is a numeric type of arbitrary length

Parameters:
    

**size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_size_ , _signed =True_, _label =None_)¶
    

Parameters:
    

  * **size** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The size of the integer, in bits

  * **signed** – Whether the integer is signed or not

  * **label** – A label for the type

_property _size _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

The size of the type in bits, or None if no size is computable.

extract(_state_ , _addr_ , _concrete =False_)¶
    

store(_state_ , _addr_ , _value_)¶
    

Parameters:
    

**value** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

copy()¶
    

_class _angr.sim_type.SimTypeInt(_signed =True_, _label =None_)¶
    

Bases: `SimTypeReg`

SimTypeInt is a type that specifies a signed or unsigned C integer.

__init__(_signed =True_, _label =None_)¶
    

Parameters:
    

  * **signed** – True if signed, False if unsigned

  * **label** – The type label

c_repr(_name =None_, _full =0_, _memo =None_, _indent =0_, _name_parens =True_)¶
    

Parameters:
    

**name_parens** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

_property _size¶
    

The size of the type in bits, or None if no size is computable.

extract(_state_ , _addr_ , _concrete =False_)¶
    

copy()¶
    

_class _angr.sim_type.SimTypeShort(_signed =True_, _label =None_)¶
    

Bases: `SimTypeInt`

_class _angr.sim_type.SimTypeLong(_signed =True_, _label =None_)¶
    

Bases: `SimTypeInt`

_class _angr.sim_type.SimTypeLongLong(_signed =True_, _label =None_)¶
    

Bases: `SimTypeInt`

_class _angr.sim_type.SimTypeFixedSizeInt(_signed =True_, _label =None_)¶
    

Bases: `SimTypeInt`

The base class for all fixed-size (i.e., the size stays the same on all platforms) integer types. Do not instantiate this class directly.

c_repr(_name =None_, _full =0_, _memo =None_, _indent =0_, _name_parens =True_)¶
    

Parameters:
    

  * **indent** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **name_parens** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

_property _size _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

The size of the type in bits, or None if no size is computable.

_class _angr.sim_type.SimTypeInt128(_signed =True_, _label =None_)¶
    

Bases: `SimTypeFixedSizeInt`

_class _angr.sim_type.SimTypeInt256(_signed =True_, _label =None_)¶
    

Bases: `SimTypeFixedSizeInt`

_class _angr.sim_type.SimTypeInt512(_signed =True_, _label =None_)¶
    

Bases: `SimTypeFixedSizeInt`

_class _angr.sim_type.SimTypeChar(_signed =True_, _label =None_)¶
    

Bases: `SimTypeReg`

SimTypeChar is a type that specifies a character; this could be represented by a byte, but this is meant to be interpreted as a character.

__init__(_signed =True_, _label =None_)¶
    

Parameters:
    

**label** – the type label.

store(_state_ , _addr_ , _value_)¶
    

Parameters:
    

**value** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

extract(_state_ , _addr_ , _concrete =False_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)")

Parameters:
    

**concrete** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

copy()¶
    

_class _angr.sim_type.SimTypeWideChar(_signed =True_, _label =None_, _endness =Endness.BE_)¶
    

Bases: `SimTypeReg`

SimTypeWideChar is a type that specifies a wide character (a UTF-16 character).

Parameters:
    

**endness** (_Endness_)

__init__(_signed =True_, _label =None_, _endness =Endness.BE_)¶
    

Parameters:
    

  * **label** – the type label.

  * **endness** ([_Endness_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.types.Endness "\(in archinfo\)"))

store(_state_ , _addr_ , _value_)¶
    

Parameters:
    

**value** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

extract(_state_ , _addr_ , _concrete =False_)¶
    

Return type:
    

[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")

copy()¶
    

_class _angr.sim_type.SimTypeBool(_signed =True_, _label =None_)¶
    

Bases: `SimTypeReg`

__init__(_signed =True_, _label =None_)¶
    

Parameters:
    

**label** – the type label.

store(_state_ , _addr_ , _value_)¶
    

Parameters:
    

**value** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _|_[_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

extract(_state_ , _addr_ , _concrete =False_)¶
    

copy()¶
    

_class _angr.sim_type.SimTypeFd(_label =None_)¶
    

Bases: `SimTypeReg`

SimTypeFd is a type that specifies a file descriptor.

__init__(_label =None_)¶
    

Parameters:
    

**label** – the type label

_property _size¶
    

The size of the type in bits, or None if no size is computable.

copy()¶
    

extract(_state_ , _addr_ , _concrete =False_)¶
    

_class _angr.sim_type.SimTypePointer(_pts_to_ , _label =None_, _offset =0_)¶
    

Bases: `SimTypeReg`

SimTypePointer is a type that specifies a pointer to some other type.

__init__(_pts_to_ , _label =None_, _offset =0_)¶
    

Parameters:
    

  * **label** – The type label.

  * **pts_to** – The type to which this pointer points.

c_repr(_name =None_, _full =0_, _memo =None_, _indent =0_, _name_parens =True_)¶
    

Parameters:
    

**name_parens** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

make(_pts_to_)¶
    

_property _size¶
    

The size of the type in bits, or None if no size is computable.

copy()¶
    

extract(_state_ , _addr_ , _concrete =False_)¶
    

_class _angr.sim_type.SimTypeReference(_refs_ , _label =None_)¶
    

Bases: `SimTypeReg`

SimTypeReference is a type that specifies a reference to some other type.

__init__(_refs_ , _label =None_)¶
    

Parameters:
    

  * **label** – the type label.

  * **size** – the size of the type (e.g. 32bit, 8bit, etc.).

c_repr(_name =None_, _full =0_, _memo =None_, _indent =0_, _name_parens =True_)¶
    

Parameters:
    

**name_parens** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

make(_refs_)¶
    

_property _size¶
    

The size of the type in bits, or None if no size is computable.

copy()¶
    

extract(_state_ , _addr_ , _concrete =False_)¶
    

_class _angr.sim_type.SimTypeArray(_elem_type_ , _length =None_, _label =None_)¶
    

Bases: `SimType`

SimTypeArray is a type that specifies a series of data laid out in sequence.

__init__(_elem_type_ , _length =None_, _label =None_)¶
    

Parameters:
    

  * **label** – The type label.

  * **elem_type** – The type of each element in the array.

  * **length** – An expression of the length of the array, if known.

c_repr(_name =None_, _full =0_, _memo =None_, _indent =0_, _name_parens =True_)¶
    

Parameters:
    

**name_parens** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

_property _size¶
    

The size of the type in bits, or None if no size is computable.

_property _alignment¶
    

The alignment of the type in bytes.

copy()¶
    

extract(_state_ , _addr_ , _concrete =False_)¶
    

store(_state_ , _addr_ , _value_)¶
    

Parameters:
    

**value** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _]_)

angr.sim_type.SimTypeFixedSizeArray¶
    

alias of `SimTypeArray`

_class _angr.sim_type.SimTypeString(_length =None_, _label =None_, _name =None_)¶
    

Bases: `NamedTypeMixin`, `SimType`

SimTypeString is a type that represents a C-style string, i.e. a NUL-terminated array of bytes.

Parameters:
    

  * **length** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

__init__(_length =None_, _label =None_, _name =None_)¶
    

Parameters:
    

  * **label** – The type label.

  * **length** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – An expression of the length of the string, if known.

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

c_repr(_name =None_, _full =0_, _memo =None_, _indent =0_, _name_parens =True_)¶
    

Parameters:
    

**name_parens** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

extract(_state_ , _addr_ , _concrete =False_)¶
    

Parameters:
    

**state** (_SimState_)

_property _size¶
    

The size of the type in bits, or None if no size is computable.

_property _alignment¶
    

The alignment of the type in bytes.

copy()¶
    

_class _angr.sim_type.SimTypeWString(_length =None_, _label =None_, _name =None_)¶
    

Bases: `NamedTypeMixin`, `SimType`

A wide-character null-terminated string, where each character is 2 bytes.

Parameters:
    

  * **length** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

__init__(_length =None_, _label =None_, _name =None_)¶
    

Parameters:
    

  * **label** – the type label.

  * **length** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

c_repr(_name =None_, _full =0_, _memo =None_, _indent =0_, _name_parens =True_)¶
    

Parameters:
    

**name_parens** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

extract(_state_ , _addr_ , _concrete =False_)¶
    

store(_state_ , _addr_ , _value_)¶
    

_property _size¶
    

The size of the type in bits, or None if no size is computable.

_property _alignment¶
    

The alignment of the type in bytes.

copy()¶
    

_class _angr.sim_type.SimTypeFunction(_args_ , _returnty_ , _label =None_, _arg_names =None_, _variadic =False_)¶
    

Bases: `SimType`

SimTypeFunction is a type that specifies an actual function (i.e. not a pointer) with certain types of arguments and a certain return value.

Parameters:
    

  * **args** (_Iterable_ _[__SimType_ _]_)

  * **returnty** (_SimType_ _|__None_)

  * **arg_names** (_Iterable_ _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

base _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_ _ = False_¶
    

__init__(_args_ , _returnty_ , _label =None_, _arg_names =None_, _variadic =False_)¶
    

Parameters:
    

  * **label** – The type label

  * **args** ([`Iterable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)")[`SimType`]) – A tuple of types representing the arguments to the function

  * **returnty** (`SimType` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")) – The return type of the function, or none for void

  * **variadic** – Whether the function accepts varargs

  * **arg_names** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

c_repr(_name =None_, _full =0_, _memo =None_, _indent =0_, _name_parens =True_)¶
    

Parameters:
    

**name_parens** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

_property _size¶
    

The size of the type in bits, or None if no size is computable.

copy()¶
    

_class _angr.sim_type.SimTypeCppFunction(_args_ , _returnty_ , _label =None_, _arg_names =None_, _ctor =False_, _dtor =False_, _convention =None_)¶
    

Bases: `SimTypeFunction`

SimTypeCppFunction is a type that specifies an actual C++-style function with information about arguments, return value, and more C++-specific properties.

Variables:
    

  * **ctor** – Whether the function is a constructor or not.

  * **dtor** – Whether the function is a destructor or not.

Parameters:
    

  * **args** ([_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__SimType_ _,__...__]_)

  * **returnty** (_SimType_ _|__None_)

  * **arg_names** (_Iterable_ _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **ctor** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **dtor** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **convention** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

__init__(_args_ , _returnty_ , _label =None_, _arg_names =None_, _ctor =False_, _dtor =False_, _convention =None_)¶
    

Parameters:
    

  * **label** – The type label

  * **args** – A tuple of types representing the arguments to the function

  * **returnty** – The return type of the function, or none for void

  * **variadic** – Whether the function accepts varargs

  * **arg_names** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **ctor** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **dtor** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **convention** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

copy()¶
    

_class _angr.sim_type.SimTypeLength(_signed =False_, _addr =None_, _length =None_, _label =None_)¶
    

Bases: `SimTypeLong`

SimTypeLength is a type that specifies the length of some buffer in memory.

…I’m not really sure what the original design of this class was going for

__init__(_signed =False_, _addr =None_, _length =None_, _label =None_)¶
    

Parameters:
    

  * **signed** – Whether the value is signed or not

  * **label** – The type label.

  * **addr** – The memory address (expression).

  * **length** – The length (expression).

_property _size¶
    

The size of the type in bits, or None if no size is computable.

copy()¶
    

_class _angr.sim_type.SimTypeFloat(_size =32_)¶
    

Bases: `SimTypeReg`

An IEEE754 single-precision floating point number

__init__(_size =32_)¶
    

Parameters:
    

  * **label** – the type label.

  * **size** – the size of the type (e.g. 32bit, 8bit, etc.).

sort _ = FLOAT_¶
    

signed _ = True_¶
    

_property _size _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

The size of the type in bits, or None if no size is computable.

extract(_state_ , _addr_ , _concrete =False_)¶
    

store(_state_ , _addr_ , _value_)¶
    

Parameters:
    

**value** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _|_[_FP_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)"))

copy()¶
    

_class _angr.sim_type.SimTypeDouble(_align_double =True_)¶
    

Bases: `SimTypeFloat`

An IEEE754 double-precision floating point number

__init__(_align_double =True_)¶
    

Parameters:
    

  * **label** – the type label.

  * **size** – the size of the type (e.g. 32bit, 8bit, etc.).

sort _ = DOUBLE_¶
    

_property _size _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

The size of the type in bits, or None if no size is computable.

_property _alignment¶
    

The alignment of the type in bytes.

copy()¶
    

_class _angr.sim_type.SimStruct(_fields_ , _name =None_, _pack =False_, _align =None_, _anonymous =False_)¶
    

Bases: `NamedTypeMixin`, `SimType`

Parameters:
    

  * **fields** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__SimType_ _]__|__OrderedDict_ _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__SimType_ _]_)

  * **anonymous** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_fields_ , _name =None_, _pack =False_, _align =None_, _anonymous =False_)¶
    

Parameters:
    

  * **label** – the type label.

  * **fields** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__SimType_ _]__|_[_OrderedDict_](https://docs.python.org/3/library/collections.html#collections.OrderedDict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__SimType_ _]_)

  * **anonymous** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

_property _packed¶
    

_property _offsets _: [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"), [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]_¶
    

extract(_state_ , _addr_ , _concrete =False_)¶
    

Return type:
    

`SimStructValue`

c_repr(_name =None_, _full =0_, _memo =None_, _indent =0_, _name_parens =True_)¶
    

Parameters:
    

**name_parens** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

_property _size¶
    

The size of the type in bits, or None if no size is computable.

_property _alignment¶
    

The alignment of the type in bytes.

store(_state_ , _addr_ , _value_)¶
    

Parameters:
    

**value** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

copy()¶
    

_class _angr.sim_type.SimStructValue(_struct_ , _values =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A SimStruct type paired with some real values

__init__(_struct_ , _values =None_)¶
    

Parameters:
    

  * **struct** – A SimStruct instance describing the type of this struct

  * **values** – A mapping from struct fields to values

_property _struct¶
    

copy()¶
    

_class _angr.sim_type.SimUnion(_members_ , _name =None_, _label =None_)¶
    

Bases: `NamedTypeMixin`, `SimType`

Parameters:
    

**members** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__SimType_ _]_)

fields _ = ('members', 'name')_¶
    

__init__(_members_ , _name =None_, _label =None_)¶
    

Parameters:
    

  * **members** ([`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"), `SimType`]) – The members of the union, as a mapping name -> type

  * **name** – The name of the union

_property _size¶
    

The size of the type in bits, or None if no size is computable.

_property _alignment¶
    

The alignment of the type in bytes.

extract(_state_ , _addr_ , _concrete =False_)¶
    

c_repr(_name =None_, _full =0_, _memo =None_, _indent =0_, _name_parens =True_)¶
    

Parameters:
    

**name_parens** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

copy()¶
    

_class _angr.sim_type.SimUnionValue(_union_ , _values =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A SimStruct type paired with some real values

__init__(_union_ , _values =None_)¶
    

Parameters:
    

  * **union** – A SimUnion instance describing the type of this union

  * **values** – A mapping from union members to values

copy()¶
    

_class _angr.sim_type.SimCppClass(_*_ , _unique_name =None_, _name =None_, _members =None_, _function_members =None_, _vtable_ptrs =None_, _pack =False_, _align =None_)¶
    

Bases: `SimStruct`

Parameters:
    

  * **unique_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **members** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__SimType_ _]__|__None_)

  * **function_members** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__SimTypeCppFunction_ _]__|__None_)

  * **pack** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_*_ , _unique_name =None_, _name =None_, _members =None_, _function_members =None_, _vtable_ptrs =None_, _pack =False_, _align =None_)¶
    

Parameters:
    

  * **label** – the type label.

  * **unique_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **members** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__SimType_ _]__|__None_)

  * **function_members** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__SimTypeCppFunction_ _]__|__None_)

  * **pack** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

_property _members¶
    

extract(_state_ , _addr_ , _concrete =False_)¶
    

Return type:
    

`SimCppClassValue`

store(_state_ , _addr_ , _value_)¶
    

Parameters:
    

**value** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

copy()¶
    

_class _angr.sim_type.SimCppClassValue(_class_type_ , _values_)¶
    

Bases: `SimStructValue`

A SimCppClass type paired with some real values

Parameters:
    

**class_type** (_SimCppClass_)

__init__(_class_type_ , _values_)¶
    

Parameters:
    

  * **struct** – A SimStruct instance describing the type of this struct

  * **values** – A mapping from struct fields to values

  * **class_type** (_SimCppClass_)

copy()¶
    

_class _angr.sim_type.SimTypeNumOffset(_size_ , _signed =True_, _label =None_, _offset =0_)¶
    

Bases: `SimTypeNum`

like SimTypeNum, but supports an offset of 1 to 7 to a byte aligned address to allow structs with bitfields

__init__(_size_ , _signed =True_, _label =None_, _offset =0_)¶
    

Parameters:
    

  * **size** – The size of the integer, in bits

  * **signed** – Whether the integer is signed or not

  * **label** – A label for the type

extract(_state_ , _addr_ , _concrete =False_)¶
    

Parameters:
    

**state** (_SimState_)

store(_state_ , _addr_ , _value_)¶
    

copy()¶
    

_class _angr.sim_type.SimTypeRef(_name_ , _original_type_)¶
    

Bases: `SimType`

SimTypeRef is a to-be-resolved reference to another SimType.

SimTypeRef is not SimTypeReference.

Parameters:
    

**original_type** ([_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__SimStruct_ _]_)

__init__(_name_ , _original_type_)¶
    

Parameters:
    

  * **label** – the type label.

  * **original_type** ([_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__SimStruct_ _]_)

_property _name _: [str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

set_size(_v_)¶
    

Parameters:
    

**v** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

c_repr(_name =None_, _full =0_, _memo =None_, _indent =0_, _name_parens =True_)¶
    

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

Parameters:
    

**name_parens** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

angr.sim_type.register_types(_types_)¶
    

Pass in some types and they will be registered to the global type store.

The argument may be either a mapping from name to SimType, or a plain SimType. The plain SimType must be either a struct or union type with a name present.
    
    
    >>> register_types(parse_types("typedef int x; typedef float y;"))
    >>> register_types(parse_type("struct abcd { int ab; float cd; }"))
    

angr.sim_type.do_preprocess(_defn_ , _include_path =()_)¶
    

Run a string through the C preprocessor that ships with pycparser but is weirdly inaccessible?

angr.sim_type.parse_signature(_defn_ , _preprocess =True_, _predefined_types =None_, _arch =None_)¶
    

Parse a single function prototype and return its type

angr.sim_type.parse_defns(_defn_ , _preprocess =True_, _predefined_types =None_, _arch =None_)¶
    

Parse a series of C definitions, returns a mapping from variable name to variable type object

angr.sim_type.parse_types(_defn_ , _preprocess =True_, _predefined_types =None_, _arch =None_)¶
    

Parse a series of C definitions, returns a mapping from type name to type object

angr.sim_type.parse_file(_defn_ , _preprocess =True_, _predefined_types =None_, _arch =None_)¶
    

Parse a series of C definitions, returns a tuple of two type mappings, one for variable definitions and one for type definitions.

Parameters:
    

**predefined_types** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _,__SimType_ _]__|__None_)

angr.sim_type.type_parser_singleton()¶
    

Return type:
    

`CParser`

angr.sim_type.parse_type(_defn_ , _preprocess =True_, _predefined_types =None_, _arch =None_)¶
    

Parse a simple type expression into a SimType
    
    
    >>> parse_type('int *')
    

angr.sim_type.parse_type_with_name(_defn_ , _preprocess =True_, _predefined_types =None_, _arch =None_)¶
    

Parse a simple type expression into a SimType, returning a tuple of the type object and any associated name that might be found in the place a name would go in a type declaration.
    
    
    >>> parse_type_with_name('int *foo')
    

Parameters:
    

**predefined_types** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _,__SimType_ _]__|__None_)

angr.sim_type.normalize_cpp_function_name(_name_)¶
    

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

Parameters:
    

**name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

angr.sim_type.parse_cpp_file(_cpp_decl_ , _with_param_names =False_)¶
    

Parameters:
    

**with_param_names** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

_class _angr.callable.Callable(_project_ , _addr_ , _prototype =None_, _concrete_only =False_, _perform_merge =True_, _base_state =None_, _toc =None_, _cc =None_, _add_options =None_, _remove_options =None_, _step_limit =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Callable is a representation of a function in the binary that can be interacted with like a native python function.

If you set perform_merge=True (the default), the result will be returned to you, and you can get the result state with callable.result_state.

Otherwise, you can get the resulting simulation manager at callable.result_path_group.

Parameters:
    

**step_limit** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_project_ , _addr_ , _prototype =None_, _concrete_only =False_, _perform_merge =True_, _base_state =None_, _toc =None_, _cc =None_, _add_options =None_, _remove_options =None_, _step_limit =None_)¶
    

Parameters:
    

  * **project** – The project to operate on

  * **addr** – The address of the function to use

  * **step_limit** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

The following parameters are optional:

Parameters:
    

  * **prototype** – The signature of the calls you would like to make. This really shouldn’t be optional.

  * **concrete_only** – Throw an exception if the execution splits into multiple paths

  * **perform_merge** – Merge all result states into one at the end (only relevant if concrete_only=False)

  * **base_state** – The state from which to do these runs

  * **toc** – The address of the table of contents for ppc64

  * **cc** – The SimCC to use for a calling convention

  * **step_limit** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

set_base_state(_state_)¶
    

Swap out the state you’d like to use to perform the call :type state: :param state: The state to use to perform the call

perform_call(_* args_, _prototype =None_)¶
    

call_c(_c_args_)¶
    

Call this Callable with a string of C-style arguments.

Parameters:
    

**c_args** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – C-style arguments.

Returns:
    

The return value from the call.

Return type:
    

claripy.Ast

## Knowledge Base¶

Representing the artifacts of a project.

_class _angr.knowledge_base.KnowledgeBase(_project_ , _obj =None_, _name =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Represents a “model” of knowledge about an artifact.

Contains things like a CFG, data references, etc.

functions _: `FunctionManager`_¶
    

variables _: `VariableManager`_¶
    

defs _: `KeyDefinitionManager`_¶
    

cfgs _: `CFGManager`_¶
    

types _: `TypesStore`_¶
    

propagations _: `PropagationManager`_¶
    

xrefs _: `XRefManager`_¶
    

decompilations _: `StructuredCodeManager`_¶
    

__init__(_project_ , _obj =None_, _name =None_)¶
    

_property _callgraph¶
    

_property _unresolved_indirect_jumps¶
    

_property _resolved_indirect_jumps¶
    

has_plugin(_name_)¶
    

get_plugin(_name_)¶
    

register_plugin(_name_ , _plugin_)¶
    

release_plugin(_name_)¶
    

K _ = ~K_¶
    

get_knowledge(_requested_plugin_cls_)¶
    

Type inference safe method to request a knowledge base plugin Explicitly passing the type of the requested plugin achieves two things: 1\. Every location using this plugin can be easily found with an IDE by searching explicit references to the type 2\. Basic type inference can deduce the result type and properly type check usages of it

If there isn’t already an instance of this class None will be returned to make it clear to the caller that there is no existing knowledge of this type yet. The code that initially creates this knowledge should use the register_plugin method to register the initial knowledge state :type requested_plugin_cls: type[K] :param requested_plugin_cls: :rtype: K | None :return: Instance of the requested plugin class or null if it is not a known plugin

Parameters:
    

**requested_plugin_cls** ([_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__K_ _]_)

Return type:
    

K | None

request_knowledge(_requested_plugin_cls_)¶
    

Return type:
    

K

Parameters:
    

**requested_plugin_cls** ([_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__K_ _]_)

_class _angr.knowledge_plugins.CFGManager(_kb_)¶
    

Bases: `KnowledgeBasePlugin`

This is the CFG manager, it manages CFGs

__init__(_kb_)¶
    

new_model(_prefix_)¶
    

copy()¶
    

get_most_accurate()¶
    

Return type:
    

`CFGModel` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

The most accurate CFG present in the CFGManager, or None if it does not hold any.

_class _angr.knowledge_plugins.CallsitePrototypes(_kb_)¶
    

Bases: `KnowledgeBasePlugin`

CallsitePrototypes manages callee prototypes at call sites.

__init__(_kb_)¶
    

set_prototype(_callsite_block_addr_ , _cc_ , _prototype_ , _manual =False_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **callsite_block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **cc** (_SimCC_)

  * **prototype** (_SimTypeFunction_)

  * **manual** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

get_cc(_callsite_block_addr_)¶
    

Return type:
    

`SimCC` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**callsite_block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_prototype(_callsite_block_addr_)¶
    

Return type:
    

`SimTypeFunction` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**callsite_block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_prototype_type(_callsite_block_addr_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**callsite_block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

has_prototype(_callsite_block_addr_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**callsite_block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

copy()¶
    

_class _angr.knowledge_plugins.Comments(_kb_)¶
    

Bases: `KnowledgeBasePlugin`, [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")

Tracks comments via a Dict of Address -> Text

Parameters:
    

**kb** (_KnowledgeBase_)

copy() → a shallow copy of D¶
    

_class _angr.knowledge_plugins.CustomStrings(_kb_)¶
    

Bases: `KnowledgeBasePlugin`

Store new strings that are recovered during various analysis. Each string has a unique ID associated.

__init__(_kb_)¶
    

allocate(_s_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

Parameters:
    

**s** ([_bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)"))

copy()¶
    

_class _angr.knowledge_plugins.Data(_kb_)¶
    

Bases: `KnowledgeBasePlugin`

The knowledge what purpose this plugin serves has been lost to the passing of time but the linter does not care for these failures of mere mortals and demands a docstring anyway. The pact has been made, and no violations of the rules will be tolerated, even if the spirit does not match the letter. Making the plugin smaller has only increased the weight of the failure, and thus this file has drawn its ire.

The only thing left to do is to attempt to find meaning in the meaninglessness, as the only act of rebellion against the uncaring forces that bind us. For is this not what being human is all about?

Parameters:
    

**kb** (_KnowledgeBase_)

copy()¶
    

_class _angr.knowledge_plugins.DebugVariableManager(_kb_)¶
    

Bases: `KnowledgeBasePlugin`

Structure to manage and access variables with different visibility scopes.

Parameters:
    

**kb** (_KnowledgeBase_)

__init__(_kb_)¶
    

Parameters:
    

**kb** (_KnowledgeBase_)

from_name_and_pc(_var_name_ , _pc_addr_)¶
    

Get a variable from its string in the scope of pc.

Return type:
    

[`Variable`](https://docs.angr.io/projects/cle/en/latest/api/backends/elf.html#cle.backends.elf.variable.Variable "\(in cle\)")

Parameters:
    

  * **var_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **pc_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

from_name(_var_name_)¶
    

Get the variable container for all variables named var_name

Parameters:
    

**var_name** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – name for a variable

Return type:
    

`DebugVariableContainer`

add_variable(_cle_var_ , _low_pc_ , _high_pc_)¶
    

Add/load a variable

Parameters:
    

  * **cle_variable** – The variable to add

  * **low_pc** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Start of the visibility scope of the variable as program counter address (rebased)

  * **high_pc** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – End of the visibility scope of the variable as program counter address (rebased)

  * **cle_var** ([_Variable_](https://docs.angr.io/projects/cle/en/latest/api/backends/elf.html#cle.backends.elf.variable.Variable "\(in cle\)"))

add_variable_list(_vlist_ , _low_pc_ , _high_pc_)¶
    

Add all variables in a list with the same visibility range

Parameters:
    

  * **vlist** ([`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`Variable`](https://docs.angr.io/projects/cle/en/latest/api/backends/elf.html#cle.backends.elf.variable.Variable "\(in cle\)")]) – A list of cle variables to add

  * **low_pc** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Start of the visibility scope as program counter address (rebased)

  * **high_pc** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – End of the visibility scope as program counter address (rebased)

load_from_dwarf(_elf_object =None_, _cu =None_)¶
    

Automatically load all variables (global/local) from the DWARF debugging info

Parameters:
    

  * **elf_object** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`ELF`](https://docs.angr.io/projects/cle/en/latest/api/backends/elf.html#cle.backends.ELF "\(in cle\)")]) – Optional, when only one elf object should be considered (e.g. p.loader.main_object)

  * **cu** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`CompilationUnit`](https://docs.angr.io/projects/cle/en/latest/api/backends/elf.html#cle.backends.elf.compilation_unit.CompilationUnit "\(in cle\)")]) – Optional, when only one compilation unit should be considered

_class _angr.knowledge_plugins.Function(_function_manager_ , _addr_ , _name =None_, _syscall =None_, _is_simprocedure =None_, _binary_name =None_, _is_plt =None_, _returning =None_, _alignment =False_, _calling_convention =None_, _prototype =None_, _prototype_libname =None_, _is_prototype_guessed =True_)¶
    

Bases: `Serializable`

A representation of a function and various information about it.

Parameters:
    

  * **is_simprocedure** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **is_plt** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **calling_convention** (_SimCC_ _|__None_)

  * **prototype** (_SimTypeFunction_ _|__None_)

  * **prototype_libname** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **is_prototype_guessed** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_function_manager_ , _addr_ , _name =None_, _syscall =None_, _is_simprocedure =None_, _binary_name =None_, _is_plt =None_, _returning =None_, _alignment =False_, _calling_convention =None_, _prototype =None_, _prototype_libname =None_, _is_prototype_guessed =True_)¶
    

Function constructor. If the optional parameters are not provided, they will be automatically determined upon the creation of a Function object.

Parameters:
    

  * **addr** – The address of the function.

  * **is_simprocedure** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **is_plt** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **calling_convention** (_SimCC_ _|__None_)

  * **prototype** (_SimTypeFunction_ _|__None_)

  * **prototype_libname** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **is_prototype_guessed** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

The following parameters are optional.

Parameters:
    

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The name of the function.

  * **syscall** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether this function is a syscall or not.

  * **is_simprocedure** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether this function is a SimProcedure or not.

  * **binary_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of the binary where this function is.

  * **is_plt** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If this function is a PLT entry.

  * **returning** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If this function returns.

  * **alignment** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If this function acts as an alignment filler. Such functions usually only contain nops.

  * **calling_convention** (_SimCC_ _|__None_)

  * **prototype** (_SimTypeFunction_ _|__None_)

  * **prototype_libname** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **is_prototype_guessed** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

transition_graph¶
    

normalized¶
    

addr¶
    

startpoint¶
    

is_alignment¶
    

bp_on_stack¶
    

retaddr_on_stack¶
    

sp_delta¶
    

calling_convention¶
    

prototype¶
    

prototype_libname¶
    

is_prototype_guessed¶
    

info¶
    

tags¶
    

ran_cca¶
    

is_syscall¶
    

is_simprocedure¶
    

is_plt¶
    

is_default_name¶
    

previous_names¶
    

from_signature _: [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

binary_name¶
    

_property _name¶
    

_property _project¶
    

_property _returning¶
    

_property _blocks¶
    

An iterator of all local blocks in the current function.

Returns:
    

angr.lifter.Block instances.

_property _cyclomatic_complexity¶
    

The cyclomatic complexity of the function.

Cyclomatic complexity is a software metric used to indicate the complexity of a program. It is a quantitative measure of the number of linearly independent paths through a program’s source code. It is computed using the formula: M = E - N + 2P, where E = the number of edges in the graph, N = the number of nodes in the graph, P = the number of connected components.

The cyclomatic complexity value is lazily computed and cached for future use. Initially this value is None until it is computed for the first time

Returns:
    

The cyclomatic complexity of the function.

Return type:
    

[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

_property _xrefs¶
    

An iterator of all xrefs of the current function.

Returns:
    

angr.knowledge_plugins.xrefs.xref.XRef instances.

_property _block_addrs¶
    

An iterator of all local block addresses in the current function.

Returns:
    

block addresses.

_property _block_addrs_set¶
    

Return a set of block addresses for a better performance of inclusion tests.

Returns:
    

A set of block addresses.

Return type:
    

[set](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")

get_block(_addr_ , _size =None_, _byte_string =None_)¶
    

Getting a block out of the current function.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address of the block.

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The size of the block. This is optional. If not provided, angr will load

  * **byte_string** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)")])

Returns:
    

get_block_size(_addr_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_property _nodes _: [Iterable](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)")[CodeNode]_¶
    

get_node(_addr_)¶
    

Return type:
    

`BlockNode` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

_property _has_unresolved_jumps¶
    

_property _has_unresolved_calls¶
    

_property _operations¶
    

All of the operations that are done by this functions.

_property _code_constants¶
    

All of the constants that are used by this functions’s code.

serialize_to_cmessage()¶
    

Serialize the class object and returns a protobuf cmessage object.

Returns:
    

A protobuf cmessage object.

Return type:
    

protobuf.cmessage

_classmethod _parse_from_cmessage(_cmsg_ , _** kwargs_)¶
    

Parameters:
    

**cmsg**

Return Function:
    

The function instantiated out of the cmsg data.

string_references(_minimum_length =2_)¶
    

All of the constant string references used by this function.

Parameters:
    

**minimum_length** – The minimum length of strings to find (default is 1)

Returns:
    

A generator yielding tuples of (address, string) where is address is the location of the string in memory.

_property _local_runtime_values¶
    

Tries to find all runtime values of this function which do not come from inputs. These values are generated by starting from a blank state and reanalyzing the basic blocks once each. Function calls are skipped, and back edges are never taken so these values are often unreliable, This function is good at finding simple constant addresses which the function will use or calculate.

Returns:
    

a set of constants

_property _num_arguments¶
    

_property _endpoints¶
    

_property _endpoints_with_type¶
    

_property _ret_sites¶
    

_property _jumpout_sites¶
    

_property _retout_sites¶
    

_property _callout_sites¶
    

_property _size¶
    

_property _binary¶
    

Get the object this function belongs to. :return: The object this function belongs to.

_property _offset _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

the function’s binary offset (i.e., non-rebased address)

Type:
    

return

_property _symbol _: [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") | [Symbol](https://docs.angr.io/projects/cle/en/latest/api/backend.html#cle.backends.symbol.Symbol "\(in cle\)")_¶
    

the function’s Symbol, if any

Type:
    

return

_property _pseudocode _: [str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

the function’s pseudocode

Type:
    

return

add_jumpout_site(_node_)¶
    

Add a custom jumpout site.

Parameters:
    

**node** (`CodeNode`) – The address of the basic block that control flow leaves during this transition.

Returns:
    

None

add_retout_site(_node_)¶
    

Add a custom retout site.

Retout (returning to outside of the function) sites are very rare. It mostly occurs during CFG recovery when we incorrectly identify the beginning of a function in the first iteration, and then correctly identify that function later in the same iteration (function alignments can lead to this bizarre case). We will mark all edges going out of the header of that function as a outside edge, because all successors now belong to the incorrectly-identified function. This identification error will be fixed in the second iteration of CFG recovery. However, we still want to keep track of jumpouts/retouts during the first iteration so other logic in CFG recovery still work.

Parameters:
    

**node** (`CodeNode`) – The address of the basic block that control flow leaves the current function after a call.

Returns:
    

None

mark_nonreturning_calls_endpoints()¶
    

Iterate through all call edges in transition graph. For each call a non-returning function, mark the source basic block as an endpoint.

This method should only be executed once all functions are recovered and analyzed by CFG recovery, so we know whether each function returns or not.

Returns:
    

None

get_call_sites()¶
    

Gets a list of all the basic blocks that end in calls.

Return type:
    

[`Iterable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]

Returns:
    

A view of the addresses of the blocks that end in calls.

get_call_target(_callsite_addr_)¶
    

Get the target of a call.

Parameters:
    

**callsite_addr** – The address of a basic block that ends in a call.

Returns:
    

The target of said call, or None if callsite_addr is not a callsite.

get_call_return(_callsite_addr_)¶
    

Get the hypothetical return address of a call.

Parameters:
    

**callsite_addr** – The address of the basic block that ends in a call.

Returns:
    

The likely return target of said call, or None if callsite_addr is not a callsite.

_property _graph¶
    

Get a local transition graph. A local transition graph is a transition graph that only contains nodes that belong to the current function. All edges, except for the edges going out from the current function or coming from outside the current function, are included.

The generated graph is cached in self._local_transition_graph.

Returns:
    

A local transition graph.

Return type:
    

networkx.DiGraph

graph_ex(_exception_edges =True_)¶
    

Get a local transition graph with a custom configuration. A local transition graph is a transition graph that only contains nodes that belong to the current function. This method allows user to exclude certain types of edges together with the nodes that are only reachable through such edges, such as exception edges.

The generated graph is not cached.

Parameters:
    

**exception_edges** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Should exception edges and the nodes that are only reachable through exception edges be kept.

Returns:
    

A local transition graph with a special configuration.

Return type:
    

networkx.DiGraph

transition_graph_ex(_exception_edges =True_)¶
    

Get a transition graph with a custom configuration. This method allows user to exclude certain types of edges together with the nodes that are only reachable through such edges, such as exception edges.

The generated graph is not cached.

Parameters:
    

**exception_edges** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Should exception edges and the nodes that are only reachable through exception edges be kept.

Returns:
    

A local transition graph with a special configuration.

Return type:
    

networkx.DiGraph

subgraph(_ins_addrs_)¶
    

Generate a sub control flow graph of instruction addresses based on self.graph

Parameters:
    

**ins_addrs** (_iterable_) – A collection of instruction addresses that should be included in the subgraph.

Return networkx.DiGraph:
    

A subgraph.

instruction_size(_insn_addr_)¶
    

Get the size of the instruction specified by insn_addr.

Parameters:
    

**insn_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the instruction

Return int:
    

Size of the instruction in bytes, or None if the instruction is not found.

addr_to_instruction_addr(_addr_)¶
    

Obtain the address of the instruction that covers @addr.

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – An address.

Returns:
    

Address of the instruction that covers @addr, or None if this addr is not covered by any instruction of this function.

Return type:
    

[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") or None

dbg_print()¶
    

Returns a representation of the list of basic blocks in this function.

dbg_draw(_filename_)¶
    

Draw the graph and save it to a PNG file.

_property _arguments¶
    

_property _has_return¶
    

_property _callable¶
    

normalize()¶
    

Make sure all basic blocks in the transition graph of this function do not overlap. You will end up with a CFG that IDA Pro generates.

This method does not touch the CFG result. You may call CFG{Emulated, Fast}.normalize() for that matter.

Returns:
    

None

find_declaration(_ignore_binary_name =False_, _binary_name_hint =None_)¶
    

Find the most likely function declaration from the embedded collection of prototypes, set it to self.prototype, and update self.calling_convention with the declaration.

Parameters:
    

  * **ignore_binary_name** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Do not rely on the executable or library where the function belongs to determine its source library. This is useful when working on statically linked binaries (because all functions will belong to the main executable). We will search for all libraries in angr to find the first declaration match.

  * **binary_name_hint** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]) – Substring of the library name where this function might be originally coming from. Useful for FLIRT-identified functions in statically linked binaries.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

True if a declaration is found and self.prototype and self.calling_convention are updated. False if we fail to find a matching function declaration, in which case self.prototype or self.calling_convention will be kept untouched.

is_rust_function()¶
    

_property _demangled_name¶
    

_property _short_name¶
    

get_unambiguous_name(_display_name =None_)¶
    

Get a disambiguated function name.

Parameters:
    

**display_name** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]) – Name to display, otherwise the function name.

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

Returns:
    

The function name in the form: ::<name> when the function binary is the main object. ::<obj>::<name> when the function binary is not the main object. ::<addr>::<name> when the function binary is an unnamed non-main object, or when multiple functions with

> the same name are defined in the function binary.

apply_definition(_definition_ , _calling_convention =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **definition** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **calling_convention** (_SimCC_ _|_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__SimCC_ _]__|__None_)

functions_reachable()¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Function`]

Returns:
    

The set of all functions that can be reached from the function represented by self.

copy()¶
    

pp(_** kwargs_)¶
    

Pretty-print the function disassembly.

_class _angr.knowledge_plugins.FunctionManager(_kb_)¶
    

Bases: `KnowledgeBasePlugin`, [`Mapping`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Mapping "\(in Python v3.13\)")

This is a function boundaries management tool. It takes in intermediate results during CFG generation, and manages a function map of the binary.

__init__(_kb_)¶
    

copy()¶
    

clear()¶
    

is_plt_cached(_addr_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_binary_name_cached(_addr_)¶
    

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_by_addr(_addr_)¶
    

Return type:
    

`Function`

get_by_name(_name_ , _check_previous_names =False_)¶
    

Return type:
    

[`Generator`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Generator "\(in Python v3.13\)")[`Function`]

Parameters:
    

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **check_previous_names** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

contains_addr(_addr_)¶
    

Decide if an address is handled by the function manager.

Note: this function is non-conformant with python programming idioms, but its needed for performance reasons.

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function.

ceiling_func(_addr_)¶
    

Return the function who has the least address that is greater than or equal to addr.

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address to query.

Returns:
    

A Function instance, or None if there is no other function after addr.

Return type:
    

Function or None

floor_func(_addr_)¶
    

Return the function who has the greatest address that is less than or equal to addr.

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address to query.

Returns:
    

A Function instance, or None if there is no other function before addr.

Return type:
    

Function or None

query(_query_ , _check_previous_names =False_)¶
    

Query for a function using selectors to disambiguate. Supported variations: :rtype: `Function` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

> ::<name> Function <name> in the main object ::<addr>::<name> Function <name> at <addr> ::<obj>::<name> Function <name> in <obj>

Parameters:
    

  * **query** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **check_previous_names** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Return type:
    

_Function_ | None

function(_addr =None_, _name =None_, _check_previous_names =False_, _create =False_, _syscall =False_, _plt =None_)¶
    

Get a function object from the function manager.

Pass either addr or name with the appropriate values.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function.

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of the function.

  * **create** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether to create the function or not if the function does not exist.

  * **syscall** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True to create the function as a syscall, False otherwise.

  * **plt** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _or_ _None_) – True to find the PLT stub, False to find a non-PLT stub, None to disable this restriction.

Returns:
    

The Function instance, or None if the function is not found and create is False.

Return type:
    

Function or None

dbg_draw(_prefix ='dbg_function_'_)¶
    

rebuild_callgraph()¶
    

_class _angr.knowledge_plugins.IndirectJumps(_kb_)¶
    

Bases: `KnowledgeBasePlugin`, [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")

This plugin tracks the targets of indirect jumps

__init__(_kb_)¶
    

copy() → a shallow copy of D¶
    

update_resolved_addrs(_indirect_address_ , _resolved_addresses_)¶
    

Parameters:
    

  * **indirect_address** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **resolved_addresses** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]_)

_class _angr.knowledge_plugins.KeyDefinitionManager(_kb_)¶
    

Bases: `KnowledgeBasePlugin`

KeyDefinitionManager manages and caches reaching definition models for each function.

For each function, by default we cache the entire reaching definitions model with observed results at the following locations: \- Before each call instruction: (‘insn’, address of the call instruction, OP_BEFORE) \- After returning from each call: (‘node’, address of the block that ends with a call, OP_AFTER)

Parameters:
    

**kb** (_KnowledgeBase_)

__init__(_kb_)¶
    

Parameters:
    

**kb** (_KnowledgeBase_)

has_model(_func_addr_)¶
    

Parameters:
    

**func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_model(_func_addr_)¶
    

Parameters:
    

**func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

copy()¶
    

Return type:
    

`KeyDefinitionManager`

_class _angr.knowledge_plugins.KnowledgeBasePlugin(_kb_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Parameters:
    

**kb** (_KnowledgeBase_)

__init__(_kb_)¶
    

Parameters:
    

**kb** (_KnowledgeBase_)

copy()¶
    

_static _register_default(_name_ , _cls_)¶
    

_class _angr.knowledge_plugins.Labels(_kb_)¶
    

Bases: `KnowledgeBasePlugin`

__init__(_kb_)¶
    

items()¶
    

get(_addr_)¶
    

Get a label as string for a given address Same as .labels[x]

lookup(_name_)¶
    

Returns an address to a given label To show all available labels, iterate over .labels or list(b.kb.labels)

copy()¶
    

get_unique_label(_label_)¶
    

Get a unique label name from the given label name.

Parameters:
    

**label** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The desired label name.

Returns:
    

A unique label name.

_class _angr.knowledge_plugins.Obfuscations(_kb_)¶
    

Bases: `KnowledgeBasePlugin`

Store discovered information and artifacts about (string) obfuscation techniques in the project.

__init__(_kb_)¶
    

copy()¶
    

_class _angr.knowledge_plugins.PatchManager(_kb_)¶
    

Bases: `KnowledgeBasePlugin`

A placeholder-style implementation for a binary patch manager. This class should be significantly changed in the future when all data about loaded binary objects are loaded into angr knowledge base from CLE. As of now, it only stores byte-level replacements.

Patches should not overlap, but it’s user’s responsibility to check for and avoid overlapping patches.

__init__(_kb_)¶
    

add_patch(_addr_ , _new_bytes_ , _comment =None_)¶
    

Parameters:
    

**comment** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

add_patch_obj(_patch_)¶
    

Parameters:
    

**patch** (_Patch_)

remove_patch(_addr_)¶
    

patch_addrs()¶
    

get_patch(_addr_)¶
    

Get patch at the given address.

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address of the patch.

Returns:
    

The patch if there is one starting at the address, or None if there isn’t any.

Return type:
    

Patch or None

get_all_patches(_addr_ , _size_)¶
    

Retrieve all patches that cover a region specified by [addr, addr+size).

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address of the beginning of the region.

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Size of the region.

Returns:
    

A list of patches.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

keys()¶
    

items()¶
    

values()¶
    

copy()¶
    

_static _overlap(_a0_ , _a1_ , _b0_ , _b1_)¶
    

apply_patches_to_binary(_binary_bytes =None_, _patches =None_)¶
    

Return type:
    

[`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)")

Parameters:
    

  * **binary_bytes** ([_bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") _|__None_)

  * **patches** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__Patch_ _]__|__None_)

apply_patches_to_state(_state_)¶
    

_property _patched_entry_state¶
    

_class _angr.knowledge_plugins.PropagationManager(_kb_)¶
    

Bases: `KnowledgeBasePlugin`

Manages the results of Propagator, including intermediate results for unfinished Propagation runs.

__init__(_kb_)¶
    

exists(_prop_key_)¶
    

Internal function to check if a func, specified as a CodeLocation exists in our known propagations

Parameters:
    

**prop_key** ([`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")) – A key of the propagation result.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

Whether such a key exists or not.

update(_prop_key_ , _model_)¶
    

Add the replacements to known propagations

Parameters:
    

  * **prop_key** ([`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")) – A key of the propagation result.

  * **model** (`PropagationModel`) – The propagation result to store

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

get(_prop_key_ , _default =None_)¶
    

Gets the replacements for a specified function location. If the replacement does not exist in the known propagations, it returns None.

Parameters:
    

  * **prop_key** – A key of the propagation result.

  * **default** – The default value to return if the prop_key does not exist in the cache.

Return type:
    

`PropagationModel`

Returns:
    

Dict or None

copy()¶
    

discard_by_prefix(_prefix_)¶
    

Parameters:
    

**prefix** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.knowledge_plugins.StructuredCodeManager(_kb_)¶
    

Bases: `KnowledgeBasePlugin`

A knowledge base plugin to store structured code generator results.

__init__(_kb_)¶
    

discard(_key_)¶
    

available_flavors(_item_)¶
    

copy()¶
    

_class _angr.knowledge_plugins.TypesStore(_kb_)¶
    

Bases: `KnowledgeBasePlugin`, [`UserDict`](https://docs.python.org/3/library/collections.html#collections.UserDict "\(in Python v3.13\)")

A kb plugin that stores a mapping from name to TypeRef. It will return types from angr.sim_type.ALL_TYPES as a default.

__init__(_kb_)¶
    

copy()¶
    

iter_own()¶
    

Iterate over all the names which are stored in this object - i.e. `values()` without `ALL_TYPES`

rename(_old_ , _new_)¶
    

unique_type_name()¶
    

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

_class _angr.knowledge_plugins.VariableManager(_kb_)¶
    

Bases: `KnowledgeBasePlugin`

Manage variables.

__init__(_kb_)¶
    

has_function_manager(_key_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**key** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_function_manager(_func_addr_)¶
    

Return type:
    

`VariableManagerInternal`

initialize_variable_names()¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

get_variable_accesses(_variable_ , _same_name =False_)¶
    

Get a list of all references to the given variable.

Parameters:
    

  * **variable** (`SimVariable`) – The variable.

  * **same_name** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether to include all variables with the same variable name, or just based on the variable identifier.

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`VariableAccess`]

Returns:
    

All references to the variable.

copy()¶
    

_static _convert_variable_list(_vlist_ , _manager_)¶
    

Parameters:
    

  * **vlist** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_Variable_](https://docs.angr.io/projects/cle/en/latest/api/backends/elf.html#cle.backends.elf.variable.Variable "\(in cle\)") _]_)

  * **manager** (_VariableManagerInternal_)

load_from_dwarf(_cu_list =None_)¶
    

Parameters:
    

**cu_list** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_CompilationUnit_](https://docs.angr.io/projects/cle/en/latest/api/backends/elf.html#cle.backends.elf.compilation_unit.CompilationUnit "\(in cle\)") _]__|__None_)

_class _angr.knowledge_plugins.XRefManager(_kb_)¶
    

Bases: `KnowledgeBasePlugin`, `Serializable`

__init__(_kb_)¶
    

copy()¶
    

clear()¶
    

add_xref(_xref_)¶
    

add_xrefs(_xrefs_)¶
    

get_xrefs_by_ins_addr(_ins_addr_)¶
    

get_xrefs_by_dst(_dst_)¶
    

get_xrefs_by_dst_region(_start_ , _end_)¶
    

Get a set of XRef objects that point to a given address region bounded by start and end. Will only return absolute xrefs, not relative ones (like SP offsets)

get_xrefs_by_ins_addr_region(_start_ , _end_)¶
    

Get a set of XRef objects that originate at a given address region bounded by start and end. Useful for finding references from a basic block or function.

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`XRef`]

serialize_to_cmessage()¶
    

Serialize the class object and returns a protobuf cmessage object.

Returns:
    

A protobuf cmessage object.

Return type:
    

protobuf.cmessage

_classmethod _parse_from_cmessage(_cmsg_ , _cfg_model =None_, _kb =None_, _** kwargs_)¶
    

Parse a protobuf cmessage and create a class object.

Parameters:
    

**cmsg** – The probobuf cmessage object.

Returns:
    

A unserialized class object.

Return type:
    

cls

_class _angr.knowledge_plugins.patches.Patch(_addr_ , _new_bytes_ , _comment =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Parameters:
    

**comment** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

__init__(_addr_ , _new_bytes_ , _comment =None_)¶
    

Parameters:
    

**comment** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

_class _angr.knowledge_plugins.patches.PatchManager(_kb_)¶
    

Bases: `KnowledgeBasePlugin`

A placeholder-style implementation for a binary patch manager. This class should be significantly changed in the future when all data about loaded binary objects are loaded into angr knowledge base from CLE. As of now, it only stores byte-level replacements.

Patches should not overlap, but it’s user’s responsibility to check for and avoid overlapping patches.

__init__(_kb_)¶
    

add_patch(_addr_ , _new_bytes_ , _comment =None_)¶
    

Parameters:
    

**comment** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

add_patch_obj(_patch_)¶
    

Parameters:
    

**patch** (_Patch_)

remove_patch(_addr_)¶
    

patch_addrs()¶
    

get_patch(_addr_)¶
    

Get patch at the given address.

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address of the patch.

Returns:
    

The patch if there is one starting at the address, or None if there isn’t any.

Return type:
    

Patch or None

get_all_patches(_addr_ , _size_)¶
    

Retrieve all patches that cover a region specified by [addr, addr+size).

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address of the beginning of the region.

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Size of the region.

Returns:
    

A list of patches.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

keys()¶
    

items()¶
    

values()¶
    

copy()¶
    

_static _overlap(_a0_ , _a1_ , _b0_ , _b1_)¶
    

apply_patches_to_binary(_binary_bytes =None_, _patches =None_)¶
    

Return type:
    

[`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)")

Parameters:
    

  * **binary_bytes** ([_bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") _|__None_)

  * **patches** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__Patch_ _]__|__None_)

apply_patches_to_state(_state_)¶
    

_property _patched_entry_state¶
    

_class _angr.knowledge_plugins.plugin.KnowledgeBasePlugin(_kb_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Parameters:
    

**kb** (_KnowledgeBase_)

__init__(_kb_)¶
    

Parameters:
    

**kb** (_KnowledgeBase_)

copy()¶
    

_static _register_default(_name_ , _cls_)¶
    

_class _angr.knowledge_plugins.callsite_prototypes.CallsitePrototypes(_kb_)¶
    

Bases: `KnowledgeBasePlugin`

CallsitePrototypes manages callee prototypes at call sites.

__init__(_kb_)¶
    

set_prototype(_callsite_block_addr_ , _cc_ , _prototype_ , _manual =False_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **callsite_block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **cc** (_SimCC_)

  * **prototype** (_SimTypeFunction_)

  * **manual** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

get_cc(_callsite_block_addr_)¶
    

Return type:
    

`SimCC` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**callsite_block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_prototype(_callsite_block_addr_)¶
    

Return type:
    

`SimTypeFunction` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**callsite_block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_prototype_type(_callsite_block_addr_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**callsite_block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

has_prototype(_callsite_block_addr_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**callsite_block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

copy()¶
    

_class _angr.knowledge_plugins.cfg.CFGENode(_addr_ , _size_ , _cfg_ , _simprocedure_name =None_, _no_ret =False_, _function_address =None_, _block_id =None_, _irsb =None_, _instruction_addrs =None_, _thumb =False_, _byte_string =None_, _is_syscall =None_, _name =None_, _input_state =None_, _final_states =None_, _syscall_name =None_, _looping_times =0_, _depth =None_, _callstack_key =None_, _creation_failure_info =None_)¶
    

Bases: `CFGNode`

The CFGNode that is used in CFGEmulated.

__init__(_addr_ , _size_ , _cfg_ , _simprocedure_name =None_, _no_ret =False_, _function_address =None_, _block_id =None_, _irsb =None_, _instruction_addrs =None_, _thumb =False_, _byte_string =None_, _is_syscall =None_, _name =None_, _input_state =None_, _final_states =None_, _syscall_name =None_, _looping_times =0_, _depth =None_, _callstack_key =None_, _creation_failure_info =None_)¶
    

Note: simprocedure_name is not used to recreate the SimProcedure object. It’s only there for better __repr__.

input_state¶
    

looping_times¶
    

depth¶
    

creation_failure_info¶
    

final_states¶
    

return_target¶
    

syscall¶
    

_property _callstack_key¶
    

_property _creation_failed¶
    

downsize()¶
    

Drop saved states.

copy()¶
    

_class _angr.knowledge_plugins.cfg.CFGManager(_kb_)¶
    

Bases: `KnowledgeBasePlugin`

This is the CFG manager, it manages CFGs

__init__(_kb_)¶
    

new_model(_prefix_)¶
    

copy()¶
    

get_most_accurate()¶
    

Return type:
    

`CFGModel` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

The most accurate CFG present in the CFGManager, or None if it does not hold any.

_class _angr.knowledge_plugins.cfg.CFGModel(_ident_ , _cfg_manager =None_, _is_arm =False_)¶
    

Bases: `Serializable`

This class describes a Control Flow Graph for a specific range of code.

__init__(_ident_ , _cfg_manager =None_, _is_arm =False_)¶
    

ident¶
    

is_arm¶
    

graph¶
    

jump_tables _: [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), `IndirectJump`]_¶
    

memory_data _: [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), `MemoryData`]_¶
    

insn_addr_to_memory_data _: [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), `MemoryData`]_¶
    

normalized¶
    

edges_to_repair¶
    

_property _project¶
    

serialize_to_cmessage()¶
    

Serialize the class object and returns a protobuf cmessage object.

Returns:
    

A protobuf cmessage object.

Return type:
    

protobuf.cmessage

_classmethod _parse_from_cmessage(_cmsg_ , _cfg_manager =None_, _loader =None_)¶
    

Parse a protobuf cmessage and create a class object.

Parameters:
    

**cmsg** – The probobuf cmessage object.

Returns:
    

A unserialized class object.

Return type:
    

cls

copy()¶
    

add_node(_block_id_ , _node_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **block_id** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **node** (_CFGNode_)

remove_node(_block_id_ , _node_)¶
    

Remove the given CFGNode instance. Note that this method _does not_ remove the node from the graph.

Parameters:
    

  * **block_id** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The Unique ID of the CFGNode.

  * **node** (`CFGNode`) – The CFGNode instance to remove.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

None

get_node(_block_id_)¶
    

Get a single node from node key.

Parameters:
    

**block_id** (_BlockID_) – Block ID of the node.

Returns:
    

The CFGNode

Return type:
    

CFGNode

get_any_node(_addr_ , _is_syscall =None_, _anyaddr =False_, _force_fastpath =False_)¶
    

Get an arbitrary CFGNode (without considering their contexts) from our graph.

Parameters:
    

  * **addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the beginning of the basic block. Set anyaddr to True to support arbitrary address.

  * **is_syscall** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")]) – Whether you want to get the syscall node or any other node. This is due to the fact that syscall SimProcedures have the same address as the target it returns to. None means get either, True means get a syscall node, False means get something that isn’t a syscall node.

  * **anyaddr** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If anyaddr is True, then addr doesn’t have to be the beginning address of a basic block. By default the entire graph.nodes() will be iterated, and the first node containing the specific address is returned, which can be slow.

  * **force_fastpath** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If force_fastpath is True, it will only perform a dict lookup in the _nodes_by_addr dict.

Return type:
    

`CFGNode` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

A CFGNode if there is any that satisfies given conditions, or None otherwise

get_all_nodes(_addr_ , _is_syscall =None_, _anyaddr =False_)¶
    

Get all CFGNodes whose address is the specified one.

Parameters:
    

  * **addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the node

  * **is_syscall** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")]) – True returns the syscall node, False returns the normal CFGNode, None returns both

  * **anyaddr** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`CFGNode`]

Returns:
    

all CFGNodes

get_all_nodes_intersecting_region(_addr_ , _size =1_)¶
    

Get all CFGNodes that intersect the given region.

Parameters:
    

  * **addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Minimum address of target region.

  * **size** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Size of region, in bytes.

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`CFGNode`]

nodes()¶
    

An iterator of all nodes in the graph.

Returns:
    

The iterator.

Return type:
    

iterator

get_predecessors(_cfgnode_ , _excluding_fakeret =True_, _jumpkind =None_)¶
    

Get predecessors of a node in the control flow graph.

Parameters:
    

  * **cfgnode** (`CFGNode`) – The node.

  * **excluding_fakeret** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True if you want to exclude all predecessors that is connected to the node with a fakeret edge.

  * **jumpkind** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]) – Only return predecessors with the specified jumpkind. This argument will be ignored if set to None.

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`CFGNode`]

Returns:
    

A list of predecessors

get_successors(_node_ , _excluding_fakeret =True_, _jumpkind =None_)¶
    

Get successors of a node in the control flow graph.

Parameters:
    

  * **node** (_CFGNode_) – The node.

  * **excluding_fakeret** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True if you want to exclude all successors that is connected to the node with a fakeret edge.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_) – Only return successors with the specified jumpkind. This argument will be ignored if set to None.

  * **jumpkind**

Returns:
    

A list of successors

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

get_successors_and_jumpkinds(_node_ , _excluding_fakeret =True_)¶
    

Get a list of tuples where the first element is the successor of the CFG node and the second element is the jumpkind of the successor.

Parameters:
    

  * **node** (_CFGNode_) – The node.

  * **excluding_fakeret** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True if you want to exclude all successors that are fall-through successors.

Returns:
    

A list of successors and their corresponding jumpkinds.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

get_successors_and_jumpkind(_node_ , _excluding_fakeret =True_)¶
    

Get a list of tuples where the first element is the successor of the CFG node and the second element is the jumpkind of the successor.

Parameters:
    

  * **node** (_CFGNode_) – The node.

  * **excluding_fakeret** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True if you want to exclude all successors that are fall-through successors.

Returns:
    

A list of successors and their corresponding jumpkinds.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

get_predecessors_and_jumpkinds(_node_ , _excluding_fakeret =True_)¶
    

Get a list of tuples where the first element is the predecessor of the CFG node and the second element is the jumpkind of the predecessor.

Parameters:
    

  * **node** (`CFGNode`) – The node.

  * **excluding_fakeret** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True if you want to exclude all predecessors that are fall-through predecessors.

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`CFGNode`, [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]]

Returns:
    

A list of predecessors and their corresponding jumpkinds.

get_predecessors_and_jumpkind(_node_ , _excluding_fakeret =True_)¶
    

Get a list of tuples where the first element is the predecessor of the CFG node and the second element is the jumpkind of the predecessor.

Parameters:
    

  * **node** (`CFGNode`) – The node.

  * **excluding_fakeret** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True if you want to exclude all predecessors that are fall-through predecessors.

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`CFGNode`, [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]]

Returns:
    

A list of predecessors and their corresponding jumpkinds.

get_all_predecessors(_cfgnode_ , _depth_limit =None_)¶
    

Get all predecessors of a specific node on the control flow graph.

Parameters:
    

  * **cfgnode** (_CFGNode_) – The CFGNode object

  * **depth_limit** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Optional depth limit for the depth-first search

Returns:
    

A list of predecessors in the CFG

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

get_all_successors(_cfgnode_ , _depth_limit =None_)¶
    

Get all successors of a specific node on the control flow graph.

Parameters:
    

  * **cfgnode** (_CFGNode_) – The CFGNode object

  * **depth_limit** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Optional depth limit for the depth-first search

Returns:
    

A list of successors in the CFG

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

get_branching_nodes()¶
    

Returns all nodes that has an out degree >= 2

get_exit_stmt_idx(_src_block_ , _dst_block_)¶
    

Get the corresponding exit statement ID for control flow to reach destination block from source block. The exit statement ID was put on the edge when creating the CFG. Note that there must be a direct edge between the two blocks, otherwise an exception will be raised.

Returns:
    

The exit statement ID

add_memory_data(_data_addr_ , _data_type_ , _data_size =None_)¶
    

Add a MemoryData entry to self.memory_data.

Parameters:
    

  * **data_addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the data

  * **data_type** (`MemoryDataSort` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")) – Type of the memory data

  * **data_size** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – Size of the memory data, or None if unknown for now.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

True if a new memory data entry is added, False otherwise.

tidy_data_references(_memory_data_addrs =None_, _exec_mem_regions =None_, _xrefs =None_, _seg_list =None_, _data_type_guessing_handlers =None_)¶
    

Go through all data references (or the ones as specified by memory_data_addrs) and determine their sizes and types if possible.

Parameters:
    

  * **memory_data_addrs** (list[int] | None) – A list of addresses of memory data, or None if tidying all known memory data entries.

  * **exec_mem_regions** (list[tuple[int, int]] | None) – A list of start and end addresses of executable memory regions.

  * **seg_list** (SegmentList | None) – The segment list that CFGFast uses during CFG recovery.

  * **data_type_guessing_handlers** (list[Callable] | None) – A list of Python functions that will guess data types. They will be called in sequence to determine data types for memory data whose type is unknown.

  * **xrefs** (_XRefManager_ _|__None_)

Return type:
    

bool

Returns:
    

True if new data entries are found, False otherwise.

remove_node_and_graph_node(_node_)¶
    

Like remove_node, but also removes node from the graph.

Parameters:
    

**node** (`CFGNode`) – The node to remove.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

get_intersecting_functions(_addr_ , _size =1_, _kb =None_)¶
    

Find all functions with nodes intersecting [addr, addr + size).

Parameters:
    

  * **addr** (int) – Minimum address of target region.

  * **size** (int) – Size of region, in bytes.

  * **kb** (KnowledgeBase | None) – Knowledge base to search for functions in.

Return type:
    

set[Function]

find_function_for_reflow_into_addr(_addr_ , _kb =None_)¶
    

Look for a function that flows into a new node at addr.

Parameters:
    

  * **addr** (int) – Address of new block.

  * **kb** (KnowledgeBase | None) – Knowledge base to search for functions in.

Return type:
    

Function | None

clear_region_for_reflow(_addr_ , _size =1_, _kb =None_)¶
    

Remove nodes in the graph intersecting region [addr, addr + size).

Any functions that intersect the range, and their associated nodes in the CFG, will also be removed from the knowledge base for analysis.

Parameters:
    

  * **addr** (int) – Minimum address of target region.

  * **size** (int) – Size of the region, in bytes.

  * **kb** (KnowledgeBase | None) – Knowledge base to search for functions in.

Return type:
    

None

_class _angr.knowledge_plugins.cfg.CFGNode(_addr_ , _size_ , _cfg_ , _simprocedure_name =None_, _no_ret =False_, _function_address =None_, _block_id =None_, _irsb =None_, _soot_block =None_, _instruction_addrs =None_, _thumb =False_, _byte_string =None_, _is_syscall =None_, _name =None_)¶
    

Bases: `Serializable`

This class stands for each single node in CFG.

__init__(_addr_ , _size_ , _cfg_ , _simprocedure_name =None_, _no_ret =False_, _function_address =None_, _block_id =None_, _irsb =None_, _soot_block =None_, _instruction_addrs =None_, _thumb =False_, _byte_string =None_, _is_syscall =None_, _name =None_)¶
    

Note: simprocedure_name is not used to recreate the SimProcedure object. It’s only there for better __repr__.

addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`SootAddressDescriptor`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_soot.SootAddressDescriptor "\(in archinfo\)")_¶
    

size¶
    

simprocedure_name¶
    

no_ret¶
    

function_address¶
    

thumb¶
    

byte_string _: [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

is_syscall¶
    

instruction_addrs¶
    

irsb¶
    

soot_block¶
    

has_return¶
    

block_id _: `BlockID` | [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_property _name¶
    

_property _successors¶
    

_property _predecessors¶
    

successors_and_jumpkinds(_excluding_fakeret =True_)¶
    

predecessors_and_jumpkinds(_excluding_fakeret =True_)¶
    

get_data_references(_kb =None_)¶
    

Get the known data references for this CFGNode via the knowledge base.

Parameters:
    

**kb** – Which knowledge base to use; uses the global KB by default if none is provided

Returns:
    

Generator yielding xrefs to this CFGNode’s block.

Return type:
    

iter

_property _accessed_data_references¶
    

Property providing a view of all the known data references for this CFGNode via the global knowledge base

Returns:
    

Generator yielding xrefs to this CFGNode’s block.

Return type:
    

iter

_property _is_simprocedure¶
    

_property _callstack_key¶
    

serialize_to_cmessage()¶
    

Serialize the class object and returns a protobuf cmessage object.

Returns:
    

A protobuf cmessage object.

Return type:
    

protobuf.cmessage

_classmethod _parse_from_cmessage(_cmsg_ , _cfg =None_)¶
    

Parse a protobuf cmessage and create a class object.

Parameters:
    

**cmsg** – The probobuf cmessage object.

Returns:
    

A unserialized class object.

Return type:
    

cls

copy()¶
    

merge(_other_)¶
    

Merges this node with the other, returning a new node that spans the both.

to_codenode()¶
    

_property _block _: Block | SootBlock | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

syscall_name¶
    

_class _angr.knowledge_plugins.cfg.IndirectJump(_addr_ , _ins_addr_ , _func_addr_ , _jumpkind_ , _stmt_idx_ , _resolved_targets =None_, _jumptable =False_, _jumptable_addr =None_, _jumptable_size =None_, _jumptable_entry_size =None_, _jumptable_entries =None_, _type_ =255_)¶
    

Bases: `Serializable`

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **resolved_targets** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **jumptable** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **jumptable_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **jumptable_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **jumptable_entry_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **jumptable_entries** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **type_** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_addr_ , _ins_addr_ , _func_addr_ , _jumpkind_ , _stmt_idx_ , _resolved_targets =None_, _jumptable =False_, _jumptable_addr =None_, _jumptable_size =None_, _jumptable_entry_size =None_, _jumptable_entries =None_, _type_ =255_)¶
    

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **resolved_targets** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **jumptable** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **jumptable_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **jumptable_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **jumptable_entry_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **jumptable_entries** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **type_** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

addr¶
    

ins_addr¶
    

func_addr¶
    

jumpkind¶
    

stmt_idx¶
    

resolved_targets¶
    

jumptable¶
    

jumptable_addr¶
    

jumptable_size¶
    

jumptable_entry_size¶
    

jumptable_entries¶
    

type¶
    

_class _angr.knowledge_plugins.cfg.IndirectJumpType¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Jumptable_AddressLoadedFromMemory _ = 0_¶
    

Jumptable_AddressComputed _ = 1_¶
    

Vtable _ = 3_¶
    

Unknown _ = 255_¶
    

_class _angr.knowledge_plugins.cfg.MemoryData(_address_ , _size_ , _sort_ , _pointer_addr =None_, _max_size =None_, _reference_size =None_)¶
    

Bases: `Serializable`

MemoryData describes the syntactic content of a single address of memory.

reference_size reflects the size of content. It can be different from size, which is the actual size of the memory data item in memory. The intended way to get the actual content in memory is self.content[:self.size].

Parameters:
    

  * **address** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **sort** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **pointer_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **max_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **reference_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_address_ , _size_ , _sort_ , _pointer_addr =None_, _max_size =None_, _reference_size =None_)¶
    

Parameters:
    

  * **address** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **sort** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **pointer_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **max_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **reference_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

size _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

reference_size _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

sort _: [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

max_size _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

pointer_addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

content _: [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

_property _address¶
    

copy()¶
    

Make a copy of the MemoryData.

Returns:
    

A copy of the MemoryData instance.

Return type:
    

MemoryData

fill_content(_loader_)¶
    

Load data to fill self.content.

Parameters:
    

**loader** – The project loader.

Returns:
    

None

serialize_to_cmessage()¶
    

Serialize the class object and returns a protobuf cmessage object.

Returns:
    

A protobuf cmessage object.

Return type:
    

protobuf.cmessage

_classmethod _parse_from_cmessage(_cmsg_ , _** kwargs_)¶
    

Parse a protobuf cmessage and create a class object.

Parameters:
    

**cmsg** – The probobuf cmessage object.

Returns:
    

A unserialized class object.

Return type:
    

cls

_class _angr.knowledge_plugins.cfg.MemoryDataSort¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Unspecified _ = None_¶
    

Unknown _ = 'unknown'_¶
    

Integer _ = 'integer'_¶
    

PointerArray _ = 'pointer-array'_¶
    

String _ = 'string'_¶
    

UnicodeString _ = 'unicode'_¶
    

SegmentBoundary _ = 'segment-boundary'_¶
    

CodeReference _ = 'code reference'_¶
    

GOTPLTEntry _ = 'GOT PLT Entry'_¶
    

ELFHeader _ = 'elf-header'_¶
    

FloatingPoint _ = 'fp'_¶
    

Alignment _ = 'alignment'_¶
    

_class _angr.knowledge_plugins.cfg.cfg_model.CFGModel(_ident_ , _cfg_manager =None_, _is_arm =False_)¶
    

Bases: `Serializable`

This class describes a Control Flow Graph for a specific range of code.

__init__(_ident_ , _cfg_manager =None_, _is_arm =False_)¶
    

ident¶
    

is_arm¶
    

graph¶
    

jump_tables _: [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), `IndirectJump`]_¶
    

memory_data _: [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), `MemoryData`]_¶
    

insn_addr_to_memory_data _: [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), `MemoryData`]_¶
    

normalized¶
    

edges_to_repair¶
    

_property _project¶
    

serialize_to_cmessage()¶
    

Serialize the class object and returns a protobuf cmessage object.

Returns:
    

A protobuf cmessage object.

Return type:
    

protobuf.cmessage

_classmethod _parse_from_cmessage(_cmsg_ , _cfg_manager =None_, _loader =None_)¶
    

Parse a protobuf cmessage and create a class object.

Parameters:
    

**cmsg** – The probobuf cmessage object.

Returns:
    

A unserialized class object.

Return type:
    

cls

copy()¶
    

add_node(_block_id_ , _node_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **block_id** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **node** (_CFGNode_)

remove_node(_block_id_ , _node_)¶
    

Remove the given CFGNode instance. Note that this method _does not_ remove the node from the graph.

Parameters:
    

  * **block_id** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The Unique ID of the CFGNode.

  * **node** (`CFGNode`) – The CFGNode instance to remove.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

None

get_node(_block_id_)¶
    

Get a single node from node key.

Parameters:
    

**block_id** (_BlockID_) – Block ID of the node.

Returns:
    

The CFGNode

Return type:
    

CFGNode

get_any_node(_addr_ , _is_syscall =None_, _anyaddr =False_, _force_fastpath =False_)¶
    

Get an arbitrary CFGNode (without considering their contexts) from our graph.

Parameters:
    

  * **addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the beginning of the basic block. Set anyaddr to True to support arbitrary address.

  * **is_syscall** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")]) – Whether you want to get the syscall node or any other node. This is due to the fact that syscall SimProcedures have the same address as the target it returns to. None means get either, True means get a syscall node, False means get something that isn’t a syscall node.

  * **anyaddr** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If anyaddr is True, then addr doesn’t have to be the beginning address of a basic block. By default the entire graph.nodes() will be iterated, and the first node containing the specific address is returned, which can be slow.

  * **force_fastpath** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If force_fastpath is True, it will only perform a dict lookup in the _nodes_by_addr dict.

Return type:
    

`CFGNode` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

A CFGNode if there is any that satisfies given conditions, or None otherwise

get_all_nodes(_addr_ , _is_syscall =None_, _anyaddr =False_)¶
    

Get all CFGNodes whose address is the specified one.

Parameters:
    

  * **addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the node

  * **is_syscall** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")]) – True returns the syscall node, False returns the normal CFGNode, None returns both

  * **anyaddr** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`CFGNode`]

Returns:
    

all CFGNodes

get_all_nodes_intersecting_region(_addr_ , _size =1_)¶
    

Get all CFGNodes that intersect the given region.

Parameters:
    

  * **addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Minimum address of target region.

  * **size** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Size of region, in bytes.

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`CFGNode`]

nodes()¶
    

An iterator of all nodes in the graph.

Returns:
    

The iterator.

Return type:
    

iterator

get_predecessors(_cfgnode_ , _excluding_fakeret =True_, _jumpkind =None_)¶
    

Get predecessors of a node in the control flow graph.

Parameters:
    

  * **cfgnode** (`CFGNode`) – The node.

  * **excluding_fakeret** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True if you want to exclude all predecessors that is connected to the node with a fakeret edge.

  * **jumpkind** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]) – Only return predecessors with the specified jumpkind. This argument will be ignored if set to None.

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`CFGNode`]

Returns:
    

A list of predecessors

get_successors(_node_ , _excluding_fakeret =True_, _jumpkind =None_)¶
    

Get successors of a node in the control flow graph.

Parameters:
    

  * **node** (_CFGNode_) – The node.

  * **excluding_fakeret** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True if you want to exclude all successors that is connected to the node with a fakeret edge.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_) – Only return successors with the specified jumpkind. This argument will be ignored if set to None.

  * **jumpkind**

Returns:
    

A list of successors

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

get_successors_and_jumpkinds(_node_ , _excluding_fakeret =True_)¶
    

Get a list of tuples where the first element is the successor of the CFG node and the second element is the jumpkind of the successor.

Parameters:
    

  * **node** (_CFGNode_) – The node.

  * **excluding_fakeret** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True if you want to exclude all successors that are fall-through successors.

Returns:
    

A list of successors and their corresponding jumpkinds.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

get_successors_and_jumpkind(_node_ , _excluding_fakeret =True_)¶
    

Get a list of tuples where the first element is the successor of the CFG node and the second element is the jumpkind of the successor.

Parameters:
    

  * **node** (_CFGNode_) – The node.

  * **excluding_fakeret** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True if you want to exclude all successors that are fall-through successors.

Returns:
    

A list of successors and their corresponding jumpkinds.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

get_predecessors_and_jumpkinds(_node_ , _excluding_fakeret =True_)¶
    

Get a list of tuples where the first element is the predecessor of the CFG node and the second element is the jumpkind of the predecessor.

Parameters:
    

  * **node** (`CFGNode`) – The node.

  * **excluding_fakeret** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True if you want to exclude all predecessors that are fall-through predecessors.

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`CFGNode`, [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]]

Returns:
    

A list of predecessors and their corresponding jumpkinds.

get_predecessors_and_jumpkind(_node_ , _excluding_fakeret =True_)¶
    

Get a list of tuples where the first element is the predecessor of the CFG node and the second element is the jumpkind of the predecessor.

Parameters:
    

  * **node** (`CFGNode`) – The node.

  * **excluding_fakeret** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True if you want to exclude all predecessors that are fall-through predecessors.

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`CFGNode`, [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]]

Returns:
    

A list of predecessors and their corresponding jumpkinds.

get_all_predecessors(_cfgnode_ , _depth_limit =None_)¶
    

Get all predecessors of a specific node on the control flow graph.

Parameters:
    

  * **cfgnode** (_CFGNode_) – The CFGNode object

  * **depth_limit** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Optional depth limit for the depth-first search

Returns:
    

A list of predecessors in the CFG

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

get_all_successors(_cfgnode_ , _depth_limit =None_)¶
    

Get all successors of a specific node on the control flow graph.

Parameters:
    

  * **cfgnode** (_CFGNode_) – The CFGNode object

  * **depth_limit** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Optional depth limit for the depth-first search

Returns:
    

A list of successors in the CFG

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

get_branching_nodes()¶
    

Returns all nodes that has an out degree >= 2

get_exit_stmt_idx(_src_block_ , _dst_block_)¶
    

Get the corresponding exit statement ID for control flow to reach destination block from source block. The exit statement ID was put on the edge when creating the CFG. Note that there must be a direct edge between the two blocks, otherwise an exception will be raised.

Returns:
    

The exit statement ID

add_memory_data(_data_addr_ , _data_type_ , _data_size =None_)¶
    

Add a MemoryData entry to self.memory_data.

Parameters:
    

  * **data_addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the data

  * **data_type** (`MemoryDataSort` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")) – Type of the memory data

  * **data_size** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – Size of the memory data, or None if unknown for now.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

True if a new memory data entry is added, False otherwise.

tidy_data_references(_memory_data_addrs =None_, _exec_mem_regions =None_, _xrefs =None_, _seg_list =None_, _data_type_guessing_handlers =None_)¶
    

Go through all data references (or the ones as specified by memory_data_addrs) and determine their sizes and types if possible.

Parameters:
    

  * **memory_data_addrs** (list[int] | None) – A list of addresses of memory data, or None if tidying all known memory data entries.

  * **exec_mem_regions** (list[tuple[int, int]] | None) – A list of start and end addresses of executable memory regions.

  * **seg_list** (SegmentList | None) – The segment list that CFGFast uses during CFG recovery.

  * **data_type_guessing_handlers** (list[Callable] | None) – A list of Python functions that will guess data types. They will be called in sequence to determine data types for memory data whose type is unknown.

  * **xrefs** (_XRefManager_ _|__None_)

Return type:
    

bool

Returns:
    

True if new data entries are found, False otherwise.

remove_node_and_graph_node(_node_)¶
    

Like remove_node, but also removes node from the graph.

Parameters:
    

**node** (`CFGNode`) – The node to remove.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

get_intersecting_functions(_addr_ , _size =1_, _kb =None_)¶
    

Find all functions with nodes intersecting [addr, addr + size).

Parameters:
    

  * **addr** (int) – Minimum address of target region.

  * **size** (int) – Size of region, in bytes.

  * **kb** (KnowledgeBase | None) – Knowledge base to search for functions in.

Return type:
    

set[Function]

find_function_for_reflow_into_addr(_addr_ , _kb =None_)¶
    

Look for a function that flows into a new node at addr.

Parameters:
    

  * **addr** (int) – Address of new block.

  * **kb** (KnowledgeBase | None) – Knowledge base to search for functions in.

Return type:
    

Function | None

clear_region_for_reflow(_addr_ , _size =1_, _kb =None_)¶
    

Remove nodes in the graph intersecting region [addr, addr + size).

Any functions that intersect the range, and their associated nodes in the CFG, will also be removed from the knowledge base for analysis.

Parameters:
    

  * **addr** (int) – Minimum address of target region.

  * **size** (int) – Size of the region, in bytes.

  * **kb** (KnowledgeBase | None) – Knowledge base to search for functions in.

Return type:
    

None

_class _angr.knowledge_plugins.cfg.memory_data.MemoryDataSort¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Unspecified _ = None_¶
    

Unknown _ = 'unknown'_¶
    

Integer _ = 'integer'_¶
    

PointerArray _ = 'pointer-array'_¶
    

String _ = 'string'_¶
    

UnicodeString _ = 'unicode'_¶
    

SegmentBoundary _ = 'segment-boundary'_¶
    

CodeReference _ = 'code reference'_¶
    

GOTPLTEntry _ = 'GOT PLT Entry'_¶
    

ELFHeader _ = 'elf-header'_¶
    

FloatingPoint _ = 'fp'_¶
    

Alignment _ = 'alignment'_¶
    

_class _angr.knowledge_plugins.cfg.memory_data.MemoryData(_address_ , _size_ , _sort_ , _pointer_addr =None_, _max_size =None_, _reference_size =None_)¶
    

Bases: `Serializable`

MemoryData describes the syntactic content of a single address of memory.

reference_size reflects the size of content. It can be different from size, which is the actual size of the memory data item in memory. The intended way to get the actual content in memory is self.content[:self.size].

Parameters:
    

  * **address** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **sort** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **pointer_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **max_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **reference_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_address_ , _size_ , _sort_ , _pointer_addr =None_, _max_size =None_, _reference_size =None_)¶
    

Parameters:
    

  * **address** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **sort** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **pointer_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **max_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **reference_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

size _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

reference_size _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

sort _: [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

max_size _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

pointer_addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

content _: [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

_property _address¶
    

copy()¶
    

Make a copy of the MemoryData.

Returns:
    

A copy of the MemoryData instance.

Return type:
    

MemoryData

fill_content(_loader_)¶
    

Load data to fill self.content.

Parameters:
    

**loader** – The project loader.

Returns:
    

None

serialize_to_cmessage()¶
    

Serialize the class object and returns a protobuf cmessage object.

Returns:
    

A protobuf cmessage object.

Return type:
    

protobuf.cmessage

_classmethod _parse_from_cmessage(_cmsg_ , _** kwargs_)¶
    

Parse a protobuf cmessage and create a class object.

Parameters:
    

**cmsg** – The probobuf cmessage object.

Returns:
    

A unserialized class object.

Return type:
    

cls

_class _angr.knowledge_plugins.cfg.cfg_manager.CFGManager(_kb_)¶
    

Bases: `KnowledgeBasePlugin`

This is the CFG manager, it manages CFGs

__init__(_kb_)¶
    

new_model(_prefix_)¶
    

copy()¶
    

get_most_accurate()¶
    

Return type:
    

`CFGModel` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

The most accurate CFG present in the CFGManager, or None if it does not hold any.

_class _angr.knowledge_plugins.cfg.cfg_node.CFGNodeCreationFailure(_exc_info =None_, _to_copy =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

This class contains additional information for whenever creating a CFGNode failed. It includes a full traceback and the exception messages.

__init__(_exc_info =None_, _to_copy =None_)¶
    

short_reason¶
    

long_reason¶
    

traceback¶
    

_class _angr.knowledge_plugins.cfg.cfg_node.CFGNode(_addr_ , _size_ , _cfg_ , _simprocedure_name =None_, _no_ret =False_, _function_address =None_, _block_id =None_, _irsb =None_, _soot_block =None_, _instruction_addrs =None_, _thumb =False_, _byte_string =None_, _is_syscall =None_, _name =None_)¶
    

Bases: `Serializable`

This class stands for each single node in CFG.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_SootAddressDescriptor_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_soot.SootAddressDescriptor "\(in archinfo\)"))

  * **block_id** (_BlockID_ _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **byte_string** ([_bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") _|__None_)

__init__(_addr_ , _size_ , _cfg_ , _simprocedure_name =None_, _no_ret =False_, _function_address =None_, _block_id =None_, _irsb =None_, _soot_block =None_, _instruction_addrs =None_, _thumb =False_, _byte_string =None_, _is_syscall =None_, _name =None_)¶
    

Note: simprocedure_name is not used to recreate the SimProcedure object. It’s only there for better __repr__.

addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`SootAddressDescriptor`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_soot.SootAddressDescriptor "\(in archinfo\)")_¶
    

size¶
    

simprocedure_name¶
    

no_ret¶
    

function_address¶
    

thumb¶
    

byte_string _: [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

is_syscall¶
    

instruction_addrs¶
    

irsb¶
    

soot_block¶
    

has_return¶
    

block_id _: `BlockID` | [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_property _name¶
    

_property _successors¶
    

_property _predecessors¶
    

successors_and_jumpkinds(_excluding_fakeret =True_)¶
    

predecessors_and_jumpkinds(_excluding_fakeret =True_)¶
    

get_data_references(_kb =None_)¶
    

Get the known data references for this CFGNode via the knowledge base.

Parameters:
    

**kb** – Which knowledge base to use; uses the global KB by default if none is provided

Returns:
    

Generator yielding xrefs to this CFGNode’s block.

Return type:
    

iter

_property _accessed_data_references¶
    

Property providing a view of all the known data references for this CFGNode via the global knowledge base

Returns:
    

Generator yielding xrefs to this CFGNode’s block.

Return type:
    

iter

_property _is_simprocedure¶
    

_property _callstack_key¶
    

serialize_to_cmessage()¶
    

Serialize the class object and returns a protobuf cmessage object.

Returns:
    

A protobuf cmessage object.

Return type:
    

protobuf.cmessage

_classmethod _parse_from_cmessage(_cmsg_ , _cfg =None_)¶
    

Parse a protobuf cmessage and create a class object.

Parameters:
    

**cmsg** – The probobuf cmessage object.

Returns:
    

A unserialized class object.

Return type:
    

cls

copy()¶
    

merge(_other_)¶
    

Merges this node with the other, returning a new node that spans the both.

to_codenode()¶
    

_property _block _: Block | SootBlock | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

syscall_name¶
    

_class _angr.knowledge_plugins.cfg.cfg_node.CFGENode(_addr_ , _size_ , _cfg_ , _simprocedure_name =None_, _no_ret =False_, _function_address =None_, _block_id =None_, _irsb =None_, _instruction_addrs =None_, _thumb =False_, _byte_string =None_, _is_syscall =None_, _name =None_, _input_state =None_, _final_states =None_, _syscall_name =None_, _looping_times =0_, _depth =None_, _callstack_key =None_, _creation_failure_info =None_)¶
    

Bases: `CFGNode`

The CFGNode that is used in CFGEmulated.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_SootAddressDescriptor_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch_soot.SootAddressDescriptor "\(in archinfo\)"))

  * **block_id** (_BlockID_ _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **byte_string** ([_bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") _|__None_)

__init__(_addr_ , _size_ , _cfg_ , _simprocedure_name =None_, _no_ret =False_, _function_address =None_, _block_id =None_, _irsb =None_, _instruction_addrs =None_, _thumb =False_, _byte_string =None_, _is_syscall =None_, _name =None_, _input_state =None_, _final_states =None_, _syscall_name =None_, _looping_times =0_, _depth =None_, _callstack_key =None_, _creation_failure_info =None_)¶
    

Note: simprocedure_name is not used to recreate the SimProcedure object. It’s only there for better __repr__.

input_state¶
    

looping_times¶
    

depth¶
    

creation_failure_info¶
    

final_states¶
    

return_target¶
    

syscall¶
    

_property _callstack_key¶
    

_property _creation_failed¶
    

downsize()¶
    

Drop saved states.

copy()¶
    

_class _angr.knowledge_plugins.cfg.indirect_jump.IndirectJumpType¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Jumptable_AddressLoadedFromMemory _ = 0_¶
    

Jumptable_AddressComputed _ = 1_¶
    

Vtable _ = 3_¶
    

Unknown _ = 255_¶
    

_class _angr.knowledge_plugins.cfg.indirect_jump.IndirectJump(_addr_ , _ins_addr_ , _func_addr_ , _jumpkind_ , _stmt_idx_ , _resolved_targets =None_, _jumptable =False_, _jumptable_addr =None_, _jumptable_size =None_, _jumptable_entry_size =None_, _jumptable_entries =None_, _type_ =255_)¶
    

Bases: `Serializable`

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **resolved_targets** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **jumptable** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **jumptable_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **jumptable_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **jumptable_entry_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **jumptable_entries** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **type_** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_addr_ , _ins_addr_ , _func_addr_ , _jumpkind_ , _stmt_idx_ , _resolved_targets =None_, _jumptable =False_, _jumptable_addr =None_, _jumptable_size =None_, _jumptable_entry_size =None_, _jumptable_entries =None_, _type_ =255_)¶
    

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **resolved_targets** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **jumptable** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **jumptable_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **jumptable_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **jumptable_entry_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **jumptable_entries** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **type_** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

addr¶
    

ins_addr¶
    

func_addr¶
    

jumpkind¶
    

stmt_idx¶
    

resolved_targets¶
    

jumptable¶
    

jumptable_addr¶
    

jumptable_size¶
    

jumptable_entry_size¶
    

jumptable_entries¶
    

type¶
    

_class _angr.knowledge_plugins.types.TypesStore(_kb_)¶
    

Bases: `KnowledgeBasePlugin`, [`UserDict`](https://docs.python.org/3/library/collections.html#collections.UserDict "\(in Python v3.13\)")

A kb plugin that stores a mapping from name to TypeRef. It will return types from angr.sim_type.ALL_TYPES as a default.

__init__(_kb_)¶
    

copy()¶
    

iter_own()¶
    

Iterate over all the names which are stored in this object - i.e. `values()` without `ALL_TYPES`

rename(_old_ , _new_)¶
    

unique_type_name()¶
    

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

_class _angr.knowledge_plugins.propagations.PropagationManager(_kb_)¶
    

Bases: `KnowledgeBasePlugin`

Manages the results of Propagator, including intermediate results for unfinished Propagation runs.

__init__(_kb_)¶
    

exists(_prop_key_)¶
    

Internal function to check if a func, specified as a CodeLocation exists in our known propagations

Parameters:
    

**prop_key** ([`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")) – A key of the propagation result.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

Whether such a key exists or not.

update(_prop_key_ , _model_)¶
    

Add the replacements to known propagations

Parameters:
    

  * **prop_key** ([`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")) – A key of the propagation result.

  * **model** (`PropagationModel`) – The propagation result to store

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

get(_prop_key_ , _default =None_)¶
    

Gets the replacements for a specified function location. If the replacement does not exist in the known propagations, it returns None.

Parameters:
    

  * **prop_key** – A key of the propagation result.

  * **default** – The default value to return if the prop_key does not exist in the cache.

Return type:
    

`PropagationModel`

Returns:
    

Dict or None

copy()¶
    

discard_by_prefix(_prefix_)¶
    

Parameters:
    

**prefix** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.knowledge_plugins.propagations.PropagationModel(_prop_key_ , _node_iterations =None_, _states =None_, _block_initial_reg_values =None_, _replacements =None_, _equivalence =None_, _function =None_, _input_states =None_)¶
    

Bases: `Serializable`

This class stores the propagation result that comes out of Propagator.

Parameters:
    

  * **prop_key** ([_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)"))

  * **node_iterations** (_defaultdict_ _[__Any_ _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **states** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _|__None_)

  * **block_initial_reg_values** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _|__None_)

  * **replacements** (_defaultdict_ _[__Any_ _,_[_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _]__|__None_)

  * **equivalence** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _|__None_)

  * **function** (_Function_ _|__None_)

  * **input_states** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _|__None_)

__init__(_prop_key_ , _node_iterations =None_, _states =None_, _block_initial_reg_values =None_, _replacements =None_, _equivalence =None_, _function =None_, _input_states =None_)¶
    

Parameters:
    

  * **prop_key** ([_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)"))

  * **node_iterations** ([_defaultdict_](https://docs.python.org/3/library/collections.html#collections.defaultdict "\(in Python v3.13\)") _[_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **states** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _|__None_)

  * **block_initial_reg_values** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _|__None_)

  * **replacements** ([_defaultdict_](https://docs.python.org/3/library/collections.html#collections.defaultdict "\(in Python v3.13\)") _[_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _,_[_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _]__|__None_)

  * **equivalence** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _|__None_)

  * **function** (_Function_ _|__None_)

  * **input_states** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _|__None_)

key¶
    

node_iterations¶
    

input_states¶
    

states¶
    

block_initial_reg_values¶
    

replacements¶
    

equivalence¶
    

graph_visitor¶
    

downsize()¶
    

block_beginning_state(_block_addr_)¶
    

Return type:
    

`PropagatorState`

_class _angr.knowledge_plugins.comments.Comments(_kb_)¶
    

Bases: `KnowledgeBasePlugin`, [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")

Tracks comments via a Dict of Address -> Text

Parameters:
    

**kb** (_KnowledgeBase_)

copy() → a shallow copy of D¶
    

_class _angr.knowledge_plugins.data.Data(_kb_)¶
    

Bases: `KnowledgeBasePlugin`

The knowledge what purpose this plugin serves has been lost to the passing of time but the linter does not care for these failures of mere mortals and demands a docstring anyway. The pact has been made, and no violations of the rules will be tolerated, even if the spirit does not match the letter. Making the plugin smaller has only increased the weight of the failure, and thus this file has drawn its ire.

The only thing left to do is to attempt to find meaning in the meaninglessness, as the only act of rebellion against the uncaring forces that bind us. For is this not what being human is all about?

Parameters:
    

**kb** (_KnowledgeBase_)

copy()¶
    

_class _angr.knowledge_plugins.indirect_jumps.IndirectJumps(_kb_)¶
    

Bases: `KnowledgeBasePlugin`, [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")

This plugin tracks the targets of indirect jumps

__init__(_kb_)¶
    

copy() → a shallow copy of D¶
    

update_resolved_addrs(_indirect_address_ , _resolved_addresses_)¶
    

Parameters:
    

  * **indirect_address** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **resolved_addresses** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]_)

_class _angr.knowledge_plugins.labels.Labels(_kb_)¶
    

Bases: `KnowledgeBasePlugin`

__init__(_kb_)¶
    

items()¶
    

get(_addr_)¶
    

Get a label as string for a given address Same as .labels[x]

lookup(_name_)¶
    

Returns an address to a given label To show all available labels, iterate over .labels or list(b.kb.labels)

copy()¶
    

get_unique_label(_label_)¶
    

Get a unique label name from the given label name.

Parameters:
    

**label** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The desired label name.

Returns:
    

A unique label name.

_class _angr.knowledge_plugins.functions.Function(_function_manager_ , _addr_ , _name =None_, _syscall =None_, _is_simprocedure =None_, _binary_name =None_, _is_plt =None_, _returning =None_, _alignment =False_, _calling_convention =None_, _prototype =None_, _prototype_libname =None_, _is_prototype_guessed =True_)¶
    

Bases: `Serializable`

A representation of a function and various information about it.

Parameters:
    

  * **is_simprocedure** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **is_plt** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **calling_convention** (_SimCC_ _|__None_)

  * **prototype** (_SimTypeFunction_ _|__None_)

  * **prototype_libname** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **is_prototype_guessed** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_function_manager_ , _addr_ , _name =None_, _syscall =None_, _is_simprocedure =None_, _binary_name =None_, _is_plt =None_, _returning =None_, _alignment =False_, _calling_convention =None_, _prototype =None_, _prototype_libname =None_, _is_prototype_guessed =True_)¶
    

Function constructor. If the optional parameters are not provided, they will be automatically determined upon the creation of a Function object.

Parameters:
    

  * **addr** – The address of the function.

  * **is_simprocedure** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **is_plt** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **calling_convention** (_SimCC_ _|__None_)

  * **prototype** (_SimTypeFunction_ _|__None_)

  * **prototype_libname** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **is_prototype_guessed** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

The following parameters are optional.

Parameters:
    

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The name of the function.

  * **syscall** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether this function is a syscall or not.

  * **is_simprocedure** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether this function is a SimProcedure or not.

  * **binary_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of the binary where this function is.

  * **is_plt** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If this function is a PLT entry.

  * **returning** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If this function returns.

  * **alignment** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If this function acts as an alignment filler. Such functions usually only contain nops.

  * **calling_convention** (_SimCC_ _|__None_)

  * **prototype** (_SimTypeFunction_ _|__None_)

  * **prototype_libname** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **is_prototype_guessed** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

transition_graph¶
    

normalized¶
    

addr¶
    

startpoint¶
    

is_alignment¶
    

bp_on_stack¶
    

retaddr_on_stack¶
    

sp_delta¶
    

calling_convention¶
    

prototype¶
    

prototype_libname¶
    

is_prototype_guessed¶
    

info¶
    

tags¶
    

ran_cca¶
    

is_syscall¶
    

is_simprocedure¶
    

is_plt¶
    

is_default_name¶
    

previous_names¶
    

from_signature _: [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

binary_name¶
    

_property _name¶
    

_property _project¶
    

_property _returning¶
    

_property _blocks¶
    

An iterator of all local blocks in the current function.

Returns:
    

angr.lifter.Block instances.

_property _cyclomatic_complexity¶
    

The cyclomatic complexity of the function.

Cyclomatic complexity is a software metric used to indicate the complexity of a program. It is a quantitative measure of the number of linearly independent paths through a program’s source code. It is computed using the formula: M = E - N + 2P, where E = the number of edges in the graph, N = the number of nodes in the graph, P = the number of connected components.

The cyclomatic complexity value is lazily computed and cached for future use. Initially this value is None until it is computed for the first time

Returns:
    

The cyclomatic complexity of the function.

Return type:
    

[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

_property _xrefs¶
    

An iterator of all xrefs of the current function.

Returns:
    

angr.knowledge_plugins.xrefs.xref.XRef instances.

_property _block_addrs¶
    

An iterator of all local block addresses in the current function.

Returns:
    

block addresses.

_property _block_addrs_set¶
    

Return a set of block addresses for a better performance of inclusion tests.

Returns:
    

A set of block addresses.

Return type:
    

[set](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")

get_block(_addr_ , _size =None_, _byte_string =None_)¶
    

Getting a block out of the current function.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address of the block.

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The size of the block. This is optional. If not provided, angr will load

  * **byte_string** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)")])

Returns:
    

get_block_size(_addr_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_property _nodes _: [Iterable](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)")[CodeNode]_¶
    

get_node(_addr_)¶
    

Return type:
    

`BlockNode` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

_property _has_unresolved_jumps¶
    

_property _has_unresolved_calls¶
    

_property _operations¶
    

All of the operations that are done by this functions.

_property _code_constants¶
    

All of the constants that are used by this functions’s code.

serialize_to_cmessage()¶
    

Serialize the class object and returns a protobuf cmessage object.

Returns:
    

A protobuf cmessage object.

Return type:
    

protobuf.cmessage

_classmethod _parse_from_cmessage(_cmsg_ , _** kwargs_)¶
    

Parameters:
    

**cmsg**

Return Function:
    

The function instantiated out of the cmsg data.

string_references(_minimum_length =2_)¶
    

All of the constant string references used by this function.

Parameters:
    

**minimum_length** – The minimum length of strings to find (default is 1)

Returns:
    

A generator yielding tuples of (address, string) where is address is the location of the string in memory.

_property _local_runtime_values¶
    

Tries to find all runtime values of this function which do not come from inputs. These values are generated by starting from a blank state and reanalyzing the basic blocks once each. Function calls are skipped, and back edges are never taken so these values are often unreliable, This function is good at finding simple constant addresses which the function will use or calculate.

Returns:
    

a set of constants

_property _num_arguments¶
    

_property _endpoints¶
    

_property _endpoints_with_type¶
    

_property _ret_sites¶
    

_property _jumpout_sites¶
    

_property _retout_sites¶
    

_property _callout_sites¶
    

_property _size¶
    

_property _binary¶
    

Get the object this function belongs to. :return: The object this function belongs to.

_property _offset _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

the function’s binary offset (i.e., non-rebased address)

Type:
    

return

_property _symbol _: [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") | [Symbol](https://docs.angr.io/projects/cle/en/latest/api/backend.html#cle.backends.symbol.Symbol "\(in cle\)")_¶
    

the function’s Symbol, if any

Type:
    

return

_property _pseudocode _: [str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

the function’s pseudocode

Type:
    

return

add_jumpout_site(_node_)¶
    

Add a custom jumpout site.

Parameters:
    

**node** (`CodeNode`) – The address of the basic block that control flow leaves during this transition.

Returns:
    

None

add_retout_site(_node_)¶
    

Add a custom retout site.

Retout (returning to outside of the function) sites are very rare. It mostly occurs during CFG recovery when we incorrectly identify the beginning of a function in the first iteration, and then correctly identify that function later in the same iteration (function alignments can lead to this bizarre case). We will mark all edges going out of the header of that function as a outside edge, because all successors now belong to the incorrectly-identified function. This identification error will be fixed in the second iteration of CFG recovery. However, we still want to keep track of jumpouts/retouts during the first iteration so other logic in CFG recovery still work.

Parameters:
    

**node** (`CodeNode`) – The address of the basic block that control flow leaves the current function after a call.

Returns:
    

None

mark_nonreturning_calls_endpoints()¶
    

Iterate through all call edges in transition graph. For each call a non-returning function, mark the source basic block as an endpoint.

This method should only be executed once all functions are recovered and analyzed by CFG recovery, so we know whether each function returns or not.

Returns:
    

None

get_call_sites()¶
    

Gets a list of all the basic blocks that end in calls.

Return type:
    

[`Iterable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]

Returns:
    

A view of the addresses of the blocks that end in calls.

get_call_target(_callsite_addr_)¶
    

Get the target of a call.

Parameters:
    

**callsite_addr** – The address of a basic block that ends in a call.

Returns:
    

The target of said call, or None if callsite_addr is not a callsite.

get_call_return(_callsite_addr_)¶
    

Get the hypothetical return address of a call.

Parameters:
    

**callsite_addr** – The address of the basic block that ends in a call.

Returns:
    

The likely return target of said call, or None if callsite_addr is not a callsite.

_property _graph¶
    

Get a local transition graph. A local transition graph is a transition graph that only contains nodes that belong to the current function. All edges, except for the edges going out from the current function or coming from outside the current function, are included.

The generated graph is cached in self._local_transition_graph.

Returns:
    

A local transition graph.

Return type:
    

networkx.DiGraph

graph_ex(_exception_edges =True_)¶
    

Get a local transition graph with a custom configuration. A local transition graph is a transition graph that only contains nodes that belong to the current function. This method allows user to exclude certain types of edges together with the nodes that are only reachable through such edges, such as exception edges.

The generated graph is not cached.

Parameters:
    

**exception_edges** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Should exception edges and the nodes that are only reachable through exception edges be kept.

Returns:
    

A local transition graph with a special configuration.

Return type:
    

networkx.DiGraph

transition_graph_ex(_exception_edges =True_)¶
    

Get a transition graph with a custom configuration. This method allows user to exclude certain types of edges together with the nodes that are only reachable through such edges, such as exception edges.

The generated graph is not cached.

Parameters:
    

**exception_edges** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Should exception edges and the nodes that are only reachable through exception edges be kept.

Returns:
    

A local transition graph with a special configuration.

Return type:
    

networkx.DiGraph

subgraph(_ins_addrs_)¶
    

Generate a sub control flow graph of instruction addresses based on self.graph

Parameters:
    

**ins_addrs** (_iterable_) – A collection of instruction addresses that should be included in the subgraph.

Return networkx.DiGraph:
    

A subgraph.

instruction_size(_insn_addr_)¶
    

Get the size of the instruction specified by insn_addr.

Parameters:
    

**insn_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the instruction

Return int:
    

Size of the instruction in bytes, or None if the instruction is not found.

addr_to_instruction_addr(_addr_)¶
    

Obtain the address of the instruction that covers @addr.

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – An address.

Returns:
    

Address of the instruction that covers @addr, or None if this addr is not covered by any instruction of this function.

Return type:
    

[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") or None

dbg_print()¶
    

Returns a representation of the list of basic blocks in this function.

dbg_draw(_filename_)¶
    

Draw the graph and save it to a PNG file.

_property _arguments¶
    

_property _has_return¶
    

_property _callable¶
    

normalize()¶
    

Make sure all basic blocks in the transition graph of this function do not overlap. You will end up with a CFG that IDA Pro generates.

This method does not touch the CFG result. You may call CFG{Emulated, Fast}.normalize() for that matter.

Returns:
    

None

find_declaration(_ignore_binary_name =False_, _binary_name_hint =None_)¶
    

Find the most likely function declaration from the embedded collection of prototypes, set it to self.prototype, and update self.calling_convention with the declaration.

Parameters:
    

  * **ignore_binary_name** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Do not rely on the executable or library where the function belongs to determine its source library. This is useful when working on statically linked binaries (because all functions will belong to the main executable). We will search for all libraries in angr to find the first declaration match.

  * **binary_name_hint** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]) – Substring of the library name where this function might be originally coming from. Useful for FLIRT-identified functions in statically linked binaries.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

True if a declaration is found and self.prototype and self.calling_convention are updated. False if we fail to find a matching function declaration, in which case self.prototype or self.calling_convention will be kept untouched.

is_rust_function()¶
    

_property _demangled_name¶
    

_property _short_name¶
    

get_unambiguous_name(_display_name =None_)¶
    

Get a disambiguated function name.

Parameters:
    

**display_name** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]) – Name to display, otherwise the function name.

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

Returns:
    

The function name in the form: ::<name> when the function binary is the main object. ::<obj>::<name> when the function binary is not the main object. ::<addr>::<name> when the function binary is an unnamed non-main object, or when multiple functions with

> the same name are defined in the function binary.

apply_definition(_definition_ , _calling_convention =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **definition** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **calling_convention** (_SimCC_ _|_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__SimCC_ _]__|__None_)

functions_reachable()¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Function`]

Returns:
    

The set of all functions that can be reached from the function represented by self.

copy()¶
    

pp(_** kwargs_)¶
    

Pretty-print the function disassembly.

_class _angr.knowledge_plugins.functions.FunctionManager(_kb_)¶
    

Bases: `KnowledgeBasePlugin`, [`Mapping`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Mapping "\(in Python v3.13\)")

This is a function boundaries management tool. It takes in intermediate results during CFG generation, and manages a function map of the binary.

__init__(_kb_)¶
    

copy()¶
    

clear()¶
    

is_plt_cached(_addr_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_binary_name_cached(_addr_)¶
    

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_by_addr(_addr_)¶
    

Return type:
    

`Function`

get_by_name(_name_ , _check_previous_names =False_)¶
    

Return type:
    

[`Generator`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Generator "\(in Python v3.13\)")[`Function`]

Parameters:
    

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **check_previous_names** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

contains_addr(_addr_)¶
    

Decide if an address is handled by the function manager.

Note: this function is non-conformant with python programming idioms, but its needed for performance reasons.

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function.

ceiling_func(_addr_)¶
    

Return the function who has the least address that is greater than or equal to addr.

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address to query.

Returns:
    

A Function instance, or None if there is no other function after addr.

Return type:
    

Function or None

floor_func(_addr_)¶
    

Return the function who has the greatest address that is less than or equal to addr.

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address to query.

Returns:
    

A Function instance, or None if there is no other function before addr.

Return type:
    

Function or None

query(_query_ , _check_previous_names =False_)¶
    

Query for a function using selectors to disambiguate. Supported variations: :rtype: `Function` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

> ::<name> Function <name> in the main object ::<addr>::<name> Function <name> at <addr> ::<obj>::<name> Function <name> in <obj>

Parameters:
    

  * **query** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **check_previous_names** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Return type:
    

_Function_ | None

function(_addr =None_, _name =None_, _check_previous_names =False_, _create =False_, _syscall =False_, _plt =None_)¶
    

Get a function object from the function manager.

Pass either addr or name with the appropriate values.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function.

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of the function.

  * **create** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether to create the function or not if the function does not exist.

  * **syscall** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True to create the function as a syscall, False otherwise.

  * **plt** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _or_ _None_) – True to find the PLT stub, False to find a non-PLT stub, None to disable this restriction.

Returns:
    

The Function instance, or None if the function is not found and create is False.

Return type:
    

Function or None

dbg_draw(_prefix ='dbg_function_'_)¶
    

rebuild_callgraph()¶
    

_class _angr.knowledge_plugins.functions.function_manager.FunctionDict(_backref_ , _* args_, _** kwargs_)¶
    

Bases: `SortedDict`

FunctionDict is a dict where the keys are function starting addresses and map to the associated `Function`.

__init__(_backref_ , _* args_, _** kwargs_)¶
    

Initialize sorted dict instance.

Optional key-function argument defines a callable that, like the key argument to the built-in sorted function, extracts a comparison key from each dictionary key. If no function is specified, the default compares the dictionary keys directly. The key-function argument must be provided as a positional argument and must come before all other arguments.

Optional iterable argument provides an initial sequence of pairs to initialize the sorted dict. Each pair in the sequence defines the key and corresponding value. If a key is seen more than once, the last value associated with it is stored in the new sorted dict.

Optional mapping argument provides an initial mapping of items to initialize the sorted dict.

If keyword arguments are given, the keywords themselves, with their associated values, are added as items to the dictionary. If a key is specified both in the positional argument and as a keyword argument, the value associated with the keyword is stored in the sorted dict.

Sorted dict keys must be hashable, per the requirement for Python’s dictionaries. Keys (or the result of the key-function) must also be comparable, per the requirement for sorted lists.
    
    
    >>> d = {'alpha': 1, 'beta': 2}
    >>> SortedDict([('alpha', 1), ('beta', 2)]) == d
    True
    >>> SortedDict({'alpha': 1, 'beta': 2}) == d
    True
    >>> SortedDict(alpha=1, beta=2) == d
    True
    

get(_addr_)¶
    

Return the value for key if key is in the dictionary, else default.

floor_addr(_addr_)¶
    

ceiling_addr(_addr_)¶
    

_class _angr.knowledge_plugins.functions.function_manager.FunctionManager(_kb_)¶
    

Bases: `KnowledgeBasePlugin`, [`Mapping`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Mapping "\(in Python v3.13\)")

This is a function boundaries management tool. It takes in intermediate results during CFG generation, and manages a function map of the binary.

__init__(_kb_)¶
    

copy()¶
    

clear()¶
    

is_plt_cached(_addr_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_binary_name_cached(_addr_)¶
    

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_by_addr(_addr_)¶
    

Return type:
    

`Function`

get_by_name(_name_ , _check_previous_names =False_)¶
    

Return type:
    

[`Generator`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Generator "\(in Python v3.13\)")[`Function`]

Parameters:
    

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **check_previous_names** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

contains_addr(_addr_)¶
    

Decide if an address is handled by the function manager.

Note: this function is non-conformant with python programming idioms, but its needed for performance reasons.

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function.

ceiling_func(_addr_)¶
    

Return the function who has the least address that is greater than or equal to addr.

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address to query.

Returns:
    

A Function instance, or None if there is no other function after addr.

Return type:
    

Function or None

floor_func(_addr_)¶
    

Return the function who has the greatest address that is less than or equal to addr.

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address to query.

Returns:
    

A Function instance, or None if there is no other function before addr.

Return type:
    

Function or None

query(_query_ , _check_previous_names =False_)¶
    

Query for a function using selectors to disambiguate. Supported variations: :rtype: `Function` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

> ::<name> Function <name> in the main object ::<addr>::<name> Function <name> at <addr> ::<obj>::<name> Function <name> in <obj>

Parameters:
    

  * **query** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **check_previous_names** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Return type:
    

_Function_ | None

function(_addr =None_, _name =None_, _check_previous_names =False_, _create =False_, _syscall =False_, _plt =None_)¶
    

Get a function object from the function manager.

Pass either addr or name with the appropriate values.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function.

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of the function.

  * **create** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether to create the function or not if the function does not exist.

  * **syscall** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True to create the function as a syscall, False otherwise.

  * **plt** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _or_ _None_) – True to find the PLT stub, False to find a non-PLT stub, None to disable this restriction.

Returns:
    

The Function instance, or None if the function is not found and create is False.

Return type:
    

Function or None

dbg_draw(_prefix ='dbg_function_'_)¶
    

rebuild_callgraph()¶
    

_class _angr.knowledge_plugins.functions.function.Function(_function_manager_ , _addr_ , _name =None_, _syscall =None_, _is_simprocedure =None_, _binary_name =None_, _is_plt =None_, _returning =None_, _alignment =False_, _calling_convention =None_, _prototype =None_, _prototype_libname =None_, _is_prototype_guessed =True_)¶
    

Bases: `Serializable`

A representation of a function and various information about it.

Parameters:
    

  * **is_simprocedure** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **is_plt** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **calling_convention** (_SimCC_ _|__None_)

  * **prototype** (_SimTypeFunction_ _|__None_)

  * **prototype_libname** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **is_prototype_guessed** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_function_manager_ , _addr_ , _name =None_, _syscall =None_, _is_simprocedure =None_, _binary_name =None_, _is_plt =None_, _returning =None_, _alignment =False_, _calling_convention =None_, _prototype =None_, _prototype_libname =None_, _is_prototype_guessed =True_)¶
    

Function constructor. If the optional parameters are not provided, they will be automatically determined upon the creation of a Function object.

Parameters:
    

  * **addr** – The address of the function.

  * **is_simprocedure** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **is_plt** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **calling_convention** (_SimCC_ _|__None_)

  * **prototype** (_SimTypeFunction_ _|__None_)

  * **prototype_libname** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **is_prototype_guessed** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

The following parameters are optional.

Parameters:
    

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The name of the function.

  * **syscall** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether this function is a syscall or not.

  * **is_simprocedure** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether this function is a SimProcedure or not.

  * **binary_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of the binary where this function is.

  * **is_plt** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If this function is a PLT entry.

  * **returning** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If this function returns.

  * **alignment** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If this function acts as an alignment filler. Such functions usually only contain nops.

  * **calling_convention** (_SimCC_ _|__None_)

  * **prototype** (_SimTypeFunction_ _|__None_)

  * **prototype_libname** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **is_prototype_guessed** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

transition_graph¶
    

normalized¶
    

addr¶
    

startpoint¶
    

is_alignment¶
    

bp_on_stack¶
    

retaddr_on_stack¶
    

sp_delta¶
    

calling_convention¶
    

prototype¶
    

prototype_libname¶
    

is_prototype_guessed¶
    

info¶
    

tags¶
    

ran_cca¶
    

is_syscall¶
    

is_simprocedure¶
    

is_plt¶
    

is_default_name¶
    

previous_names¶
    

from_signature _: [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

binary_name¶
    

_property _name¶
    

_property _project¶
    

_property _returning¶
    

_property _blocks¶
    

An iterator of all local blocks in the current function.

Returns:
    

angr.lifter.Block instances.

_property _cyclomatic_complexity¶
    

The cyclomatic complexity of the function.

Cyclomatic complexity is a software metric used to indicate the complexity of a program. It is a quantitative measure of the number of linearly independent paths through a program’s source code. It is computed using the formula: M = E - N + 2P, where E = the number of edges in the graph, N = the number of nodes in the graph, P = the number of connected components.

The cyclomatic complexity value is lazily computed and cached for future use. Initially this value is None until it is computed for the first time

Returns:
    

The cyclomatic complexity of the function.

Return type:
    

[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

_property _xrefs¶
    

An iterator of all xrefs of the current function.

Returns:
    

angr.knowledge_plugins.xrefs.xref.XRef instances.

_property _block_addrs¶
    

An iterator of all local block addresses in the current function.

Returns:
    

block addresses.

_property _block_addrs_set¶
    

Return a set of block addresses for a better performance of inclusion tests.

Returns:
    

A set of block addresses.

Return type:
    

[set](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")

get_block(_addr_ , _size =None_, _byte_string =None_)¶
    

Getting a block out of the current function.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address of the block.

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The size of the block. This is optional. If not provided, angr will load

  * **byte_string** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)")])

Returns:
    

get_block_size(_addr_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_property _nodes _: [Iterable](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)")[CodeNode]_¶
    

get_node(_addr_)¶
    

Return type:
    

`BlockNode` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

_property _has_unresolved_jumps¶
    

_property _has_unresolved_calls¶
    

_property _operations¶
    

All of the operations that are done by this functions.

_property _code_constants¶
    

All of the constants that are used by this functions’s code.

serialize_to_cmessage()¶
    

Serialize the class object and returns a protobuf cmessage object.

Returns:
    

A protobuf cmessage object.

Return type:
    

protobuf.cmessage

_classmethod _parse_from_cmessage(_cmsg_ , _** kwargs_)¶
    

Parameters:
    

**cmsg**

Return Function:
    

The function instantiated out of the cmsg data.

string_references(_minimum_length =2_)¶
    

All of the constant string references used by this function.

Parameters:
    

**minimum_length** – The minimum length of strings to find (default is 1)

Returns:
    

A generator yielding tuples of (address, string) where is address is the location of the string in memory.

_property _local_runtime_values¶
    

Tries to find all runtime values of this function which do not come from inputs. These values are generated by starting from a blank state and reanalyzing the basic blocks once each. Function calls are skipped, and back edges are never taken so these values are often unreliable, This function is good at finding simple constant addresses which the function will use or calculate.

Returns:
    

a set of constants

_property _num_arguments¶
    

_property _endpoints¶
    

_property _endpoints_with_type¶
    

_property _ret_sites¶
    

_property _jumpout_sites¶
    

_property _retout_sites¶
    

_property _callout_sites¶
    

_property _size¶
    

_property _binary¶
    

Get the object this function belongs to. :return: The object this function belongs to.

_property _offset _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

the function’s binary offset (i.e., non-rebased address)

Type:
    

return

_property _symbol _: [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") | [Symbol](https://docs.angr.io/projects/cle/en/latest/api/backend.html#cle.backends.symbol.Symbol "\(in cle\)")_¶
    

the function’s Symbol, if any

Type:
    

return

_property _pseudocode _: [str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

the function’s pseudocode

Type:
    

return

add_jumpout_site(_node_)¶
    

Add a custom jumpout site.

Parameters:
    

**node** (`CodeNode`) – The address of the basic block that control flow leaves during this transition.

Returns:
    

None

add_retout_site(_node_)¶
    

Add a custom retout site.

Retout (returning to outside of the function) sites are very rare. It mostly occurs during CFG recovery when we incorrectly identify the beginning of a function in the first iteration, and then correctly identify that function later in the same iteration (function alignments can lead to this bizarre case). We will mark all edges going out of the header of that function as a outside edge, because all successors now belong to the incorrectly-identified function. This identification error will be fixed in the second iteration of CFG recovery. However, we still want to keep track of jumpouts/retouts during the first iteration so other logic in CFG recovery still work.

Parameters:
    

**node** (`CodeNode`) – The address of the basic block that control flow leaves the current function after a call.

Returns:
    

None

mark_nonreturning_calls_endpoints()¶
    

Iterate through all call edges in transition graph. For each call a non-returning function, mark the source basic block as an endpoint.

This method should only be executed once all functions are recovered and analyzed by CFG recovery, so we know whether each function returns or not.

Returns:
    

None

get_call_sites()¶
    

Gets a list of all the basic blocks that end in calls.

Return type:
    

[`Iterable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]

Returns:
    

A view of the addresses of the blocks that end in calls.

get_call_target(_callsite_addr_)¶
    

Get the target of a call.

Parameters:
    

**callsite_addr** – The address of a basic block that ends in a call.

Returns:
    

The target of said call, or None if callsite_addr is not a callsite.

get_call_return(_callsite_addr_)¶
    

Get the hypothetical return address of a call.

Parameters:
    

**callsite_addr** – The address of the basic block that ends in a call.

Returns:
    

The likely return target of said call, or None if callsite_addr is not a callsite.

_property _graph¶
    

Get a local transition graph. A local transition graph is a transition graph that only contains nodes that belong to the current function. All edges, except for the edges going out from the current function or coming from outside the current function, are included.

The generated graph is cached in self._local_transition_graph.

Returns:
    

A local transition graph.

Return type:
    

networkx.DiGraph

graph_ex(_exception_edges =True_)¶
    

Get a local transition graph with a custom configuration. A local transition graph is a transition graph that only contains nodes that belong to the current function. This method allows user to exclude certain types of edges together with the nodes that are only reachable through such edges, such as exception edges.

The generated graph is not cached.

Parameters:
    

**exception_edges** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Should exception edges and the nodes that are only reachable through exception edges be kept.

Returns:
    

A local transition graph with a special configuration.

Return type:
    

networkx.DiGraph

transition_graph_ex(_exception_edges =True_)¶
    

Get a transition graph with a custom configuration. This method allows user to exclude certain types of edges together with the nodes that are only reachable through such edges, such as exception edges.

The generated graph is not cached.

Parameters:
    

**exception_edges** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Should exception edges and the nodes that are only reachable through exception edges be kept.

Returns:
    

A local transition graph with a special configuration.

Return type:
    

networkx.DiGraph

subgraph(_ins_addrs_)¶
    

Generate a sub control flow graph of instruction addresses based on self.graph

Parameters:
    

**ins_addrs** (_iterable_) – A collection of instruction addresses that should be included in the subgraph.

Return networkx.DiGraph:
    

A subgraph.

instruction_size(_insn_addr_)¶
    

Get the size of the instruction specified by insn_addr.

Parameters:
    

**insn_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the instruction

Return int:
    

Size of the instruction in bytes, or None if the instruction is not found.

addr_to_instruction_addr(_addr_)¶
    

Obtain the address of the instruction that covers @addr.

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – An address.

Returns:
    

Address of the instruction that covers @addr, or None if this addr is not covered by any instruction of this function.

Return type:
    

[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") or None

dbg_print()¶
    

Returns a representation of the list of basic blocks in this function.

dbg_draw(_filename_)¶
    

Draw the graph and save it to a PNG file.

_property _arguments¶
    

_property _has_return¶
    

_property _callable¶
    

normalize()¶
    

Make sure all basic blocks in the transition graph of this function do not overlap. You will end up with a CFG that IDA Pro generates.

This method does not touch the CFG result. You may call CFG{Emulated, Fast}.normalize() for that matter.

Returns:
    

None

find_declaration(_ignore_binary_name =False_, _binary_name_hint =None_)¶
    

Find the most likely function declaration from the embedded collection of prototypes, set it to self.prototype, and update self.calling_convention with the declaration.

Parameters:
    

  * **ignore_binary_name** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Do not rely on the executable or library where the function belongs to determine its source library. This is useful when working on statically linked binaries (because all functions will belong to the main executable). We will search for all libraries in angr to find the first declaration match.

  * **binary_name_hint** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]) – Substring of the library name where this function might be originally coming from. Useful for FLIRT-identified functions in statically linked binaries.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

True if a declaration is found and self.prototype and self.calling_convention are updated. False if we fail to find a matching function declaration, in which case self.prototype or self.calling_convention will be kept untouched.

is_rust_function()¶
    

_property _demangled_name¶
    

_property _short_name¶
    

get_unambiguous_name(_display_name =None_)¶
    

Get a disambiguated function name.

Parameters:
    

**display_name** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]) – Name to display, otherwise the function name.

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

Returns:
    

The function name in the form: ::<name> when the function binary is the main object. ::<obj>::<name> when the function binary is not the main object. ::<addr>::<name> when the function binary is an unnamed non-main object, or when multiple functions with

> the same name are defined in the function binary.

apply_definition(_definition_ , _calling_convention =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **definition** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **calling_convention** (_SimCC_ _|_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__SimCC_ _]__|__None_)

functions_reachable()¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Function`]

Returns:
    

The set of all functions that can be reached from the function represented by self.

copy()¶
    

pp(_** kwargs_)¶
    

Pretty-print the function disassembly.

_class _angr.knowledge_plugins.functions.function_parser.FunctionParser¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

The implementation of the serialization methods for the <Function> class.

_static _serialize(_function_)¶
    

:return :

_static _parse_from_cmsg(_cmsg_ , _function_manager =None_, _project =None_, _all_func_addrs =None_)¶
    

Parameters:
    

**cmsg** – The data to instantiate the <Function> from.

Return Function:
    

_class _angr.knowledge_plugins.functions.soot_function.SootFunction(_function_manager_ , _addr_ , _name =None_, _syscall =None_)¶
    

Bases: `Function`

A representation of a function and various information about it.

__init__(_function_manager_ , _addr_ , _name =None_, _syscall =None_)¶
    

Function constructor for Soot

Parameters:
    

  * **addr** – The address of the function.

  * **name** – (Optional) The name of the function.

  * **syscall** – (Optional) Whether this function is a syscall or not.

transition_graph¶
    

normalized¶
    

previous_names¶
    

addr¶
    

is_syscall¶
    

is_plt¶
    

is_simprocedure¶
    

binary_name¶
    

bp_on_stack¶
    

retaddr_on_stack¶
    

sp_delta¶
    

calling_convention¶
    

prototype¶
    

is_alignment¶
    

startpoint¶
    

info¶
    

tags¶
    

normalize()¶
    

Make sure all basic blocks in the transition graph of this function do not overlap. You will end up with a CFG that IDA Pro generates.

This method does not touch the CFG result. You may call CFG{Emulated, Fast}.normalize() for that matter.

Returns:
    

None

from_signature _: str | None_¶
    

is_default_name¶
    

is_prototype_guessed¶
    

prototype_libname¶
    

ran_cca¶
    

_class _angr.knowledge_plugins.variables.VariableManager(_kb_)¶
    

Bases: `KnowledgeBasePlugin`

Manage variables.

__init__(_kb_)¶
    

has_function_manager(_key_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**key** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_function_manager(_func_addr_)¶
    

Return type:
    

`VariableManagerInternal`

initialize_variable_names()¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

get_variable_accesses(_variable_ , _same_name =False_)¶
    

Get a list of all references to the given variable.

Parameters:
    

  * **variable** (`SimVariable`) – The variable.

  * **same_name** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether to include all variables with the same variable name, or just based on the variable identifier.

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`VariableAccess`]

Returns:
    

All references to the variable.

copy()¶
    

_static _convert_variable_list(_vlist_ , _manager_)¶
    

Parameters:
    

  * **vlist** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_Variable_](https://docs.angr.io/projects/cle/en/latest/api/backends/elf.html#cle.backends.elf.variable.Variable "\(in cle\)") _]_)

  * **manager** (_VariableManagerInternal_)

load_from_dwarf(_cu_list =None_)¶
    

Parameters:
    

**cu_list** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_CompilationUnit_](https://docs.angr.io/projects/cle/en/latest/api/backends/elf.html#cle.backends.elf.compilation_unit.CompilationUnit "\(in cle\)") _]__|__None_)

_class _angr.knowledge_plugins.variables.VariableType¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Describes variable types.

REGISTER _ = 0_¶
    

MEMORY _ = 1_¶
    

_class _angr.knowledge_plugins.variables.variable_access.VariableAccessSort¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Provides enums for variable access types.

WRITE _ = 0_¶
    

READ _ = 1_¶
    

REFERENCE _ = 2_¶
    

_class _angr.knowledge_plugins.variables.variable_access.VariableAccess(_variable_ , _access_type_ , _location_ , _offset_ , _atom_hash =None_)¶
    

Bases: `Serializable`

Describes a variable access.

__init__(_variable_ , _access_type_ , _location_ , _offset_ , _atom_hash =None_)¶
    

variable _: `SimVariable`_¶
    

access_type _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

location _: `CodeLocation`_¶
    

offset _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

atom_hash _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

serialize_to_cmessage()¶
    

Serialize the class object and returns a protobuf cmessage object.

Returns:
    

A protobuf cmessage object.

Return type:
    

protobuf.cmessage

_classmethod _parse_from_cmessage(_cmsg_ , _variable_by_ident =None_, _** kwargs_)¶
    

Parse a protobuf cmessage and create a class object.

Parameters:
    

  * **cmsg** – The probobuf cmessage object.

  * **variable_by_ident** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__SimVariable_ _]__|__None_)

Returns:
    

A unserialized class object.

Return type:
    

cls

_class _angr.knowledge_plugins.variables.variable_manager.VariableType¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Describes variable types.

REGISTER _ = 0_¶
    

MEMORY _ = 1_¶
    

_class _angr.knowledge_plugins.variables.variable_manager.LiveVariables(_register_region_ , _stack_region_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A collection of live variables at a program point.

__init__(_register_region_ , _stack_region_)¶
    

register_region¶
    

stack_region¶
    

_class _angr.knowledge_plugins.variables.variable_manager.VariableManagerInternal(_manager_ , _func_addr =None_)¶
    

Bases: `Serializable`

Manage variables for a function. It is meant to be used internally by VariableManager, but it’s common to be given a reference to one in response to a query for “the variables for a given function”. Maybe a better name would be “VariableManagerScope”.

__init__(_manager_ , _func_addr =None_)¶
    

set_manager(_manager_)¶
    

Parameters:
    

**manager** (_VariableManager_)

serialize_to_cmessage()¶
    

Serialize the class object and returns a protobuf cmessage object.

Returns:
    

A protobuf cmessage object.

Return type:
    

protobuf.cmessage

_classmethod _parse_from_cmessage(_cmsg_ , _variable_manager =None_, _func_addr =None_, _** kwargs_)¶
    

Parse a protobuf cmessage and create a class object.

Parameters:
    

**cmsg** – The probobuf cmessage object.

Returns:
    

A unserialized class object.

Return type:
    

cls

next_variable_ident(_sort_)¶
    

add_variable(_sort_ , _start_ , _variable_)¶
    

Parameters:
    

**variable** (_SimVariable_)

set_variable(_sort_ , _start_ , _variable_)¶
    

Parameters:
    

**variable** (_SimVariable_)

write_to(_variable_ , _offset_ , _location_ , _overwrite =False_, _atom =None_)¶
    

read_from(_variable_ , _offset_ , _location_ , _overwrite =False_, _atom =None_)¶
    

reference_at(_variable_ , _offset_ , _location_ , _overwrite =False_, _atom =None_)¶
    

record_variable(_location_ , _variable_ , _offset_ , _overwrite =False_, _atom =None_)¶
    

Parameters:
    

**location** (_CodeLocation_)

remove_variable_by_atom(_location_ , _variable_ , _atom_)¶
    

Parameters:
    

  * **location** (_CodeLocation_)

  * **variable** (_SimVariable_)

make_phi_node(_block_addr_ , _* variables_)¶
    

Create a phi variable for variables at block block_addr.

Parameters:
    

  * **block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address of the current block.

  * **variables** – Variables that the phi variable represents.

Returns:
    

The created phi variable.

set_live_variables(_addr_ , _register_region_ , _stack_region_)¶
    

find_variables_by_insn(_ins_addr_ , _sort_)¶
    

is_variable_used_at(_variable_ , _loc_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

  * **variable** (_SimVariable_)

  * **loc** ([_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]_)

find_variable_by_stmt(_block_addr_ , _stmt_idx_ , _sort_ , _block_idx =None_)¶
    

Parameters:
    

**block_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

find_variables_by_stmt(_block_addr_ , _stmt_idx_ , _sort_ , _block_idx =None_)¶
    

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`SimVariable`, [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]]

Parameters:
    

  * **block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **sort** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **block_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

find_variable_by_atom(_block_addr_ , _stmt_idx_ , _atom_ , _block_idx =None_)¶
    

Parameters:
    

**block_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

find_variables_by_atom(_block_addr_ , _stmt_idx_ , _atom_ , _block_idx =None_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`SimVariable`, [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]]

Parameters:
    

**block_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

find_variables_by_stack_offset(_offset_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`SimVariable`]

Parameters:
    

**offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

find_variables_by_register(_reg_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`SimVariable`]

Parameters:
    

**reg** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_variable_accesses(_variable_ , _same_name =False_)¶
    

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`VariableAccess`]

Parameters:
    

  * **variable** (_SimVariable_)

  * **same_name** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

get_variables(_sort =None_, _collapse_same_ident =False_)¶
    

Get a list of variables.

Parameters:
    

  * **sort** – Sort of the variable to get.

  * **collapse_same_ident** – Whether variables of the same identifier should be collapsed or not.

Returns:
    

A list of variables.

get_unified_variables(_sort =None_)¶
    

Get a list of unified variables.

Parameters:
    

**sort** – Sort of the variable to get.

Returns:
    

A list of variables.

get_global_variables(_addr_)¶
    

Get global variable by the address of the variable.

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the variable.

Returns:
    

A set of variables or an empty set if no variable exists.

is_phi_variable(_var_)¶
    

Test if var is a phi variable.

Parameters:
    

**var** (_SimVariable_) – The variable instance.

Returns:
    

True if var is a phi variable, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

get_phi_subvariables(_var_)¶
    

Get sub-variables that phi variable var represents.

Parameters:
    

**var** (_SimVariable_) – The variable instance.

Returns:
    

A set of sub-variables, or an empty set if var is not a phi variable.

Return type:
    

[set](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")

get_phi_variables(_block_addr_)¶
    

Get a dict of phi variables and their corresponding variables.

Parameters:
    

**block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the block.

Returns:
    

A dict of phi variables of an empty dict if there are no phi variables at the block.

Return type:
    

[dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")

get_variables_without_writes()¶
    

Get all variables that have never been written to.

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`SimVariable`]

Returns:
    

A list of variables that are never written to.

input_variables(_exclude_specials =True_)¶
    

Get all variables that have never been written to.

Returns:
    

A list of variables that are never written to.

Parameters:
    

**exclude_specials** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

assign_variable_names(_labels =None_, _types =None_)¶
    

Assign default names to all SSA variables.

Parameters:
    

**labels** – Known labels in the binary.

Returns:
    

None

assign_unified_variable_names(_labels =None_, _arg_names =None_, _reset =False_, _func_blocks =None_)¶
    

Assign default names to all unified variables. If func_blocks is provided, we will find out variables that are only ever written to in Phi assignments and never used elsewhere, and put these variables at the end of the sorted list. These variables are likely completely removed during the dephication process.

Parameters:
    

  * **labels** – Known labels in the binary.

  * **arg_names** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]]) – Known argument names.

  * **reset** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Reset all variable names or not.

  * **func_blocks** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`Block`]]) – A list of function blocks of the function where these variables are accessed.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

set_variable_type(_var_ , _ty_ , _name =None_, _override_bot =True_, _all_unified =False_, _mark_manual =False_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **var** (_SimVariable_)

  * **ty** (_SimType_)

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **override_bot** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **all_unified** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **mark_manual** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

get_variable_type(_var_)¶
    

Return type:
    

`SimType` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

remove_types()¶
    

unify_variables(_interference =None_)¶
    

Map SSA variables to a unified variable. Fill in self._unified_variables.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**interference** (_DiGraph_ _|__None_)

set_unified_variable(_variable_ , _unified_)¶
    

Set the unified variable for a given SSA variable.

Parameters:
    

  * **variable** (`SimVariable`) – The SSA variable.

  * **unified** (`SimVariable`) – The unified variable.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

None

unified_variable(_variable_)¶
    

Return the unified variable for a given SSA variable,

Parameters:
    

**variable** (`SimVariable`) – The SSA variable.

Return type:
    

`SimVariable` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

The unified variable, or None if there is no such SSA variable.

get_stackvar_max_sizes(_stack_items_)¶
    

Get the maximum size of each stack variable regardless of the type of each stack variable, under the assumption that stack variables do not overlap.

Return type:
    

[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[`SimStackVariable`, [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]

Returns:
    

A dictionary from SimStackVariable to its maximum size.

Parameters:
    

**stack_items** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__StackItem_ _]_)

_class _angr.knowledge_plugins.variables.variable_manager.VariableManager(_kb_)¶
    

Bases: `KnowledgeBasePlugin`

Manage variables.

__init__(_kb_)¶
    

has_function_manager(_key_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**key** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_function_manager(_func_addr_)¶
    

Return type:
    

`VariableManagerInternal`

initialize_variable_names()¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

get_variable_accesses(_variable_ , _same_name =False_)¶
    

Get a list of all references to the given variable.

Parameters:
    

  * **variable** (`SimVariable`) – The variable.

  * **same_name** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether to include all variables with the same variable name, or just based on the variable identifier.

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`VariableAccess`]

Returns:
    

All references to the variable.

copy()¶
    

_static _convert_variable_list(_vlist_ , _manager_)¶
    

Parameters:
    

  * **vlist** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_Variable_](https://docs.angr.io/projects/cle/en/latest/api/backends/elf.html#cle.backends.elf.variable.Variable "\(in cle\)") _]_)

  * **manager** (_VariableManagerInternal_)

load_from_dwarf(_cu_list =None_)¶
    

Parameters:
    

**cu_list** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_CompilationUnit_](https://docs.angr.io/projects/cle/en/latest/api/backends/elf.html#cle.backends.elf.compilation_unit.CompilationUnit "\(in cle\)") _]__|__None_)

_class _angr.knowledge_plugins.debug_variables.DebugVariableContainer¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Variable tree for variables with same name to lock up which variable is visible at a given program counter address.

__init__()¶
    

It is recommended to use DebugVariableManager.add_variable() instead

from_pc(_pc_)¶
    

Returns the visible variable (if any) for a given pc address.

Return type:
    

[`Variable`](https://docs.angr.io/projects/cle/en/latest/api/backends/elf.html#cle.backends.elf.variable.Variable "\(in cle\)")

_class _angr.knowledge_plugins.debug_variables.DebugVariable(_low_pc_ , _high_pc_ , _cle_variable_)¶
    

Bases: `DebugVariableContainer`

Variables:
    

  * **low_pc** – Start of the visibility scope of the variable as program counter address (rebased)

  * **high_pc** – End of the visibility scope of the variable as program counter address (rebased)

  * **cle_variable** – Original variable from cle

Parameters:
    

  * **low_pc** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **high_pc** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **cle_variable** (_Variable_)

__init__(_low_pc_ , _high_pc_ , _cle_variable_)¶
    

It is recommended to use DebugVariableManager.add_variable() instead

Parameters:
    

  * **low_pc** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **high_pc** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **cle_variable** ([_Variable_](https://docs.angr.io/projects/cle/en/latest/api/backends/elf.html#cle.backends.elf.variable.Variable "\(in cle\)"))

from_pc(_pc_)¶
    

Returns the visible variable (if any) for a given pc address.

Return type:
    

[`Variable`](https://docs.angr.io/projects/cle/en/latest/api/backends/elf.html#cle.backends.elf.variable.Variable "\(in cle\)")

contains(_dvar_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**dvar** (_DebugVariable_)

test_unsupported_overlap(_dvar_)¶
    

Test for an unsupported overlapping

Parameters:
    

**dvar** (`DebugVariable`) – Second DebugVariable to compare with

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

True if there is an unsupported overlapping

_class _angr.knowledge_plugins.debug_variables.DebugVariableManager(_kb_)¶
    

Bases: `KnowledgeBasePlugin`

Structure to manage and access variables with different visibility scopes.

Parameters:
    

**kb** (_KnowledgeBase_)

__init__(_kb_)¶
    

Parameters:
    

**kb** (_KnowledgeBase_)

from_name_and_pc(_var_name_ , _pc_addr_)¶
    

Get a variable from its string in the scope of pc.

Return type:
    

[`Variable`](https://docs.angr.io/projects/cle/en/latest/api/backends/elf.html#cle.backends.elf.variable.Variable "\(in cle\)")

Parameters:
    

  * **var_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **pc_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

from_name(_var_name_)¶
    

Get the variable container for all variables named var_name

Parameters:
    

**var_name** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – name for a variable

Return type:
    

`DebugVariableContainer`

add_variable(_cle_var_ , _low_pc_ , _high_pc_)¶
    

Add/load a variable

Parameters:
    

  * **cle_variable** – The variable to add

  * **low_pc** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Start of the visibility scope of the variable as program counter address (rebased)

  * **high_pc** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – End of the visibility scope of the variable as program counter address (rebased)

  * **cle_var** ([_Variable_](https://docs.angr.io/projects/cle/en/latest/api/backends/elf.html#cle.backends.elf.variable.Variable "\(in cle\)"))

add_variable_list(_vlist_ , _low_pc_ , _high_pc_)¶
    

Add all variables in a list with the same visibility range

Parameters:
    

  * **vlist** ([`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`Variable`](https://docs.angr.io/projects/cle/en/latest/api/backends/elf.html#cle.backends.elf.variable.Variable "\(in cle\)")]) – A list of cle variables to add

  * **low_pc** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Start of the visibility scope as program counter address (rebased)

  * **high_pc** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – End of the visibility scope as program counter address (rebased)

load_from_dwarf(_elf_object =None_, _cu =None_)¶
    

Automatically load all variables (global/local) from the DWARF debugging info

Parameters:
    

  * **elf_object** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`ELF`](https://docs.angr.io/projects/cle/en/latest/api/backends/elf.html#cle.backends.ELF "\(in cle\)")]) – Optional, when only one elf object should be considered (e.g. p.loader.main_object)

  * **cu** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`CompilationUnit`](https://docs.angr.io/projects/cle/en/latest/api/backends/elf.html#cle.backends.elf.compilation_unit.CompilationUnit "\(in cle\)")]) – Optional, when only one compilation unit should be considered

_class _angr.knowledge_plugins.structured_code.StructuredCodeManager(_kb_)¶
    

Bases: `KnowledgeBasePlugin`

A knowledge base plugin to store structured code generator results.

__init__(_kb_)¶
    

discard(_key_)¶
    

available_flavors(_item_)¶
    

copy()¶
    

_class _angr.knowledge_plugins.key_definitions.Definition(_atom_ , _codeloc_ , _dummy =False_, _tags =None_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`A`]

An atom definition.

Variables:
    

  * **atom** – The atom being defined.

  * **codeloc** – Where this definition is created in the original binary code.

  * **dummy** – Tell whether the definition should be considered dummy or not. During simplification by AILment, definitions marked as dummy will not be removed.

  * **tags** – A set of tags containing information about the definition gathered during analyses.

Parameters:
    

  * **atom** (_A_)

  * **codeloc** (_CodeLocation_)

  * **dummy** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **tags** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Tag_ _]__|__None_)

__init__(_atom_ , _codeloc_ , _dummy =False_, _tags =None_)¶
    

Parameters:
    

  * **atom** (_A_)

  * **codeloc** (_CodeLocation_)

  * **dummy** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **tags** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Tag_ _]__|__None_)

atom _: [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`A`, bound= `Atom`)_¶
    

codeloc _: `CodeLocation`_¶
    

dummy _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

tags¶
    

_property _offset _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_property _size _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

matches(_** kwargs_)¶
    

Return whether this definition has certain characteristics.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.knowledge_plugins.key_definitions.DerefSize(_value_)¶
    

Bases: [`Enum`](https://docs.python.org/3/library/enum.html#enum.Enum "\(in Python v3.13\)")

An enum for specialized kinds of dereferences

NULL_TERMINATE - Dereference until the first byte which could be a literal null. Return a value including the
    

terminator.

NULL_TERMINATE _ = 1_¶
    

_class _angr.knowledge_plugins.key_definitions.KeyDefinitionManager(_kb_)¶
    

Bases: `KnowledgeBasePlugin`

KeyDefinitionManager manages and caches reaching definition models for each function.

For each function, by default we cache the entire reaching definitions model with observed results at the following locations: \- Before each call instruction: (‘insn’, address of the call instruction, OP_BEFORE) \- After returning from each call: (‘node’, address of the block that ends with a call, OP_AFTER)

Parameters:
    

**kb** (_KnowledgeBase_)

__init__(_kb_)¶
    

Parameters:
    

**kb** (_KnowledgeBase_)

has_model(_func_addr_)¶
    

Parameters:
    

**func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_model(_func_addr_)¶
    

Parameters:
    

**func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

copy()¶
    

Return type:
    

`KeyDefinitionManager`

_class _angr.knowledge_plugins.key_definitions.LiveDefinitions(_arch_ , _track_tmps =False_, _canonical_size =8_, _registers =None_, _stack =None_, _memory =None_, _heap =None_, _tmps =None_, _others =None_, _register_uses =None_, _stack_uses =None_, _heap_uses =None_, _memory_uses =None_, _tmp_uses =None_, _other_uses =None_, _element_limit =5_, _merge_into_tops =True_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A LiveDefinitions instance contains definitions and uses for register, stack, memory, and temporary variables, uncovered during the analysis.

Parameters:
    

  * **arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

  * **track_tmps** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **merge_into_tops** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

INITIAL_SP_32BIT _ = 2147418112_¶
    

INITIAL_SP_64BIT _ = 140737488289792_¶
    

__init__(_arch_ , _track_tmps =False_, _canonical_size =8_, _registers =None_, _stack =None_, _memory =None_, _heap =None_, _tmps =None_, _others =None_, _register_uses =None_, _stack_uses =None_, _heap_uses =None_, _memory_uses =None_, _tmp_uses =None_, _other_uses =None_, _element_limit =5_, _merge_into_tops =True_)¶
    

Parameters:
    

  * **arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)"))

  * **track_tmps** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **merge_into_tops** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

project _: `Project` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

arch¶
    

track_tmps¶
    

registers _: `MultiValuedMemory`_¶
    

stack _: `MultiValuedMemory`_¶
    

memory _: `MultiValuedMemory`_¶
    

heap _: `MultiValuedMemory`_¶
    

tmps _: [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]]_¶
    

others _: [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[`Atom`, `MultiValues`]_¶
    

register_uses¶
    

stack_uses¶
    

heap_uses¶
    

memory_uses¶
    

tmp_uses _: [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`CodeLocation`]]_¶
    

other_uses¶
    

uses_by_codeloc _: [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[`CodeLocation`, [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]]_¶
    

copy(_discard_tmpdefs =False_)¶
    

Return type:
    

`LiveDefinitions`

reset_uses()¶
    

_static _top(_bits_)¶
    

Get a TOP value.

Parameters:
    

**bits** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Width of the TOP value (in bits).

Returns:
    

The TOP value.

_static _is_top(_expr_)¶
    

Check if the given expression is a TOP value.

Parameters:
    

**expr** – The given expression.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

True if the expression is TOP, False otherwise.

stack_address(_offset_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

**offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_static _is_stack_address(_addr_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**addr** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

_static _get_stack_offset(_addr_ , _had_stack_base =False_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**addr** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

_static _annotate_with_def(_symvar_ , _definition_)¶
    

Parameters:
    

  * **symvar** ([`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`MVType`, bound= [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`FP`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)")))

  * **definition** (`Definition`)

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`MVType`, bound= [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`FP`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)"))

Returns:
    

_static _extract_defs(_symvar_)¶
    

Return type:
    

[`Generator`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Generator "\(in Python v3.13\)")[`Definition`]

Parameters:
    

**symvar** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

_static _extract_defs_from_annotations(_annos_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]

Parameters:
    

**annos** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[_[_Annotation_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.annotation.Annotation "\(in claripy\)") _]_)

_static _extract_defs_from_mv(_mv_)¶
    

Return type:
    

[`Generator`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Generator "\(in Python v3.13\)")[`Definition`]

Parameters:
    

**mv** (_MultiValues_)

get_sp()¶
    

Return the concrete value contained by the stack pointer.

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

get_sp_offset()¶
    

Return the offset of the stack pointer.

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

get_stack_address(_offset_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**offset** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

stack_offset_to_stack_addr(_offset_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

merge(_* others_)¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`LiveDefinitions`, [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")]

Parameters:
    

**others** (_LiveDefinitions_)

compare(_other_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**other** (_LiveDefinitions_)

kill_definitions(_atom_)¶
    

Overwrite existing definitions w.r.t ‘atom’ with a dummy definition instance. A dummy definition will not be removed during simplification.

Parameters:
    

**atom** (`Atom`)

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

None

kill_and_add_definition(_atom_ , _code_loc_ , _data_ , _dummy =False_, _tags =None_, _endness =None_, _annotated =False_)¶
    

Return type:
    

`MultiValues` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **atom** (_Atom_)

  * **code_loc** (_CodeLocation_)

  * **data** (_MultiValues_)

  * **tags** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Tag_ _]__|__None_)

add_use(_atom_ , _code_loc_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **atom** (_Atom_)

  * **code_loc** (_CodeLocation_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_use_by_def(_definition_ , _code_loc_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **definition** (_Definition_)

  * **code_loc** (_CodeLocation_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

get_definitions(_thing_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`[`Atom`]]

Parameters:
    

**thing** (_Atom_ _|__Definition_ _[__Atom_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Atom_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _[__Atom_ _]__]__|__MultiValues_)

get_tmp_definitions(_tmp_idx_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]

Parameters:
    

**tmp_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_register_definitions(_reg_offset_ , _size_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]

Parameters:
    

  * **reg_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_stack_values(_stack_offset_ , _size_ , _endness_)¶
    

Return type:
    

`MultiValues` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **stack_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

get_stack_definitions(_stack_offset_ , _size_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]

Parameters:
    

  * **stack_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_heap_definitions(_heap_addr_ , _size_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]

Parameters:
    

  * **heap_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_memory_definitions(_addr_ , _size_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_values(_spec_ , _endness =None_)¶
    

Return type:
    

`MultiValues` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **spec** (_A_ _|__Definition_ _[__A_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__A_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _[__A_ _]__]_)

  * **endness** ([_Endness_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.types.Endness "\(in archinfo\)") _|__None_)

get_one_value(_spec_ , _strip_annotations =False_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **spec** (_A_ _|__Definition_ _[__A_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__A_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _[__A_ _]__]_)

  * **strip_annotations** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

get_concrete_value(_spec_ , _cast_to= <class 'int'>_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **spec** (_A_ _|__Definition_ _[__A_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__A_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _[__A_ _]__]_)

  * **cast_to** ([_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[_[_bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") _]_)

add_register_use(_reg_offset_ , _size_ , _code_loc_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **reg_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **code_loc** (_CodeLocation_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_register_use_by_def(_def__ , _code_loc_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **def_** (_Definition_)

  * **code_loc** (_CodeLocation_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_stack_use(_atom_ , _code_loc_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **atom** (_MemoryLocation_)

  * **code_loc** (_CodeLocation_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_stack_use_by_def(_def__ , _code_loc_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **def_** (_Definition_)

  * **code_loc** (_CodeLocation_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_heap_use(_atom_ , _code_loc_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **atom** (_MemoryLocation_)

  * **code_loc** (_CodeLocation_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_heap_use_by_def(_def__ , _code_loc_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **def_** (_Definition_)

  * **code_loc** (_CodeLocation_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_memory_use(_atom_ , _code_loc_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **atom** (_MemoryLocation_)

  * **code_loc** (_CodeLocation_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_memory_use_by_def(_def__ , _code_loc_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **def_** (_Definition_)

  * **code_loc** (_CodeLocation_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_tmp_use(_atom_ , _code_loc_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **atom** (_Tmp_)

  * **code_loc** (_CodeLocation_)

add_tmp_use_by_def(_def__ , _code_loc_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **def_** (_Definition_)

  * **code_loc** (_CodeLocation_)

deref(_pointer_ , _size_ , _endness =Endness.BE_)¶
    

_static _is_heap_address(_addr_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**addr** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

_static _get_heap_offset(_addr_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**addr** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

heap_address(_offset_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

**offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__HeapAddress_)

_class _angr.knowledge_plugins.key_definitions.ReachingDefinitionsModel(_func_addr =None_, _track_liveness =True_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Models the definitions, uses, and memory of a ReachingDefinitionState object

Parameters:
    

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **track_liveness** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_func_addr =None_, _track_liveness =True_)¶
    

Parameters:
    

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **track_liveness** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

add_def(_d_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**d** (_Definition_)

kill_def(_d_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**d** (_Definition_)

at_new_stmt(_codeloc_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**codeloc** (_CodeLocation_)

at_new_block(_code_loc_ , _pred_codelocs_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **code_loc** (_CodeLocation_)

  * **pred_codelocs** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__CodeLocation_ _]_)

make_liveness_snapshot()¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

find_defs_at(_code_loc_ , _op =ObservationPointType.OP_BEFORE_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]

Parameters:
    

  * **code_loc** (_CodeLocation_)

  * **op** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_defs(_atom_ , _code_loc_ , _op_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]

Parameters:
    

  * **atom** (_Atom_)

  * **code_loc** (_CodeLocation_)

  * **op** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

copy()¶
    

Return type:
    

`ReachingDefinitionsModel`

merge(_model_)¶
    

Parameters:
    

**model** (_ReachingDefinitionsModel_)

get_observation_by_insn(_ins_addr_ , _kind_)¶
    

Return type:
    

`LiveDefinitions` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__CodeLocation_)

  * **kind** (_ObservationPointType_)

get_observation_by_node(_node_addr_ , _kind_ , _node_idx =None_)¶
    

Return type:
    

`LiveDefinitions` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **node_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__CodeLocation_)

  * **kind** (_ObservationPointType_)

  * **node_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

get_observation_by_stmt(_arg1_ , _arg2_ , _arg3 =None_, _*_ , _block_idx =None_)¶
    

get_observation_by_exit(_node_addr_ , _stmt_idx_ , _src_node_idx =None_)¶
    

Return type:
    

`LiveDefinitions` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **node_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **src_node_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

_class _angr.knowledge_plugins.key_definitions.Uses(_uses_by_definition =None_, _uses_by_location =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Describes uses (including the use location and the use expression) for definitions.

Parameters:
    

  * **uses_by_definition** (_DefaultChainMapCOW_ _|__None_)

  * **uses_by_location** (_DefaultChainMapCOW_ _|__None_)

__init__(_uses_by_definition =None_, _uses_by_location =None_)¶
    

Parameters:
    

  * **uses_by_definition** (_DefaultChainMapCOW_ _|__None_)

  * **uses_by_location** (_DefaultChainMapCOW_ _|__None_)

add_use(_definition_ , _codeloc_ , _expr =None_)¶
    

Add a use for a given definition.

Parameters:
    

  * **definition** (`Definition`) – The definition that is used.

  * **codeloc** (`CodeLocation`) – The code location where the use occurs.

  * **expr** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]) – The expression that uses the specified definition at this location.

get_uses(_definition_)¶
    

Retrieve the uses of a given definition.

Parameters:
    

**definition** (`Definition`) – The definition for which we get the uses.

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`CodeLocation`]

get_uses_with_expr(_definition_)¶
    

Retrieve the uses and the corresponding expressions of a given definition.

Parameters:
    

**definition** (`Definition`) – The definition for which we get the uses and the corresponding expressions.

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`CodeLocation`, [`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]]

remove_use(_definition_ , _codeloc_ , _expr =None_)¶
    

Remove one use of a given definition.

Parameters:
    

  * **definition** (`Definition`) – The definition of which to remove the uses.

  * **codeloc** (`CodeLocation`) – The code location where the use is.

  * **expr** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]) – The expression that uses the definition at the given location.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

None

remove_uses(_definition_)¶
    

Remove all uses of a given definition.

Parameters:
    

**definition** (`Definition`) – The definition of which to remove the uses.

Returns:
    

None

get_uses_by_location(_codeloc_ , _exprs =False_)¶
    

Retrieve all definitions that are used at a given location.

Parameters:
    

  * **codeloc** (`CodeLocation`) – The code location.

  * **exprs** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`] | [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`Definition`, [`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]]

Returns:
    

A set of definitions that are used at the given location.

get_uses_by_insaddr(_ins_addr_ , _exprs =False_)¶
    

Retrieve all definitions that are used at a given location specified by the instruction address.

Parameters:
    

  * **ins_addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The instruction address.

  * **exprs** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`] | [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`Definition`, [`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]]

Returns:
    

A set of definitions that are used at the given location.

copy()¶
    

Copy the instance.

Return type:
    

`Uses`

Returns:
    

Return a new <Uses> instance containing the same data.

merge(_other_)¶
    

Merge an instance of <Uses> into the current instance.

Parameters:
    

**other** (`Uses`) – The other <Uses> from which the data will be added to the current instance.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

True if any merge occurred, False otherwise

_class _angr.knowledge_plugins.key_definitions.atoms.AtomKind(_value_)¶
    

Bases: [`Enum`](https://docs.python.org/3/library/enum.html#enum.Enum "\(in Python v3.13\)")

An enum indicating the class of an atom

REGISTER _ = 1_¶
    

MEMORY _ = 2_¶
    

TMP _ = 3_¶
    

GUARD _ = 4_¶
    

CONSTANT _ = 5_¶
    

_class _angr.knowledge_plugins.key_definitions.atoms.Atom(_size_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

This class represents a data storage location manipulated by IR instructions.

It could either be a Tmp (temporary variable), a Register, a MemoryLocation.

__init__(_size_)¶
    

Parameters:
    

**size** – The size of the atom in bytes

size¶
    

_property _bits _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_static _from_ail_expr(_expr_ , _arch_ , _full_reg =False_)¶
    

Return type:
    

`Register`

Parameters:
    

  * **expr** (_Expression_)

  * **arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)"))

  * **full_reg** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

_static _from_argument(_argument_ , _arch_ , _full_reg =False_, _sp =None_)¶
    

Instantiate an Atom from a given argument.

Parameters:
    

  * **argument** (`SimFunctionArgument`) – The argument to create a new atom from.

  * **arch** ([`Arch`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)")) – The argument representing archinfo architecture for argument.

  * **full_reg** – Whether to return an atom indicating the entire register if the argument only specifies a slice of the register.

  * **sp** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – The current stack offset. Optional. Only used when argument is a SimStackArg.

Return type:
    

`Register` | `MemoryLocation`

_static _reg(_thing_ , _size =None_, _arch =None_)¶
    

Create a Register atom.

Parameters:
    

  * **thing** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`RegisterOffset`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.types.RegisterOffset "\(in archinfo\)")) – The register offset (e.g., project.arch.registers[“rax”][0]) or the register name (e.g., “rax”).

  * **size** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – Size of the register atom. Must be provided when creating the atom using a register offset.

  * **arch** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`Arch`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)")]) – The architecture. Must be provided when creating the atom using a register name.

Return type:
    

`Register`

Returns:
    

The Register Atom object.

_static _register(_thing_ , _size =None_, _arch =None_)¶
    

Create a Register atom.

Parameters:
    

  * **thing** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`RegisterOffset`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.types.RegisterOffset "\(in archinfo\)")) – The register offset (e.g., project.arch.registers[“rax”][0]) or the register name (e.g., “rax”).

  * **size** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – Size of the register atom. Must be provided when creating the atom using a register offset.

  * **arch** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`Arch`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)")]) – The architecture. Must be provided when creating the atom using a register name.

Return type:
    

`Register`

Returns:
    

The Register Atom object.

_static _mem(_addr_ , _size_ , _endness =None_)¶
    

Create a MemoryLocation atom,

Parameters:
    

  * **addr** (`SpOffset` | `HeapAddress` | [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The memory location. Can be an SpOffset for stack variables, an int for global memory variables, or a HeapAddress for items on the heap.

  * **size** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Size of the atom.

  * **endness** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`Endness`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.types.Endness "\(in archinfo\)")]) – Optional, either “Iend_LE” or “Iend_BE”.

Return type:
    

`MemoryLocation`

Returns:
    

The MemoryLocation Atom object.

_static _memory(_addr_ , _size_ , _endness =None_)¶
    

Create a MemoryLocation atom,

Parameters:
    

  * **addr** (`SpOffset` | `HeapAddress` | [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The memory location. Can be an SpOffset for stack variables, an int for global memory variables, or a HeapAddress for items on the heap.

  * **size** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Size of the atom.

  * **endness** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`Endness`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.types.Endness "\(in archinfo\)")]) – Optional, either “Iend_LE” or “Iend_BE”.

Return type:
    

`MemoryLocation`

Returns:
    

The MemoryLocation Atom object.

_class _angr.knowledge_plugins.key_definitions.atoms.GuardUse(_target_)¶
    

Bases: `Atom`

Implements a guard use.

__init__(_target_)¶
    

Parameters:
    

**size** – The size of the atom in bytes

target¶
    

_class _angr.knowledge_plugins.key_definitions.atoms.ConstantSrc(_value_ , _size_)¶
    

Bases: `Atom`

Represents a constant.

Parameters:
    

  * **value** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_value_ , _size_)¶
    

Parameters:
    

  * **size** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The size of the atom in bytes

  * **value** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

value _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.knowledge_plugins.key_definitions.atoms.Tmp(_tmp_idx_ , _size_)¶
    

Bases: `Atom`

Represents a variable used by the IR to store intermediate values.

Parameters:
    

  * **tmp_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_tmp_idx_ , _size_)¶
    

Parameters:
    

  * **size** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The size of the atom in bytes

  * **tmp_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

tmp_idx¶
    

_class _angr.knowledge_plugins.key_definitions.atoms.Register(_reg_offset_ , _size_ , _arch =None_)¶
    

Bases: `Atom`

Represents a given CPU register.

As an IR abstracts the CPU design to target different architectures, registers are represented as a separated memory space. Thus a register is defined by its offset from the base of this memory and its size.

Variables:
    

  * **reg_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The offset from the base to define its place in the memory bloc.

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The size, in number of bytes.

Parameters:
    

  * **reg_offset** (_RegisterOffset_ _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **arch** (_Arch_ _|__None_)

__init__(_reg_offset_ , _size_ , _arch =None_)¶
    

Parameters:
    

  * **size** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The size of the atom in bytes

  * **reg_offset** ([_RegisterOffset_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.types.RegisterOffset "\(in archinfo\)") _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)") _|__None_)

reg_offset¶
    

arch¶
    

_property _name _: [str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")_¶
    

_class _angr.knowledge_plugins.key_definitions.atoms.VirtualVariable(_varid_ , _size_ , _category_ , _oident =None_)¶
    

Bases: `Atom`

Represents a virtual variable.

Parameters:
    

  * **varid** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **category** (_ailment.Expr.VirtualVariableCategory_)

  * **oident** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _|__None_)

__init__(_varid_ , _size_ , _category_ , _oident =None_)¶
    

Parameters:
    

  * **size** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The size of the atom in bytes

  * **varid** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **category** (_VirtualVariableCategory_)

  * **oident** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _|__None_)

varid¶
    

category¶
    

oident¶
    

_property _was_reg _: [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

_property _was_stack _: [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

_property _was_parameter _: [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

_property _was_tmp _: [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

_property _reg_offset _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

_property _stack_offset _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

_property _tmp_idx _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

_class _angr.knowledge_plugins.key_definitions.atoms.MemoryLocation(_addr_ , _size_ , _endness =None_)¶
    

Bases: `Atom`

Represents a memory slice.

It is characterized by its address and its size.

Parameters:
    

  * **addr** (_SpOffset_ _|__HeapAddress_ _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **endness** (_Endness_ _|__None_)

__init__(_addr_ , _size_ , _endness =None_)¶
    

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address of the beginning memory location slice.

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The size of the represented memory location, in bytes.

  * **endness** ([_Endness_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.types.Endness "\(in archinfo\)") _|__None_)

addr _: `SpOffset` | [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")_¶
    

endness¶
    

_property _is_on_stack _: [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

True if this memory location is located on the stack.

_property _symbolic _: [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

_class _angr.knowledge_plugins.key_definitions.constants.ObservationPointType(_value_)¶
    

Bases: [`IntEnum`](https://docs.python.org/3/library/enum.html#enum.IntEnum "\(in Python v3.13\)")

Enum to replace the previously generic constants This makes it possible to annotate where they are expected by typing something as ObservationPointType instead of Literal[0,1]

OP_BEFORE _ = 0_¶
    

OP_AFTER _ = 1_¶
    

_class _angr.knowledge_plugins.key_definitions.definition.DefinitionMatchPredicate(_kind =None_, _bbl_addr =None_, _ins_addr =None_, _variable =None_, _variable_manager =None_, _stack_offset =None_, _reg_name =None_, _heap_offset =None_, _global_addr =None_, _tmp_idx =None_, _const_val =None_, _extern =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A dataclass indicating several facts which much all must match in order for a definition to match. Largely an internal class; don’t worry about this.

Parameters:
    

  * **kind** (_AtomKind_ _|_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__Atom_ _]__|__None_)

  * **bbl_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **variable** (_SimVariable_ _|__None_)

  * **variable_manager** (_VariableManagerInternal_ _|__None_ _|_[_Literal_](https://docs.python.org/3/library/typing.html#typing.Literal "\(in Python v3.13\)") _[__False_ _]_)

  * **stack_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **reg_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **heap_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **global_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **tmp_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **const_val** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **extern** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

kind _: `AtomKind` | [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`Atom`] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

bbl_addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

ins_addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

variable _: `SimVariable` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

variable_manager _: [`Union`](https://docs.python.org/3/library/typing.html#typing.Union "\(in Python v3.13\)")[`VariableManagerInternal`, [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)"), [`Literal`](https://docs.python.org/3/library/typing.html#typing.Literal "\(in Python v3.13\)")[`False`]]__ = None_¶
    

stack_offset _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

reg_name _: [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

heap_offset _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

global_addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

tmp_idx _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

const_val _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

extern _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

_static _construct(_predicate =None_, _** kwargs_)¶
    

Return type:
    

`DefinitionMatchPredicate`

Parameters:
    

**predicate** (_DefinitionMatchPredicate_ _|__None_)

normalize()¶
    

matches(_defn_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**defn** (_Definition_)

__init__(_kind =None_, _bbl_addr =None_, _ins_addr =None_, _variable =None_, _variable_manager =None_, _stack_offset =None_, _reg_name =None_, _heap_offset =None_, _global_addr =None_, _tmp_idx =None_, _const_val =None_, _extern =None_)¶
    

Parameters:
    

  * **kind** (_AtomKind_ _|_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__Atom_ _]__|__None_)

  * **bbl_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **variable** (_SimVariable_ _|__None_)

  * **variable_manager** (_VariableManagerInternal_ _|__None_ _|_[_Literal_](https://docs.python.org/3/library/typing.html#typing.Literal "\(in Python v3.13\)") _[__False_ _]_)

  * **stack_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **reg_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **heap_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **global_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **tmp_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **const_val** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **extern** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

Return type:
    

None

_class _angr.knowledge_plugins.key_definitions.definition.Definition(_atom_ , _codeloc_ , _dummy =False_, _tags =None_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`A`]

An atom definition.

Variables:
    

  * **atom** – The atom being defined.

  * **codeloc** – Where this definition is created in the original binary code.

  * **dummy** – Tell whether the definition should be considered dummy or not. During simplification by AILment, definitions marked as dummy will not be removed.

  * **tags** – A set of tags containing information about the definition gathered during analyses.

Parameters:
    

  * **atom** (_A_)

  * **codeloc** (_CodeLocation_)

  * **dummy** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **tags** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Tag_ _]__|__None_)

__init__(_atom_ , _codeloc_ , _dummy =False_, _tags =None_)¶
    

Parameters:
    

  * **atom** (_A_)

  * **codeloc** (_CodeLocation_)

  * **dummy** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **tags** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Tag_ _]__|__None_)

atom _: [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`A`, bound= `Atom`)_¶
    

codeloc _: `CodeLocation`_¶
    

dummy _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

tags¶
    

_property _offset _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_property _size _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

matches(_** kwargs_)¶
    

Return whether this definition has certain characteristics.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.knowledge_plugins.key_definitions.environment.Environment(_environment =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Represent the environment in which a program runs. It’s a mapping of variable names, to claripy.ast.Base that should contain possible addresses, or <UNDEFINED>, at which their respective values are stored.

**Note** : The <Environment> object does not store the values associated with variables themselves.

Parameters:
    

**environment** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__Undefined_ _,_[_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_claripy.ast.Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.Base "\(in claripy\)") _]__]__|__None_)

__init__(_environment =None_)¶
    

Parameters:
    

**environment** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__Undefined_ _,_[_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)") _]__]__|__None_)

get(_names_)¶
    

Parameters:
    

**names** (`set`[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]) – Potential values for the name of the environment variable to get the pointers of.

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`set`[[`Base`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)")], [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")]

Returns:
    

The potential addresses of the values the environment variable can take; And a boolean value telling whether all the names were known of the internal representation (i.e. will be False if one of the queried variable was not found).

set(_name_ , _pointers_)¶
    

Parameters:
    

  * **name** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | `Undefined`) – Name of the environment variable to which we will associate the pointers.

  * **pointers** (`set`[[`Base`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)")]) – New addresses where the new values of the environment variable are located.

merge(_* others_)¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`Environment`, [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")]

Parameters:
    

**others** (_Environment_)

compare(_other_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**other** (_Environment_)

_class _angr.knowledge_plugins.key_definitions.heap_address.HeapAddress(_value_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

The representation of an address on the heap.

Parameters:
    

**value** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__Undefined_)

__init__(_value_)¶
    

Parameters:
    

**value** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__Undefined_)

_property _value¶
    

_class _angr.knowledge_plugins.key_definitions.key_definition_manager.RDAObserverControl(_func_addr_ , _call_site_block_addrs_ , _call_site_ins_addrs_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Parameters:
    

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **call_site_block_addrs** (_Iterable_ _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]_)

  * **call_site_ins_addrs** (_Iterable_ _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]_)

__init__(_func_addr_ , _call_site_block_addrs_ , _call_site_ins_addrs_)¶
    

Parameters:
    

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **call_site_block_addrs** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]_)

  * **call_site_ins_addrs** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]_)

rda_observe_callback(_ob_type_ , _** kwargs_)¶
    

_class _angr.knowledge_plugins.key_definitions.key_definition_manager.KeyDefinitionManager(_kb_)¶
    

Bases: `KnowledgeBasePlugin`

KeyDefinitionManager manages and caches reaching definition models for each function.

For each function, by default we cache the entire reaching definitions model with observed results at the following locations: \- Before each call instruction: (‘insn’, address of the call instruction, OP_BEFORE) \- After returning from each call: (‘node’, address of the block that ends with a call, OP_AFTER)

Parameters:
    

**kb** (_KnowledgeBase_)

__init__(_kb_)¶
    

Parameters:
    

**kb** (_KnowledgeBase_)

has_model(_func_addr_)¶
    

Parameters:
    

**func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_model(_func_addr_)¶
    

Parameters:
    

**func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

copy()¶
    

Return type:
    

`KeyDefinitionManager`

_class _angr.knowledge_plugins.key_definitions.live_definitions.DerefSize(_value_)¶
    

Bases: [`Enum`](https://docs.python.org/3/library/enum.html#enum.Enum "\(in Python v3.13\)")

An enum for specialized kinds of dereferences

NULL_TERMINATE - Dereference until the first byte which could be a literal null. Return a value including the
    

terminator.

NULL_TERMINATE _ = 1_¶
    

_class _angr.knowledge_plugins.key_definitions.live_definitions.DefinitionAnnotation(_definition_)¶
    

Bases: [`Annotation`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.annotation.Annotation "\(in claripy\)")

An annotation that attaches a Definition to an AST.

__init__(_definition_)¶
    

definition¶
    

_property _relocatable¶
    

Returns whether this annotation can be relocated in a simplification.

Returns:
    

True if it can be relocated, false otherwise.

_property _eliminatable¶
    

Returns whether this annotation can be eliminated in a simplification.

Returns:
    

True if eliminatable, False otherwise

_class _angr.knowledge_plugins.key_definitions.live_definitions.LiveDefinitions(_arch_ , _track_tmps =False_, _canonical_size =8_, _registers =None_, _stack =None_, _memory =None_, _heap =None_, _tmps =None_, _others =None_, _register_uses =None_, _stack_uses =None_, _heap_uses =None_, _memory_uses =None_, _tmp_uses =None_, _other_uses =None_, _element_limit =5_, _merge_into_tops =True_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A LiveDefinitions instance contains definitions and uses for register, stack, memory, and temporary variables, uncovered during the analysis.

Parameters:
    

  * **arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

  * **track_tmps** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **registers** (_MultiValuedMemory_)

  * **stack** (_MultiValuedMemory_)

  * **memory** (_MultiValuedMemory_)

  * **heap** (_MultiValuedMemory_)

  * **tmps** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Definition_ _]__]_)

  * **others** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__Atom_ _,__MultiValues_ _]_)

  * **tmp_uses** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__CodeLocation_ _]__]_)

  * **merge_into_tops** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

INITIAL_SP_32BIT _ = 2147418112_¶
    

INITIAL_SP_64BIT _ = 140737488289792_¶
    

__init__(_arch_ , _track_tmps =False_, _canonical_size =8_, _registers =None_, _stack =None_, _memory =None_, _heap =None_, _tmps =None_, _others =None_, _register_uses =None_, _stack_uses =None_, _heap_uses =None_, _memory_uses =None_, _tmp_uses =None_, _other_uses =None_, _element_limit =5_, _merge_into_tops =True_)¶
    

Parameters:
    

  * **arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)"))

  * **track_tmps** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **merge_into_tops** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

project _: `Project` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

arch¶
    

track_tmps¶
    

registers _: `MultiValuedMemory`_¶
    

stack _: `MultiValuedMemory`_¶
    

memory _: `MultiValuedMemory`_¶
    

heap _: `MultiValuedMemory`_¶
    

tmps _: [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]]_¶
    

others _: [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[`Atom`, `MultiValues`]_¶
    

register_uses¶
    

stack_uses¶
    

heap_uses¶
    

memory_uses¶
    

tmp_uses _: [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`CodeLocation`]]_¶
    

other_uses¶
    

uses_by_codeloc _: [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[`CodeLocation`, [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]]_¶
    

copy(_discard_tmpdefs =False_)¶
    

Return type:
    

`LiveDefinitions`

reset_uses()¶
    

_static _top(_bits_)¶
    

Get a TOP value.

Parameters:
    

**bits** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Width of the TOP value (in bits).

Returns:
    

The TOP value.

_static _is_top(_expr_)¶
    

Check if the given expression is a TOP value.

Parameters:
    

**expr** – The given expression.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

True if the expression is TOP, False otherwise.

stack_address(_offset_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

**offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_static _is_stack_address(_addr_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**addr** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

_static _get_stack_offset(_addr_ , _had_stack_base =False_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**addr** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

_static _annotate_with_def(_symvar_ , _definition_)¶
    

Parameters:
    

  * **symvar** ([`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`MVType`, bound= [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`FP`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)")))

  * **definition** (`Definition`)

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`MVType`, bound= [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`FP`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)"))

Returns:
    

_static _extract_defs(_symvar_)¶
    

Return type:
    

[`Generator`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Generator "\(in Python v3.13\)")[`Definition`]

Parameters:
    

**symvar** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

_static _extract_defs_from_annotations(_annos_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]

Parameters:
    

**annos** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[_[_Annotation_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.annotation.Annotation "\(in claripy\)") _]_)

_static _extract_defs_from_mv(_mv_)¶
    

Return type:
    

[`Generator`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Generator "\(in Python v3.13\)")[`Definition`]

Parameters:
    

**mv** (_MultiValues_)

get_sp()¶
    

Return the concrete value contained by the stack pointer.

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

get_sp_offset()¶
    

Return the offset of the stack pointer.

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

get_stack_address(_offset_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**offset** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

stack_offset_to_stack_addr(_offset_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

merge(_* others_)¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`LiveDefinitions`, [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")]

Parameters:
    

**others** (_LiveDefinitions_)

compare(_other_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**other** (_LiveDefinitions_)

kill_definitions(_atom_)¶
    

Overwrite existing definitions w.r.t ‘atom’ with a dummy definition instance. A dummy definition will not be removed during simplification.

Parameters:
    

**atom** (`Atom`)

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

None

kill_and_add_definition(_atom_ , _code_loc_ , _data_ , _dummy =False_, _tags =None_, _endness =None_, _annotated =False_)¶
    

Return type:
    

`MultiValues` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **atom** (_Atom_)

  * **code_loc** (_CodeLocation_)

  * **data** (_MultiValues_)

  * **tags** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Tag_ _]__|__None_)

add_use(_atom_ , _code_loc_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **atom** (_Atom_)

  * **code_loc** (_CodeLocation_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_use_by_def(_definition_ , _code_loc_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **definition** (_Definition_)

  * **code_loc** (_CodeLocation_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

get_definitions(_thing_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`[`Atom`]]

Parameters:
    

**thing** (_Atom_ _|__Definition_ _[__Atom_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Atom_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _[__Atom_ _]__]__|__MultiValues_)

get_tmp_definitions(_tmp_idx_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]

Parameters:
    

**tmp_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_register_definitions(_reg_offset_ , _size_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]

Parameters:
    

  * **reg_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_stack_values(_stack_offset_ , _size_ , _endness_)¶
    

Return type:
    

`MultiValues` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **stack_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

get_stack_definitions(_stack_offset_ , _size_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]

Parameters:
    

  * **stack_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_heap_definitions(_heap_addr_ , _size_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]

Parameters:
    

  * **heap_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_memory_definitions(_addr_ , _size_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_values(_spec_ , _endness =None_)¶
    

Return type:
    

`MultiValues` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **spec** (_A_ _|__Definition_ _[__A_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__A_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _[__A_ _]__]_)

  * **endness** ([_Endness_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.types.Endness "\(in archinfo\)") _|__None_)

get_one_value(_spec_ , _strip_annotations =False_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **spec** (_A_ _|__Definition_ _[__A_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__A_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _[__A_ _]__]_)

  * **strip_annotations** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

get_concrete_value(_spec_ , _cast_to= <class 'int'>_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **spec** (_A_ _|__Definition_ _[__A_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__A_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _[__A_ _]__]_)

  * **cast_to** ([_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[_[_bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") _]_)

add_register_use(_reg_offset_ , _size_ , _code_loc_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **reg_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **code_loc** (_CodeLocation_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_register_use_by_def(_def__ , _code_loc_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **def_** (_Definition_)

  * **code_loc** (_CodeLocation_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_stack_use(_atom_ , _code_loc_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **atom** (_MemoryLocation_)

  * **code_loc** (_CodeLocation_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_stack_use_by_def(_def__ , _code_loc_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **def_** (_Definition_)

  * **code_loc** (_CodeLocation_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_heap_use(_atom_ , _code_loc_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **atom** (_MemoryLocation_)

  * **code_loc** (_CodeLocation_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_heap_use_by_def(_def__ , _code_loc_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **def_** (_Definition_)

  * **code_loc** (_CodeLocation_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_memory_use(_atom_ , _code_loc_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **atom** (_MemoryLocation_)

  * **code_loc** (_CodeLocation_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_memory_use_by_def(_def__ , _code_loc_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **def_** (_Definition_)

  * **code_loc** (_CodeLocation_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_tmp_use(_atom_ , _code_loc_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **atom** (_Tmp_)

  * **code_loc** (_CodeLocation_)

add_tmp_use_by_def(_def__ , _code_loc_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **def_** (_Definition_)

  * **code_loc** (_CodeLocation_)

deref(_pointer_ , _size_ , _endness =Endness.BE_)¶
    

_static _is_heap_address(_addr_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**addr** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

_static _get_heap_offset(_addr_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**addr** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

heap_address(_offset_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

**offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__HeapAddress_)

_class _angr.knowledge_plugins.key_definitions.rd_model.ReachingDefinitionsModel(_func_addr =None_, _track_liveness =True_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Models the definitions, uses, and memory of a ReachingDefinitionState object

Parameters:
    

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **track_liveness** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_func_addr =None_, _track_liveness =True_)¶
    

Parameters:
    

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **track_liveness** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

add_def(_d_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**d** (_Definition_)

kill_def(_d_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**d** (_Definition_)

at_new_stmt(_codeloc_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**codeloc** (_CodeLocation_)

at_new_block(_code_loc_ , _pred_codelocs_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **code_loc** (_CodeLocation_)

  * **pred_codelocs** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__CodeLocation_ _]_)

make_liveness_snapshot()¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

find_defs_at(_code_loc_ , _op =ObservationPointType.OP_BEFORE_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]

Parameters:
    

  * **code_loc** (_CodeLocation_)

  * **op** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_defs(_atom_ , _code_loc_ , _op_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]

Parameters:
    

  * **atom** (_Atom_)

  * **code_loc** (_CodeLocation_)

  * **op** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

copy()¶
    

Return type:
    

`ReachingDefinitionsModel`

merge(_model_)¶
    

Parameters:
    

**model** (_ReachingDefinitionsModel_)

get_observation_by_insn(_ins_addr_ , _kind_)¶
    

Return type:
    

`LiveDefinitions` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__CodeLocation_)

  * **kind** (_ObservationPointType_)

get_observation_by_node(_node_addr_ , _kind_ , _node_idx =None_)¶
    

Return type:
    

`LiveDefinitions` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **node_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__CodeLocation_)

  * **kind** (_ObservationPointType_)

  * **node_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

get_observation_by_stmt(_arg1_ , _arg2_ , _arg3 =None_, _*_ , _block_idx =None_)¶
    

get_observation_by_exit(_node_addr_ , _stmt_idx_ , _src_node_idx =None_)¶
    

Return type:
    

`LiveDefinitions` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **node_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **src_node_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

Classes to structure the different types of <Tag>s that can be attached to <Definition>s.

  * Tag
    
    * FunctionTag
    
      * ParameterTag

      * LocalVariableTag

      * ReturnValueTag

    * InitialValueTag

_class _angr.knowledge_plugins.key_definitions.tag.Tag(_metadata =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A tag for a Definition that can carry different kinds of metadata.

Parameters:
    

**metadata** ([_object_](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)"))

__init__(_metadata =None_)¶
    

Parameters:
    

**metadata** ([_object_](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)") _|__None_)

_class _angr.knowledge_plugins.key_definitions.tag.FunctionTag(_function =None_, _metadata =None_)¶
    

Bases: `Tag`

A tag for a definition created (or used) in the context of a function.

Parameters:
    

  * **function** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **metadata** ([_object_](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)"))

__init__(_function =None_, _metadata =None_)¶
    

Parameters:
    

  * **function** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **metadata** ([_object_](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)") _|__None_)

_class _angr.knowledge_plugins.key_definitions.tag.SideEffectTag(_function =None_, _metadata =None_)¶
    

Bases: `FunctionTag`

A tag for a definition created or used as a side-effect of a function.

Example: The <MemoryLocation> pointed by rdi during a sprintf.

Parameters:
    

  * **function** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **metadata** ([_object_](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)"))

_class _angr.knowledge_plugins.key_definitions.tag.ParameterTag(_function =None_, _metadata =None_)¶
    

Bases: `FunctionTag`

A tag for a definition of a parameter.

Parameters:
    

  * **function** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **metadata** ([_object_](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)"))

_class _angr.knowledge_plugins.key_definitions.tag.LocalVariableTag(_function =None_, _metadata =None_)¶
    

Bases: `FunctionTag`

A tag for a definition of a local variable of a function.

Parameters:
    

  * **function** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **metadata** ([_object_](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)"))

_class _angr.knowledge_plugins.key_definitions.tag.ReturnValueTag(_function =None_, _metadata =None_)¶
    

Bases: `FunctionTag`

A tag for a definition of a return value of a function.

Parameters:
    

  * **function** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **metadata** ([_object_](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)"))

_class _angr.knowledge_plugins.key_definitions.tag.InitialValueTag(_metadata =None_)¶
    

Bases: `Tag`

A tag for a definition of an initial value

Parameters:
    

**metadata** ([_object_](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)"))

_class _angr.knowledge_plugins.key_definitions.tag.UnknownSizeTag(_metadata =None_)¶
    

Bases: `Tag`

A tag for a definition of an initial value

Parameters:
    

**metadata** ([_object_](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)"))

_class _angr.knowledge_plugins.key_definitions.undefined.Undefined¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A TOP-like value indicating an unknown data source. Should live next to raw integers in DataSets.

_class _angr.knowledge_plugins.key_definitions.unknown_size.UnknownSize¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A value indicating an unknown size for elements of DataSets. Should “behave” like an integer.

_class _angr.knowledge_plugins.key_definitions.uses.Uses(_uses_by_definition =None_, _uses_by_location =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Describes uses (including the use location and the use expression) for definitions.

Parameters:
    

  * **uses_by_definition** (_DefaultChainMapCOW_ _|__None_)

  * **uses_by_location** (_DefaultChainMapCOW_ _|__None_)

__init__(_uses_by_definition =None_, _uses_by_location =None_)¶
    

Parameters:
    

  * **uses_by_definition** (_DefaultChainMapCOW_ _|__None_)

  * **uses_by_location** (_DefaultChainMapCOW_ _|__None_)

add_use(_definition_ , _codeloc_ , _expr =None_)¶
    

Add a use for a given definition.

Parameters:
    

  * **definition** (`Definition`) – The definition that is used.

  * **codeloc** (`CodeLocation`) – The code location where the use occurs.

  * **expr** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]) – The expression that uses the specified definition at this location.

get_uses(_definition_)¶
    

Retrieve the uses of a given definition.

Parameters:
    

**definition** (`Definition`) – The definition for which we get the uses.

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`CodeLocation`]

get_uses_with_expr(_definition_)¶
    

Retrieve the uses and the corresponding expressions of a given definition.

Parameters:
    

**definition** (`Definition`) – The definition for which we get the uses and the corresponding expressions.

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`CodeLocation`, [`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]]

remove_use(_definition_ , _codeloc_ , _expr =None_)¶
    

Remove one use of a given definition.

Parameters:
    

  * **definition** (`Definition`) – The definition of which to remove the uses.

  * **codeloc** (`CodeLocation`) – The code location where the use is.

  * **expr** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]) – The expression that uses the definition at the given location.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

None

remove_uses(_definition_)¶
    

Remove all uses of a given definition.

Parameters:
    

**definition** (`Definition`) – The definition of which to remove the uses.

Returns:
    

None

get_uses_by_location(_codeloc_ , _exprs =False_)¶
    

Retrieve all definitions that are used at a given location.

Parameters:
    

  * **codeloc** (`CodeLocation`) – The code location.

  * **exprs** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`] | [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`Definition`, [`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]]

Returns:
    

A set of definitions that are used at the given location.

get_uses_by_insaddr(_ins_addr_ , _exprs =False_)¶
    

Retrieve all definitions that are used at a given location specified by the instruction address.

Parameters:
    

  * **ins_addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The instruction address.

  * **exprs** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`] | [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`Definition`, [`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]]

Returns:
    

A set of definitions that are used at the given location.

copy()¶
    

Copy the instance.

Return type:
    

`Uses`

Returns:
    

Return a new <Uses> instance containing the same data.

merge(_other_)¶
    

Merge an instance of <Uses> into the current instance.

Parameters:
    

**other** (`Uses`) – The other <Uses> from which the data will be added to the current instance.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

True if any merge occurred, False otherwise

_class _angr.knowledge_plugins.xrefs.XRef(_ins_addr =None_, _block_addr =None_, _stmt_idx =None_, _insn_op_idx =None_, _memory_data =None_, _dst =None_, _xref_type =None_)¶
    

Bases: `Serializable`

XRef describes a reference to a MemoryData instance (if a MemoryData instance is available) or just an address.

Parameters:
    

  * **ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **insn_op_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **dst** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_ins_addr =None_, _block_addr =None_, _stmt_idx =None_, _insn_op_idx =None_, _memory_data =None_, _dst =None_, _xref_type =None_)¶
    

Parameters:
    

  * **ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **insn_op_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **dst** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

ins_addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

insn_op_idx _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

block_addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

stmt_idx _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

memory_data¶
    

type¶
    

dst¶
    

_property _type_string¶
    

serialize_to_cmessage()¶
    

Serialize the class object and returns a protobuf cmessage object.

Returns:
    

A protobuf cmessage object.

Return type:
    

protobuf.cmessage

_classmethod _parse_from_cmessage(_cmsg_ , _bits =None_, _** kwargs_)¶
    

Parse a protobuf cmessage and create a class object.

Parameters:
    

**cmsg** – The probobuf cmessage object.

Returns:
    

A unserialized class object.

Return type:
    

cls

copy()¶
    

insn_op_type¶
    

_class _angr.knowledge_plugins.xrefs.XRefManager(_kb_)¶
    

Bases: `KnowledgeBasePlugin`, `Serializable`

__init__(_kb_)¶
    

copy()¶
    

clear()¶
    

add_xref(_xref_)¶
    

add_xrefs(_xrefs_)¶
    

get_xrefs_by_ins_addr(_ins_addr_)¶
    

get_xrefs_by_dst(_dst_)¶
    

get_xrefs_by_dst_region(_start_ , _end_)¶
    

Get a set of XRef objects that point to a given address region bounded by start and end. Will only return absolute xrefs, not relative ones (like SP offsets)

get_xrefs_by_ins_addr_region(_start_ , _end_)¶
    

Get a set of XRef objects that originate at a given address region bounded by start and end. Useful for finding references from a basic block or function.

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`XRef`]

serialize_to_cmessage()¶
    

Serialize the class object and returns a protobuf cmessage object.

Returns:
    

A protobuf cmessage object.

Return type:
    

protobuf.cmessage

_classmethod _parse_from_cmessage(_cmsg_ , _cfg_model =None_, _kb =None_, _** kwargs_)¶
    

Parse a protobuf cmessage and create a class object.

Parameters:
    

**cmsg** – The probobuf cmessage object.

Returns:
    

A unserialized class object.

Return type:
    

cls

_class _angr.knowledge_plugins.xrefs.XRefType¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Offset _ = 0_¶
    

Read _ = 1_¶
    

Write _ = 2_¶
    

_static _to_string(_ty_)¶
    

_class _angr.knowledge_plugins.xrefs.xref.XRef(_ins_addr =None_, _block_addr =None_, _stmt_idx =None_, _insn_op_idx =None_, _memory_data =None_, _dst =None_, _xref_type =None_)¶
    

Bases: `Serializable`

XRef describes a reference to a MemoryData instance (if a MemoryData instance is available) or just an address.

Parameters:
    

  * **ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **insn_op_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **dst** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_ins_addr =None_, _block_addr =None_, _stmt_idx =None_, _insn_op_idx =None_, _memory_data =None_, _dst =None_, _xref_type =None_)¶
    

Parameters:
    

  * **ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **insn_op_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **dst** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

ins_addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

insn_op_idx _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

block_addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

stmt_idx _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

memory_data¶
    

type¶
    

dst¶
    

_property _type_string¶
    

serialize_to_cmessage()¶
    

Serialize the class object and returns a protobuf cmessage object.

Returns:
    

A protobuf cmessage object.

Return type:
    

protobuf.cmessage

_classmethod _parse_from_cmessage(_cmsg_ , _bits =None_, _** kwargs_)¶
    

Parse a protobuf cmessage and create a class object.

Parameters:
    

**cmsg** – The probobuf cmessage object.

Returns:
    

A unserialized class object.

Return type:
    

cls

copy()¶
    

insn_op_type¶
    

_class _angr.knowledge_plugins.xrefs.xref_types.XRefType¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Offset _ = 0_¶
    

Read _ = 1_¶
    

Write _ = 2_¶
    

_static _to_string(_ty_)¶
    

_class _angr.knowledge_plugins.xrefs.xref_manager.XRefManager(_kb_)¶
    

Bases: `KnowledgeBasePlugin`, `Serializable`

__init__(_kb_)¶
    

copy()¶
    

clear()¶
    

add_xref(_xref_)¶
    

add_xrefs(_xrefs_)¶
    

get_xrefs_by_ins_addr(_ins_addr_)¶
    

get_xrefs_by_dst(_dst_)¶
    

get_xrefs_by_dst_region(_start_ , _end_)¶
    

Get a set of XRef objects that point to a given address region bounded by start and end. Will only return absolute xrefs, not relative ones (like SP offsets)

get_xrefs_by_ins_addr_region(_start_ , _end_)¶
    

Get a set of XRef objects that originate at a given address region bounded by start and end. Useful for finding references from a basic block or function.

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`XRef`]

serialize_to_cmessage()¶
    

Serialize the class object and returns a protobuf cmessage object.

Returns:
    

A protobuf cmessage object.

Return type:
    

protobuf.cmessage

_classmethod _parse_from_cmessage(_cmsg_ , _cfg_model =None_, _kb =None_, _** kwargs_)¶
    

Parse a protobuf cmessage and create a class object.

Parameters:
    

**cmsg** – The probobuf cmessage object.

Returns:
    

A unserialized class object.

Return type:
    

cls

_class _angr.code_location.CodeLocation(_block_addr_ , _stmt_idx_ , _sim_procedure =None_, _ins_addr =None_, _context =None_, _block_idx =None_, _** kwargs_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Stands for a specific program point by specifying basic block address and statement ID (for IRSBs), or SimProcedure name (for SimProcedures).

Parameters:
    

  * **block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **context** (_Any_)

  * **block_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_block_addr_ , _stmt_idx_ , _sim_procedure =None_, _ins_addr =None_, _context =None_, _block_idx =None_, _** kwargs_)¶
    

Constructor.

Parameters:
    

  * **block_addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")) – Address of the block

  * **stmt_idx** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")) – Statement ID. None for SimProcedures or if the code location is meant to refer to the entire block.

  * **sim_procedure** (_class_) – The corresponding SimProcedure class.

  * **ins_addr** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – The instruction address.

  * **context** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]) – A tuple that represents the context of this CodeLocation in contextual mode, or None in contextless mode.

  * **kwargs** – Optional arguments, will be stored, but not used in __eq__ or __hash__.

  * **block_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

block_addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

stmt_idx _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

sim_procedure¶
    

ins_addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

context _: [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

block_idx _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

info _: [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

_property _short_repr¶
    

_class _angr.code_location.ExternalCodeLocation(_call_string =None_)¶
    

Bases: `CodeLocation`

Stands for a program point that originates from outside an analysis’ scope. i.e. a value loaded from rdi in a callee where the caller has not been analyzed.

Parameters:
    

**call_string** ([_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__...__]__|__None_)

__init__(_call_string =None_)¶
    

Constructor.

Parameters:
    

  * **block_addr** – Address of the block

  * **stmt_idx** – Statement ID. None for SimProcedures or if the code location is meant to refer to the entire block.

  * **sim_procedure** (_class_) – The corresponding SimProcedure class.

  * **ins_addr** – The instruction address.

  * **context** – A tuple that represents the context of this CodeLocation in contextual mode, or None in contextless mode.

  * **kwargs** – Optional arguments, will be stored, but not used in __eq__ or __hash__.

  * **call_string** ([_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__...__]__|__None_)

call_string¶
    

_class _angr.keyed_region.StoredObject(_start_ , _obj_ , _size_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_start_ , _obj_ , _size_)¶
    

start¶
    

obj¶
    

size _: `UnknownSize` | [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_property _obj_id¶
    

_class _angr.keyed_region.RegionObject(_start_ , _size_ , _objects =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Represents one or more objects occupying one or more bytes in KeyedRegion.

__init__(_start_ , _size_ , _objects =None_)¶
    

start¶
    

size¶
    

stored_objects¶
    

_property _is_empty¶
    

_property _end¶
    

_property _internal_objects¶
    

includes(_offset_)¶
    

split(_split_at_)¶
    

add_object(_obj_)¶
    

set_object(_obj_)¶
    

copy()¶
    

_class _angr.keyed_region.KeyedRegion(_tree =None_, _phi_node_contains =None_, _canonical_size =8_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

KeyedRegion keeps a mapping between stack offsets and all objects covering that offset. It assumes no variable in this region overlap with another variable in this region.

Registers and function frames can all be viewed as a keyed region.

__init__(_tree =None_, _phi_node_contains =None_, _canonical_size =8_)¶
    

copy()¶
    

merge(_other_ , _replacements =None_)¶
    

Merge another KeyedRegion into this KeyedRegion.

Parameters:
    

**other** (_KeyedRegion_) – The other instance to merge with.

Returns:
    

None

merge_to_top(_other_ , _replacements =None_, _top =None_)¶
    

Merge another KeyedRegion into this KeyedRegion, but mark all variables with different values as TOP.

Parameters:
    

  * **other** – The other instance to merge with.

  * **replacements**

Returns:
    

self

replace(_replacements_)¶
    

Replace variables with other variables.

Parameters:
    

**replacements** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")) – A dict of variable replacements.

Returns:
    

self

dbg_repr()¶
    

Get a debugging representation of this keyed region. :return: A string of debugging output.

add_variable(_start_ , _variable_)¶
    

Add a variable to this region at the given offset.

Parameters:
    

  * **start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **variable** (_SimVariable_)

Returns:
    

None

add_object(_start_ , _obj_ , _object_size_)¶
    

Add/Store an object to this region at the given offset.

Parameters:
    

  * **start**

  * **obj**

  * **object_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Size of the object

Returns:
    

set_variable(_start_ , _variable_)¶
    

Add a variable to this region at the given offset, and remove all other variables that are fully covered by this variable.

Parameters:
    

  * **start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **variable** (_SimVariable_)

Returns:
    

None

set_object(_start_ , _obj_ , _object_size_)¶
    

Add an object to this region at the given offset, and remove all other objects that are fully covered by this object.

Parameters:
    

  * **start**

  * **obj**

  * **object_size**

Returns:
    

get_base_addr(_addr_)¶
    

Get the base offset (the key we are using to index objects covering the given offset) of a specific offset.

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

Returns:
    

Return type:
    

[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") or None

get_variables_by_offset(_start_)¶
    

Find variables covering the given region offset.

Parameters:
    

**start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

Returns:
    

A set of variables.

Return type:
    

[set](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")

get_objects_by_offset(_start_)¶
    

Find objects covering the given region offset.

Parameters:
    

**start**

Returns:
    

get_all_variables()¶
    

Get all variables covering the current region.

Returns:
    

A set of all variables.

## Serialization¶

_class _angr.serializable.Serializable¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

The base class of all protobuf-serializable classes in angr.

serialize_to_cmessage()¶
    

Serialize the class object and returns a protobuf cmessage object.

Returns:
    

A protobuf cmessage object.

Return type:
    

protobuf.cmessage

serialize()¶
    

Serialize the class object and returns a bytes object.

Returns:
    

A bytes object.

Return type:
    

[bytes](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)")

_classmethod _parse_from_cmessage(_cmsg_ , _** kwargs_)¶
    

Parse a protobuf cmessage and create a class object.

Parameters:
    

**cmsg** – The probobuf cmessage object.

Returns:
    

A unserialized class object.

Return type:
    

cls

_classmethod _parse(_s_ , _** kwargs_)¶
    

Parse a bytes object and create a class object.

Parameters:
    

**s** ([_bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)")) – A bytes object.

Returns:
    

A class object.

Return type:
    

cls

_class _angr.vaults.VaultPickler(_vault_ , _file_ , _* args_, _assigned_objects =()_, _** kwargs_)¶
    

Bases: `Pickler`

__init__(_vault_ , _file_ , _* args_, _assigned_objects =()_, _** kwargs_)¶
    

A persistence-aware pickler. It will check for persistence of any objects except for those with IDs in ‘assigned_objects’.

persistent_id(_obj_)¶
    

_class _angr.vaults.VaultUnpickler(_vault_ , _file_ , _* args_, _** kwargs_)¶
    

Bases: `Unpickler`

__init__(_vault_ , _file_ , _* args_, _** kwargs_)¶
    

persistent_load(_pid_)¶
    

_class _angr.vaults.Vault¶
    

Bases: [`MutableMapping`](https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableMapping "\(in Python v3.13\)")

The vault is a serializer for angr.

keys()¶
    

Should return the IDs stored by the vault.

__init__()¶
    

is_stored(_i_)¶
    

Checks if the provided id is already in the vault.

load(_oid_)¶
    

store(_o_)¶
    

dumps(_o_)¶
    

Returns a serialized string representing the object, post-deduplication.

Parameters:
    

**o** – the object

loads(_s_)¶
    

Deserializes a string representation of the object.

Parameters:
    

**s** – the string

_static _close()¶
    

_class _angr.vaults.VaultDict(_d =None_)¶
    

Bases: `Vault`

A Vault that uses a dictionary for storage.

__init__(_d =None_)¶
    

is_stored(_i_)¶
    

Checks if the provided id is already in the vault.

keys()¶
    

Should return the IDs stored by the vault.

_class _angr.vaults.VaultDir(_d =None_)¶
    

Bases: `Vault`

A Vault that uses a directory for storage.

__init__(_d =None_)¶
    

keys()¶
    

Should return the IDs stored by the vault.

_class _angr.vaults.VaultShelf(_path =None_)¶
    

Bases: `VaultDict`

A Vault that uses a shelve.Shelf for storage.

__init__(_path =None_)¶
    

close()¶
    

_class _angr.vaults.VaultDirShelf(_d =None_)¶
    

Bases: `VaultDict`

A Vault that uses a directory for storage, where every object is stored into a single shelve.Shelf instance. VaultDir creates a file for each object. VaultDirShelf creates only one file for a stored object and everything else it references.

__init__(_d =None_)¶
    

store(_o_)¶
    

load(_oid_)¶
    

keys()¶
    

Should return the IDs stored by the vault.

## Analysis¶

_class _angr.analyses.CDG(_cfg_ , _start =None_, _no_construct =False_)¶
    

Bases: `Analysis`

Implements a control dependence graph.

__init__(_cfg_ , _start =None_, _no_construct =False_)¶
    

Constructor.

Parameters:
    

  * **cfg** – The control flow graph upon which this control dependence graph will build

  * **start** – The starting point to begin constructing the control dependence graph

  * **no_construct** – Skip the construction step. Only used in unit-testing.

_property _graph¶
    

get_post_dominators()¶
    

Return the post-dom tree

get_dependants(_run_)¶
    

Return a list of nodes that are control dependent on the given node in the control dependence graph

get_guardians(_run_)¶
    

Return a list of nodes on whom the specific node is control dependent in the control dependence graph

_class _angr.analyses.CFG(_** kwargs_)¶
    

Bases: `CFGFast`

tl;dr: CFG is just a wrapper around CFGFast for compatibility issues. It will be fully replaced by CFGFast in future releases. Feel free to use CFG if you intend to use CFGFast. Please use CFGEmulated if you _have to_ use the old, slow, dynamically-generated version of CFG.

For multiple historical reasons, angr’s CFG is accurate but slow, which does not meet what most people expect. We developed CFGFast for light-speed CFG recovery, and renamed the old CFG class to CFGEmulated. For compatibility concerns, CFG was kept as an alias to CFGEmulated.

However, so many new users of angr would load up a binary and generate a CFG immediately after running “pip install angr”, and draw the conclusion that “angr’s CFG is so slow - angr must be unusable!” Therefore, we made the hard decision: CFG will be an alias to CFGFast, instead of CFGEmulated.

To ease the transition of your existing code and script, the following changes are made:

  * A CFG class, which is a sub class of CFGFast, is created.

  * You will see both a warning message printed out to stderr and an exception raised by angr if you are passing CFG any parameter that only CFGEmulated supports. This exception is not a sub class of AngrError, so you wouldn’t capture it with your old code by mistake.

  * In the near future, this wrapper class will be removed completely, and CFG will be a simple alias to CFGFast.

We expect most interfaces are the same between CFGFast and CFGEmulated. Apparently some functionalities (like context-sensitivity, and state keeping) only exist in CFGEmulated, which is when you want to use CFGEmulated instead.

__init__(_** kwargs_)¶
    

Parameters:
    

  * **binary** – The binary to recover CFG on. By default the main binary is used.

  * **objects** – A list of objects to recover the CFG on. By default it will recover the CFG of all loaded objects.

  * **regions** (_iterable_) – A list of tuples in the form of (start address, end address) describing memory regions that the CFG should cover.

  * **pickle_intermediate_results** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If we want to store the intermediate results or not.

  * **symbols** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Get function beginnings from symbols in the binary.

  * **function_prologues** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Scan the binary for function prologues, and use those positions as function beginnings

  * **resolve_indirect_jumps** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Try to resolve indirect jumps. This is necessary to resolve jump targets from jump tables, etc.

  * **force_segment** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Force CFGFast to rely on binary segments instead of sections.

  * **force_complete_scan** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Perform a complete scan on the binary and maximize the number of identified code blocks.

  * **data_references** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Enables the collection of references to data used by individual instructions. This does not collect ‘cross-references’, particularly those that involve multiple instructions. For that, see cross_references

  * **cross_references** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether CFGFast should collect “cross-references” from the entire program or not. This will populate the knowledge base with references to and from each recognizable address constant found in the code. Note that, because this performs constant propagation on the entire program, it may be much slower and consume more memory. This option implies data_references=True.

  * **normalize** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Normalize the CFG as well as all function graphs after CFG recovery.

  * **start_at_entry** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Begin CFG recovery at the entry point of this project. Setting it to False prevents CFGFast from viewing the entry point as one of the starting points of code scanning.

  * **function_starts** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A list of extra function starting points. CFGFast will try to resume scanning from each address in the list.

  * **extra_memory_regions** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A list of 2-tuple (start-address, end-address) that shows extra memory regions. Integers falling inside will be considered as pointers.

  * **indirect_jump_resolvers** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A custom list of indirect jump resolvers. If this list is None or empty, default indirect jump resolvers specific to this architecture and binary types will be loaded.

  * **base_state** – A state to use as a backer for all memory loads

  * **detect_tail_calls** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Enable aggressive tail-call optimization detection.

  * **elf_eh_frame** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Retrieve function starts (and maybe sizes later) from the .eh_frame of ELF binaries.

  * **skip_unmapped_addrs** – Ignore all branches into unmapped regions. True by default. You may want to set it to False if you are analyzing manually patched binaries or malware samples.

  * **indirect_calls_always_return** – Should CFG assume indirect calls must return or not. Assuming indirect calls must return will significantly reduce the number of constant propagation runs, but may reduce the overall CFG recovery precision when facing non-returning indirect calls. By default, we only assume indirect calls always return for large binaries (region > 50KB).

  * **jumptable_resolver_resolves_calls** – Whether JumpTableResolver should resolve indirect calls or not. Most indirect calls in C++ binaries or UEFI binaries cannot be resolved using jump table resolver and must be resolved using their specific resolvers. By default, we will only disable JumpTableResolver from resolving indirect calls for large binaries (region > 50 KB).

:param check_funcret_max_job When popping return-site jobs out of the job queue, angr will prioritize jobs
    

for which the callee is known to return. This check may be slow when there are a large amount of jobs in different caller functions, and this situation often occurs in obfuscated binaries where many functions never return. This parameter acts as a threshold to disable this check when the number of jobs in the queue exceeds this threshold.

Parameters:
    

  * **start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – (Deprecated) The beginning address of CFG recovery.

  * **end** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – (Deprecated) The end address of CFG recovery.

  * **arch_options** (_CFGArchOptions_) – Architecture-specific options.

  * **extra_arch_options** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")) – Any key-value pair in kwargs will be seen as an arch-specific option and will be used to set the option value in self._arch_options.

Extra parameters that angr.Analysis takes:

Parameters:
    

  * **progress_callback** – Specify a callback function to get the progress during CFG recovery.

  * **show_progressbar** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Should CFGFast show a progressbar during CFG recovery or not.

Returns:
    

None

_class _angr.analyses.DDG(_cfg_ , _start =None_, _call_depth =None_, _block_addrs =None_)¶
    

Bases: `Analysis`

This is a fast data dependence graph directly generated from our CFG analysis result. The only reason for its existence is the speed. There is zero guarantee for being sound or accurate. You are supposed to use it only when you want to track the simplest data dependence, and you do not care about soundness or accuracy.

For a better data dependence graph, please consider performing a better static analysis first (like Value-set Analysis), and then construct a dependence graph on top of the analysis result (for example, the VFG in angr).

The DDG is based on a CFG, which should ideally be a CFGEmulated generated with the following options:

>   * keep_state=True to keep all input states
> 
>   * state_add_options=angr.options.refs to store memory, register, and temporary value accesses
> 
> 

You may want to consider a high value for context_sensitivity_level as well when generating the CFG.

Also note that since we are using states from CFG, any improvement in analysis performed on CFG (like a points-to analysis) will directly benefit the DDG.

__init__(_cfg_ , _start =None_, _call_depth =None_, _block_addrs =None_)¶
    

Parameters:
    

  * **cfg** – Control flow graph. Please make sure each node has an associated state with it, e.g. by passing the keep_state=True and state_add_options=angr.options.refs arguments to CFGEmulated.

  * **start** – An address, Specifies where we start the generation of this data dependence graph.

  * **call_depth** – None or integers. A non-negative integer specifies how deep we would like to track in the call tree. None disables call_depth limit.

  * **block_addrs** (_iterable_ _or_ _None_) – A collection of block addresses that the DDG analysis should be performed on.

_property _graph¶
    

A networkx DiGraph instance representing the dependence relations between statements. :rtype: networkx.DiGraph

Type:
    

returns

_property _data_graph¶
    

Get the data dependence graph.

Returns:
    

A networkx DiGraph instance representing data dependence.

Return type:
    

networkx.DiGraph

_property _simplified_data_graph¶
    

return:

_property _ast_graph¶
    

pp()¶
    

Pretty printing.

dbg_repr()¶
    

Representation for debugging.

get_predecessors(_code_location_)¶
    

Returns all predecessors of the code location.

Parameters:
    

**code_location** – A CodeLocation instance.

Returns:
    

A list of all predecessors.

function_dependency_graph(_func_)¶
    

Get a dependency graph for the function func.

Parameters:
    

**func** – The Function object in CFG.function_manager.

Returns:
    

A networkx.DiGraph instance.

data_sub_graph(_pv_ , _simplified =True_, _killing_edges =False_, _excluding_types =None_)¶
    

Get a subgraph from the data graph or the simplified data graph that starts from node pv.

Parameters:
    

  * **pv** (_ProgramVariable_) – The starting point of the subgraph.

  * **simplified** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – When True, the simplified data graph is used, otherwise the data graph is used.

  * **killing_edges** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Are killing edges included or not.

  * **excluding_types** (_iterable_) – Excluding edges whose types are among those excluded types.

Returns:
    

A subgraph.

Return type:
    

networkx.MultiDiGraph

find_definitions(_variable_ , _location =None_, _simplified_graph =True_)¶
    

Find all definitions of the given variable.

Parameters:
    

  * **variable** (_SimVariable_)

  * **simplified_graph** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True if you just want to search in the simplified graph instead of the normal graph. Usually the simplified graph suffices for finding definitions of register or memory variables.

Returns:
    

A collection of all variable definitions to the specific variable.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

find_consumers(_var_def_ , _simplified_graph =True_)¶
    

Find all consumers to the specified variable definition.

Parameters:
    

  * **var_def** (_ProgramVariable_) – The variable definition.

  * **simplified_graph** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True if we want to search in the simplified graph, False otherwise.

Returns:
    

A collection of all consumers to the specified variable definition.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

find_killers(_var_def_ , _simplified_graph =True_)¶
    

Find all killers to the specified variable definition.

Parameters:
    

  * **var_def** (_ProgramVariable_) – The variable definition.

  * **simplified_graph** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True if we want to search in the simplified graph, False otherwise.

Returns:
    

A collection of all killers to the specified variable definition.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

find_sources(_var_def_ , _simplified_graph =True_)¶
    

Find all sources to the specified variable definition.

Parameters:
    

  * **var_def** (_ProgramVariable_) – The variable definition.

  * **simplified_graph** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True if we want to search in the simplified graph, False otherwise.

Returns:
    

A collection of all sources to the specified variable definition.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

_class _angr.analyses.VFG(_cfg =None_, _context_sensitivity_level =2_, _start =None_, _function_start =None_, _interfunction_level =0_, _initial_state =None_, _avoid_runs =None_, _remove_options =None_, _timeout =None_, _max_iterations_before_widening =8_, _max_iterations =40_, _widening_interval =3_, _final_state_callback =None_, _status_callback =None_, _record_function_final_states =False_)¶
    

Bases: `ForwardAnalysis`[`SimState`, `VFGNode`, `VFGJob`, `BlockID`], `Analysis`

This class represents a control-flow graph with static analysis result.

Perform abstract interpretation analysis starting from the given function address. The output is an invariant at the beginning (or the end) of each basic block.

Steps:

>   * Generate a CFG first if CFG is not provided.
> 
>   * Identify all merge points (denote the set of merge points as Pw) in the CFG.
> 
>   * Cut those loop back edges (can be derived from Pw) so that we gain an acyclic CFG.
> 
>   * Identify all variables that are 1) from memory loading 2) from initial values, or 3) phi functions. Denote
>     
> 
> the set of those variables as S_{var}.
> 
>   * Start real AI analysis and try to compute a fix point of each merge point. Perform widening/narrowing only on
>     
> 
> variables in S_{var}.
> 
> 

Parameters:
    

  * **cfg** (_CFGEmulated_ _|__None_)

  * **context_sensitivity_level** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **function_start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **interfunction_level** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **initial_state** (_SimState_ _|__None_)

  * **avoid_runs** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **remove_options** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **timeout** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **max_iterations_before_widening** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **max_iterations** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **widening_interval** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **final_state_callback** (_Callable_ _[__[__SimState_ _,__CallStack_ _]__,__Any_ _]__|__None_)

  * **status_callback** (_Callable_ _[__[__VFG_ _]__,__Any_ _]__|__None_)

  * **record_function_final_states** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_cfg =None_, _context_sensitivity_level =2_, _start =None_, _function_start =None_, _interfunction_level =0_, _initial_state =None_, _avoid_runs =None_, _remove_options =None_, _timeout =None_, _max_iterations_before_widening =8_, _max_iterations =40_, _widening_interval =3_, _final_state_callback =None_, _status_callback =None_, _record_function_final_states =False_)¶
    

Parameters:
    

  * **cfg** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[`CFGEmulated`]) – The control-flow graph to base this analysis on. If none is provided, we will construct a CFGEmulated.

  * **context_sensitivity_level** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The level of context-sensitivity of this VFG. It ranges from 0 to infinity. Default 2.

  * **function_start** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – The address of the function to analyze.

  * **interfunction_level** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The level of interfunction-ness to be

  * **initial_state** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[`SimState`]) – A state to use as the initial one

  * **avoid_runs** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]]) – A list of runs to avoid

  * **remove_options** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]]) – State options to remove from the initial state. It only works when initial_state is None

  * **timeout** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **final_state_callback** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`Callable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)")[[`SimState`, `CallStack`], [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – callback function when countering final state

  * **status_callback** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`Callable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)")[[`VFG`], [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – callback function used in _analysis_core_baremetal

  * **start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **max_iterations_before_widening** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **max_iterations** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **widening_interval** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **record_function_final_states** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Return type:
    

None

_property _function_initial_states¶
    

_property _function_final_states¶
    

get_any_node(_addr_)¶
    

Get any VFG node corresponding to the basic block at @addr. Note that depending on the context sensitivity level, there might be multiple nodes corresponding to different contexts. This function will return the first one it encounters, which might not be what you want.

Return type:
    

`VFGNode` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_all_nodes(_addr_)¶
    

Return type:
    

[`Generator`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Generator "\(in Python v3.13\)")[`VFGNode`]

irsb_from_node(_node_)¶
    

copy()¶
    

_class _angr.analyses.VSA_DDG(_vfg =None_, _start_addr =None_, _interfunction_level =0_, _context_sensitivity_level =2_, _keep_data =False_)¶
    

Bases: `Analysis`

A Data dependency graph based on VSA states. That means we don’t (and shouldn’t) expect any symbolic expressions.

__init__(_vfg =None_, _start_addr =None_, _interfunction_level =0_, _context_sensitivity_level =2_, _keep_data =False_)¶
    

Constructor.

Parameters:
    

  * **vfg** – An already constructed VFG. If not specified, a new VFG will be created with other specified parameters. vfg and start_addr cannot both be unspecified.

  * **start_addr** – The address where to start the analysis (typically, a function’s entry point).

  * **interfunction_level** – See VFG analysis.

  * **context_sensitivity_level** – See VFG analysis.

  * **keep_data** – Whether we keep set of addresses as edges in the graph, or just the cardinality of the sets, which can be used as a “weight”.

get_predecessors(_code_location_)¶
    

Returns all predecessors of code_location.

Parameters:
    

**code_location** – A CodeLocation instance.

Returns:
    

A list of all predecessors.

get_all_nodes(_simrun_addr_ , _stmt_idx_)¶
    

Get all DDG nodes matching the given basic block address and statement index.

_class _angr.analyses.AnalysesHub(_project_)¶
    

Bases: `PluginVendor`[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]

This class contains functions for all the registered and runnable analyses,

__init__(_project_)¶
    

_class _angr.analyses.Analysis¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

This class represents an analysis on the program.

Variables:
    

  * **project** – The project for this analysis.

  * **kb** (_KnowledgeBase_) – The knowledgebase object.

  * **_progress_callback** – A callback function for receiving the progress of this analysis. It only takes one argument, which is a float number from 0.0 to 100.0 indicating the current progress.

  * **_show_progressbar** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If a progressbar should be shown during the analysis. It’s independent from _progress_callback.

  * **_progressbar** (_progress.Progress_) – The progress bar object.

project _: `Project`_¶
    

kb _: `KnowledgeBase`_¶
    

errors _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`AnalysisLogEntry`]__ = []_¶
    

named_errors _: [`defaultdict`](https://docs.python.org/3/library/collections.html#collections.defaultdict "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"), [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`AnalysisLogEntry`]]__ = {}_¶
    

_class _angr.analyses.BackwardSlice(_cfg_ , _cdg_ , _ddg_ , _targets =None_, _cfg_node =None_, _stmt_id =None_, _control_flow_slice =False_, _same_function =False_, _no_construct =False_)¶
    

Bases: `Analysis`

Represents a backward slice of the program.

__init__(_cfg_ , _cdg_ , _ddg_ , _targets =None_, _cfg_node =None_, _stmt_id =None_, _control_flow_slice =False_, _same_function =False_, _no_construct =False_)¶
    

Create a backward slice from a specific statement based on provided control flow graph (CFG), control dependence graph (CDG), and data dependence graph (DDG).

The data dependence graph can be either CFG-based, or Value-set analysis based. A CFG-based DDG is much faster to generate, but it only reflects those states while generating the CFG, and it is neither sound nor accurate. The VSA based DDG (called VSA_DDG) is based on static analysis, which gives you a much better result.

Parameters:
    

  * **cfg** – The control flow graph.

  * **cdg** – The control dependence graph.

  * **ddg** – The data dependence graph.

  * **targets** – A list of “target” that specify targets of the backward slices. Each target can be a tuple in form of (cfg_node, stmt_idx), or a CodeLocation instance.

  * **cfg_node** – Deprecated. The target CFGNode to reach. It should exist in the CFG.

  * **stmt_id** – Deprecated. The target statement to reach.

  * **control_flow_slice** – True/False, indicates whether we should slice only based on CFG. Sometimes when acquiring DDG is difficult or impossible, you can just create a slice on your CFG. Well, if you don’t even have a CFG, then…

  * **no_construct** – Only used for testing and debugging to easily create a BackwardSlice object.

dbg_repr(_max_display =10_)¶
    

Debugging output of this slice.

Parameters:
    

**max_display** – The maximum number of SimRun slices to show.

Returns:
    

A string representation.

dbg_repr_run(_run_addr_)¶
    

Debugging output of a single SimRun slice.

Parameters:
    

**run_addr** – Address of the SimRun.

Returns:
    

A string representation.

annotated_cfg(_start_point =None_)¶
    

Returns an AnnotatedCFG based on slicing result.

is_taint_related_to_ip(_simrun_addr_ , _stmt_idx_ , _taint_type_ , _simrun_whitelist =None_)¶
    

Query in taint graph to check if a specific taint will taint the IP in the future or not. The taint is specified with the tuple (simrun_addr, stmt_idx, taint_type).

Parameters:
    

  * **simrun_addr** – Address of the SimRun.

  * **stmt_idx** – Statement ID.

  * **taint_type** – Type of the taint, might be one of the following: ‘reg’, ‘tmp’, ‘mem’.

  * **simrun_whitelist** – A list of SimRun addresses that are whitelisted, i.e. the tainted exit will be ignored if it is in those SimRuns.

Returns:
    

True/False

is_taint_impacting_stack_pointers(_simrun_addr_ , _stmt_idx_ , _taint_type_ , _simrun_whitelist =None_)¶
    

Query in taint graph to check if a specific taint will taint the stack pointer in the future or not. The taint is specified with the tuple (simrun_addr, stmt_idx, taint_type).

Parameters:
    

  * **simrun_addr** – Address of the SimRun.

  * **stmt_idx** – Statement ID.

  * **taint_type** – Type of the taint, might be one of the following: ‘reg’, ‘tmp’, ‘mem’.

  * **simrun_whitelist** – A list of SimRun addresses that are whitelisted.

Returns:
    

True/False.

_class _angr.analyses.BinDiff(_other_project_ , _cfg_a =None_, _cfg_b =None_)¶
    

Bases: `Analysis`

This class computes the a diff between two binaries represented by angr Projects

__init__(_other_project_ , _cfg_a =None_, _cfg_b =None_)¶
    

Parameters:
    

**other_project** – The second project to diff

functions_probably_identical(_func_a_addr_ , _func_b_addr_ , _check_consts =False_)¶
    

Compare two functions and return True if they appear identical.

Parameters:
    

  * **func_a_addr** – The address of the first function (in the first binary).

  * **func_b_addr** – The address of the second function (in the second binary).

Returns:
    

Whether or not the functions appear to be identical.

_property _identical_functions¶
    

A list of function matches that appear to be identical

Type:
    

returns

_property _differing_functions¶
    

A list of function matches that appear to differ

Type:
    

returns

differing_functions_with_consts()¶
    

Returns:
    

A list of function matches that appear to differ including just by constants

_property _differing_blocks¶
    

A list of block matches that appear to differ

Type:
    

returns

_property _identical_blocks¶
    

return A list of all block matches that appear to be identical

_property _blocks_with_differing_constants¶
    

A dict of block matches with differing constants to the tuple of constants

Type:
    

return

_property _unmatched_functions¶
    

get_function_diff(_function_addr_a_ , _function_addr_b_)¶
    

Parameters:
    

  * **function_addr_a** – The address of the first function (in the first binary)

  * **function_addr_b** – The address of the second function (in the second binary)

Returns:
    

the FunctionDiff of the two functions

_class _angr.analyses.BinaryOptimizer(_cfg_ , _techniques_)¶
    

Bases: `Analysis`

This is a collection of binary optimization techniques we used in Mechanical Phish during the finals of Cyber Grand Challenge. It focuses on dealing with some serious speed-impacting code constructs, and _sort of_ worked on _some_ CGC binaries compiled with O0. Use this analysis as a reference of how to use data dependency graph and such.

There is no guarantee that BinaryOptimizer will ever work on non-CGC binaries. Feel free to give us PR or MR, but please _do not_ ask for support of non-CGC binaries.

BLOCKS_THRESHOLD _ = 500_¶
    

__init__(_cfg_ , _techniques_)¶
    

optimize()¶
    

_class _angr.analyses.BoyScout(_cookiesize =1_)¶
    

Bases: `Analysis`

Try to determine the architecture and endieness of a binary blob

__init__(_cookiesize =1_)¶
    

_class _angr.analyses.CFGArchOptions(_arch_ , _** options_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Stores architecture-specific options and settings, as well as the detailed explanation of those options and settings.

Suppose ao is the CFGArchOptions object, and there is an option called ret_jumpkind_heuristics, you can access it by ao.ret_jumpkind_heuristics and set its value via ao.ret_jumpkind_heuristics = True

Variables:
    

  * **OPTIONS** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")) – A dict of all default options for different architectures.

  * **arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)")) – The architecture object.

  * **_options** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")) – Values of all CFG options that are specific to the current architecture.

OPTIONS _ = {'ARMCortexM': {'has_arm_code': (<class 'bool'>, False), 'pattern_match_ifuncs': (<class 'bool'>, True), 'ret_jumpkind_heuristics': (<class 'bool'>, True), 'switch_mode_on_nodecode': (<class 'bool'>, False)}, 'ARMEL': {'has_arm_code': (<class 'bool'>, True), 'pattern_match_ifuncs': (<class 'bool'>, True), 'ret_jumpkind_heuristics': (<class 'bool'>, True), 'switch_mode_on_nodecode': (<class 'bool'>, True)}, 'ARMHF': {'has_arm_code': (<class 'bool'>, True), 'pattern_match_ifuncs': (<class 'bool'>, True), 'ret_jumpkind_heuristics': (<class 'bool'>, True), 'switch_mode_on_nodecode': (<class 'bool'>, True)}}_¶
    

__init__(_arch_ , _** options_)¶
    

Constructor.

Parameters:
    

  * **arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)")) – The architecture instance.

  * **options** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")) – Architecture-specific options, which will be used to initialize this object.

arch _ = None_¶
    

_class _angr.analyses.CFGEmulated(_context_sensitivity_level =1_, _start =None_, _avoid_runs =None_, _enable_function_hints =False_, _call_depth =None_, _call_tracing_filter =None_, _initial_state =None_, _starts =None_, _keep_state =False_, _indirect_jump_target_limit =100000_, _resolve_indirect_jumps =True_, _enable_advanced_backward_slicing =False_, _enable_symbolic_back_traversal =False_, _indirect_jump_resolvers =None_, _additional_edges =None_, _no_construct =False_, _normalize =False_, _max_iterations =1_, _address_whitelist =None_, _base_graph =None_, _iropt_level =None_, _max_steps =None_, _state_add_options =None_, _state_remove_options =None_, _model =None_)¶
    

Bases: `ForwardAnalysis`, `CFGBase`

This class represents a control-flow graph.

tag _: str | None_ _ = 'CFGEmulated'_¶
    

__init__(_context_sensitivity_level =1_, _start =None_, _avoid_runs =None_, _enable_function_hints =False_, _call_depth =None_, _call_tracing_filter =None_, _initial_state =None_, _starts =None_, _keep_state =False_, _indirect_jump_target_limit =100000_, _resolve_indirect_jumps =True_, _enable_advanced_backward_slicing =False_, _enable_symbolic_back_traversal =False_, _indirect_jump_resolvers =None_, _additional_edges =None_, _no_construct =False_, _normalize =False_, _max_iterations =1_, _address_whitelist =None_, _base_graph =None_, _iropt_level =None_, _max_steps =None_, _state_add_options =None_, _state_remove_options =None_, _model =None_)¶
    

All parameters are optional.

Parameters:
    

  * **context_sensitivity_level** – The level of context-sensitivity of this CFG (see documentation for further details). It ranges from 0 to infinity. Default 1.

  * **avoid_runs** – A list of runs to avoid.

  * **enable_function_hints** – Whether to use function hints (constants that might be used as exit targets) or not.

  * **call_depth** – How deep in the call stack to trace.

  * **call_tracing_filter** – Filter to apply on a given path and jumpkind to determine if it should be skipped when call_depth is reached.

  * **initial_state** – An initial state to use to begin analysis.

  * **starts** (_iterable_) – A collection of starting points to begin analysis. It can contain the following three different types of entries: an address specified as an integer, a 2-tuple that includes an integer address and a jumpkind, or a SimState instance. Unsupported entries in starts will lead to an AngrCFGError being raised.

  * **keep_state** – Whether to keep the SimStates for each CFGNode.

  * **resolve_indirect_jumps** – Whether to enable the indirect jump resolvers for resolving indirect jumps

  * **enable_advanced_backward_slicing** – Whether to enable an intensive technique for resolving indirect jumps

  * **enable_symbolic_back_traversal** – Whether to enable an intensive technique for resolving indirect jumps

  * **indirect_jump_resolvers** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A custom list of indirect jump resolvers. If this list is None or empty, default indirect jump resolvers specific to this architecture and binary types will be loaded.

  * **additional_edges** – A dict mapping addresses of basic blocks to addresses of successors to manually include and analyze forward from.

  * **no_construct** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Skip the construction procedure. Only used in unit-testing.

  * **normalize** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If the CFG as well as all Function graphs should be normalized or not.

  * **max_iterations** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The maximum number of iterations that each basic block should be “executed”. 1 by default. Larger numbers of iterations are usually required for complex analyses like loop analysis.

  * **address_whitelist** (_iterable_) – A list of allowed addresses. Any basic blocks outside of this collection of addresses will be ignored.

  * **base_graph** (_networkx.DiGraph_) – A basic control flow graph to follow. Each node inside this graph must have the following properties: addr and size. CFG recovery will strictly follow nodes and edges shown in the graph, and discard any control flow that does not follow an existing edge in the base graph. For example, you can pass in a Function local transition graph as the base graph, and CFGEmulated will traverse nodes and edges and extract useful information.

  * **iropt_level** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The optimization level of VEX IR (0, 1, 2). The default level will be used if iropt_level is None.

  * **max_steps** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The maximum number of basic blocks to recover forthe longest path from each start before pausing the recovery procedure.

  * **state_add_options** – State options that will be added to the initial state.

  * **state_remove_options** – State options that will be removed from the initial state.

copy()¶
    

Make a copy of the CFG.

Return type:
    

`CFGEmulated`

Returns:
    

A copy of the CFG instance.

resume(_starts =None_, _max_steps =None_)¶
    

Resume a paused or terminated control flow graph recovery.

Parameters:
    

  * **starts** (_iterable_) – A collection of new starts to resume from. If starts is None, we will resume CFG recovery from where it was paused before.

  * **max_steps** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The maximum number of blocks on the longest path starting from each start before pausing the recovery.

Returns:
    

None

remove_cycles()¶
    

Forces graph to become acyclic, removes all loop back edges and edges between overlapped loop headers and their successors.

downsize()¶
    

Remove saved states from all CFGNodes to reduce memory usage.

Returns:
    

None

unroll_loops(_max_loop_unrolling_times_)¶
    

Unroll loops for each function. The resulting CFG may still contain loops due to recursion, function calls, etc.

Parameters:
    

**max_loop_unrolling_times** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The maximum iterations of unrolling.

Returns:
    

None

force_unroll_loops(_max_loop_unrolling_times_)¶
    

Unroll loops globally. The resulting CFG does not contain any loop, but this method is slow on large graphs.

Parameters:
    

**max_loop_unrolling_times** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The maximum iterations of unrolling.

Returns:
    

None

immediate_dominators(_start_ , _target_graph =None_)¶
    

Get all immediate dominators of sub graph from given node upwards.

Parameters:
    

  * **start** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – id of the node to navigate forwards from.

  * **target_graph** (_networkx.classes.digraph.DiGraph_) – graph to analyse, default is self.graph.

Returns:
    

each node of graph as index values, with element as respective node’s immediate dominator.

Return type:
    

[dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")

immediate_postdominators(_end_ , _target_graph =None_)¶
    

Get all immediate postdominators of sub graph from given node upwards.

Parameters:
    

  * **start** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – id of the node to navigate forwards from.

  * **target_graph** (_networkx.classes.digraph.DiGraph_) – graph to analyse, default is self.graph.

Returns:
    

each node of graph as index values, with element as respective node’s immediate dominator.

Return type:
    

[dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")

remove_fakerets()¶
    

Get rid of fake returns (i.e., Ijk_FakeRet edges) from this CFG

Returns:
    

None

get_topological_order(_cfg_node_)¶
    

Get the topological order of a CFG Node.

Parameters:
    

**cfg_node** – A CFGNode instance.

Returns:
    

An integer representing its order, or None if the CFGNode does not exist in the graph.

get_subgraph(_starting_node_ , _block_addresses_)¶
    

Get a sub-graph out of a bunch of basic block addresses.

Parameters:
    

  * **starting_node** (_CFGNode_) – The beginning of the subgraph

  * **block_addresses** (_iterable_) – A collection of block addresses that should be included in the subgraph if there is a path between starting_node and a CFGNode with the specified address, and all nodes on the path should also be included in the subgraph.

Returns:
    

A new CFG that only contain the specific subgraph.

Return type:
    

CFGEmulated

get_function_subgraph(_start_ , _max_call_depth =None_)¶
    

Get a sub-graph of a certain function.

Parameters:
    

  * **start** – The function start. Currently it should be an integer.

  * **max_call_depth** – Call depth limit. None indicates no limit.

Returns:
    

A CFG instance which is a sub-graph of self.graph

_property _context_sensitivity_level¶
    

_property _graph¶
    

_property _unresolvables¶
    

Get those SimRuns that have non-resolvable exits.

Returns:
    

A set of SimRuns

Return type:
    

[set](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")

_property _deadends¶
    

Get all CFGNodes that has an out-degree of 0

Returns:
    

A list of CFGNode instances

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

_class _angr.analyses.CFGFast(_binary =None_, _objects =None_, _regions =None_, _pickle_intermediate_results =False_, _symbols =True_, _function_prologues =None_, _resolve_indirect_jumps =True_, _force_segment =False_, _force_smart_scan =None_, _force_complete_scan =False_, _indirect_jump_target_limit =100000_, _data_references =True_, _cross_references =False_, _normalize =False_, _start_at_entry =True_, _function_starts =None_, _extra_memory_regions =None_, _data_type_guessing_handlers =None_, _arch_options =None_, _indirect_jump_resolvers =None_, _base_state =None_, _exclude_sparse_regions =True_, _skip_specific_regions =True_, _heuristic_plt_resolving =None_, _detect_tail_calls =False_, _low_priority =False_, _cfb =None_, _model =None_, _elf_eh_frame =True_, _exceptions =True_, _skip_unmapped_addrs =True_, _nodecode_window_size =512_, _nodecode_threshold =0.3_, _nodecode_step =16483_, _check_funcret_max_job =500_, _indirect_calls_always_return =None_, _jumptable_resolver_resolves_calls =None_, _start =None_, _end =None_, _collect_data_references =None_, _extra_cross_references =None_, _** extra_arch_options_)¶
    

Bases: `ForwardAnalysis`[`CFGNode`, `CFGNode`, `CFGJob`, [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")], `CFGBase`

We find functions inside the given binary, and build a control-flow graph in very fast manners: instead of simulating program executions, keeping track of states, and performing expensive data-flow analysis, CFGFast will only perform light-weight analyses combined with some heuristics, and with some strong assumptions.

In order to identify as many functions as possible, and as accurate as possible, the following operation sequence is followed:

# Active scanning

>   * If the binary has “function symbols” (TODO: this term is not accurate enough), they are starting points of the code scanning
> 
>   * If the binary does not have any “function symbol”, we will first perform a function prologue scanning on the entire binary, and start from those places that look like function beginnings
> 
>   * Otherwise, the binary’s entry point will be the starting point for scanning
> 
> 

# Passive scanning

>   * After all active scans are done, we will go through the whole image and scan all code pieces
> 
> 

Due to the nature of those techniques that are used here, a base address is often not required to use this analysis routine. However, with a correct base address, CFG recovery will almost always yield a much better result. A custom analysis, called GirlScout, is specifically made to recover the base address of a binary blob. After the base address is determined, you may want to reload the binary with the new base address by creating a new Project object, and then re-recover the CFG.

Parameters:
    

  * **function_prologues** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **force_smart_scan** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **indirect_calls_always_return** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **jumptable_resolver_resolves_calls** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

PRINTABLES _ = b'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&\'()*+,-./:;<=>?@[\\\\]^_`{|}~ \t\n\r'_¶
    

SPECIAL_THUNKS _ = {'AMD64': {b'\xe8\x07\x00\x00\x00\xf3\x90\x0f\xae\xe8\xeb\xf9H\x89\x04$\xc3': ('jmp', 'rax'), b'\xe8\x07\x00\x00\x00\xf3\x90\x0f\xae\xe8\xeb\xf9H\x8dd$\x08\xc3': ('ret',)}}_¶
    

tag _: str | None_ _ = 'CFGFast'_¶
    

__init__(_binary =None_, _objects =None_, _regions =None_, _pickle_intermediate_results =False_, _symbols =True_, _function_prologues =None_, _resolve_indirect_jumps =True_, _force_segment =False_, _force_smart_scan =None_, _force_complete_scan =False_, _indirect_jump_target_limit =100000_, _data_references =True_, _cross_references =False_, _normalize =False_, _start_at_entry =True_, _function_starts =None_, _extra_memory_regions =None_, _data_type_guessing_handlers =None_, _arch_options =None_, _indirect_jump_resolvers =None_, _base_state =None_, _exclude_sparse_regions =True_, _skip_specific_regions =True_, _heuristic_plt_resolving =None_, _detect_tail_calls =False_, _low_priority =False_, _cfb =None_, _model =None_, _elf_eh_frame =True_, _exceptions =True_, _skip_unmapped_addrs =True_, _nodecode_window_size =512_, _nodecode_threshold =0.3_, _nodecode_step =16483_, _check_funcret_max_job =500_, _indirect_calls_always_return =None_, _jumptable_resolver_resolves_calls =None_, _start =None_, _end =None_, _collect_data_references =None_, _extra_cross_references =None_, _** extra_arch_options_)¶
    

Parameters:
    

  * **binary** – The binary to recover CFG on. By default the main binary is used.

  * **objects** – A list of objects to recover the CFG on. By default it will recover the CFG of all loaded objects.

  * **regions** (_iterable_) – A list of tuples in the form of (start address, end address) describing memory regions that the CFG should cover.

  * **pickle_intermediate_results** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If we want to store the intermediate results or not.

  * **symbols** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Get function beginnings from symbols in the binary.

  * **function_prologues** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Scan the binary for function prologues, and use those positions as function beginnings

  * **resolve_indirect_jumps** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Try to resolve indirect jumps. This is necessary to resolve jump targets from jump tables, etc.

  * **force_segment** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Force CFGFast to rely on binary segments instead of sections.

  * **force_complete_scan** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Perform a complete scan on the binary and maximize the number of identified code blocks.

  * **data_references** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Enables the collection of references to data used by individual instructions. This does not collect ‘cross-references’, particularly those that involve multiple instructions. For that, see cross_references

  * **cross_references** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether CFGFast should collect “cross-references” from the entire program or not. This will populate the knowledge base with references to and from each recognizable address constant found in the code. Note that, because this performs constant propagation on the entire program, it may be much slower and consume more memory. This option implies data_references=True.

  * **normalize** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Normalize the CFG as well as all function graphs after CFG recovery.

  * **start_at_entry** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Begin CFG recovery at the entry point of this project. Setting it to False prevents CFGFast from viewing the entry point as one of the starting points of code scanning.

  * **function_starts** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A list of extra function starting points. CFGFast will try to resume scanning from each address in the list.

  * **extra_memory_regions** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A list of 2-tuple (start-address, end-address) that shows extra memory regions. Integers falling inside will be considered as pointers.

  * **indirect_jump_resolvers** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A custom list of indirect jump resolvers. If this list is None or empty, default indirect jump resolvers specific to this architecture and binary types will be loaded.

  * **base_state** – A state to use as a backer for all memory loads

  * **detect_tail_calls** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Enable aggressive tail-call optimization detection.

  * **elf_eh_frame** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Retrieve function starts (and maybe sizes later) from the .eh_frame of ELF binaries.

  * **skip_unmapped_addrs** – Ignore all branches into unmapped regions. True by default. You may want to set it to False if you are analyzing manually patched binaries or malware samples.

  * **indirect_calls_always_return** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")]) – Should CFG assume indirect calls must return or not. Assuming indirect calls must return will significantly reduce the number of constant propagation runs, but may reduce the overall CFG recovery precision when facing non-returning indirect calls. By default, we only assume indirect calls always return for large binaries (region > 50KB).

  * **jumptable_resolver_resolves_calls** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")]) – Whether JumpTableResolver should resolve indirect calls or not. Most indirect calls in C++ binaries or UEFI binaries cannot be resolved using jump table resolver and must be resolved using their specific resolvers. By default, we will only disable JumpTableResolver from resolving indirect calls for large binaries (region > 50 KB).

  * **force_smart_scan** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

:param check_funcret_max_job When popping return-site jobs out of the job queue, angr will prioritize jobs
    

for which the callee is known to return. This check may be slow when there are a large amount of jobs in different caller functions, and this situation often occurs in obfuscated binaries where many functions never return. This parameter acts as a threshold to disable this check when the number of jobs in the queue exceeds this threshold.

Parameters:
    

  * **start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – (Deprecated) The beginning address of CFG recovery.

  * **end** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – (Deprecated) The end address of CFG recovery.

  * **arch_options** (_CFGArchOptions_) – Architecture-specific options.

  * **extra_arch_options** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")) – Any key-value pair in kwargs will be seen as an arch-specific option and will be used to set the option value in self._arch_options.

  * **function_prologues** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **force_smart_scan** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **indirect_calls_always_return** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **jumptable_resolver_resolves_calls** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

Extra parameters that angr.Analysis takes:

Parameters:
    

  * **progress_callback** – Specify a callback function to get the progress during CFG recovery.

  * **show_progressbar** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Should CFGFast show a progressbar during CFG recovery or not.

  * **function_prologues** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **force_smart_scan** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **indirect_calls_always_return** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **jumptable_resolver_resolves_calls** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

Returns:
    

None

_property _graph¶
    

_property _memory_data¶
    

_property _jump_tables¶
    

_property _insn_addr_to_memory_data¶
    

do_full_xrefs(_overlay_state =None_)¶
    

Perform xref recovery on all functions.

Parameters:
    

**overlay** (_SimState_) – An overlay state for loading constant data.

Returns:
    

None

copy()¶
    

output()¶
    

_class _angr.analyses.CFGFastSoot(_support_jni =False_, _** kwargs_)¶
    

Bases: `CFGFast`

__init__(_support_jni =False_, _** kwargs_)¶
    

Parameters:
    

  * **binary** – The binary to recover CFG on. By default the main binary is used.

  * **objects** – A list of objects to recover the CFG on. By default it will recover the CFG of all loaded objects.

  * **regions** (_iterable_) – A list of tuples in the form of (start address, end address) describing memory regions that the CFG should cover.

  * **pickle_intermediate_results** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If we want to store the intermediate results or not.

  * **symbols** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Get function beginnings from symbols in the binary.

  * **function_prologues** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Scan the binary for function prologues, and use those positions as function beginnings

  * **resolve_indirect_jumps** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Try to resolve indirect jumps. This is necessary to resolve jump targets from jump tables, etc.

  * **force_segment** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Force CFGFast to rely on binary segments instead of sections.

  * **force_complete_scan** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Perform a complete scan on the binary and maximize the number of identified code blocks.

  * **data_references** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Enables the collection of references to data used by individual instructions. This does not collect ‘cross-references’, particularly those that involve multiple instructions. For that, see cross_references

  * **cross_references** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether CFGFast should collect “cross-references” from the entire program or not. This will populate the knowledge base with references to and from each recognizable address constant found in the code. Note that, because this performs constant propagation on the entire program, it may be much slower and consume more memory. This option implies data_references=True.

  * **normalize** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Normalize the CFG as well as all function graphs after CFG recovery.

  * **start_at_entry** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Begin CFG recovery at the entry point of this project. Setting it to False prevents CFGFast from viewing the entry point as one of the starting points of code scanning.

  * **function_starts** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A list of extra function starting points. CFGFast will try to resume scanning from each address in the list.

  * **extra_memory_regions** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A list of 2-tuple (start-address, end-address) that shows extra memory regions. Integers falling inside will be considered as pointers.

  * **indirect_jump_resolvers** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A custom list of indirect jump resolvers. If this list is None or empty, default indirect jump resolvers specific to this architecture and binary types will be loaded.

  * **base_state** – A state to use as a backer for all memory loads

  * **detect_tail_calls** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Enable aggressive tail-call optimization detection.

  * **elf_eh_frame** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Retrieve function starts (and maybe sizes later) from the .eh_frame of ELF binaries.

  * **skip_unmapped_addrs** – Ignore all branches into unmapped regions. True by default. You may want to set it to False if you are analyzing manually patched binaries or malware samples.

  * **indirect_calls_always_return** – Should CFG assume indirect calls must return or not. Assuming indirect calls must return will significantly reduce the number of constant propagation runs, but may reduce the overall CFG recovery precision when facing non-returning indirect calls. By default, we only assume indirect calls always return for large binaries (region > 50KB).

  * **jumptable_resolver_resolves_calls** – Whether JumpTableResolver should resolve indirect calls or not. Most indirect calls in C++ binaries or UEFI binaries cannot be resolved using jump table resolver and must be resolved using their specific resolvers. By default, we will only disable JumpTableResolver from resolving indirect calls for large binaries (region > 50 KB).

:param check_funcret_max_job When popping return-site jobs out of the job queue, angr will prioritize jobs
    

for which the callee is known to return. This check may be slow when there are a large amount of jobs in different caller functions, and this situation often occurs in obfuscated binaries where many functions never return. This parameter acts as a threshold to disable this check when the number of jobs in the queue exceeds this threshold.

Parameters:
    

  * **start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – (Deprecated) The beginning address of CFG recovery.

  * **end** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – (Deprecated) The end address of CFG recovery.

  * **arch_options** (_CFGArchOptions_) – Architecture-specific options.

  * **extra_arch_options** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")) – Any key-value pair in kwargs will be seen as an arch-specific option and will be used to set the option value in self._arch_options.

Extra parameters that angr.Analysis takes:

Parameters:
    

  * **progress_callback** – Specify a callback function to get the progress during CFG recovery.

  * **show_progressbar** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Should CFGFast show a progressbar during CFG recovery or not.

Returns:
    

None

normalize()¶
    

Normalize the CFG, making sure that there are no overlapping basic blocks.

Note that this method will not alter transition graphs of each function in self.kb.functions. You may call normalize() on each Function object to normalize their transition graphs.

Returns:
    

None

make_functions()¶
    

Revisit the entire control flow graph, create Function instances accordingly, and correctly put blocks into each function.

Although Function objects are crated during the CFG recovery, they are neither sound nor accurate. With a pre-constructed CFG, this method rebuilds all functions bearing the following rules:

>   * A block may only belong to one function.
> 
>   * Small functions lying inside the startpoint and the endpoint of another function will be merged with the other function
> 
>   * Tail call optimizations are detected.
> 
>   * PLT stubs are aligned by 16.
> 
> 

Returns:
    

None

_class _angr.analyses.CalleeCleanupFinder(_starts =None_, _hook_all =False_)¶
    

Bases: `Analysis`

__init__(_starts =None_, _hook_all =False_)¶
    

analyze(_addr_)¶
    

_class _angr.analyses.CallingConventionAnalysis(_func_ , _cfg =None_, _analyze_callsites =False_, _caller_func_addr =None_, _callsite_block_addr =None_, _callsite_insn_addr =None_, _func_graph =None_, _input_args =None_, _retval_size =None_)¶
    

Bases: `Analysis`

Analyze the calling convention of a function and guess a probable prototype.

The calling convention of a function can be inferred at both its call sites and the function itself. At call sites, we consider all register and stack variables that are not alive after the function call as parameters to this function. In the function itself, we consider all register and stack variables that are read but without initialization as parameters. Then we synthesize the information from both locations and make a reasonable inference of calling convention of this function.

Variables:
    

  * **_function** – The function to recover calling convention for.

  * **_variable_manager** – A handy accessor to the variable manager.

  * **_cfg** – A reference of the CFGModel of the current binary. It is used to discover call sites of the current function in order to perform analysis at call sites.

  * **analyze_callsites** – True if we should analyze all call sites of the current function to determine the calling convention and arguments. This can be time-consuming if there are many call sites to analyze.

  * **cc** – The recovered calling convention for the function.

Parameters:
    

  * **func** (_Function_ _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **cfg** (_CFGModel_ _|__None_)

  * **analyze_callsites** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **caller_func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **callsite_block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **callsite_insn_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **func_graph** (_networkx.DiGraph_ _|__None_)

  * **input_args** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__SimRegArg_ _|__SimStackArg_ _]__|__None_)

  * **retval_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_func_ , _cfg =None_, _analyze_callsites =False_, _caller_func_addr =None_, _callsite_block_addr =None_, _callsite_insn_addr =None_, _func_graph =None_, _input_args =None_, _retval_size =None_)¶
    

Parameters:
    

  * **func** (_Function_ _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **cfg** (_CFGModel_ _|__None_)

  * **analyze_callsites** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **caller_func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **callsite_block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **callsite_insn_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **func_graph** (_DiGraph_ _|__None_)

  * **input_args** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__SimRegArg_ _|__SimStackArg_ _]__|__None_)

  * **retval_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

is_va_start_amd64(_func_)¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"), [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")]

Parameters:
    

**func** (_Function_)

_class _angr.analyses.ClassIdentifier¶
    

Bases: `Analysis`

This is a class identifier for non stripped or partially stripped binaries, it identifies classes based on the demangled function names, and also assigns functions to their respective classes based on their names. It also uses the results from the VtableFinder analysis to assign the corresponding vtable to the classes.

> self.classes contains a mapping between class names and SimCppClass objects
> 
> e.g. A::tool() and A::qux() belong to the class A

__init__()¶
    

_class _angr.analyses.CodeCaveAnalysis¶
    

Bases: `Analysis`

Best-effort static location of potential vacant code caves for possible code injection: \- Padding functions \- Unreachable code

__init__()¶
    

codecaves _: list[CodeCave]_¶
    

_class _angr.analyses.CodeTagging(_func_)¶
    

Bases: `Analysis`

__init__(_func_)¶
    

analyze()¶
    

has_xor()¶
    

Detects if there is any xor operation in the function.

Returns:
    

Tags

has_bitshifts()¶
    

Detects if there is any bitwise operation in the function.

Returns:
    

Tags.

has_sql()¶
    

Detects if there is any reference to strings that look like SQL queries.

_class _angr.analyses.CompleteCallingConventionsAnalysis(_mode =CallingConventionAnalysisMode.FAST_, _recover_variables =False_, _low_priority =False_, _force =False_, _cfg =None_, _analyze_callsites =False_, _skip_signature_matched_functions =False_, _max_function_blocks =None_, _max_function_size =None_, _workers =0_, _cc_callback =None_, _prioritize_func_addrs =None_, _skip_other_funcs =False_, _auto_start =True_, _func_graphs =None_)¶
    

Bases: `Analysis`

Implements full-binary calling convention analysis. During the initial analysis of a binary, you may set recover_variables to True so that it will perform variable recovery on each function before performing calling convention analysis.

Parameters:
    

  * **mode** (_CallingConventionAnalysisMode_)

  * **cfg** (_CFGFast_ _|__CFGModel_ _|__None_)

  * **analyze_callsites** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **skip_signature_matched_functions** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **max_function_blocks** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **max_function_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **workers** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **cc_callback** (_Callable_ _|__None_)

  * **prioritize_func_addrs** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|_[_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **skip_other_funcs** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **auto_start** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **func_graphs** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__networkx.DiGraph_ _]__|__None_)

__init__(_mode =CallingConventionAnalysisMode.FAST_, _recover_variables =False_, _low_priority =False_, _force =False_, _cfg =None_, _analyze_callsites =False_, _skip_signature_matched_functions =False_, _max_function_blocks =None_, _max_function_size =None_, _workers =0_, _cc_callback =None_, _prioritize_func_addrs =None_, _skip_other_funcs =False_, _auto_start =True_, _func_graphs =None_)¶
    

Parameters:
    

  * **recover_variables** – Recover variables on each function before performing calling convention analysis.

  * **low_priority** – Run in the background - periodically release GIL.

  * **force** – Perform calling convention analysis on functions even if they have calling conventions or prototypes already specified (or previously recovered).

  * **cfg** ([`Union`](https://docs.python.org/3/library/typing.html#typing.Union "\(in Python v3.13\)")[`CFGFast`, `CFGModel`, [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")]) – The control flow graph model, which will be passed to CallingConventionAnalysis.

  * **analyze_callsites** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Consider artifacts at call sites when performing calling convention analysis.

  * **skip_signature_matched_functions** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Do not perform calling convention analysis on functions that match against existing FLIRT signatures.

  * **max_function_blocks** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – Do not perform calling convention analysis on functions with more than the specified number of blocks. Setting it to None disables this check.

  * **max_function_size** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – Do not perform calling convention analysis on functions whose sizes are more than max_function_size. Setting it to None disables this check.

  * **workers** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Number of multiprocessing workers.

  * **mode** (_CallingConventionAnalysisMode_)

  * **cc_callback** ([_Callable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)") _|__None_)

  * **prioritize_func_addrs** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|_[_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **skip_other_funcs** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **auto_start** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **func_graphs** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__DiGraph_ _]__|__None_)

work()¶
    

prioritize_functions(_func_addrs_to_prioritize_)¶
    

Prioritize the analysis of specified functions.

Parameters:
    

**func_addrs_to_prioritize** ([`Iterable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – A collection of function addresses to analyze first.

_static _function_needs_variable_recovery(_func_)¶
    

Check if running variable recovery on the function is the only way to determine the calling convention of the this function.

We do not need to run variable recovery to determine the calling convention of a function if: \- The function is a SimProcedure. \- The function is a PLT stub. \- The function is a library function and we already know its prototype.

Parameters:
    

**func** – The function object.

Returns:
    

True if we must run VariableRecovery before we can determine what the calling convention of this function is. False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.analyses.CongruencyCheck(_throw =False_)¶
    

Bases: `Analysis`

This is an analysis to ensure that angr executes things identically with different execution backends (i.e., unicorn vs vex).

__init__(_throw =False_)¶
    

Initializes a CongruencyCheck analysis.

Parameters:
    

**throw** – whether to raise an exception if an incongruency is found.

set_state_options(_left_add_options =None_, _left_remove_options =None_, _right_add_options =None_, _right_remove_options =None_)¶
    

Checks that the specified state options result in the same states over the next depth states.

set_states(_left_state_ , _right_state_)¶
    

Checks that the specified paths stay the same over the next depth states.

set_simgr(_simgr_)¶
    

run(_depth =None_)¶
    

Checks that the paths in the specified path group stay the same over the next depth bytes.

The path group should have a “left” and a “right” stash, each with a single path.

compare_path_group(_pg_)¶
    

compare_states(_sl_ , _sr_)¶
    

Compares two states for similarity.

compare_paths(_pl_ , _pr_)¶
    

_class _angr.analyses.DataDependencyGraphAnalysis(_end_state_ , _start_from =None_, _end_at =None_, _block_addrs =None_)¶
    

Bases: `Analysis`

This is a DYNAMIC data dependency graph that utilizes a given SimState to produce a DDG graph that is accurate to the path the program took during execution.

This analysis utilizes the SimActionData objects present in the provided SimState’s action history to generate the dependency graph.

Parameters:
    

  * **end_state** (_SimState_)

  * **start_from** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **end_at** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **block_addrs** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

__init__(_end_state_ , _start_from =None_, _end_at =None_, _block_addrs =None_)¶
    

Parameters:
    

  * **end_state** (`SimState`) – Simulation state used to extract all SimActionData

  * **start_from** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – An address or None, Specifies where to start generation of DDG

  * **end_at** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – An address or None, Specifies where to end generation of DDG

  * **block_addrs** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_) – List of block addresses that the DDG analysis should be run on

  * **block_addrs**

_property _graph _: DiGraph | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

_property _simplified_graph _: DiGraph | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

_property _sub_graph _: DiGraph | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

get_data_dep(_g_node_ , _include_tmp_nodes_ , _backwards_)¶
    

Return type:
    

`DiGraph` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **g_node** (_BaseDepNode_)

  * **include_tmp_nodes** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **backwards** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

_class _angr.analyses.Decompiler(_func_ , _cfg =None_, _options =None_, _preset =None_, _optimization_passes =None_, _sp_tracker_track_memory =True_, _variable_kb =None_, _peephole_optimizations =None_, _vars_must_struct =None_, _flavor ='pseudocode'_, _expr_comments =None_, _stmt_comments =None_, _ite_exprs =None_, _binop_operators =None_, _decompile =True_, _regen_clinic =True_, _inline_functions =frozenset({})_, _desired_variables =frozenset({})_, _update_memory_data =True_, _generate_code =True_, _use_cache =True_, _expr_collapse_depth =16_, _clinic_graph =None_, _clinic_arg_vvars =None_, _clinic_start_stage =None_)¶
    

Bases: `Analysis`

The decompiler analysis.

Run this on a Function object for which a normalized CFG has been constructed. The fully processed output can be found in result.codegen.text

Parameters:
    

  * **func** (_Function_ _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **cfg** (_CFGFast_ _|__CFGModel_ _|__None_)

  * **preset** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__DecompilationPreset_ _|__None_)

  * **peephole_optimizations** (__PEEPHOLE_OPTIMIZATIONS_TYPE_)

  * **vars_must_struct** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **update_memory_data** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **generate_code** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **use_cache** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **expr_collapse_depth** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_func_ , _cfg =None_, _options =None_, _preset =None_, _optimization_passes =None_, _sp_tracker_track_memory =True_, _variable_kb =None_, _peephole_optimizations =None_, _vars_must_struct =None_, _flavor ='pseudocode'_, _expr_comments =None_, _stmt_comments =None_, _ite_exprs =None_, _binop_operators =None_, _decompile =True_, _regen_clinic =True_, _inline_functions =frozenset({})_, _desired_variables =frozenset({})_, _update_memory_data =True_, _generate_code =True_, _use_cache =True_, _expr_collapse_depth =16_, _clinic_graph =None_, _clinic_arg_vvars =None_, _clinic_start_stage =None_)¶
    

Parameters:
    

  * **func** (_Function_ _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **cfg** (_CFGFast_ _|__CFGModel_ _|__None_)

  * **preset** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__DecompilationPreset_ _|__None_)

  * **peephole_optimizations** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__PeepholeOptimizationStmtBase_ _]__|_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__PeepholeOptimizationExprBase_ _]__]__|__None_)

  * **vars_must_struct** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **update_memory_data** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **generate_code** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **use_cache** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **expr_collapse_depth** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

reflow_variable_types(_type_constraints_ , _func_typevar_ , _var_to_typevar_ , _codegen_)¶
    

Re-run type inference on an existing variable recovery result, then rerun codegen to generate new results.

Returns:
    

Parameters:
    

  * **type_constraints** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__TypeVariable_ _,_[_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__TypeConstraint_ _]__]_)

  * **var_to_typevar** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)"))

find_data_references_and_update_memory_data(_seq_node_)¶
    

Parameters:
    

**seq_node** (_SequenceNode_)

transform_graph_from_ssa(_ail_graph_)¶
    

Translate an SSA AIL graph out of SSA form. This is useful for producing a non-SSA AIL graph for displaying in angr management.

Parameters:
    

**ail_graph** (`DiGraph`) – The AIL graph to transform out of SSA form.

Return type:
    

`DiGraph`

Returns:
    

The translated AIL graph.

transform_seqnode_from_ssa(_seq_node_)¶
    

Return type:
    

`SequenceNode`

Parameters:
    

**seq_node** (_SequenceNode_)

_static _options_to_params(_options_)¶
    

Convert decompilation options to a dict of params.

Parameters:
    

**options** ([`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`DecompilationOption`, [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – The decompilation options.

Return type:
    

[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]

Returns:
    

A dict of keyword arguments.

_class _angr.analyses.Disassembly(_function =None_, _ranges =None_, _thumb =False_, _include_ir =False_, _block_bytes =None_)¶
    

Bases: `Analysis`

Produce formatted machine code disassembly.

Parameters:
    

  * **function** (_Function_ _|__None_)

  * **ranges** (_Sequence_ _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__]__|__None_)

  * **thumb** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **include_ir** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **block_bytes** ([_bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") _|__None_)

__init__(_function =None_, _ranges =None_, _thumb =False_, _include_ir =False_, _block_bytes =None_)¶
    

Parameters:
    

  * **function** (_Function_ _|__None_)

  * **ranges** ([_Sequence_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__]__|__None_)

  * **thumb** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **include_ir** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **block_bytes** ([_bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") _|__None_)

func_lookup(_block_)¶
    

parse_block(_block_)¶
    

Parse instructions for a given block node

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**block** (_BlockNode_)

render(_formatting =None_, _show_edges =True_, _show_addresses =True_, _show_bytes =False_, _ascii_only =None_, _color =True_, _min_edge_depth =0_)¶
    

Render the disassembly to a string, with optional edges and addresses.

Color will be added by default, if enabled. To disable color pass an empty formatting dict.

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

Parameters:
    

  * **show_edges** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **show_addresses** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **show_bytes** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **ascii_only** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **color** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **min_edge_depth** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_class _angr.analyses.DominanceFrontier(_func_ , _func_graph =None_, _entry =None_, _exception_edges =False_)¶
    

Bases: `Analysis`

Computes the dominance frontier of all nodes in a function graph, and provides an easy-to-use interface for querying the frontier information.

__init__(_func_ , _func_graph =None_, _entry =None_, _exception_edges =False_)¶
    

_class _angr.analyses.FactCollector(_func_ , _max_depth =30_)¶
    

Bases: `Analysis`

An extremely fast analysis that extracts necessary facts of a function for CallingConventionAnalysis to make decision on the calling convention and prototype of a function.

Parameters:
    

  * **func** (_Function_)

  * **max_depth** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_func_ , _max_depth =30_)¶
    

Parameters:
    

  * **func** (_Function_)

  * **max_depth** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_class _angr.analyses.FastConstantPropagation(_func_ , _blocks =None_, _vex_cross_insn_opt =False_, _load_callback =None_)¶
    

Bases: `Analysis`

An extremely fast constant propagation analysis that finds function-wide constant values with potentially high false negative rates.

Parameters:
    

  * **func** (_Function_)

  * **blocks** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Block_ _]__|__None_)

  * **vex_cross_insn_opt** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **load_callback** (_Callable_ _|__None_)

__init__(_func_ , _blocks =None_, _vex_cross_insn_opt =False_, _load_callback =None_)¶
    

Parameters:
    

  * **func** (_Function_)

  * **blocks** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Block_ _]__|__None_)

  * **vex_cross_insn_opt** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **load_callback** ([_Callable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)") _|__None_)

_class _angr.analyses.FlirtAnalysis(_sig =None_, _max_mismatched_bytes =0_)¶
    

Bases: `Analysis`

FlirtAnalysis accomplishes two purposes:

  * If a FLIRT signature file is specified, it will match the given signature file against the current binary and rename recognized functions accordingly.

  * If no FLIRT signature file is specified, it will use strings to determine possible libraries embedded in the current binary, and then match all possible signatures for the architecture.

Parameters:
    

  * **sig** (_FlirtSignature_ _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **max_mismatched_bytes** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_sig =None_, _max_mismatched_bytes =0_)¶
    

Parameters:
    

  * **sig** (_FlirtSignature_ _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **max_mismatched_bytes** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_class _angr.analyses.ForwardAnalysis(_order_jobs =False_, _allow_merging =False_, _allow_widening =False_, _status_callback =None_, _graph_visitor =None_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`AnalysisState`, `NodeType`, `JobType`, `JobKey`]

This is my very first attempt to build a static forward analysis framework that can serve as the base of multiple static analyses in angr, including CFG analysis, VFG analysis, DDG, etc.

In short, ForwardAnalysis performs a forward data-flow analysis by traversing a graph, compute on abstract values, and store results in abstract states. The user can specify what graph to traverse, how a graph should be traversed, how abstract values and abstract states are defined, etc.

ForwardAnalysis has a few options to toggle, making it suitable to be the base class of several different styles of forward data-flow analysis implementations.

ForwardAnalysis supports a special mode when no graph is available for traversal (for example, when a CFG is being initialized and constructed, no other graph can be used). In that case, the graph traversal functionality is disabled, and the optimal graph traversal order is not guaranteed. The user can provide a job sorting method to sort the jobs in queue and optimize traversal order.

Feel free to discuss with me (Fish) if you have any suggestions or complaints.

Parameters:
    

  * **status_callback** (_Callable_ _[__[_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__ForwardAnalysis_ _]__]__,__Any_ _]__|__None_)

  * **graph_visitor** (_GraphVisitor_ _[__NodeType_ _]__|__None_)

__init__(_order_jobs =False_, _allow_merging =False_, _allow_widening =False_, _status_callback =None_, _graph_visitor =None_)¶
    

Constructor

Parameters:
    

  * **order_jobs** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If all jobs should be ordered or not.

  * **allow_merging** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If job merging is allowed.

  * **allow_widening** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If job widening is allowed.

  * **graph_visitor** (_GraphVisitor_ _or_ _None_) – A graph visitor to provide successors.

  * **status_callback** ([_Callable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)") _[__[_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__ForwardAnalysis_ _]__]__,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]__|__None_)

Returns:
    

None

_property _should_abort¶
    

Should the analysis be terminated. :return: True/False

_property _graph _: DiGraph_¶
    

_property _jobs¶
    

abort()¶
    

Abort the analysis :return: None

has_job(_job_)¶
    

Checks whether there exists another job which has the same job key. :type job: [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`JobType`) :param job: The job to check.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

True if there exists another job with the same key, False otherwise.

Parameters:
    

**job** (_JobType_)

downsize()¶
    

_class _angr.analyses.Identifier(_cfg =None_, _require_predecessors =True_, _only_find =None_)¶
    

Bases: `Analysis`

__init__(_cfg =None_, _require_predecessors =True_, _only_find =None_)¶
    

run(_only_find =None_)¶
    

can_call_same_name(_addr_ , _name_)¶
    

get_func_info(_func_)¶
    

_static _constrain_all_zero(_before_state_ , _state_ , _regs_)¶
    

identify_func(_function_)¶
    

check_tests(_cfg_func_ , _match_func_)¶
    

map_callsites()¶
    

do_trace(_addr_trace_ , _reverse_accesses_ , _func_info_)¶
    

get_call_args(_func_ , _callsite_)¶
    

_static _get_reg_name(_arch_ , _reg_offset_)¶
    

Parameters:
    

  * **arch** – the architecture

  * **reg_offset** – Tries to find the name of a register given the offset in the registers.

Returns:
    

The register name

find_stack_vars_x86(_func_)¶
    

_static _make_initial_state(_project_ , _stack_length_)¶
    

Returns:
    

an initial state with a symbolic stack and good options for rop

_static _make_symbolic_state(_project_ , _reg_list_ , _stack_length =80_)¶
    

converts an input state into a state with symbolic registers :return: the symbolic state

_class _angr.analyses.InitializationFinder(_func =None_, _func_graph =None_, _block =None_, _max_iterations =1_, _replacements =None_, _overlay =None_, _pointers_only =False_)¶
    

Bases: `ForwardAnalysis`, `Analysis`

Finds possible initializations for global data sections and generate an overlay to be used in other analyses later on.

__init__(_func =None_, _func_graph =None_, _block =None_, _max_iterations =1_, _replacements =None_, _overlay =None_, _pointers_only =False_)¶
    

Constructor

Parameters:
    

  * **order_jobs** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If all jobs should be ordered or not.

  * **allow_merging** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If job merging is allowed.

  * **allow_widening** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If job widening is allowed.

  * **graph_visitor** (_GraphVisitor_ _or_ _None_) – A graph visitor to provide successors.

Returns:
    

None

_class _angr.analyses.LoopFinder(_functions =None_, _normalize =True_)¶
    

Bases: `Analysis`

Extracts all the loops from all the functions in a binary.

__init__(_functions =None_, _normalize =True_)¶
    

_class _angr.analyses.PackingDetector(_cfg =None_, _region_size_threshold =32_)¶
    

Bases: `Analysis`

This analysis detects if a binary is likely packed or not. We may extend it to identify which packer is in use in the future.

Parameters:
    

  * **cfg** (_CFGModel_ _|__None_)

  * **region_size_threshold** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

PACKED_MIN_BYTES _ = 256_¶
    

PACKED_ENTROPY_MIN_THRESHOLD _ = 0.88_¶
    

__init__(_cfg =None_, _region_size_threshold =32_)¶
    

Parameters:
    

  * **cfg** (_CFGModel_ _|__None_)

  * **region_size_threshold** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

analyze()¶
    

_class _angr.analyses.PatchFinderAnalysis¶
    

Bases: `Analysis`

Looks for binary patches using some basic heuristics: \- Looking for interleaved functions \- Looking for unaligned functions

__init__()¶
    

atypical_alignments _: list[AtypicallyAlignedFunction]_¶
    

possibly_patched_out _: list[PatchedOutFunctionality]_¶
    

_class _angr.analyses.Pathfinder(_start_state_ , _goal_addr_ , _cfg_ , _cache_size =10000_)¶
    

Bases: `Analysis`

Parameters:
    

  * **start_state** (_SimState_)

  * **goal_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **cfg** (_CFGModel_)

__init__(_start_state_ , _goal_addr_ , _cfg_ , _cache_size =10000_)¶
    

Parameters:
    

  * **start_state** (_SimState_)

  * **goal_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **cfg** (_CFGModel_)

cache_state(_state_)¶
    

Parameters:
    

**state** (_SimState_)

marker_to_state(_marker_)¶
    

Return type:
    

`SimState` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**marker** (_SimStateMarker_)

analyze()¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

find_best_hypothesis_path()¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`...`](https://docs.python.org/3/library/constants.html#Ellipsis "\(in Python v3.13\)")]

diagnose_unsat(_state_)¶
    

Parameters:
    

**state** (_SimState_)

test_path(_bbl_addr_trace_)¶
    

Return type:
    

`TestPathReport`

Parameters:
    

**bbl_addr_trace** ([_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__...__]_)

_class _angr.analyses.PropagatorAnalysis(_func =None_, _block =None_, _func_graph =None_, _base_state =None_, _max_iterations =30_, _load_callback =None_, _stack_pointer_tracker =None_, _only_consts =False_, _completed_funcs =None_, _do_binops =True_, _store_tops =True_, _vex_cross_insn_opt =False_, _func_addr =None_, _gp =None_, _cache_results =False_, _key_prefix =None_, _profiling =False_)¶
    

Bases: `ForwardAnalysis`, `Analysis`

PropagatorAnalysis implements copy propagation. It propagates values (either constant values or variables) and expressions inside a block or across a function.

PropagatorAnalysis only supports VEX. For AIL, please use SPropagator.

PropagatorAnalysis performs certain arithmetic operations between constants, including but are not limited to:

  * addition

  * subtraction

  * multiplication

  * division

  * xor

It also performs the following memory operations:

  * Loading values from a known address

  * Writing values to a stack variable

Parameters:
    

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **gp** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **cache_results** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **key_prefix** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **profiling** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_func =None_, _block =None_, _func_graph =None_, _base_state =None_, _max_iterations =30_, _load_callback =None_, _stack_pointer_tracker =None_, _only_consts =False_, _completed_funcs =None_, _do_binops =True_, _store_tops =True_, _vex_cross_insn_opt =False_, _func_addr =None_, _gp =None_, _cache_results =False_, _key_prefix =None_, _profiling =False_)¶
    

Constructor

Parameters:
    

  * **order_jobs** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If all jobs should be ordered or not.

  * **allow_merging** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If job merging is allowed.

  * **allow_widening** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If job widening is allowed.

  * **graph_visitor** (_GraphVisitor_ _or_ _None_) – A graph visitor to provide successors.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **gp** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **cache_results** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **key_prefix** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **profiling** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Returns:
    

None

_property _prop_key _: [tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)"), [str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"), [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"), [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"), [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")]_¶
    

Gets a key that represents the function and the “flavor” of the propagation result.

_property _replacements¶
    

_class _angr.analyses.ProximityGraphAnalysis(_func_ , _cfg_model_ , _xrefs_ , _decompilation =None_, _expand_funcs =None_)¶
    

Bases: `Analysis`

Generate a proximity graph.

Parameters:
    

  * **func** (_Function_)

  * **cfg_model** (_CFGModel_)

  * **xrefs** (_XRefManager_)

  * **decompilation** (_Decompiler_ _|__None_)

  * **expand_funcs** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

__init__(_func_ , _cfg_model_ , _xrefs_ , _decompilation =None_, _expand_funcs =None_)¶
    

Parameters:
    

  * **func** (_Function_)

  * **cfg_model** (_CFGModel_)

  * **xrefs** (_XRefManager_)

  * **decompilation** (_Decompiler_ _|__None_)

  * **expand_funcs** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

_class _angr.analyses.ReachingDefinitionsAnalysis(_subject_ , _func_graph =None_, _max_iterations =30_, _track_tmps =False_, _track_consts =True_, _observation_points =None_, _init_state =None_, _init_context =None_, _state_initializer =None_, _cc =None_, _function_handler =None_, _observe_all =False_, _visited_blocks =None_, _dep_graph =True_, _observe_callback =None_, _canonical_size =8_, _stack_pointer_tracker =None_, _use_callee_saved_regs_at_return =True_, _interfunction_level =0_, _track_liveness =True_, _func_addr =None_, _element_limit =5_, _merge_into_tops =True_)¶
    

Bases: `ForwardAnalysis`[`ReachingDefinitionsState`, `NodeType`, [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)"), [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")], `Analysis`

ReachingDefinitionsAnalysis is a text-book implementation of a static data-flow analysis that works on either a function or a block. It supports both VEX and AIL. By registering observers to observation points, users may use this analysis to generate use-def chains, def-use chains, and reaching definitions, and perform other traditional data-flow analyses such as liveness analysis.

  * I’ve always wanted to find a better name for this analysis. Now I gave up and decided to live with this name for the foreseeable future (until a better name is proposed by someone else).

  * Aliasing is definitely a problem, and I forgot how aliasing is resolved in this implementation. I’ll leave this as a post-graduation TODO.

  * Some more documentation and examples would be nice.

Parameters:
    

  * **subject** (_Subject_ _|__ailment.Block_ _|__Block_ _|__Function_ _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **observation_points** (_Iterable_ _[__ObservationPoint_ _]__|__None_)

  * **init_state** (_ReachingDefinitionsState_ _|__None_)

  * **state_initializer** (_RDAStateInitializer_ _|__None_)

  * **function_handler** (_FunctionHandler_ _|__None_)

  * **dep_graph** (_DepGraph_ _|_[_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **interfunction_level** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **track_liveness** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **element_limit** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **merge_into_tops** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_subject_ , _func_graph =None_, _max_iterations =30_, _track_tmps =False_, _track_consts =True_, _observation_points =None_, _init_state =None_, _init_context =None_, _state_initializer =None_, _cc =None_, _function_handler =None_, _observe_all =False_, _visited_blocks =None_, _dep_graph =True_, _observe_callback =None_, _canonical_size =8_, _stack_pointer_tracker =None_, _use_callee_saved_regs_at_return =True_, _interfunction_level =0_, _track_liveness =True_, _func_addr =None_, _element_limit =5_, _merge_into_tops =True_)¶
    

Parameters:
    

  * **subject** (`Subject` | `Block` | `Block` | `Function` | [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The subject of the analysis: a function, or a single basic block

  * **func_graph** – Alternative graph for function.graph.

  * **max_iterations** – The maximum number of iterations before the analysis is terminated.

  * **track_tmps** – Whether or not temporary variables should be taken into consideration during the analysis.

  * **observation_points** (_iterable_) – A collection of tuples of (“node”|”insn”, ins_addr, OP_TYPE) defining where reaching definitions should be copied and stored. OP_TYPE can be OP_BEFORE or OP_AFTER.

  * **init_state** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[`ReachingDefinitionsState`]) – An optional initialization state. The analysis creates and works on a copy. Default to None: the analysis then initialize its own abstract state, based on the given <Subject>.

  * **init_context** – If init_state is not given, this is used to initialize the context field of the initial state’s CodeLocation. The only default-supported type which may go here is a tuple of integers, i.e. a callstack. Anything else requires a custom FunctionHandler.

  * **cc** – Calling convention of the function.

  * **function_handler** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[`FunctionHandler`]) – The function handler to update the analysis state and results on function calls.

  * **observe_all** – Observe every statement, both before and after.

  * **visited_blocks** – A set of previously visited blocks.

  * **dep_graph** (`DepGraph` | [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")) – An initial dependency graph to add the result of the analysis to. Set it to None to skip dependency graph generation.

  * **canonical_size** – The sizes (in bytes) that objects with an UNKNOWN_SIZE are treated as for operations where sizes are necessary.

  * **dep_graph** – Set this to True to generate a dependency graph for the subject. It will be available as result.dep_graph.

  * **interfunction_level** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The number of functions we should recurse into. This parameter is only used if function_handler is not provided.

  * **track_liveness** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether to track liveness information. This can consume sizeable amounts of RAM on large functions. (e.g. ~15GB for a function with 4k nodes)

  * **merge_into_tops** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Merge known values into TOP if TOP is present. If True: {TOP} V {0xabc} = {TOP} If False: {TOP} V {0xabc} = {TOP, 0xabc}

  * **state_initializer** (_RDAStateInitializer_ _|__None_)

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **element_limit** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_property _observed_results _: [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"), [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")], LiveDefinitions]_¶
    

_property _all_definitions¶
    

_property _all_uses¶
    

_property _one_result¶
    

_property _dep_graph _: DepGraph_¶
    

_property _visited_blocks¶
    

get_reaching_definitions_by_insn(_ins_addr_ , _op_type_)¶
    

get_reaching_definitions_by_node(_node_addr_ , _op_type_)¶
    

node_observe(_node_addr_ , _state_ , _op_type_ , _node_idx =None_)¶
    

Parameters:
    

  * **node_addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the node.

  * **state** (`ReachingDefinitionsState`) – The analysis state.

  * **op_type** (`ObservationPointType`) – Type of the observation point. Must be one of the following: OP_BEFORE, OP_AFTER.

  * **node_idx** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – ID of the node. Used in AIL to differentiate blocks with the same address.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

insn_observe(_insn_addr_ , _stmt_ , _block_ , _state_ , _op_type_)¶
    

Parameters:
    

  * **insn_addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the instruction.

  * **stmt** (`Statement` | [`IRStmt`](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.stmt.IRStmt "\(in pyvex\)")) – The statement.

  * **block** (`Block` | `Block`) – The current block.

  * **state** (`ReachingDefinitionsState`) – The abstract analysis state.

  * **op_type** (`ObservationPointType`) – Type of the observation point. Must be one of the following: OP_BEORE, OP_AFTER.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

stmt_observe(_stmt_idx_ , _stmt_ , _block_ , _state_ , _op_type_)¶
    

Parameters:
    

  * **stmt_idx** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **stmt** (`Statement` | [`IRStmt`](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.stmt.IRStmt "\(in pyvex\)"))

  * **block** (`Block` | `Block`)

  * **state** (`ReachingDefinitionsState`)

  * **op_type** (`ObservationPointType`)

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

exit_observe(_node_addr_ , _exit_stmt_idx_ , _block_ , _state_ , _node_idx =None_)¶
    

Parameters:
    

  * **node_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **exit_stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **block** (_Block_ _|__Block_)

  * **state** (_ReachingDefinitionsState_)

  * **node_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

_property _subject¶
    

callsites_to(_target_)¶
    

Return type:
    

[`Iterable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)")[`FunctionCallRelationships`]

Parameters:
    

**target** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__Function_)

_class _angr.analyses.Reassembler(_syntax ='intel'_, _remove_cgc_attachments =True_, _log_relocations =True_)¶
    

Bases: `Analysis`

High-level representation of a binary with a linear representation of all instructions and data regions. After calling “symbolize”, it essentially acts as a binary reassembler.

Tested on CGC, x86 and x86-64 binaries.

Disclaimer: The reassembler is an empirical solution. Don’t be surprised if it does not work on some binaries.

__init__(_syntax ='intel'_, _remove_cgc_attachments =True_, _log_relocations =True_)¶
    

_property _instructions¶
    

Get a list of all instructions in the binary

Returns:
    

A list of (address, instruction)

Return type:
    

[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

_property _relocations¶
    

_property _inserted_asm_before_label¶
    

_property _inserted_asm_after_label¶
    

_property _main_executable_regions¶
    

return:

_property _main_nonexecutable_regions¶
    

return:

section_alignment(_section_name_)¶
    

Get the alignment for the specific section. If the section is not found, 16 is used as default.

Parameters:
    

**section_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The section.

Returns:
    

The alignment in bytes.

Return type:
    

[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

main_executable_regions_contain(_addr_)¶
    

Parameters:
    

**addr**

Returns:
    

main_executable_region_limbos_contain(_addr_)¶
    

Sometimes there exists a pointer that points to a few bytes before the beginning of a section, or a few bytes after the beginning of the section. We take care of that here.

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address to check.

Returns:
    

A 2-tuple of (bool, the closest base address)

Return type:
    

[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

main_nonexecutable_regions_contain(_addr_)¶
    

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address to check.

Returns:
    

True if the address is inside a non-executable region, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

main_nonexecutable_region_limbos_contain(_addr_ , _tolerance_before =64_, _tolerance_after =64_)¶
    

Sometimes there exists a pointer that points to a few bytes before the beginning of a section, or a few bytes after the beginning of the section. We take care of that here.

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address to check.

Returns:
    

A 2-tuple of (bool, the closest base address)

Return type:
    

[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

register_instruction_reference(_insn_addr_ , _ref_addr_ , _sort_ , _operand_offset_)¶
    

register_data_reference(_data_addr_ , _ref_addr_)¶
    

add_label(_name_ , _addr_)¶
    

Add a new label to the symbol manager.

Parameters:
    

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of the label.

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the label.

Returns:
    

None

insert_asm(_addr_ , _asm_code_ , _before_label =False_)¶
    

Insert some assembly code at the specific address. There must be an instruction starting at that address.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of insertion

  * **asm_code** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The assembly code to insert

Returns:
    

None

append_procedure(_name_ , _asm_code_)¶
    

Add a new procedure with specific name and assembly code.

Parameters:
    

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The name of the new procedure.

  * **asm_code** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The assembly code of the procedure

Returns:
    

None

append_data(_name_ , _initial_content_ , _size_ , _readonly =False_, _sort ='unknown'_)¶
    

Append a new data entry into the binary with specific name, content, and size.

Parameters:
    

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of the data entry. Will be used as the label.

  * **initial_content** ([_bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)")) – The initial content of the data entry.

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Size of the data entry.

  * **readonly** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If the data entry belongs to the readonly region.

  * **sort** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Type of the data.

Returns:
    

None

remove_instruction(_ins_addr_)¶
    

Parameters:
    

**ins_addr**

Returns:
    

randomize_procedures()¶
    

Returns:
    

symbolize()¶
    

assembly(_comments =False_, _symbolized =True_)¶
    

remove_cgc_attachments()¶
    

Remove CGC attachments.

Returns:
    

True if CGC attachments are found and removed, False otherwise

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

remove_unnecessary_stuff()¶
    

Remove unnecessary functions and data

Returns:
    

None

remove_unnecessary_stuff_glibc()¶
    

fast_memory_load(_addr_ , _size_ , _data_type_ , _endness ='Iend_LE'_)¶
    

Load memory bytes from loader’s memory backend.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address to begin memory loading.

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Size in bytes.

  * **data_type** – Type of the data.

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Endianness of this memory load.

Returns:
    

Data read out of the memory.

Return type:
    

[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") or [bytes](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") or [str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") or None

_class _angr.analyses.SLivenessAnalysis(_func_ , _func_graph =None_, _entry =None_, _func_addr =None_, _arg_vvars =None_)¶
    

Bases: `Analysis`

Calculates LiveIn and LiveOut sets for each block in a partial-SSA function.

Parameters:
    

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **arg_vvars** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__VirtualVariable_ _]__|__None_)

__init__(_func_ , _func_graph =None_, _entry =None_, _func_addr =None_, _arg_vvars =None_)¶
    

Parameters:
    

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **arg_vvars** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__VirtualVariable_ _]__|__None_)

interference_graph()¶
    

Generate an interference graph based on the liveness analysis result.

Return type:
    

`Graph`

Returns:
    

A networkx.Graph instance.

_class _angr.analyses.SPropagatorAnalysis(_subject_ , _func_graph =None_, _only_consts =True_, _stack_pointer_tracker =None_, _func_args =None_, _func_addr =None_)¶
    

Bases: `Analysis`

Constant and expression propagation that only supports SSA AIL graphs.

Parameters:
    

  * **subject** (_Block_ _|__Function_)

  * **func_graph** (_networkx.DiGraph_ _|__None_)

  * **only_consts** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **func_args** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__VirtualVariable_ _]__|__None_)

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_subject_ , _func_graph =None_, _only_consts =True_, _stack_pointer_tracker =None_, _func_args =None_, _func_addr =None_)¶
    

Parameters:
    

  * **subject** (_Block_ _|__Function_)

  * **func_graph** (_DiGraph_ _|__None_)

  * **only_consts** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **func_args** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__VirtualVariable_ _]__|__None_)

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

_property _replacements¶
    

_property _dead_vvar_ids¶
    

_static _is_global_variable_updated(_func_graph_ , _block_dict_ , _varid_ , _gv_addr_ , _gv_size_ , _defloc_ , _useloc_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

  * **varid** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **gv_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **gv_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **defloc** (_CodeLocation_)

  * **useloc** (_CodeLocation_)

_static _is_vvar_used_for_addr_loading_switch_case(_uselocs_ , _blocks_)¶
    

Check if a virtual variable is used for loading an address in a switch-case construct.

Parameters:
    

  * **uselocs** ([`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`CodeLocation`]) – The use locations of the virtual variable.

  * **blocks** – All blocks of the current function.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

True if the virtual variable is used for loading an address in a switch-case construct, False otherwise.

_static _vvar_dep_graph(_blocks_ , _vvar_def_locs_ , _vvar_use_locs_)¶
    

Return type:
    

`DiGraph`

_class _angr.analyses.SReachingDefinitionsAnalysis(_subject_ , _func_addr =None_, _func_graph =None_, _func_args =None_, _track_tmps =False_)¶
    

Bases: `Analysis`

Constant and expression propagation that only supports SSA AIL graphs.

Parameters:
    

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **func_graph** (_networkx.DiGraph_ _[__Block_ _]__|__None_)

  * **func_args** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__VirtualVariable_ _]__|__None_)

  * **track_tmps** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_subject_ , _func_addr =None_, _func_graph =None_, _func_args =None_, _track_tmps =False_)¶
    

_class _angr.analyses.SelfModifyingCodeAnalysis(_subject_ , _max_bytes =0_, _state =None_)¶
    

Bases: `Analysis`

Determine if some piece of code is self-modifying.

This determination is made by simply executing. If an address is executed that is also written to, the code is determined to be self-modifying. The determination is stored in the result property. The regions property contains a list of (addr, length) regions that were both written to and executed.

Parameters:
    

  * **subject** (_None_ _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__Function_)

  * **max_bytes** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **state** (_SimState_ _|__None_)

__init__(_subject_ , _max_bytes =0_, _state =None_)¶
    

Parameters:
    

  * **subject** ([`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") | [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | `Function`) – Subject of analysis

  * **max_bytes** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Maximum number of bytes from subject address. 0 for no limit (default).

  * **state** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[`SimState`]) – State to begin executing from.

regions _: list[tuple[int, int]]_¶
    

result _: bool_¶
    

_class _angr.analyses.SootClassHierarchy¶
    

Bases: `Analysis`

Generate complete hierarchy.

__init__()¶
    

init_hierarchy()¶
    

has_super_class(_cls_)¶
    

is_subclass_including(_cls_child_ , _cls_parent_)¶
    

is_subclass(_cls_child_ , _cls_parent_)¶
    

is_visible_method(_cls_ , _method_)¶
    

is_visible_class(_cls_from_ , _cls_to_)¶
    

get_super_classes(_cls_)¶
    

get_super_classes_including(_cls_)¶
    

get_implementers(_interface_)¶
    

get_sub_interfaces_including(_interface_)¶
    

get_sub_interfaces(_interface_)¶
    

get_sub_classes(_cls_)¶
    

get_sub_classes_including(_cls_)¶
    

resolve_abstract_dispatch(_cls_ , _method_)¶
    

resolve_concrete_dispatch(_cls_ , _method_)¶
    

resolve_special_dispatch(_method_ , _container_)¶
    

resolve_invoke(_invoke_expr_ , _method_ , _container_)¶
    

_class _angr.analyses.StackPointerTracker(_func_ , _reg_offsets_ , _block =None_, _track_memory =True_, _cross_insn_opt =True_, _initial_reg_values =None_, _resilient =True_)¶
    

Bases: `Analysis`, `ForwardAnalysis`

Track the offset of stack pointer at the end of each basic block of a function.

Parameters:
    

  * **func** (_Function_ _|__None_)

  * **reg_offsets** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]_)

  * **block** (_Block_ _|__None_)

  * **resilient** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_func_ , _reg_offsets_ , _block =None_, _track_memory =True_, _cross_insn_opt =True_, _initial_reg_values =None_, _resilient =True_)¶
    

Parameters:
    

  * **func** (_Function_ _|__None_)

  * **reg_offsets** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]_)

  * **block** (_Block_ _|__None_)

  * **resilient** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

offset_after(_addr_ , _reg_)¶
    

offset_before(_addr_ , _reg_)¶
    

offset_after_block(_block_addr_ , _reg_)¶
    

offset_before_block(_block_addr_ , _reg_)¶
    

constant_after(_addr_ , _reg_)¶
    

constant_before(_addr_ , _reg_)¶
    

constant_after_block(_block_addr_ , _reg_)¶
    

constant_before_block(_block_addr_ , _reg_)¶
    

_property _inconsistent¶
    

inconsistent_for(_reg_)¶
    

offsets_for(_reg_)¶
    

_class _angr.analyses.StaticHooker(_library_ , _binary =None_)¶
    

Bases: `Analysis`

This analysis works on statically linked binaries - it finds the library functions statically linked into the binary and hooks them with the appropriate simprocedures.

Right now it only works on unstripped binaries, but hey! There’s room to grow!

__init__(_library_ , _binary =None_)¶
    

_class _angr.analyses.StaticObjectFinder¶
    

Bases: `Analysis`

This analysis tries to find objects on the heap based on calls to new(), and subsequent calls to constructors with
    

the ‘this’ pointer

__init__()¶
    

_class _angr.analyses.Typehoon(_constraints_ , _func_var_ , _ground_truth =None_, _var_mapping =None_, _must_struct =None_, _stackvar_max_sizes =None_, _stack_offset_tvs =None_, _constraint_set_degradation_threshold =150_)¶
    

Bases: `Analysis`

A spiritual tribute to the long-standing typehoon project that @jmg (John Grosen) worked on during his days in the angr team. Now I feel really bad of asking the poor guy to work directly on VEX IR without any fancy static analysis support as we have right now…

Typehoon analysis implements a pushdown system that simplifies and solves type constraints. Our type constraints are largely an implementation of the paper Polymorphic Type Inference for Machine Code by Noonan, Loginov, and Cok from GrammaTech (with missing functionality support and bugs, of course). Type constraints are collected by running VariableRecoveryFast (maybe VariableRecovery later as well) on a function, and then solved using this analysis.

User may specify ground truth, which will override all types at certain program points during constraint solving.

Parameters:
    

  * **var_mapping** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__SimVariable_ _,_[_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__TypeVariable_ _]__]__|__None_)

  * **must_struct** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__TypeVariable_ _]__|__None_)

  * **stackvar_max_sizes** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__TypeVariable_ _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **stack_offset_tvs** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__TypeVariable_ _]__|__None_)

  * **constraint_set_degradation_threshold** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_constraints_ , _func_var_ , _ground_truth =None_, _var_mapping =None_, _must_struct =None_, _stackvar_max_sizes =None_, _stack_offset_tvs =None_, _constraint_set_degradation_threshold =150_)¶
    

Parameters:
    

  * **constraints**

  * **ground_truth** – A set of SimType-style solutions for some or all type variables. They will be respected during type solving.

  * **var_mapping** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[`SimVariable`, [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`TypeVariable`]]])

  * **must_struct** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`TypeVariable`]])

  * **stackvar_max_sizes** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__TypeVariable_ _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **stack_offset_tvs** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__TypeVariable_ _]__|__None_)

  * **constraint_set_degradation_threshold** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

update_variable_types(_func_addr_ , _var_to_typevars_ , _stack_offset_tvs =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **var_to_typevars** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__SimVariable_ _,_[_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__TypeVariable_ _]__]_)

  * **stack_offset_tvs** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__TypeVariable_ _]__|__None_)

pp_constraints()¶
    

Pretty-print constraints between _variables_ using the variable mapping.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

pp_solution()¶
    

Pretty-print solutions using the variable mapping.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

_class _angr.analyses.VariableRecovery(_func_ , _max_iterations =20_, _store_live_variables =False_)¶
    

Bases: `ForwardAnalysis`, `VariableRecoveryBase`

Recover “variables” from a function using forced execution.

While variables play a very important role in programming, it does not really exist after compiling. However, we can still identify and recovery their counterparts in binaries. It is worth noting that not every variable in source code can be identified in binaries, and not every recognized variable in binaries have a corresponding variable in the original source code. In short, there is no guarantee that the variables we identified/recognized in a binary are the same variables in its source code.

This analysis uses heuristics to identify and recovers the following types of variables: \- Register variables. \- Stack variables. \- Heap variables. (not implemented yet) \- Global variables. (not implemented yet)

This analysis takes a function as input, and performs a data-flow analysis on nodes. It runs concrete execution on every statement and hooks all register/memory accesses to discover all places that are accessing variables. It is slow, but has a more accurate analysis result. For a fast but inaccurate variable recovery, you may consider using VariableRecoveryFast.

This analysis follows SSA, which means every write creates a new variable in registers or memory (statck, heap, etc.). Things may get tricky when overlapping variable (in memory, as you cannot really have overlapping accesses to registers) accesses exist, and in such cases, a new variable will be created, and this new variable will overlap with one or more existing variables. A decision procedure (which is pretty much TODO) is required at the end of this analysis to resolve the conflicts between overlapping variables.

__init__(_func_ , _max_iterations =20_, _store_live_variables =False_)¶
    

Parameters:
    

**func** (_knowledge.Function_) – The function to analyze.

_class _angr.analyses.VariableRecoveryFast(_func_ , _func_graph =None_, _entry_node_addr =None_, _max_iterations =2_, _low_priority =False_, _track_sp =True_, _func_args =None_, _store_live_variables =False_, _unify_variables =True_, _func_arg_vvars =None_, _vvar_to_vvar =None_, _type_hints =None_)¶
    

Bases: `ForwardAnalysis`, `VariableRecoveryBase`

Recover “variables” from a function by keeping track of stack pointer offsets and pattern matching VEX statements.

If calling conventions are recovered prior to running VariableRecoveryFast, variables can be recognized more accurately. However, it is not a requirement. In this case, the function graph you pass must contain information indicating the call-out sites inside the analyzed function. These graph edges must be annotated with either `"type": "call"` or `"outside": True`.

Parameters:
    

  * **func** (_Function_ _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **func_graph** (_networkx.DiGraph_ _|__None_)

  * **entry_node_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_ _]__|__None_)

  * **max_iterations** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **func_args** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__SimVariable_ _]__|__None_)

  * **func_arg_vvars** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__VirtualVariable_ _,__SimVariable_ _]__]__|__None_)

  * **vvar_to_vvar** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **type_hints** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__atoms.VirtualVariable_ _|__atoms.MemoryLocation_ _,_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__]__|__None_)

__init__(_func_ , _func_graph =None_, _entry_node_addr =None_, _max_iterations =2_, _low_priority =False_, _track_sp =True_, _func_args =None_, _store_live_variables =False_, _unify_variables =True_, _func_arg_vvars =None_, _vvar_to_vvar =None_, _type_hints =None_)¶
    

Constructor

Parameters:
    

  * **order_jobs** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If all jobs should be ordered or not.

  * **allow_merging** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If job merging is allowed.

  * **allow_widening** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If job widening is allowed.

  * **graph_visitor** (_GraphVisitor_ _or_ _None_) – A graph visitor to provide successors.

  * **func** (_Function_ _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **func_graph** (_DiGraph_ _|__None_)

  * **entry_node_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_ _]__|__None_)

  * **max_iterations** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **func_args** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__SimVariable_ _]__|__None_)

  * **func_arg_vvars** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__VirtualVariable_ _,__SimVariable_ _]__]__|__None_)

  * **vvar_to_vvar** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **type_hints** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__VirtualVariable_ _|__MemoryLocation_ _,_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__]__|__None_)

Returns:
    

None

_class _angr.analyses.Veritesting(_input_state_ , _boundaries =None_, _loop_unrolling_limit =10_, _enable_function_inlining =False_, _terminator =None_, _deviation_filter =None_)¶
    

Bases: `Analysis`

An exploration technique made for condensing chunks of code to single (nested) if-then-else constraints via CFG accurate to conduct Static Symbolic Execution SSE (conversion to single constraint)

cfg_cache _ = {}_¶
    

all_stashes _ = ('successful', 'errored', 'deadended', 'deviated', 'unconstrained')_¶
    

__init__(_input_state_ , _boundaries =None_, _loop_unrolling_limit =10_, _enable_function_inlining =False_, _terminator =None_, _deviation_filter =None_)¶
    

SSE stands for Static Symbolic Execution, and we also implemented an extended version of Veritesting (Avgerinos, Thanassis, et al, ICSE 2014).

Parameters:
    

  * **input_state** – The initial state to begin the execution with.

  * **boundaries** – Addresses where execution should stop.

  * **loop_unrolling_limit** – The maximum times that Veritesting should unroll a loop for.

  * **enable_function_inlining** – Whether we should enable function inlining and syscall inlining.

  * **terminator** – A callback function that takes a state as parameter. Veritesting will terminate if this function returns True.

  * **deviation_filter** – A callback function that takes a state as parameter. Veritesting will put the state into “deviated” stash if this function returns True.

is_not_in_cfg(_s_)¶
    

Returns if s.addr is not a proper node in our CFG.

Parameters:
    

**s** (_SimState_) – The SimState instance to test.

Returns bool:
    

False if our CFG contains p.addr, True otherwise.

is_overbound(_state_)¶
    

Filter out all states that run out of boundaries or loop too many times.

param SimState state: SimState instance to check returns bool: True if outside of mem/loop_ctr boundary

_class _angr.analyses.VtableFinder¶
    

Bases: `Analysis`

This analysis locates Vtables in a binary based on heuristics taken from - “Reconstruction of Class Hierarchies for Decompilation of C++ Programs”

__init__()¶
    

is_cross_referenced(_addr_)¶
    

is_function(_addr_)¶
    

analyze()¶
    

create_extract_vtable(_start_addr_ , _sec_size_)¶
    

_class _angr.analyses.XRefsAnalysis(_func =None_, _func_graph =None_, _block =None_, _max_iterations =1_, _replacements =None_)¶
    

Bases: `ForwardAnalysis`, `Analysis`

XRefsAnalysis recovers in-depth x-refs (cross-references) in disassembly code.

Here is an example:
    
    
    .text:
    000023C8                 LDR     R2, =time_now
    000023CA                 LDR     R3, [R2]
    000023CC                 ADDS    R3, #1
    000023CE                 STR     R3, [R2]
    000023D0                 BX      LR
    
    .bss:
    1FFF36F4 time_now        % 4
    

You will have the following x-refs for time_now:
    
    
    23c8 - offset
    23ca - read access
    23ce - write access
    

__init__(_func =None_, _func_graph =None_, _block =None_, _max_iterations =1_, _replacements =None_)¶
    

Constructor

Parameters:
    

  * **order_jobs** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If all jobs should be ordered or not.

  * **allow_merging** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If job merging is allowed.

  * **allow_widening** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If job widening is allowed.

  * **graph_visitor** (_GraphVisitor_ _or_ _None_) – A graph visitor to provide successors.

Returns:
    

None

angr.analyses.register_analysis(_cls_ , _name_)¶
    

_class _angr.analyses.analysis.AnalysisLogEntry(_message_ , _exc_info =False_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_message_ , _exc_info =False_)¶
    

format()¶
    

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

_class _angr.analyses.analysis.AnalysesHub(_project_)¶
    

Bases: `PluginVendor`[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]

This class contains functions for all the registered and runnable analyses,

__init__(_project_)¶
    

_class _angr.analyses.analysis.KnownAnalysesPlugin(_* args_, _** kwargs_)¶
    

Bases: [`Protocol`](https://docs.python.org/3/library/typing.html#typing.Protocol "\(in Python v3.13\)")

Identifier _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`Identifier`]_¶
    

CalleeCleanupFinder _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`CalleeCleanupFinder`]_¶
    

VSA_DDG _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`VSA_DDG`]_¶
    

CDG _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`CDG`]_¶
    

BinDiff _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`BinDiff`]_¶
    

CFGEmulated _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`CFGEmulated`]_¶
    

CFB _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`CFBlanket`]_¶
    

CFBlanket _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`CFBlanket`]_¶
    

CFG _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`CFG`]_¶
    

CFGFast _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`CFGFast`]_¶
    

StaticHooker _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`StaticHooker`]_¶
    

DDG _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`DDG`]_¶
    

CongruencyCheck _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`CongruencyCheck`]_¶
    

Reassembler _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`Reassembler`]_¶
    

BackwardSlice _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`BackwardSlice`]_¶
    

BinaryOptimizer _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`BinaryOptimizer`]_¶
    

VFG _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`VFG`]_¶
    

LoopFinder _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`LoopFinder`]_¶
    

Disassembly _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`Disassembly`]_¶
    

Veritesting _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`Veritesting`]_¶
    

CodeTagging _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`CodeTagging`]_¶
    

BoyScout _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`BoyScout`]_¶
    

VariableRecoveryFast _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`VariableRecoveryFast`]_¶
    

VariableRecovery _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`VariableRecovery`]_¶
    

ReachingDefinitions _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`ReachingDefinitionsAnalysis`]_¶
    

CompleteCallingConventions _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`CompleteCallingConventionsAnalysis`]_¶
    

Clinic _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`Clinic`]_¶
    

Propagator _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`PropagatorAnalysis`]_¶
    

CallingConvention _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`CallingConventionAnalysis`]_¶
    

Decompiler _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`Decompiler`]_¶
    

XRefs _: [`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`XRefsAnalysis`]_¶
    

__init__(_* args_, _** kwargs_)¶
    

_class _angr.analyses.analysis.AnalysesHubWithDefault(_project_)¶
    

Bases: `AnalysesHub`, `KnownAnalysesPlugin`

This class has type-hinting for all built-in analyses plugin

_class _angr.analyses.analysis.AnalysisFactory(_project_ , _analysis_cls_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`A`]

Parameters:
    

  * **project** (_Project_)

  * **analysis_cls** ([_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__A_ _]_)

__init__(_project_ , _analysis_cls_)¶
    

Parameters:
    

  * **project** (_Project_)

  * **analysis_cls** ([_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__A_ _]_)

prep(_fail_fast =None_, _kb =None_, _progress_callback =None_, _show_progressbar =False_)¶
    

Return type:
    

[`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`A`, bound= Analysis)]

Parameters:
    

  * **fail_fast** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **kb** (_KnowledgeBase_ _|__None_)

  * **progress_callback** ([_Callable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)") _|__None_)

  * **show_progressbar** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

_class _angr.analyses.analysis.Analysis¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

This class represents an analysis on the program.

Variables:
    

  * **project** – The project for this analysis.

  * **kb** (_KnowledgeBase_) – The knowledgebase object.

  * **_progress_callback** – A callback function for receiving the progress of this analysis. It only takes one argument, which is a float number from 0.0 to 100.0 indicating the current progress.

  * **_show_progressbar** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If a progressbar should be shown during the analysis. It’s independent from _progress_callback.

  * **_progressbar** (_progress.Progress_) – The progress bar object.

project _: `Project`_¶
    

kb _: `KnowledgeBase`_¶
    

errors _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`AnalysisLogEntry`]__ = []_¶
    

named_errors _: [`defaultdict`](https://docs.python.org/3/library/collections.html#collections.defaultdict "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"), [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`AnalysisLogEntry`]]__ = {}_¶
    

angr.analyses.analysis.register_analysis(_cls_ , _name_)¶
    

_class _angr.analyses.forward_analysis.CallGraphVisitor(_callgraph_)¶
    

Bases: `GraphVisitor`

Parameters:
    

**callgraph** (_networkx.DiGraph_)

__init__(_callgraph_)¶
    

successors(_node_)¶
    

Get successors of a node. The node should be in the graph.

Parameters:
    

**node** – The node to work with.

Returns:
    

A list of successors.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

predecessors(_node_)¶
    

Get predecessors of a node. The node should be in the graph.

Parameters:
    

**node** – The node to work with.

Returns:
    

A list of predecessors.

sort_nodes(_nodes =None_)¶
    

Get a list of all nodes sorted in an optimal traversal order.

Parameters:
    

**nodes** (_iterable_) – A collection of nodes to sort. If none, all nodes in the graph will be used to sort.

Returns:
    

A list of sorted nodes.

_class _angr.analyses.forward_analysis.ForwardAnalysis(_order_jobs =False_, _allow_merging =False_, _allow_widening =False_, _status_callback =None_, _graph_visitor =None_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`AnalysisState`, `NodeType`, `JobType`, `JobKey`]

This is my very first attempt to build a static forward analysis framework that can serve as the base of multiple static analyses in angr, including CFG analysis, VFG analysis, DDG, etc.

In short, ForwardAnalysis performs a forward data-flow analysis by traversing a graph, compute on abstract values, and store results in abstract states. The user can specify what graph to traverse, how a graph should be traversed, how abstract values and abstract states are defined, etc.

ForwardAnalysis has a few options to toggle, making it suitable to be the base class of several different styles of forward data-flow analysis implementations.

ForwardAnalysis supports a special mode when no graph is available for traversal (for example, when a CFG is being initialized and constructed, no other graph can be used). In that case, the graph traversal functionality is disabled, and the optimal graph traversal order is not guaranteed. The user can provide a job sorting method to sort the jobs in queue and optimize traversal order.

Feel free to discuss with me (Fish) if you have any suggestions or complaints.

Parameters:
    

  * **status_callback** (_Callable_ _[__[_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__ForwardAnalysis_ _]__]__,__Any_ _]__|__None_)

  * **graph_visitor** (_GraphVisitor_ _[__NodeType_ _]__|__None_)

__init__(_order_jobs =False_, _allow_merging =False_, _allow_widening =False_, _status_callback =None_, _graph_visitor =None_)¶
    

Constructor

Parameters:
    

  * **order_jobs** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If all jobs should be ordered or not.

  * **allow_merging** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If job merging is allowed.

  * **allow_widening** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If job widening is allowed.

  * **graph_visitor** (_GraphVisitor_ _or_ _None_) – A graph visitor to provide successors.

  * **status_callback** ([_Callable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)") _[__[_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__ForwardAnalysis_ _]__]__,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]__|__None_)

Returns:
    

None

_property _should_abort¶
    

Should the analysis be terminated. :return: True/False

_property _graph _: DiGraph_¶
    

_property _jobs¶
    

abort()¶
    

Abort the analysis :return: None

has_job(_job_)¶
    

Checks whether there exists another job which has the same job key. :type job: [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`JobType`) :param job: The job to check.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

True if there exists another job with the same key, False otherwise.

Parameters:
    

**job** (_JobType_)

downsize()¶
    

_class _angr.analyses.forward_analysis.FunctionGraphVisitor(_func_ , _graph =None_)¶
    

Bases: `GraphVisitor`

Parameters:
    

**func** (_knowledge.Function_)

__init__(_func_ , _graph =None_)¶
    

resume_with_new_graph(_graph_)¶
    

We can only reasonably reuse existing results if the node index of the already traversed nodes are the same as the ones from the new graph. Otherwise, we always restart.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

True if we are resuming, False if reset() is called.

Parameters:
    

**graph** (_DiGraph_)

successors(_node_)¶
    

Get successors of a node. The node should be in the graph.

Parameters:
    

**node** – The node to work with.

Returns:
    

A list of successors.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

predecessors(_node_)¶
    

Get predecessors of a node. The node should be in the graph.

Parameters:
    

**node** – The node to work with.

Returns:
    

A list of predecessors.

sort_nodes(_nodes =None_)¶
    

Get a list of all nodes sorted in an optimal traversal order.

Parameters:
    

**nodes** (_iterable_) – A collection of nodes to sort. If none, all nodes in the graph will be used to sort.

Returns:
    

A list of sorted nodes.

back_edges()¶
    

Get a list of back edges. This function is optional. If not overridden, the traverser cannot achieve an optimal graph traversal order.

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`NodeType`), [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`NodeType`)]]

Returns:
    

A list of back edges (source -> destination).

_class _angr.analyses.forward_analysis.LoopVisitor(_loop_)¶
    

Bases: `GraphVisitor`

Parameters:
    

**loop** (_angr.analyses.loopfinder.Loop_) – The loop to visit.

__init__(_loop_)¶
    

successors(_node_)¶
    

Get successors of a node. The node should be in the graph.

Parameters:
    

**node** – The node to work with.

Returns:
    

A list of successors.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

predecessors(_node_)¶
    

Get predecessors of a node. The node should be in the graph.

Parameters:
    

**node** – The node to work with.

Returns:
    

A list of predecessors.

sort_nodes(_nodes =None_)¶
    

Get a list of all nodes sorted in an optimal traversal order.

Parameters:
    

**nodes** (_iterable_) – A collection of nodes to sort. If none, all nodes in the graph will be used to sort.

Returns:
    

A list of sorted nodes.

_class _angr.analyses.forward_analysis.SingleNodeGraphVisitor(_node_)¶
    

Bases: `GraphVisitor`

Parameters:
    

**node** – The single node that should be in the graph.

__init__(_node_)¶
    

node¶
    

node_returned¶
    

reset()¶
    

Reset the internal node traversal state. Must be called prior to visiting future nodes.

Returns:
    

None

next_node()¶
    

Get the next node to visit.

Returns:
    

A node in the graph.

successors(_node_)¶
    

Get successors of a node. The node should be in the graph.

Parameters:
    

**node** – The node to work with.

Returns:
    

A list of successors.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

predecessors(_node_)¶
    

Get predecessors of a node. The node should be in the graph.

Parameters:
    

**node** – The node to work with.

Returns:
    

A list of predecessors.

sort_nodes(_nodes =None_)¶
    

Get a list of all nodes sorted in an optimal traversal order.

Parameters:
    

**nodes** (_iterable_) – A collection of nodes to sort. If none, all nodes in the graph will be used to sort.

Returns:
    

A list of sorted nodes.

_class _angr.analyses.forward_analysis.forward_analysis.ForwardAnalysis(_order_jobs =False_, _allow_merging =False_, _allow_widening =False_, _status_callback =None_, _graph_visitor =None_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`AnalysisState`, `NodeType`, `JobType`, `JobKey`]

This is my very first attempt to build a static forward analysis framework that can serve as the base of multiple static analyses in angr, including CFG analysis, VFG analysis, DDG, etc.

In short, ForwardAnalysis performs a forward data-flow analysis by traversing a graph, compute on abstract values, and store results in abstract states. The user can specify what graph to traverse, how a graph should be traversed, how abstract values and abstract states are defined, etc.

ForwardAnalysis has a few options to toggle, making it suitable to be the base class of several different styles of forward data-flow analysis implementations.

ForwardAnalysis supports a special mode when no graph is available for traversal (for example, when a CFG is being initialized and constructed, no other graph can be used). In that case, the graph traversal functionality is disabled, and the optimal graph traversal order is not guaranteed. The user can provide a job sorting method to sort the jobs in queue and optimize traversal order.

Feel free to discuss with me (Fish) if you have any suggestions or complaints.

Parameters:
    

  * **status_callback** (_Callable_ _[__[_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__ForwardAnalysis_ _]__]__,__Any_ _]__|__None_)

  * **graph_visitor** (_GraphVisitor_ _[__NodeType_ _]__|__None_)

__init__(_order_jobs =False_, _allow_merging =False_, _allow_widening =False_, _status_callback =None_, _graph_visitor =None_)¶
    

Constructor

Parameters:
    

  * **order_jobs** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If all jobs should be ordered or not.

  * **allow_merging** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If job merging is allowed.

  * **allow_widening** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If job widening is allowed.

  * **graph_visitor** (_GraphVisitor_ _or_ _None_) – A graph visitor to provide successors.

  * **status_callback** ([_Callable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)") _[__[_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__ForwardAnalysis_ _]__]__,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]__|__None_)

Returns:
    

None

_property _should_abort¶
    

Should the analysis be terminated. :return: True/False

_property _graph _: DiGraph_¶
    

_property _jobs¶
    

abort()¶
    

Abort the analysis :return: None

has_job(_job_)¶
    

Checks whether there exists another job which has the same job key. :type job: [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`JobType`) :param job: The job to check.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

True if there exists another job with the same key, False otherwise.

Parameters:
    

**job** (_JobType_)

downsize()¶
    

_class _angr.analyses.forward_analysis.job_info.JobInfo(_key_ , _job_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`JobType`, `JobKey`]

Stores information of each job.

Parameters:
    

  * **key** (_JobKey_)

  * **job** (_JobType_)

__init__(_key_ , _job_)¶
    

Parameters:
    

  * **key** (_JobKey_)

  * **job** (_JobType_)

_property _job _: JobType_¶
    

Get the latest available job.

Returns:
    

The latest available job.

_property _merged_jobs¶
    

_property _widened_jobs¶
    

add_job(_job_ , _merged =False_, _widened =False_)¶
    

Appended a new job to this JobInfo node. :type job: :param job: The new job to append. :param bool merged: Whether it is a merged job or not. :param bool widened: Whether it is a widened job or not.

_class _angr.analyses.forward_analysis.visitors.CallGraphVisitor(_callgraph_)¶
    

Bases: `GraphVisitor`

Parameters:
    

**callgraph** (_networkx.DiGraph_)

__init__(_callgraph_)¶
    

successors(_node_)¶
    

Get successors of a node. The node should be in the graph.

Parameters:
    

**node** – The node to work with.

Returns:
    

A list of successors.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

predecessors(_node_)¶
    

Get predecessors of a node. The node should be in the graph.

Parameters:
    

**node** – The node to work with.

Returns:
    

A list of predecessors.

sort_nodes(_nodes =None_)¶
    

Get a list of all nodes sorted in an optimal traversal order.

Parameters:
    

**nodes** (_iterable_) – A collection of nodes to sort. If none, all nodes in the graph will be used to sort.

Returns:
    

A list of sorted nodes.

_class _angr.analyses.forward_analysis.visitors.FunctionGraphVisitor(_func_ , _graph =None_)¶
    

Bases: `GraphVisitor`

Parameters:
    

**func** (_knowledge.Function_)

__init__(_func_ , _graph =None_)¶
    

resume_with_new_graph(_graph_)¶
    

We can only reasonably reuse existing results if the node index of the already traversed nodes are the same as the ones from the new graph. Otherwise, we always restart.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

True if we are resuming, False if reset() is called.

Parameters:
    

**graph** (_DiGraph_)

successors(_node_)¶
    

Get successors of a node. The node should be in the graph.

Parameters:
    

**node** – The node to work with.

Returns:
    

A list of successors.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

predecessors(_node_)¶
    

Get predecessors of a node. The node should be in the graph.

Parameters:
    

**node** – The node to work with.

Returns:
    

A list of predecessors.

sort_nodes(_nodes =None_)¶
    

Get a list of all nodes sorted in an optimal traversal order.

Parameters:
    

**nodes** (_iterable_) – A collection of nodes to sort. If none, all nodes in the graph will be used to sort.

Returns:
    

A list of sorted nodes.

back_edges()¶
    

Get a list of back edges. This function is optional. If not overridden, the traverser cannot achieve an optimal graph traversal order.

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`NodeType`), [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`NodeType`)]]

Returns:
    

A list of back edges (source -> destination).

_class _angr.analyses.forward_analysis.visitors.LoopVisitor(_loop_)¶
    

Bases: `GraphVisitor`

Parameters:
    

**loop** (_angr.analyses.loopfinder.Loop_) – The loop to visit.

__init__(_loop_)¶
    

successors(_node_)¶
    

Get successors of a node. The node should be in the graph.

Parameters:
    

**node** – The node to work with.

Returns:
    

A list of successors.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

predecessors(_node_)¶
    

Get predecessors of a node. The node should be in the graph.

Parameters:
    

**node** – The node to work with.

Returns:
    

A list of predecessors.

sort_nodes(_nodes =None_)¶
    

Get a list of all nodes sorted in an optimal traversal order.

Parameters:
    

**nodes** (_iterable_) – A collection of nodes to sort. If none, all nodes in the graph will be used to sort.

Returns:
    

A list of sorted nodes.

_class _angr.analyses.forward_analysis.visitors.SingleNodeGraphVisitor(_node_)¶
    

Bases: `GraphVisitor`

Parameters:
    

**node** – The single node that should be in the graph.

__init__(_node_)¶
    

node¶
    

node_returned¶
    

reset()¶
    

Reset the internal node traversal state. Must be called prior to visiting future nodes.

Returns:
    

None

next_node()¶
    

Get the next node to visit.

Returns:
    

A node in the graph.

successors(_node_)¶
    

Get successors of a node. The node should be in the graph.

Parameters:
    

**node** – The node to work with.

Returns:
    

A list of successors.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

predecessors(_node_)¶
    

Get predecessors of a node. The node should be in the graph.

Parameters:
    

**node** – The node to work with.

Returns:
    

A list of predecessors.

sort_nodes(_nodes =None_)¶
    

Get a list of all nodes sorted in an optimal traversal order.

Parameters:
    

**nodes** (_iterable_) – A collection of nodes to sort. If none, all nodes in the graph will be used to sort.

Returns:
    

A list of sorted nodes.

_class _angr.analyses.forward_analysis.visitors.call_graph.CallGraphVisitor(_callgraph_)¶
    

Bases: `GraphVisitor`

Parameters:
    

**callgraph** (_networkx.DiGraph_)

__init__(_callgraph_)¶
    

successors(_node_)¶
    

Get successors of a node. The node should be in the graph.

Parameters:
    

**node** – The node to work with.

Returns:
    

A list of successors.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

predecessors(_node_)¶
    

Get predecessors of a node. The node should be in the graph.

Parameters:
    

**node** – The node to work with.

Returns:
    

A list of predecessors.

sort_nodes(_nodes =None_)¶
    

Get a list of all nodes sorted in an optimal traversal order.

Parameters:
    

**nodes** (_iterable_) – A collection of nodes to sort. If none, all nodes in the graph will be used to sort.

Returns:
    

A list of sorted nodes.

_class _angr.analyses.forward_analysis.visitors.function_graph.FunctionGraphVisitor(_func_ , _graph =None_)¶
    

Bases: `GraphVisitor`

Parameters:
    

**func** (_knowledge.Function_)

__init__(_func_ , _graph =None_)¶
    

resume_with_new_graph(_graph_)¶
    

We can only reasonably reuse existing results if the node index of the already traversed nodes are the same as the ones from the new graph. Otherwise, we always restart.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

True if we are resuming, False if reset() is called.

Parameters:
    

**graph** (_DiGraph_)

successors(_node_)¶
    

Get successors of a node. The node should be in the graph.

Parameters:
    

**node** – The node to work with.

Returns:
    

A list of successors.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

predecessors(_node_)¶
    

Get predecessors of a node. The node should be in the graph.

Parameters:
    

**node** – The node to work with.

Returns:
    

A list of predecessors.

sort_nodes(_nodes =None_)¶
    

Get a list of all nodes sorted in an optimal traversal order.

Parameters:
    

**nodes** (_iterable_) – A collection of nodes to sort. If none, all nodes in the graph will be used to sort.

Returns:
    

A list of sorted nodes.

back_edges()¶
    

Get a list of back edges. This function is optional. If not overridden, the traverser cannot achieve an optimal graph traversal order.

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`NodeType`), [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`NodeType`)]]

Returns:
    

A list of back edges (source -> destination).

_class _angr.analyses.forward_analysis.visitors.graph.GraphVisitor¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`NodeType`]

A graph visitor takes a node in the graph and returns its successors. Typically, it visits a control flow graph, and returns successors of a CFGNode each time. This is the base class of all graph visitors.

__init__()¶
    

successors(_node_)¶
    

Get successors of a node. The node should be in the graph.

Parameters:
    

**node** ([`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`NodeType`)) – The node to work with.

Returns:
    

A list of successors.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

predecessors(_node_)¶
    

Get predecessors of a node. The node should be in the graph.

Parameters:
    

**node** ([`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`NodeType`)) – The node to work with.

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`NodeType`)]

Returns:
    

A list of predecessors.

sort_nodes(_nodes =None_)¶
    

Get a list of all nodes sorted in an optimal traversal order.

Parameters:
    

**nodes** (_iterable_) – A collection of nodes to sort. If none, all nodes in the graph will be used to sort.

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`NodeType`)]

Returns:
    

A list of sorted nodes.

back_edges()¶
    

Get a list of back edges. This function is optional. If not overridden, the traverser cannot achieve an optimal graph traversal order.

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`NodeType`), [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`NodeType`)]]

Returns:
    

A list of back edges (source -> destination).

nodes()¶
    

Return an iterator of nodes following an optimal traversal order.

Return type:
    

[`Iterator`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterator "\(in Python v3.13\)")[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`NodeType`)]

Returns:
    

reset()¶
    

Reset the internal node traversal state. Must be called prior to visiting future nodes.

Returns:
    

None

next_node()¶
    

Get the next node to visit.

Return type:
    

[`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`NodeType`)]

Returns:
    

A node in the graph.

all_successors(_node_ , _skip_reached_fixedpoint =False_)¶
    

Returns all successors to the specific node.

Parameters:
    

**node** ([`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`NodeType`)) – A node in the graph.

Returns:
    

A set of nodes that are all successors to the given node.

Return type:
    

[set](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")

revisit_successors(_node_ , _include_self =True_)¶
    

Revisit a node in the future. As a result, the successors to this node will be revisited as well.

Parameters:
    

**node** ([`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`NodeType`)) – The node to revisit in the future.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

None

revisit_node(_node_)¶
    

Revisit a node in the future. Do not include its successors immediately.

Parameters:
    

**node** ([`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`NodeType`)) – The node to revisit in the future.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

None

reached_fixedpoint(_node_)¶
    

Mark a node as reached fixed-point. This node as well as all its successors will not be visited in the future.

Parameters:
    

**node** ([`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`NodeType`)) – The node to mark as reached fixed-point.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

None

_class _angr.analyses.forward_analysis.visitors.loop.LoopVisitor(_loop_)¶
    

Bases: `GraphVisitor`

Parameters:
    

**loop** (_angr.analyses.loopfinder.Loop_) – The loop to visit.

__init__(_loop_)¶
    

successors(_node_)¶
    

Get successors of a node. The node should be in the graph.

Parameters:
    

**node** – The node to work with.

Returns:
    

A list of successors.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

predecessors(_node_)¶
    

Get predecessors of a node. The node should be in the graph.

Parameters:
    

**node** – The node to work with.

Returns:
    

A list of predecessors.

sort_nodes(_nodes =None_)¶
    

Get a list of all nodes sorted in an optimal traversal order.

Parameters:
    

**nodes** (_iterable_) – A collection of nodes to sort. If none, all nodes in the graph will be used to sort.

Returns:
    

A list of sorted nodes.

_class _angr.analyses.forward_analysis.visitors.single_node_graph.SingleNodeGraphVisitor(_node_)¶
    

Bases: `GraphVisitor`

Parameters:
    

**node** – The single node that should be in the graph.

__init__(_node_)¶
    

node¶
    

node_returned¶
    

reset()¶
    

Reset the internal node traversal state. Must be called prior to visiting future nodes.

Returns:
    

None

next_node()¶
    

Get the next node to visit.

Returns:
    

A node in the graph.

successors(_node_)¶
    

Get successors of a node. The node should be in the graph.

Parameters:
    

**node** – The node to work with.

Returns:
    

A list of successors.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

predecessors(_node_)¶
    

Get predecessors of a node. The node should be in the graph.

Parameters:
    

**node** – The node to work with.

Returns:
    

A list of predecessors.

sort_nodes(_nodes =None_)¶
    

Get a list of all nodes sorted in an optimal traversal order.

Parameters:
    

**nodes** (_iterable_) – A collection of nodes to sort. If none, all nodes in the graph will be used to sort.

Returns:
    

A list of sorted nodes.

_class _angr.analyses.backward_slice.BackwardSlice(_cfg_ , _cdg_ , _ddg_ , _targets =None_, _cfg_node =None_, _stmt_id =None_, _control_flow_slice =False_, _same_function =False_, _no_construct =False_)¶
    

Bases: `Analysis`

Represents a backward slice of the program.

__init__(_cfg_ , _cdg_ , _ddg_ , _targets =None_, _cfg_node =None_, _stmt_id =None_, _control_flow_slice =False_, _same_function =False_, _no_construct =False_)¶
    

Create a backward slice from a specific statement based on provided control flow graph (CFG), control dependence graph (CDG), and data dependence graph (DDG).

The data dependence graph can be either CFG-based, or Value-set analysis based. A CFG-based DDG is much faster to generate, but it only reflects those states while generating the CFG, and it is neither sound nor accurate. The VSA based DDG (called VSA_DDG) is based on static analysis, which gives you a much better result.

Parameters:
    

  * **cfg** – The control flow graph.

  * **cdg** – The control dependence graph.

  * **ddg** – The data dependence graph.

  * **targets** – A list of “target” that specify targets of the backward slices. Each target can be a tuple in form of (cfg_node, stmt_idx), or a CodeLocation instance.

  * **cfg_node** – Deprecated. The target CFGNode to reach. It should exist in the CFG.

  * **stmt_id** – Deprecated. The target statement to reach.

  * **control_flow_slice** – True/False, indicates whether we should slice only based on CFG. Sometimes when acquiring DDG is difficult or impossible, you can just create a slice on your CFG. Well, if you don’t even have a CFG, then…

  * **no_construct** – Only used for testing and debugging to easily create a BackwardSlice object.

dbg_repr(_max_display =10_)¶
    

Debugging output of this slice.

Parameters:
    

**max_display** – The maximum number of SimRun slices to show.

Returns:
    

A string representation.

dbg_repr_run(_run_addr_)¶
    

Debugging output of a single SimRun slice.

Parameters:
    

**run_addr** – Address of the SimRun.

Returns:
    

A string representation.

annotated_cfg(_start_point =None_)¶
    

Returns an AnnotatedCFG based on slicing result.

is_taint_related_to_ip(_simrun_addr_ , _stmt_idx_ , _taint_type_ , _simrun_whitelist =None_)¶
    

Query in taint graph to check if a specific taint will taint the IP in the future or not. The taint is specified with the tuple (simrun_addr, stmt_idx, taint_type).

Parameters:
    

  * **simrun_addr** – Address of the SimRun.

  * **stmt_idx** – Statement ID.

  * **taint_type** – Type of the taint, might be one of the following: ‘reg’, ‘tmp’, ‘mem’.

  * **simrun_whitelist** – A list of SimRun addresses that are whitelisted, i.e. the tainted exit will be ignored if it is in those SimRuns.

Returns:
    

True/False

is_taint_impacting_stack_pointers(_simrun_addr_ , _stmt_idx_ , _taint_type_ , _simrun_whitelist =None_)¶
    

Query in taint graph to check if a specific taint will taint the stack pointer in the future or not. The taint is specified with the tuple (simrun_addr, stmt_idx, taint_type).

Parameters:
    

  * **simrun_addr** – Address of the SimRun.

  * **stmt_idx** – Statement ID.

  * **taint_type** – Type of the taint, might be one of the following: ‘reg’, ‘tmp’, ‘mem’.

  * **simrun_whitelist** – A list of SimRun addresses that are whitelisted.

Returns:
    

True/False.

_exception _angr.analyses.bindiff.UnmatchedStatementsException¶
    

Bases: [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception "\(in Python v3.13\)")

_class _angr.analyses.bindiff.Difference(_diff_type_ , _value_a_ , _value_b_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_diff_type_ , _value_a_ , _value_b_)¶
    

_class _angr.analyses.bindiff.ConstantChange(_offset_ , _value_a_ , _value_b_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_offset_ , _value_a_ , _value_b_)¶
    

angr.analyses.bindiff.differing_constants(_block_a_ , _block_b_)¶
    

Compares two basic blocks and finds all the constants that differ from the first block to the second.

Parameters:
    

  * **block_a** – The first block to compare.

  * **block_b** – The second block to compare.

Returns:
    

Returns a list of differing constants in the form of ConstantChange, which has the offset in the block and the respective constants.

angr.analyses.bindiff.compare_statement_dict(_statement_1_ , _statement_2_)¶
    

_class _angr.analyses.bindiff.NormalizedBlock(_block_ , _function_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_block_ , _function_)¶
    

_class _angr.analyses.bindiff.NormalizedFunction(_function_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Parameters:
    

**function** (_Function_)

__init__(_function_)¶
    

Parameters:
    

**function** (_Function_)

_class _angr.analyses.bindiff.FunctionDiff(_function_a_ , _function_b_ , _bindiff =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

This class computes the a diff between two functions.

Parameters:
    

  * **function_a** (_Function_)

  * **function_b** (_Function_)

__init__(_function_a_ , _function_b_ , _bindiff =None_)¶
    

Parameters:
    

  * **function_a** (`Function`) – The first angr Function object to diff.

  * **function_b** (`Function`) – The second angr Function object.

  * **bindiff** – An optional Bindiff object. Used for some extra normalization during basic block comparison.

_property _probably_identical¶
    

Whether or not these two functions are identical.

Type:
    

returns

_property _identical_blocks¶
    

A list of block matches which appear to be identical

Type:
    

returns

_property _differing_blocks¶
    

A list of block matches which appear to differ

Type:
    

returns

_property _blocks_with_differing_constants¶
    

A list of block matches which appear to differ

Type:
    

return

_property _block_matches¶
    

_property _unmatched_blocks¶
    

_static _get_normalized_block(_addr_ , _function_)¶
    

Parameters:
    

  * **addr** – Where to start the normalized block.

  * **function** – A function containing the block address.

Returns:
    

A normalized basic block.

block_similarity(_block_a_ , _block_b_)¶
    

Parameters:
    

  * **block_a** – The first block address.

  * **block_b** – The second block address.

Returns:
    

The similarity of the basic blocks, normalized for the base address of the block and function call addresses.

blocks_probably_identical(_block_a_ , _block_b_ , _check_constants =False_)¶
    

Parameters:
    

  * **block_a** – The first block address.

  * **block_b** – The second block address.

  * **check_constants** – Whether or not to require matching constants in blocks.

Returns:
    

Whether or not the blocks appear to be identical.

_class _angr.analyses.bindiff.BinDiff(_other_project_ , _cfg_a =None_, _cfg_b =None_)¶
    

Bases: `Analysis`

This class computes the a diff between two binaries represented by angr Projects

__init__(_other_project_ , _cfg_a =None_, _cfg_b =None_)¶
    

Parameters:
    

**other_project** – The second project to diff

functions_probably_identical(_func_a_addr_ , _func_b_addr_ , _check_consts =False_)¶
    

Compare two functions and return True if they appear identical.

Parameters:
    

  * **func_a_addr** – The address of the first function (in the first binary).

  * **func_b_addr** – The address of the second function (in the second binary).

Returns:
    

Whether or not the functions appear to be identical.

_property _identical_functions¶
    

A list of function matches that appear to be identical

Type:
    

returns

_property _differing_functions¶
    

A list of function matches that appear to differ

Type:
    

returns

differing_functions_with_consts()¶
    

Returns:
    

A list of function matches that appear to differ including just by constants

_property _differing_blocks¶
    

A list of block matches that appear to differ

Type:
    

returns

_property _identical_blocks¶
    

return A list of all block matches that appear to be identical

_property _blocks_with_differing_constants¶
    

A dict of block matches with differing constants to the tuple of constants

Type:
    

return

_property _unmatched_functions¶
    

get_function_diff(_function_addr_a_ , _function_addr_b_)¶
    

Parameters:
    

  * **function_addr_a** – The address of the first function (in the first binary)

  * **function_addr_b** – The address of the second function (in the second binary)

Returns:
    

the FunctionDiff of the two functions

_class _angr.analyses.boyscout.BoyScout(_cookiesize =1_)¶
    

Bases: `Analysis`

Try to determine the architecture and endieness of a binary blob

__init__(_cookiesize =1_)¶
    

_class _angr.analyses.calling_convention.CallingConventionAnalysis(_func_ , _cfg =None_, _analyze_callsites =False_, _caller_func_addr =None_, _callsite_block_addr =None_, _callsite_insn_addr =None_, _func_graph =None_, _input_args =None_, _retval_size =None_)¶
    

Bases: `Analysis`

Analyze the calling convention of a function and guess a probable prototype.

The calling convention of a function can be inferred at both its call sites and the function itself. At call sites, we consider all register and stack variables that are not alive after the function call as parameters to this function. In the function itself, we consider all register and stack variables that are read but without initialization as parameters. Then we synthesize the information from both locations and make a reasonable inference of calling convention of this function.

Variables:
    

  * **_function** – The function to recover calling convention for.

  * **_variable_manager** – A handy accessor to the variable manager.

  * **_cfg** – A reference of the CFGModel of the current binary. It is used to discover call sites of the current function in order to perform analysis at call sites.

  * **analyze_callsites** – True if we should analyze all call sites of the current function to determine the calling convention and arguments. This can be time-consuming if there are many call sites to analyze.

  * **cc** – The recovered calling convention for the function.

Parameters:
    

  * **func** (_Function_ _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **cfg** (_CFGModel_ _|__None_)

  * **analyze_callsites** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **caller_func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **callsite_block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **callsite_insn_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **func_graph** (_networkx.DiGraph_ _|__None_)

  * **input_args** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__SimRegArg_ _|__SimStackArg_ _]__|__None_)

  * **retval_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_func_ , _cfg =None_, _analyze_callsites =False_, _caller_func_addr =None_, _callsite_block_addr =None_, _callsite_insn_addr =None_, _func_graph =None_, _input_args =None_, _retval_size =None_)¶
    

Parameters:
    

  * **func** (_Function_ _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **cfg** (_CFGModel_ _|__None_)

  * **analyze_callsites** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **caller_func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **callsite_block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **callsite_insn_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **func_graph** (_DiGraph_ _|__None_)

  * **input_args** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__SimRegArg_ _|__SimStackArg_ _]__|__None_)

  * **retval_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

is_va_start_amd64(_func_)¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"), [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")]

Parameters:
    

**func** (_Function_)

_class _angr.analyses.calling_convention.FactCollector(_func_ , _max_depth =30_)¶
    

Bases: `Analysis`

An extremely fast analysis that extracts necessary facts of a function for CallingConventionAnalysis to make decision on the calling convention and prototype of a function.

Parameters:
    

  * **func** (_Function_)

  * **max_depth** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_func_ , _max_depth =30_)¶
    

Parameters:
    

  * **func** (_Function_)

  * **max_depth** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_class _angr.analyses.complete_calling_conventions.CallingConventionAnalysisMode(_value_)¶
    

Bases: [`Enum`](https://docs.python.org/3/library/enum.html#enum.Enum "\(in Python v3.13\)")

The mode of calling convention analysis.

FAST: Using FactCollector to collect facts, then use facts for calling convention analysis. VARIABLES: Using variables in VariableManager for calling convention analysis.

FAST _ = 'fast'_¶
    

VARIABLES _ = 'variables'_¶
    

_class _angr.analyses.complete_calling_conventions.CompleteCallingConventionsAnalysis(_mode =CallingConventionAnalysisMode.FAST_, _recover_variables =False_, _low_priority =False_, _force =False_, _cfg =None_, _analyze_callsites =False_, _skip_signature_matched_functions =False_, _max_function_blocks =None_, _max_function_size =None_, _workers =0_, _cc_callback =None_, _prioritize_func_addrs =None_, _skip_other_funcs =False_, _auto_start =True_, _func_graphs =None_)¶
    

Bases: `Analysis`

Implements full-binary calling convention analysis. During the initial analysis of a binary, you may set recover_variables to True so that it will perform variable recovery on each function before performing calling convention analysis.

Parameters:
    

  * **mode** (_CallingConventionAnalysisMode_)

  * **cfg** (_CFGFast_ _|__CFGModel_ _|__None_)

  * **analyze_callsites** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **skip_signature_matched_functions** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **max_function_blocks** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **max_function_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **workers** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **cc_callback** (_Callable_ _|__None_)

  * **prioritize_func_addrs** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|_[_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **skip_other_funcs** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **auto_start** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **func_graphs** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__networkx.DiGraph_ _]__|__None_)

__init__(_mode =CallingConventionAnalysisMode.FAST_, _recover_variables =False_, _low_priority =False_, _force =False_, _cfg =None_, _analyze_callsites =False_, _skip_signature_matched_functions =False_, _max_function_blocks =None_, _max_function_size =None_, _workers =0_, _cc_callback =None_, _prioritize_func_addrs =None_, _skip_other_funcs =False_, _auto_start =True_, _func_graphs =None_)¶
    

Parameters:
    

  * **recover_variables** – Recover variables on each function before performing calling convention analysis.

  * **low_priority** – Run in the background - periodically release GIL.

  * **force** – Perform calling convention analysis on functions even if they have calling conventions or prototypes already specified (or previously recovered).

  * **cfg** ([`Union`](https://docs.python.org/3/library/typing.html#typing.Union "\(in Python v3.13\)")[`CFGFast`, `CFGModel`, [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")]) – The control flow graph model, which will be passed to CallingConventionAnalysis.

  * **analyze_callsites** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Consider artifacts at call sites when performing calling convention analysis.

  * **skip_signature_matched_functions** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Do not perform calling convention analysis on functions that match against existing FLIRT signatures.

  * **max_function_blocks** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – Do not perform calling convention analysis on functions with more than the specified number of blocks. Setting it to None disables this check.

  * **max_function_size** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – Do not perform calling convention analysis on functions whose sizes are more than max_function_size. Setting it to None disables this check.

  * **workers** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Number of multiprocessing workers.

  * **mode** (_CallingConventionAnalysisMode_)

  * **cc_callback** ([_Callable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)") _|__None_)

  * **prioritize_func_addrs** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|_[_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **skip_other_funcs** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **auto_start** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **func_graphs** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__DiGraph_ _]__|__None_)

work()¶
    

prioritize_functions(_func_addrs_to_prioritize_)¶
    

Prioritize the analysis of specified functions.

Parameters:
    

**func_addrs_to_prioritize** ([`Iterable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – A collection of function addresses to analyze first.

_static _function_needs_variable_recovery(_func_)¶
    

Check if running variable recovery on the function is the only way to determine the calling convention of the this function.

We do not need to run variable recovery to determine the calling convention of a function if: \- The function is a SimProcedure. \- The function is a PLT stub. \- The function is a library function and we already know its prototype.

Parameters:
    

**func** – The function object.

Returns:
    

True if we must run VariableRecovery before we can determine what the calling convention of this function is. False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_exception _angr.analyses.soot_class_hierarchy.SootClassHierarchyError(_msg_)¶
    

Bases: [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception "\(in Python v3.13\)")

__init__(_msg_)¶
    

_exception _angr.analyses.soot_class_hierarchy.NoConcreteDispatch(_msg_)¶
    

Bases: `SootClassHierarchyError`

__init__(_msg_)¶
    

_class _angr.analyses.soot_class_hierarchy.SootClassHierarchy¶
    

Bases: `Analysis`

Generate complete hierarchy.

__init__()¶
    

init_hierarchy()¶
    

has_super_class(_cls_)¶
    

is_subclass_including(_cls_child_ , _cls_parent_)¶
    

is_subclass(_cls_child_ , _cls_parent_)¶
    

is_visible_method(_cls_ , _method_)¶
    

is_visible_class(_cls_from_ , _cls_to_)¶
    

get_super_classes(_cls_)¶
    

get_super_classes_including(_cls_)¶
    

get_implementers(_interface_)¶
    

get_sub_interfaces_including(_interface_)¶
    

get_sub_interfaces(_interface_)¶
    

get_sub_classes(_cls_)¶
    

get_sub_classes_including(_cls_)¶
    

resolve_abstract_dispatch(_cls_ , _method_)¶
    

resolve_concrete_dispatch(_cls_ , _method_)¶
    

resolve_special_dispatch(_method_ , _container_)¶
    

resolve_invoke(_invoke_expr_ , _method_ , _container_)¶
    

_class _angr.analyses.cfg.CFG(_** kwargs_)¶
    

Bases: `CFGFast`

tl;dr: CFG is just a wrapper around CFGFast for compatibility issues. It will be fully replaced by CFGFast in future releases. Feel free to use CFG if you intend to use CFGFast. Please use CFGEmulated if you _have to_ use the old, slow, dynamically-generated version of CFG.

For multiple historical reasons, angr’s CFG is accurate but slow, which does not meet what most people expect. We developed CFGFast for light-speed CFG recovery, and renamed the old CFG class to CFGEmulated. For compatibility concerns, CFG was kept as an alias to CFGEmulated.

However, so many new users of angr would load up a binary and generate a CFG immediately after running “pip install angr”, and draw the conclusion that “angr’s CFG is so slow - angr must be unusable!” Therefore, we made the hard decision: CFG will be an alias to CFGFast, instead of CFGEmulated.

To ease the transition of your existing code and script, the following changes are made:

  * A CFG class, which is a sub class of CFGFast, is created.

  * You will see both a warning message printed out to stderr and an exception raised by angr if you are passing CFG any parameter that only CFGEmulated supports. This exception is not a sub class of AngrError, so you wouldn’t capture it with your old code by mistake.

  * In the near future, this wrapper class will be removed completely, and CFG will be a simple alias to CFGFast.

We expect most interfaces are the same between CFGFast and CFGEmulated. Apparently some functionalities (like context-sensitivity, and state keeping) only exist in CFGEmulated, which is when you want to use CFGEmulated instead.

__init__(_** kwargs_)¶
    

Parameters:
    

  * **binary** – The binary to recover CFG on. By default the main binary is used.

  * **objects** – A list of objects to recover the CFG on. By default it will recover the CFG of all loaded objects.

  * **regions** (_iterable_) – A list of tuples in the form of (start address, end address) describing memory regions that the CFG should cover.

  * **pickle_intermediate_results** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If we want to store the intermediate results or not.

  * **symbols** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Get function beginnings from symbols in the binary.

  * **function_prologues** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Scan the binary for function prologues, and use those positions as function beginnings

  * **resolve_indirect_jumps** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Try to resolve indirect jumps. This is necessary to resolve jump targets from jump tables, etc.

  * **force_segment** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Force CFGFast to rely on binary segments instead of sections.

  * **force_complete_scan** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Perform a complete scan on the binary and maximize the number of identified code blocks.

  * **data_references** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Enables the collection of references to data used by individual instructions. This does not collect ‘cross-references’, particularly those that involve multiple instructions. For that, see cross_references

  * **cross_references** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether CFGFast should collect “cross-references” from the entire program or not. This will populate the knowledge base with references to and from each recognizable address constant found in the code. Note that, because this performs constant propagation on the entire program, it may be much slower and consume more memory. This option implies data_references=True.

  * **normalize** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Normalize the CFG as well as all function graphs after CFG recovery.

  * **start_at_entry** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Begin CFG recovery at the entry point of this project. Setting it to False prevents CFGFast from viewing the entry point as one of the starting points of code scanning.

  * **function_starts** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A list of extra function starting points. CFGFast will try to resume scanning from each address in the list.

  * **extra_memory_regions** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A list of 2-tuple (start-address, end-address) that shows extra memory regions. Integers falling inside will be considered as pointers.

  * **indirect_jump_resolvers** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A custom list of indirect jump resolvers. If this list is None or empty, default indirect jump resolvers specific to this architecture and binary types will be loaded.

  * **base_state** – A state to use as a backer for all memory loads

  * **detect_tail_calls** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Enable aggressive tail-call optimization detection.

  * **elf_eh_frame** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Retrieve function starts (and maybe sizes later) from the .eh_frame of ELF binaries.

  * **skip_unmapped_addrs** – Ignore all branches into unmapped regions. True by default. You may want to set it to False if you are analyzing manually patched binaries or malware samples.

  * **indirect_calls_always_return** – Should CFG assume indirect calls must return or not. Assuming indirect calls must return will significantly reduce the number of constant propagation runs, but may reduce the overall CFG recovery precision when facing non-returning indirect calls. By default, we only assume indirect calls always return for large binaries (region > 50KB).

  * **jumptable_resolver_resolves_calls** – Whether JumpTableResolver should resolve indirect calls or not. Most indirect calls in C++ binaries or UEFI binaries cannot be resolved using jump table resolver and must be resolved using their specific resolvers. By default, we will only disable JumpTableResolver from resolving indirect calls for large binaries (region > 50 KB).

:param check_funcret_max_job When popping return-site jobs out of the job queue, angr will prioritize jobs
    

for which the callee is known to return. This check may be slow when there are a large amount of jobs in different caller functions, and this situation often occurs in obfuscated binaries where many functions never return. This parameter acts as a threshold to disable this check when the number of jobs in the queue exceeds this threshold.

Parameters:
    

  * **start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – (Deprecated) The beginning address of CFG recovery.

  * **end** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – (Deprecated) The end address of CFG recovery.

  * **arch_options** (_CFGArchOptions_) – Architecture-specific options.

  * **extra_arch_options** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")) – Any key-value pair in kwargs will be seen as an arch-specific option and will be used to set the option value in self._arch_options.

Extra parameters that angr.Analysis takes:

Parameters:
    

  * **progress_callback** – Specify a callback function to get the progress during CFG recovery.

  * **show_progressbar** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Should CFGFast show a progressbar during CFG recovery or not.

Returns:
    

None

_class _angr.analyses.cfg.CFBlanket(_exclude_region_types =None_, _on_object_added =None_)¶
    

Bases: `Analysis`

A Control-Flow Blanket is a representation for storing all instructions, data entries, and bytes of a full program.

Region types: \- section \- segment \- extern \- tls \- kernel

Parameters:
    

  * **exclude_region_types** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **on_object_added** (_Callable_ _[__[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__Any_ _]__,__None_ _]__|__None_)

__init__(_exclude_region_types =None_, _on_object_added =None_)¶
    

Parameters:
    

  * **on_object_added** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`Callable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)")[[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")], [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")]]) – Callable with parameters (addr, obj) called after an object is added to the blanket.

  * **exclude_region_types** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

_property _regions¶
    

Return all memory regions.

floor_addr(_addr_)¶
    

floor_item(_addr_)¶
    

floor_items(_addr =None_, _reverse =False_)¶
    

ceiling_addr(_addr_)¶
    

ceiling_item(_addr_)¶
    

ceiling_items(_addr =None_, _reverse =False_, _include_first =True_)¶
    

add_obj(_addr_ , _obj_)¶
    

Adds an object obj to the blanket at the specified address addr

add_function(_func_)¶
    

Add a function func and all blocks of this function to the blanket.

dbg_repr()¶
    

The debugging representation of this CFBlanket.

Returns:
    

The debugging representation of this CFBlanket.

Return type:
    

[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

_class _angr.analyses.cfg.CFGArchOptions(_arch_ , _** options_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Stores architecture-specific options and settings, as well as the detailed explanation of those options and settings.

Suppose ao is the CFGArchOptions object, and there is an option called ret_jumpkind_heuristics, you can access it by ao.ret_jumpkind_heuristics and set its value via ao.ret_jumpkind_heuristics = True

Variables:
    

  * **OPTIONS** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")) – A dict of all default options for different architectures.

  * **arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)")) – The architecture object.

  * **_options** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")) – Values of all CFG options that are specific to the current architecture.

OPTIONS _ = {'ARMCortexM': {'has_arm_code': (<class 'bool'>, False), 'pattern_match_ifuncs': (<class 'bool'>, True), 'ret_jumpkind_heuristics': (<class 'bool'>, True), 'switch_mode_on_nodecode': (<class 'bool'>, False)}, 'ARMEL': {'has_arm_code': (<class 'bool'>, True), 'pattern_match_ifuncs': (<class 'bool'>, True), 'ret_jumpkind_heuristics': (<class 'bool'>, True), 'switch_mode_on_nodecode': (<class 'bool'>, True)}, 'ARMHF': {'has_arm_code': (<class 'bool'>, True), 'pattern_match_ifuncs': (<class 'bool'>, True), 'ret_jumpkind_heuristics': (<class 'bool'>, True), 'switch_mode_on_nodecode': (<class 'bool'>, True)}}_¶
    

__init__(_arch_ , _** options_)¶
    

Constructor.

Parameters:
    

  * **arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)")) – The architecture instance.

  * **options** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")) – Architecture-specific options, which will be used to initialize this object.

arch _ = None_¶
    

_class _angr.analyses.cfg.CFGBase(_sort_ , _context_sensitivity_level_ , _normalize =False_, _binary =None_, _objects =None_, _regions =None_, _exclude_sparse_regions =True_, _skip_specific_regions =True_, _force_segment =False_, _base_state =None_, _resolve_indirect_jumps =True_, _indirect_jump_resolvers =None_, _indirect_jump_target_limit =100000_, _detect_tail_calls =False_, _low_priority =False_, _skip_unmapped_addrs =True_, _sp_tracking_track_memory =True_, _model =None_)¶
    

Bases: `Analysis`

The base class for control flow graphs.

tag _: str | None_ _ = None_¶
    

__init__(_sort_ , _context_sensitivity_level_ , _normalize =False_, _binary =None_, _objects =None_, _regions =None_, _exclude_sparse_regions =True_, _skip_specific_regions =True_, _force_segment =False_, _base_state =None_, _resolve_indirect_jumps =True_, _indirect_jump_resolvers =None_, _indirect_jump_target_limit =100000_, _detect_tail_calls =False_, _low_priority =False_, _skip_unmapped_addrs =True_, _sp_tracking_track_memory =True_, _model =None_)¶
    

Parameters:
    

  * **sort** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – ‘fast’ or ‘emulated’.

  * **context_sensitivity_level** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The level of context-sensitivity of this CFG (see documentation for further details). It ranges from 0 to infinity.

  * **normalize** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether the CFG as well as all Function graphs should be normalized.

  * **binary** (_cle.backends.Backend_) – The binary to recover CFG on. By default, the main binary is used.

  * **objects** – A list of objects to recover the CFG on. By default, it will recover the CFG of all loaded objects.

  * **regions** (_iterable_) – A list of tuples in the form of (start address, end address) describing memory regions that the CFG should cover.

  * **force_segment** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Force CFGFast to rely on binary segments instead of sections.

  * **base_state** (_angr.SimState_) – A state to use as a backer for all memory loads.

  * **resolve_indirect_jumps** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether to try to resolve indirect jumps. This is necessary to resolve jump targets from jump tables, etc.

  * **indirect_jump_resolvers** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A custom list of indirect jump resolvers. If this list is None or empty, default indirect jump resolvers specific to this architecture and binary types will be loaded.

  * **indirect_jump_target_limit** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Maximum indirect jump targets to be recovered.

  * **skip_unmapped_addrs** – Ignore all branches into unmapped regions. True by default. You may want to set it to False if you are analyzing manually patched binaries or malware samples.

  * **detect_tail_calls** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Aggressive tail-call optimization detection. This option is only respected in make_functions().

  * **sp_tracking_track_memory** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether or not to track memory writes if tracking the stack pointer. This increases the accuracy of stack pointer tracking, especially for architectures without a base pointer. Only used if detect_tail_calls is enabled.

  * **model** (_None_ _or_ _CFGModel_) – The CFGModel instance to write to. A new CFGModel instance will be created and registered with the knowledge base if model is None.

Returns:
    

None

_property _model _: CFGModel_¶
    

Get the CFGModel instance. :return: The CFGModel instance that this analysis currently uses.

_property _normalized¶
    

_property _context_sensitivity_level¶
    

_property _functions¶
    

A reference to the FunctionManager in the current knowledge base.

Returns:
    

FunctionManager with all functions

Return type:
    

angr.knowledge_plugins.FunctionManager

make_copy(_copy_to_)¶
    

Copy self attributes to the new object.

Parameters:
    

**copy_to** (_CFGBase_) – The target to copy to.

Returns:
    

None

copy()¶
    

output()¶
    

generate_index()¶
    

Generate an index of all nodes in the graph in order to speed up get_any_node() with anyaddr=True.

Returns:
    

None

get_loop_back_edges()¶
    

_property _graph _: networkx.DiGraph[CFGNode]_¶
    

remove_edge(_block_from_ , _block_to_)¶
    

is_thumb_addr(_addr_)¶
    

normalize()¶
    

Normalize the CFG, making sure that there are no overlapping basic blocks.

Note that this method will not alter transition graphs of each function in self.kb.functions. You may call normalize() on each Function object to normalize their transition graphs.

Returns:
    

None

mark_function_alignments()¶
    

Find all potential function alignments and mark them.

Note that it is not always correct to simply remove them, because these functions may not be actual alignments but part of an actual function, and is incorrectly marked as an individual function because of failures in resolving indirect jumps. An example is in the test binary `x86_64/dir_gcc_-O0` 0x40541d (indirect jump at 0x4051b0). If the indirect jump cannot be correctly resolved, removing function 0x40541d will cause a missing label failure in reassembler.

Returns:
    

None

make_functions()¶
    

Revisit the entire control flow graph, create Function instances accordingly, and correctly put blocks into each function.

Although Function objects are created during the CFG recovery, they are neither sound nor accurate. With a pre-constructed CFG, this method rebuilds all functions bearing the following rules:

>   * A block may only belong to one function.
> 
>   * Small functions lying inside the startpoint and the endpoint of another function will be merged with the other function
> 
>   * Tail call optimizations are detected.
> 
>   * PLT stubs are aligned by 16.
> 
> 

Returns:
    

None

_class _angr.analyses.cfg.CFGEmulated(_context_sensitivity_level =1_, _start =None_, _avoid_runs =None_, _enable_function_hints =False_, _call_depth =None_, _call_tracing_filter =None_, _initial_state =None_, _starts =None_, _keep_state =False_, _indirect_jump_target_limit =100000_, _resolve_indirect_jumps =True_, _enable_advanced_backward_slicing =False_, _enable_symbolic_back_traversal =False_, _indirect_jump_resolvers =None_, _additional_edges =None_, _no_construct =False_, _normalize =False_, _max_iterations =1_, _address_whitelist =None_, _base_graph =None_, _iropt_level =None_, _max_steps =None_, _state_add_options =None_, _state_remove_options =None_, _model =None_)¶
    

Bases: `ForwardAnalysis`, `CFGBase`

This class represents a control-flow graph.

tag _: str | None_ _ = 'CFGEmulated'_¶
    

__init__(_context_sensitivity_level =1_, _start =None_, _avoid_runs =None_, _enable_function_hints =False_, _call_depth =None_, _call_tracing_filter =None_, _initial_state =None_, _starts =None_, _keep_state =False_, _indirect_jump_target_limit =100000_, _resolve_indirect_jumps =True_, _enable_advanced_backward_slicing =False_, _enable_symbolic_back_traversal =False_, _indirect_jump_resolvers =None_, _additional_edges =None_, _no_construct =False_, _normalize =False_, _max_iterations =1_, _address_whitelist =None_, _base_graph =None_, _iropt_level =None_, _max_steps =None_, _state_add_options =None_, _state_remove_options =None_, _model =None_)¶
    

All parameters are optional.

Parameters:
    

  * **context_sensitivity_level** – The level of context-sensitivity of this CFG (see documentation for further details). It ranges from 0 to infinity. Default 1.

  * **avoid_runs** – A list of runs to avoid.

  * **enable_function_hints** – Whether to use function hints (constants that might be used as exit targets) or not.

  * **call_depth** – How deep in the call stack to trace.

  * **call_tracing_filter** – Filter to apply on a given path and jumpkind to determine if it should be skipped when call_depth is reached.

  * **initial_state** – An initial state to use to begin analysis.

  * **starts** (_iterable_) – A collection of starting points to begin analysis. It can contain the following three different types of entries: an address specified as an integer, a 2-tuple that includes an integer address and a jumpkind, or a SimState instance. Unsupported entries in starts will lead to an AngrCFGError being raised.

  * **keep_state** – Whether to keep the SimStates for each CFGNode.

  * **resolve_indirect_jumps** – Whether to enable the indirect jump resolvers for resolving indirect jumps

  * **enable_advanced_backward_slicing** – Whether to enable an intensive technique for resolving indirect jumps

  * **enable_symbolic_back_traversal** – Whether to enable an intensive technique for resolving indirect jumps

  * **indirect_jump_resolvers** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A custom list of indirect jump resolvers. If this list is None or empty, default indirect jump resolvers specific to this architecture and binary types will be loaded.

  * **additional_edges** – A dict mapping addresses of basic blocks to addresses of successors to manually include and analyze forward from.

  * **no_construct** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Skip the construction procedure. Only used in unit-testing.

  * **normalize** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If the CFG as well as all Function graphs should be normalized or not.

  * **max_iterations** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The maximum number of iterations that each basic block should be “executed”. 1 by default. Larger numbers of iterations are usually required for complex analyses like loop analysis.

  * **address_whitelist** (_iterable_) – A list of allowed addresses. Any basic blocks outside of this collection of addresses will be ignored.

  * **base_graph** (_networkx.DiGraph_) – A basic control flow graph to follow. Each node inside this graph must have the following properties: addr and size. CFG recovery will strictly follow nodes and edges shown in the graph, and discard any control flow that does not follow an existing edge in the base graph. For example, you can pass in a Function local transition graph as the base graph, and CFGEmulated will traverse nodes and edges and extract useful information.

  * **iropt_level** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The optimization level of VEX IR (0, 1, 2). The default level will be used if iropt_level is None.

  * **max_steps** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The maximum number of basic blocks to recover forthe longest path from each start before pausing the recovery procedure.

  * **state_add_options** – State options that will be added to the initial state.

  * **state_remove_options** – State options that will be removed from the initial state.

copy()¶
    

Make a copy of the CFG.

Return type:
    

`CFGEmulated`

Returns:
    

A copy of the CFG instance.

resume(_starts =None_, _max_steps =None_)¶
    

Resume a paused or terminated control flow graph recovery.

Parameters:
    

  * **starts** (_iterable_) – A collection of new starts to resume from. If starts is None, we will resume CFG recovery from where it was paused before.

  * **max_steps** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The maximum number of blocks on the longest path starting from each start before pausing the recovery.

Returns:
    

None

remove_cycles()¶
    

Forces graph to become acyclic, removes all loop back edges and edges between overlapped loop headers and their successors.

downsize()¶
    

Remove saved states from all CFGNodes to reduce memory usage.

Returns:
    

None

unroll_loops(_max_loop_unrolling_times_)¶
    

Unroll loops for each function. The resulting CFG may still contain loops due to recursion, function calls, etc.

Parameters:
    

**max_loop_unrolling_times** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The maximum iterations of unrolling.

Returns:
    

None

force_unroll_loops(_max_loop_unrolling_times_)¶
    

Unroll loops globally. The resulting CFG does not contain any loop, but this method is slow on large graphs.

Parameters:
    

**max_loop_unrolling_times** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The maximum iterations of unrolling.

Returns:
    

None

immediate_dominators(_start_ , _target_graph =None_)¶
    

Get all immediate dominators of sub graph from given node upwards.

Parameters:
    

  * **start** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – id of the node to navigate forwards from.

  * **target_graph** (_networkx.classes.digraph.DiGraph_) – graph to analyse, default is self.graph.

Returns:
    

each node of graph as index values, with element as respective node’s immediate dominator.

Return type:
    

[dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")

immediate_postdominators(_end_ , _target_graph =None_)¶
    

Get all immediate postdominators of sub graph from given node upwards.

Parameters:
    

  * **start** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – id of the node to navigate forwards from.

  * **target_graph** (_networkx.classes.digraph.DiGraph_) – graph to analyse, default is self.graph.

Returns:
    

each node of graph as index values, with element as respective node’s immediate dominator.

Return type:
    

[dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")

remove_fakerets()¶
    

Get rid of fake returns (i.e., Ijk_FakeRet edges) from this CFG

Returns:
    

None

get_topological_order(_cfg_node_)¶
    

Get the topological order of a CFG Node.

Parameters:
    

**cfg_node** – A CFGNode instance.

Returns:
    

An integer representing its order, or None if the CFGNode does not exist in the graph.

get_subgraph(_starting_node_ , _block_addresses_)¶
    

Get a sub-graph out of a bunch of basic block addresses.

Parameters:
    

  * **starting_node** (_CFGNode_) – The beginning of the subgraph

  * **block_addresses** (_iterable_) – A collection of block addresses that should be included in the subgraph if there is a path between starting_node and a CFGNode with the specified address, and all nodes on the path should also be included in the subgraph.

Returns:
    

A new CFG that only contain the specific subgraph.

Return type:
    

CFGEmulated

get_function_subgraph(_start_ , _max_call_depth =None_)¶
    

Get a sub-graph of a certain function.

Parameters:
    

  * **start** – The function start. Currently it should be an integer.

  * **max_call_depth** – Call depth limit. None indicates no limit.

Returns:
    

A CFG instance which is a sub-graph of self.graph

_property _context_sensitivity_level¶
    

_property _graph¶
    

_property _unresolvables¶
    

Get those SimRuns that have non-resolvable exits.

Returns:
    

A set of SimRuns

Return type:
    

[set](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")

_property _deadends¶
    

Get all CFGNodes that has an out-degree of 0

Returns:
    

A list of CFGNode instances

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

indirect_jumps _: dict[int, IndirectJump]_¶
    

project _: Project_¶
    

kb _: KnowledgeBase_¶
    

_class _angr.analyses.cfg.CFGFast(_binary =None_, _objects =None_, _regions =None_, _pickle_intermediate_results =False_, _symbols =True_, _function_prologues =None_, _resolve_indirect_jumps =True_, _force_segment =False_, _force_smart_scan =None_, _force_complete_scan =False_, _indirect_jump_target_limit =100000_, _data_references =True_, _cross_references =False_, _normalize =False_, _start_at_entry =True_, _function_starts =None_, _extra_memory_regions =None_, _data_type_guessing_handlers =None_, _arch_options =None_, _indirect_jump_resolvers =None_, _base_state =None_, _exclude_sparse_regions =True_, _skip_specific_regions =True_, _heuristic_plt_resolving =None_, _detect_tail_calls =False_, _low_priority =False_, _cfb =None_, _model =None_, _elf_eh_frame =True_, _exceptions =True_, _skip_unmapped_addrs =True_, _nodecode_window_size =512_, _nodecode_threshold =0.3_, _nodecode_step =16483_, _check_funcret_max_job =500_, _indirect_calls_always_return =None_, _jumptable_resolver_resolves_calls =None_, _start =None_, _end =None_, _collect_data_references =None_, _extra_cross_references =None_, _** extra_arch_options_)¶
    

Bases: `ForwardAnalysis`[`CFGNode`, `CFGNode`, `CFGJob`, [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")], `CFGBase`

We find functions inside the given binary, and build a control-flow graph in very fast manners: instead of simulating program executions, keeping track of states, and performing expensive data-flow analysis, CFGFast will only perform light-weight analyses combined with some heuristics, and with some strong assumptions.

In order to identify as many functions as possible, and as accurate as possible, the following operation sequence is followed:

# Active scanning

>   * If the binary has “function symbols” (TODO: this term is not accurate enough), they are starting points of the code scanning
> 
>   * If the binary does not have any “function symbol”, we will first perform a function prologue scanning on the entire binary, and start from those places that look like function beginnings
> 
>   * Otherwise, the binary’s entry point will be the starting point for scanning
> 
> 

# Passive scanning

>   * After all active scans are done, we will go through the whole image and scan all code pieces
> 
> 

Due to the nature of those techniques that are used here, a base address is often not required to use this analysis routine. However, with a correct base address, CFG recovery will almost always yield a much better result. A custom analysis, called GirlScout, is specifically made to recover the base address of a binary blob. After the base address is determined, you may want to reload the binary with the new base address by creating a new Project object, and then re-recover the CFG.

Parameters:
    

  * **function_prologues** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **force_smart_scan** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **indirect_calls_always_return** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **jumptable_resolver_resolves_calls** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

PRINTABLES _ = b'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&\'()*+,-./:;<=>?@[\\\\]^_`{|}~ \t\n\r'_¶
    

SPECIAL_THUNKS _ = {'AMD64': {b'\xe8\x07\x00\x00\x00\xf3\x90\x0f\xae\xe8\xeb\xf9H\x89\x04$\xc3': ('jmp', 'rax'), b'\xe8\x07\x00\x00\x00\xf3\x90\x0f\xae\xe8\xeb\xf9H\x8dd$\x08\xc3': ('ret',)}}_¶
    

tag _: str | None_ _ = 'CFGFast'_¶
    

__init__(_binary =None_, _objects =None_, _regions =None_, _pickle_intermediate_results =False_, _symbols =True_, _function_prologues =None_, _resolve_indirect_jumps =True_, _force_segment =False_, _force_smart_scan =None_, _force_complete_scan =False_, _indirect_jump_target_limit =100000_, _data_references =True_, _cross_references =False_, _normalize =False_, _start_at_entry =True_, _function_starts =None_, _extra_memory_regions =None_, _data_type_guessing_handlers =None_, _arch_options =None_, _indirect_jump_resolvers =None_, _base_state =None_, _exclude_sparse_regions =True_, _skip_specific_regions =True_, _heuristic_plt_resolving =None_, _detect_tail_calls =False_, _low_priority =False_, _cfb =None_, _model =None_, _elf_eh_frame =True_, _exceptions =True_, _skip_unmapped_addrs =True_, _nodecode_window_size =512_, _nodecode_threshold =0.3_, _nodecode_step =16483_, _check_funcret_max_job =500_, _indirect_calls_always_return =None_, _jumptable_resolver_resolves_calls =None_, _start =None_, _end =None_, _collect_data_references =None_, _extra_cross_references =None_, _** extra_arch_options_)¶
    

Parameters:
    

  * **binary** – The binary to recover CFG on. By default the main binary is used.

  * **objects** – A list of objects to recover the CFG on. By default it will recover the CFG of all loaded objects.

  * **regions** (_iterable_) – A list of tuples in the form of (start address, end address) describing memory regions that the CFG should cover.

  * **pickle_intermediate_results** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If we want to store the intermediate results or not.

  * **symbols** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Get function beginnings from symbols in the binary.

  * **function_prologues** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Scan the binary for function prologues, and use those positions as function beginnings

  * **resolve_indirect_jumps** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Try to resolve indirect jumps. This is necessary to resolve jump targets from jump tables, etc.

  * **force_segment** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Force CFGFast to rely on binary segments instead of sections.

  * **force_complete_scan** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Perform a complete scan on the binary and maximize the number of identified code blocks.

  * **data_references** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Enables the collection of references to data used by individual instructions. This does not collect ‘cross-references’, particularly those that involve multiple instructions. For that, see cross_references

  * **cross_references** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether CFGFast should collect “cross-references” from the entire program or not. This will populate the knowledge base with references to and from each recognizable address constant found in the code. Note that, because this performs constant propagation on the entire program, it may be much slower and consume more memory. This option implies data_references=True.

  * **normalize** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Normalize the CFG as well as all function graphs after CFG recovery.

  * **start_at_entry** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Begin CFG recovery at the entry point of this project. Setting it to False prevents CFGFast from viewing the entry point as one of the starting points of code scanning.

  * **function_starts** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A list of extra function starting points. CFGFast will try to resume scanning from each address in the list.

  * **extra_memory_regions** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A list of 2-tuple (start-address, end-address) that shows extra memory regions. Integers falling inside will be considered as pointers.

  * **indirect_jump_resolvers** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A custom list of indirect jump resolvers. If this list is None or empty, default indirect jump resolvers specific to this architecture and binary types will be loaded.

  * **base_state** – A state to use as a backer for all memory loads

  * **detect_tail_calls** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Enable aggressive tail-call optimization detection.

  * **elf_eh_frame** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Retrieve function starts (and maybe sizes later) from the .eh_frame of ELF binaries.

  * **skip_unmapped_addrs** – Ignore all branches into unmapped regions. True by default. You may want to set it to False if you are analyzing manually patched binaries or malware samples.

  * **indirect_calls_always_return** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")]) – Should CFG assume indirect calls must return or not. Assuming indirect calls must return will significantly reduce the number of constant propagation runs, but may reduce the overall CFG recovery precision when facing non-returning indirect calls. By default, we only assume indirect calls always return for large binaries (region > 50KB).

  * **jumptable_resolver_resolves_calls** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")]) – Whether JumpTableResolver should resolve indirect calls or not. Most indirect calls in C++ binaries or UEFI binaries cannot be resolved using jump table resolver and must be resolved using their specific resolvers. By default, we will only disable JumpTableResolver from resolving indirect calls for large binaries (region > 50 KB).

  * **force_smart_scan** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

:param check_funcret_max_job When popping return-site jobs out of the job queue, angr will prioritize jobs
    

for which the callee is known to return. This check may be slow when there are a large amount of jobs in different caller functions, and this situation often occurs in obfuscated binaries where many functions never return. This parameter acts as a threshold to disable this check when the number of jobs in the queue exceeds this threshold.

Parameters:
    

  * **start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – (Deprecated) The beginning address of CFG recovery.

  * **end** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – (Deprecated) The end address of CFG recovery.

  * **arch_options** (_CFGArchOptions_) – Architecture-specific options.

  * **extra_arch_options** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")) – Any key-value pair in kwargs will be seen as an arch-specific option and will be used to set the option value in self._arch_options.

  * **function_prologues** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **force_smart_scan** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **indirect_calls_always_return** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **jumptable_resolver_resolves_calls** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

Extra parameters that angr.Analysis takes:

Parameters:
    

  * **progress_callback** – Specify a callback function to get the progress during CFG recovery.

  * **show_progressbar** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Should CFGFast show a progressbar during CFG recovery or not.

  * **function_prologues** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **force_smart_scan** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **indirect_calls_always_return** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **jumptable_resolver_resolves_calls** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

Returns:
    

None

_property _graph¶
    

_property _memory_data¶
    

_property _jump_tables¶
    

_property _insn_addr_to_memory_data¶
    

do_full_xrefs(_overlay_state =None_)¶
    

Perform xref recovery on all functions.

Parameters:
    

**overlay** (_SimState_) – An overlay state for loading constant data.

Returns:
    

None

indirect_jumps _: dict[int, IndirectJump]_¶
    

project _: Project_¶
    

kb _: KnowledgeBase_¶
    

copy()¶
    

output()¶
    

_class _angr.analyses.cfg.CFGFastSoot(_support_jni =False_, _** kwargs_)¶
    

Bases: `CFGFast`

__init__(_support_jni =False_, _** kwargs_)¶
    

Parameters:
    

  * **binary** – The binary to recover CFG on. By default the main binary is used.

  * **objects** – A list of objects to recover the CFG on. By default it will recover the CFG of all loaded objects.

  * **regions** (_iterable_) – A list of tuples in the form of (start address, end address) describing memory regions that the CFG should cover.

  * **pickle_intermediate_results** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If we want to store the intermediate results or not.

  * **symbols** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Get function beginnings from symbols in the binary.

  * **function_prologues** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Scan the binary for function prologues, and use those positions as function beginnings

  * **resolve_indirect_jumps** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Try to resolve indirect jumps. This is necessary to resolve jump targets from jump tables, etc.

  * **force_segment** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Force CFGFast to rely on binary segments instead of sections.

  * **force_complete_scan** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Perform a complete scan on the binary and maximize the number of identified code blocks.

  * **data_references** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Enables the collection of references to data used by individual instructions. This does not collect ‘cross-references’, particularly those that involve multiple instructions. For that, see cross_references

  * **cross_references** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether CFGFast should collect “cross-references” from the entire program or not. This will populate the knowledge base with references to and from each recognizable address constant found in the code. Note that, because this performs constant propagation on the entire program, it may be much slower and consume more memory. This option implies data_references=True.

  * **normalize** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Normalize the CFG as well as all function graphs after CFG recovery.

  * **start_at_entry** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Begin CFG recovery at the entry point of this project. Setting it to False prevents CFGFast from viewing the entry point as one of the starting points of code scanning.

  * **function_starts** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A list of extra function starting points. CFGFast will try to resume scanning from each address in the list.

  * **extra_memory_regions** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A list of 2-tuple (start-address, end-address) that shows extra memory regions. Integers falling inside will be considered as pointers.

  * **indirect_jump_resolvers** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A custom list of indirect jump resolvers. If this list is None or empty, default indirect jump resolvers specific to this architecture and binary types will be loaded.

  * **base_state** – A state to use as a backer for all memory loads

  * **detect_tail_calls** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Enable aggressive tail-call optimization detection.

  * **elf_eh_frame** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Retrieve function starts (and maybe sizes later) from the .eh_frame of ELF binaries.

  * **skip_unmapped_addrs** – Ignore all branches into unmapped regions. True by default. You may want to set it to False if you are analyzing manually patched binaries or malware samples.

  * **indirect_calls_always_return** – Should CFG assume indirect calls must return or not. Assuming indirect calls must return will significantly reduce the number of constant propagation runs, but may reduce the overall CFG recovery precision when facing non-returning indirect calls. By default, we only assume indirect calls always return for large binaries (region > 50KB).

  * **jumptable_resolver_resolves_calls** – Whether JumpTableResolver should resolve indirect calls or not. Most indirect calls in C++ binaries or UEFI binaries cannot be resolved using jump table resolver and must be resolved using their specific resolvers. By default, we will only disable JumpTableResolver from resolving indirect calls for large binaries (region > 50 KB).

:param check_funcret_max_job When popping return-site jobs out of the job queue, angr will prioritize jobs
    

for which the callee is known to return. This check may be slow when there are a large amount of jobs in different caller functions, and this situation often occurs in obfuscated binaries where many functions never return. This parameter acts as a threshold to disable this check when the number of jobs in the queue exceeds this threshold.

Parameters:
    

  * **start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – (Deprecated) The beginning address of CFG recovery.

  * **end** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – (Deprecated) The end address of CFG recovery.

  * **arch_options** (_CFGArchOptions_) – Architecture-specific options.

  * **extra_arch_options** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")) – Any key-value pair in kwargs will be seen as an arch-specific option and will be used to set the option value in self._arch_options.

Extra parameters that angr.Analysis takes:

Parameters:
    

  * **progress_callback** – Specify a callback function to get the progress during CFG recovery.

  * **show_progressbar** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Should CFGFast show a progressbar during CFG recovery or not.

Returns:
    

None

normalize()¶
    

Normalize the CFG, making sure that there are no overlapping basic blocks.

Note that this method will not alter transition graphs of each function in self.kb.functions. You may call normalize() on each Function object to normalize their transition graphs.

Returns:
    

None

make_functions()¶
    

Revisit the entire control flow graph, create Function instances accordingly, and correctly put blocks into each function.

Although Function objects are crated during the CFG recovery, they are neither sound nor accurate. With a pre-constructed CFG, this method rebuilds all functions bearing the following rules:

>   * A block may only belong to one function.
> 
>   * Small functions lying inside the startpoint and the endpoint of another function will be merged with the other function
> 
>   * Tail call optimizations are detected.
> 
>   * PLT stubs are aligned by 16.
> 
> 

Returns:
    

None

_class _angr.analyses.cfg.cfb.CFBlanketView(_cfb_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A view into the control-flow blanket.

__init__(_cfb_)¶
    

_class _angr.analyses.cfg.cfb.MemoryRegion(_addr_ , _size_ , _type__ , _object__ , _cle_region_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_addr_ , _size_ , _type__ , _object__ , _cle_region_)¶
    

_class _angr.analyses.cfg.cfb.Unknown(_addr_ , _size_ , _bytes_ =None_, _object_ =None_, _segment =None_, _section =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_addr_ , _size_ , _bytes_ =None_, _object_ =None_, _segment =None_, _section =None_)¶
    

_class _angr.analyses.cfg.cfb.CFBlanket(_exclude_region_types =None_, _on_object_added =None_)¶
    

Bases: `Analysis`

A Control-Flow Blanket is a representation for storing all instructions, data entries, and bytes of a full program.

Region types: \- section \- segment \- extern \- tls \- kernel

Parameters:
    

  * **exclude_region_types** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **on_object_added** (_Callable_ _[__[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__Any_ _]__,__None_ _]__|__None_)

__init__(_exclude_region_types =None_, _on_object_added =None_)¶
    

Parameters:
    

  * **on_object_added** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`Callable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)")[[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")], [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")]]) – Callable with parameters (addr, obj) called after an object is added to the blanket.

  * **exclude_region_types** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

_property _regions¶
    

Return all memory regions.

floor_addr(_addr_)¶
    

floor_item(_addr_)¶
    

floor_items(_addr =None_, _reverse =False_)¶
    

ceiling_addr(_addr_)¶
    

ceiling_item(_addr_)¶
    

ceiling_items(_addr =None_, _reverse =False_, _include_first =True_)¶
    

add_obj(_addr_ , _obj_)¶
    

Adds an object obj to the blanket at the specified address addr

add_function(_func_)¶
    

Add a function func and all blocks of this function to the blanket.

dbg_repr()¶
    

The debugging representation of this CFBlanket.

Returns:
    

The debugging representation of this CFBlanket.

Return type:
    

[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

_exception _angr.analyses.cfg.cfg.OutdatedError¶
    

Bases: [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception "\(in Python v3.13\)")

_class _angr.analyses.cfg.cfg.CFG(_** kwargs_)¶
    

Bases: `CFGFast`

tl;dr: CFG is just a wrapper around CFGFast for compatibility issues. It will be fully replaced by CFGFast in future releases. Feel free to use CFG if you intend to use CFGFast. Please use CFGEmulated if you _have to_ use the old, slow, dynamically-generated version of CFG.

For multiple historical reasons, angr’s CFG is accurate but slow, which does not meet what most people expect. We developed CFGFast for light-speed CFG recovery, and renamed the old CFG class to CFGEmulated. For compatibility concerns, CFG was kept as an alias to CFGEmulated.

However, so many new users of angr would load up a binary and generate a CFG immediately after running “pip install angr”, and draw the conclusion that “angr’s CFG is so slow - angr must be unusable!” Therefore, we made the hard decision: CFG will be an alias to CFGFast, instead of CFGEmulated.

To ease the transition of your existing code and script, the following changes are made:

  * A CFG class, which is a sub class of CFGFast, is created.

  * You will see both a warning message printed out to stderr and an exception raised by angr if you are passing CFG any parameter that only CFGEmulated supports. This exception is not a sub class of AngrError, so you wouldn’t capture it with your old code by mistake.

  * In the near future, this wrapper class will be removed completely, and CFG will be a simple alias to CFGFast.

We expect most interfaces are the same between CFGFast and CFGEmulated. Apparently some functionalities (like context-sensitivity, and state keeping) only exist in CFGEmulated, which is when you want to use CFGEmulated instead.

__init__(_** kwargs_)¶
    

Parameters:
    

  * **binary** – The binary to recover CFG on. By default the main binary is used.

  * **objects** – A list of objects to recover the CFG on. By default it will recover the CFG of all loaded objects.

  * **regions** (_iterable_) – A list of tuples in the form of (start address, end address) describing memory regions that the CFG should cover.

  * **pickle_intermediate_results** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If we want to store the intermediate results or not.

  * **symbols** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Get function beginnings from symbols in the binary.

  * **function_prologues** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Scan the binary for function prologues, and use those positions as function beginnings

  * **resolve_indirect_jumps** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Try to resolve indirect jumps. This is necessary to resolve jump targets from jump tables, etc.

  * **force_segment** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Force CFGFast to rely on binary segments instead of sections.

  * **force_complete_scan** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Perform a complete scan on the binary and maximize the number of identified code blocks.

  * **data_references** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Enables the collection of references to data used by individual instructions. This does not collect ‘cross-references’, particularly those that involve multiple instructions. For that, see cross_references

  * **cross_references** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether CFGFast should collect “cross-references” from the entire program or not. This will populate the knowledge base with references to and from each recognizable address constant found in the code. Note that, because this performs constant propagation on the entire program, it may be much slower and consume more memory. This option implies data_references=True.

  * **normalize** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Normalize the CFG as well as all function graphs after CFG recovery.

  * **start_at_entry** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Begin CFG recovery at the entry point of this project. Setting it to False prevents CFGFast from viewing the entry point as one of the starting points of code scanning.

  * **function_starts** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A list of extra function starting points. CFGFast will try to resume scanning from each address in the list.

  * **extra_memory_regions** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A list of 2-tuple (start-address, end-address) that shows extra memory regions. Integers falling inside will be considered as pointers.

  * **indirect_jump_resolvers** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A custom list of indirect jump resolvers. If this list is None or empty, default indirect jump resolvers specific to this architecture and binary types will be loaded.

  * **base_state** – A state to use as a backer for all memory loads

  * **detect_tail_calls** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Enable aggressive tail-call optimization detection.

  * **elf_eh_frame** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Retrieve function starts (and maybe sizes later) from the .eh_frame of ELF binaries.

  * **skip_unmapped_addrs** – Ignore all branches into unmapped regions. True by default. You may want to set it to False if you are analyzing manually patched binaries or malware samples.

  * **indirect_calls_always_return** – Should CFG assume indirect calls must return or not. Assuming indirect calls must return will significantly reduce the number of constant propagation runs, but may reduce the overall CFG recovery precision when facing non-returning indirect calls. By default, we only assume indirect calls always return for large binaries (region > 50KB).

  * **jumptable_resolver_resolves_calls** – Whether JumpTableResolver should resolve indirect calls or not. Most indirect calls in C++ binaries or UEFI binaries cannot be resolved using jump table resolver and must be resolved using their specific resolvers. By default, we will only disable JumpTableResolver from resolving indirect calls for large binaries (region > 50 KB).

:param check_funcret_max_job When popping return-site jobs out of the job queue, angr will prioritize jobs
    

for which the callee is known to return. This check may be slow when there are a large amount of jobs in different caller functions, and this situation often occurs in obfuscated binaries where many functions never return. This parameter acts as a threshold to disable this check when the number of jobs in the queue exceeds this threshold.

Parameters:
    

  * **start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – (Deprecated) The beginning address of CFG recovery.

  * **end** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – (Deprecated) The end address of CFG recovery.

  * **arch_options** (_CFGArchOptions_) – Architecture-specific options.

  * **extra_arch_options** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")) – Any key-value pair in kwargs will be seen as an arch-specific option and will be used to set the option value in self._arch_options.

Extra parameters that angr.Analysis takes:

Parameters:
    

  * **progress_callback** – Specify a callback function to get the progress during CFG recovery.

  * **show_progressbar** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Should CFGFast show a progressbar during CFG recovery or not.

Returns:
    

None

_class _angr.analyses.cfg.cfg_emulated.CFGJob(_* args_, _** kwargs_)¶
    

Bases: `CFGJobBase`

The job class that CFGEmulated uses.

__init__(_* args_, _** kwargs_)¶
    

_property _block_id¶
    

_property _is_syscall¶
    

_class _angr.analyses.cfg.cfg_emulated.PendingJob(_caller_func_addr_ , _returning_source_ , _state_ , _src_block_id_ , _src_exit_stmt_idx_ , _src_exit_ins_addr_ , _call_stack_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A PendingJob is whatever will be put into our pending_exit list. A pending exit is an entry that created by the returning of a call or syscall. It is “pending” since we cannot immediately figure out whether this entry will be executed or not. If the corresponding call/syscall intentionally doesn’t return, then the pending exit will be removed. If the corresponding call/syscall returns, then the pending exit will be removed as well (since a real entry is created from the returning and will be analyzed later). If the corresponding call/syscall might return, but for some reason (for example, an unsupported instruction is met during the analysis) our analysis does not return properly, then the pending exit will be picked up and put into remaining_jobs list.

__init__(_caller_func_addr_ , _returning_source_ , _state_ , _src_block_id_ , _src_exit_stmt_idx_ , _src_exit_ins_addr_ , _call_stack_)¶
    

Parameters:
    

  * **returning_source** – Address of the callee function. It might be None if address of the callee is not resolvable.

  * **state** – The state after returning from the callee function. Of course there is no way to get a precise state without emulating the execution of the callee, but at least we can properly adjust the stack and registers to imitate the real returned state.

  * **call_stack** – A callstack.

_class _angr.analyses.cfg.cfg_emulated.CFGEmulated(_context_sensitivity_level =1_, _start =None_, _avoid_runs =None_, _enable_function_hints =False_, _call_depth =None_, _call_tracing_filter =None_, _initial_state =None_, _starts =None_, _keep_state =False_, _indirect_jump_target_limit =100000_, _resolve_indirect_jumps =True_, _enable_advanced_backward_slicing =False_, _enable_symbolic_back_traversal =False_, _indirect_jump_resolvers =None_, _additional_edges =None_, _no_construct =False_, _normalize =False_, _max_iterations =1_, _address_whitelist =None_, _base_graph =None_, _iropt_level =None_, _max_steps =None_, _state_add_options =None_, _state_remove_options =None_, _model =None_)¶
    

Bases: `ForwardAnalysis`, `CFGBase`

This class represents a control-flow graph.

tag _: str | None_ _ = 'CFGEmulated'_¶
    

__init__(_context_sensitivity_level =1_, _start =None_, _avoid_runs =None_, _enable_function_hints =False_, _call_depth =None_, _call_tracing_filter =None_, _initial_state =None_, _starts =None_, _keep_state =False_, _indirect_jump_target_limit =100000_, _resolve_indirect_jumps =True_, _enable_advanced_backward_slicing =False_, _enable_symbolic_back_traversal =False_, _indirect_jump_resolvers =None_, _additional_edges =None_, _no_construct =False_, _normalize =False_, _max_iterations =1_, _address_whitelist =None_, _base_graph =None_, _iropt_level =None_, _max_steps =None_, _state_add_options =None_, _state_remove_options =None_, _model =None_)¶
    

All parameters are optional.

Parameters:
    

  * **context_sensitivity_level** – The level of context-sensitivity of this CFG (see documentation for further details). It ranges from 0 to infinity. Default 1.

  * **avoid_runs** – A list of runs to avoid.

  * **enable_function_hints** – Whether to use function hints (constants that might be used as exit targets) or not.

  * **call_depth** – How deep in the call stack to trace.

  * **call_tracing_filter** – Filter to apply on a given path and jumpkind to determine if it should be skipped when call_depth is reached.

  * **initial_state** – An initial state to use to begin analysis.

  * **starts** (_iterable_) – A collection of starting points to begin analysis. It can contain the following three different types of entries: an address specified as an integer, a 2-tuple that includes an integer address and a jumpkind, or a SimState instance. Unsupported entries in starts will lead to an AngrCFGError being raised.

  * **keep_state** – Whether to keep the SimStates for each CFGNode.

  * **resolve_indirect_jumps** – Whether to enable the indirect jump resolvers for resolving indirect jumps

  * **enable_advanced_backward_slicing** – Whether to enable an intensive technique for resolving indirect jumps

  * **enable_symbolic_back_traversal** – Whether to enable an intensive technique for resolving indirect jumps

  * **indirect_jump_resolvers** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A custom list of indirect jump resolvers. If this list is None or empty, default indirect jump resolvers specific to this architecture and binary types will be loaded.

  * **additional_edges** – A dict mapping addresses of basic blocks to addresses of successors to manually include and analyze forward from.

  * **no_construct** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Skip the construction procedure. Only used in unit-testing.

  * **normalize** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If the CFG as well as all Function graphs should be normalized or not.

  * **max_iterations** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The maximum number of iterations that each basic block should be “executed”. 1 by default. Larger numbers of iterations are usually required for complex analyses like loop analysis.

  * **address_whitelist** (_iterable_) – A list of allowed addresses. Any basic blocks outside of this collection of addresses will be ignored.

  * **base_graph** (_networkx.DiGraph_) – A basic control flow graph to follow. Each node inside this graph must have the following properties: addr and size. CFG recovery will strictly follow nodes and edges shown in the graph, and discard any control flow that does not follow an existing edge in the base graph. For example, you can pass in a Function local transition graph as the base graph, and CFGEmulated will traverse nodes and edges and extract useful information.

  * **iropt_level** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The optimization level of VEX IR (0, 1, 2). The default level will be used if iropt_level is None.

  * **max_steps** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The maximum number of basic blocks to recover forthe longest path from each start before pausing the recovery procedure.

  * **state_add_options** – State options that will be added to the initial state.

  * **state_remove_options** – State options that will be removed from the initial state.

copy()¶
    

Make a copy of the CFG.

Return type:
    

`CFGEmulated`

Returns:
    

A copy of the CFG instance.

resume(_starts =None_, _max_steps =None_)¶
    

Resume a paused or terminated control flow graph recovery.

Parameters:
    

  * **starts** (_iterable_) – A collection of new starts to resume from. If starts is None, we will resume CFG recovery from where it was paused before.

  * **max_steps** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The maximum number of blocks on the longest path starting from each start before pausing the recovery.

Returns:
    

None

remove_cycles()¶
    

Forces graph to become acyclic, removes all loop back edges and edges between overlapped loop headers and their successors.

downsize()¶
    

Remove saved states from all CFGNodes to reduce memory usage.

Returns:
    

None

unroll_loops(_max_loop_unrolling_times_)¶
    

Unroll loops for each function. The resulting CFG may still contain loops due to recursion, function calls, etc.

Parameters:
    

**max_loop_unrolling_times** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The maximum iterations of unrolling.

Returns:
    

None

force_unroll_loops(_max_loop_unrolling_times_)¶
    

Unroll loops globally. The resulting CFG does not contain any loop, but this method is slow on large graphs.

Parameters:
    

**max_loop_unrolling_times** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The maximum iterations of unrolling.

Returns:
    

None

immediate_dominators(_start_ , _target_graph =None_)¶
    

Get all immediate dominators of sub graph from given node upwards.

Parameters:
    

  * **start** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – id of the node to navigate forwards from.

  * **target_graph** (_networkx.classes.digraph.DiGraph_) – graph to analyse, default is self.graph.

Returns:
    

each node of graph as index values, with element as respective node’s immediate dominator.

Return type:
    

[dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")

immediate_postdominators(_end_ , _target_graph =None_)¶
    

Get all immediate postdominators of sub graph from given node upwards.

Parameters:
    

  * **start** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – id of the node to navigate forwards from.

  * **target_graph** (_networkx.classes.digraph.DiGraph_) – graph to analyse, default is self.graph.

Returns:
    

each node of graph as index values, with element as respective node’s immediate dominator.

Return type:
    

[dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")

remove_fakerets()¶
    

Get rid of fake returns (i.e., Ijk_FakeRet edges) from this CFG

Returns:
    

None

get_topological_order(_cfg_node_)¶
    

Get the topological order of a CFG Node.

Parameters:
    

**cfg_node** – A CFGNode instance.

Returns:
    

An integer representing its order, or None if the CFGNode does not exist in the graph.

get_subgraph(_starting_node_ , _block_addresses_)¶
    

Get a sub-graph out of a bunch of basic block addresses.

Parameters:
    

  * **starting_node** (_CFGNode_) – The beginning of the subgraph

  * **block_addresses** (_iterable_) – A collection of block addresses that should be included in the subgraph if there is a path between starting_node and a CFGNode with the specified address, and all nodes on the path should also be included in the subgraph.

Returns:
    

A new CFG that only contain the specific subgraph.

Return type:
    

CFGEmulated

get_function_subgraph(_start_ , _max_call_depth =None_)¶
    

Get a sub-graph of a certain function.

Parameters:
    

  * **start** – The function start. Currently it should be an integer.

  * **max_call_depth** – Call depth limit. None indicates no limit.

Returns:
    

A CFG instance which is a sub-graph of self.graph

_property _context_sensitivity_level¶
    

_property _graph¶
    

_property _unresolvables¶
    

Get those SimRuns that have non-resolvable exits.

Returns:
    

A set of SimRuns

Return type:
    

[set](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")

_property _deadends¶
    

Get all CFGNodes that has an out-degree of 0

Returns:
    

A list of CFGNode instances

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

indirect_jumps _: dict[int, IndirectJump]_¶
    

project _: Project_¶
    

kb _: KnowledgeBase_¶
    

_class _angr.analyses.cfg.cfg_base.CFGBase(_sort_ , _context_sensitivity_level_ , _normalize =False_, _binary =None_, _objects =None_, _regions =None_, _exclude_sparse_regions =True_, _skip_specific_regions =True_, _force_segment =False_, _base_state =None_, _resolve_indirect_jumps =True_, _indirect_jump_resolvers =None_, _indirect_jump_target_limit =100000_, _detect_tail_calls =False_, _low_priority =False_, _skip_unmapped_addrs =True_, _sp_tracking_track_memory =True_, _model =None_)¶
    

Bases: `Analysis`

The base class for control flow graphs.

tag _: str | None_ _ = None_¶
    

__init__(_sort_ , _context_sensitivity_level_ , _normalize =False_, _binary =None_, _objects =None_, _regions =None_, _exclude_sparse_regions =True_, _skip_specific_regions =True_, _force_segment =False_, _base_state =None_, _resolve_indirect_jumps =True_, _indirect_jump_resolvers =None_, _indirect_jump_target_limit =100000_, _detect_tail_calls =False_, _low_priority =False_, _skip_unmapped_addrs =True_, _sp_tracking_track_memory =True_, _model =None_)¶
    

Parameters:
    

  * **sort** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – ‘fast’ or ‘emulated’.

  * **context_sensitivity_level** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The level of context-sensitivity of this CFG (see documentation for further details). It ranges from 0 to infinity.

  * **normalize** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether the CFG as well as all Function graphs should be normalized.

  * **binary** (_cle.backends.Backend_) – The binary to recover CFG on. By default, the main binary is used.

  * **objects** – A list of objects to recover the CFG on. By default, it will recover the CFG of all loaded objects.

  * **regions** (_iterable_) – A list of tuples in the form of (start address, end address) describing memory regions that the CFG should cover.

  * **force_segment** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Force CFGFast to rely on binary segments instead of sections.

  * **base_state** (_angr.SimState_) – A state to use as a backer for all memory loads.

  * **resolve_indirect_jumps** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether to try to resolve indirect jumps. This is necessary to resolve jump targets from jump tables, etc.

  * **indirect_jump_resolvers** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A custom list of indirect jump resolvers. If this list is None or empty, default indirect jump resolvers specific to this architecture and binary types will be loaded.

  * **indirect_jump_target_limit** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Maximum indirect jump targets to be recovered.

  * **skip_unmapped_addrs** – Ignore all branches into unmapped regions. True by default. You may want to set it to False if you are analyzing manually patched binaries or malware samples.

  * **detect_tail_calls** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Aggressive tail-call optimization detection. This option is only respected in make_functions().

  * **sp_tracking_track_memory** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether or not to track memory writes if tracking the stack pointer. This increases the accuracy of stack pointer tracking, especially for architectures without a base pointer. Only used if detect_tail_calls is enabled.

  * **model** (_None_ _or_ _CFGModel_) – The CFGModel instance to write to. A new CFGModel instance will be created and registered with the knowledge base if model is None.

Returns:
    

None

indirect_jumps _: dict[int, IndirectJump]_¶
    

_property _model _: CFGModel_¶
    

Get the CFGModel instance. :return: The CFGModel instance that this analysis currently uses.

_property _normalized¶
    

_property _context_sensitivity_level¶
    

_property _functions¶
    

A reference to the FunctionManager in the current knowledge base.

Returns:
    

FunctionManager with all functions

Return type:
    

angr.knowledge_plugins.FunctionManager

make_copy(_copy_to_)¶
    

Copy self attributes to the new object.

Parameters:
    

**copy_to** (_CFGBase_) – The target to copy to.

Returns:
    

None

copy()¶
    

output()¶
    

generate_index()¶
    

Generate an index of all nodes in the graph in order to speed up get_any_node() with anyaddr=True.

Returns:
    

None

get_loop_back_edges()¶
    

_property _graph¶
    

remove_edge(_block_from_ , _block_to_)¶
    

is_thumb_addr(_addr_)¶
    

normalize()¶
    

Normalize the CFG, making sure that there are no overlapping basic blocks.

Note that this method will not alter transition graphs of each function in self.kb.functions. You may call normalize() on each Function object to normalize their transition graphs.

Returns:
    

None

mark_function_alignments()¶
    

Find all potential function alignments and mark them.

Note that it is not always correct to simply remove them, because these functions may not be actual alignments but part of an actual function, and is incorrectly marked as an individual function because of failures in resolving indirect jumps. An example is in the test binary `x86_64/dir_gcc_-O0` 0x40541d (indirect jump at 0x4051b0). If the indirect jump cannot be correctly resolved, removing function 0x40541d will cause a missing label failure in reassembler.

Returns:
    

None

make_functions()¶
    

Revisit the entire control flow graph, create Function instances accordingly, and correctly put blocks into each function.

Although Function objects are created during the CFG recovery, they are neither sound nor accurate. With a pre-constructed CFG, this method rebuilds all functions bearing the following rules:

>   * A block may only belong to one function.
> 
>   * Small functions lying inside the startpoint and the endpoint of another function will be merged with the other function
> 
>   * Tail call optimizations are detected.
> 
>   * PLT stubs are aligned by 16.
> 
> 

Returns:
    

None

project _: Project_¶
    

kb _: KnowledgeBase_¶
    

_exception _angr.analyses.cfg.cfg_fast.ContinueScanningNotification¶
    

Bases: [`RuntimeError`](https://docs.python.org/3/library/exceptions.html#RuntimeError "\(in Python v3.13\)")

A notification raised by _next_code_addr_core() to indicate no code address is found and _next_code_addr_core() should be invoked again.

_class _angr.analyses.cfg.cfg_fast.ARMDecodingMode¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Enums indicating decoding mode for ARM code.

ARM _ = 0_¶
    

THUMB _ = 1_¶
    

_class _angr.analyses.cfg.cfg_fast.DecodingAssumption(_addr_ , _size_ , _mode_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Describes the decoding mode (ARM/THUMB) for a given basic block identified by its address.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **mode** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_addr_ , _size_ , _mode_)¶
    

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **mode** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

add_data_seg(_addr_ , _size_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_class _angr.analyses.cfg.cfg_fast.FunctionReturn(_callee_func_addr_ , _caller_func_addr_ , _call_site_addr_ , _return_to_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

FunctionReturn describes a function call in a specific location and its return location. Hashable and equatable

__init__(_callee_func_addr_ , _caller_func_addr_ , _call_site_addr_ , _return_to_)¶
    

callee_func_addr¶
    

caller_func_addr¶
    

call_site_addr¶
    

return_to¶
    

_class _angr.analyses.cfg.cfg_fast.PendingJobs(_kb_ , _deregister_job_callback_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A collection of pending jobs during CFG recovery.

__init__(_kb_ , _deregister_job_callback_)¶
    

add_job(_job_)¶
    

pop_job(_returning =True_)¶
    

Pop a job from the pending jobs list.

When returning == True, we prioritize the jobs whose functions are known to be returning (function.returning is True). As an optimization, we are sorting the pending jobs list according to job.function.returning.

Parameters:
    

**returning** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Only pop a pending job if the corresponding function returns.

Returns:
    

A pending job if we can find one, or None if we cannot find any that satisfies the requirement.

Return type:
    

angr.analyses.cfg.cfg_fast.CFGJob

cleanup()¶
    

Remove those pending exits if: a) they are the return exits of non-returning SimProcedures b) they are the return exits of non-returning syscalls b) they are the return exits of non-returning functions

Returns:
    

None

add_returning_function(_func_addr_)¶
    

Mark a function as returning.

Parameters:
    

**func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function that returns.

Returns:
    

None

add_nonreturning_function(_func_addr_)¶
    

Mark a function as not returning.

Parameters:
    

**func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function that does not return.

Returns:
    

None

clear_updated_functions()¶
    

Clear the updated_functions set.

Returns:
    

None

_class _angr.analyses.cfg.cfg_fast.FunctionEdge¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Describes an edge in functions’ transition graphs. Base class for all types of edges.

apply(_cfg_)¶
    

ins_addr¶
    

src_func_addr¶
    

stmt_idx¶
    

_class _angr.analyses.cfg.cfg_fast.FunctionTransitionEdge(_src_node_ , _dst_addr_ , _src_func_addr_ , _to_outside =False_, _dst_func_addr =None_, _stmt_idx =None_, _ins_addr =None_, _is_exception =False_)¶
    

Bases: `FunctionEdge`

Describes a transition edge in functions’ transition graphs.

__init__(_src_node_ , _dst_addr_ , _src_func_addr_ , _to_outside =False_, _dst_func_addr =None_, _stmt_idx =None_, _ins_addr =None_, _is_exception =False_)¶
    

src_node¶
    

dst_addr¶
    

to_outside¶
    

dst_func_addr¶
    

is_exception¶
    

apply(_cfg_)¶
    

_class _angr.analyses.cfg.cfg_fast.FunctionCallEdge(_src_node_ , _dst_addr_ , _ret_addr_ , _src_func_addr_ , _syscall =False_, _stmt_idx =None_, _ins_addr =None_)¶
    

Bases: `FunctionEdge`

Describes a call edge in functions’ transition graphs.

__init__(_src_node_ , _dst_addr_ , _ret_addr_ , _src_func_addr_ , _syscall =False_, _stmt_idx =None_, _ins_addr =None_)¶
    

src_node¶
    

dst_addr¶
    

ret_addr¶
    

syscall¶
    

apply(_cfg_)¶
    

_class _angr.analyses.cfg.cfg_fast.FunctionFakeRetEdge(_src_node_ , _dst_addr_ , _src_func_addr_ , _confirmed =None_)¶
    

Bases: `FunctionEdge`

Describes a FakeReturn (also called fall-through) edge in functions’ transition graphs.

__init__(_src_node_ , _dst_addr_ , _src_func_addr_ , _confirmed =None_)¶
    

src_node¶
    

dst_addr¶
    

confirmed¶
    

apply(_cfg_)¶
    

_class _angr.analyses.cfg.cfg_fast.FunctionReturnEdge(_ret_from_addr_ , _ret_to_addr_ , _dst_func_addr_)¶
    

Bases: `FunctionEdge`

Describes a return (from a function call or a syscall) edge in functions’ transition graphs.

__init__(_ret_from_addr_ , _ret_to_addr_ , _dst_func_addr_)¶
    

ret_from_addr¶
    

ret_to_addr¶
    

dst_func_addr¶
    

apply(_cfg_)¶
    

_class _angr.analyses.cfg.cfg_fast.CFGJobType(_value_)¶
    

Bases: [`Enum`](https://docs.python.org/3/library/enum.html#enum.Enum "\(in Python v3.13\)")

Defines the type of work of a CFGJob

NORMAL _ = 0_¶
    

FUNCTION_PROLOGUE _ = 1_¶
    

COMPLETE_SCANNING _ = 2_¶
    

IFUNC_HINTS _ = 3_¶
    

DATAREF_HINTS _ = 4_¶
    

_class _angr.analyses.cfg.cfg_fast.CFGJob(_addr_ , _func_addr_ , _jumpkind_ , _ret_target =None_, _last_addr =None_, _src_node =None_, _src_ins_addr =None_, _src_stmt_idx =None_, _returning_source =None_, _syscall =False_, _func_edges =None_, _job_type =CFGJobType.NORMAL_, _gp =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Defines a job to work on during the CFG recovery

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **ret_target** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **last_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **src_node** (_CFGNode_ _|__None_)

  * **src_ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **src_stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **syscall** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **func_edges** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _|__None_)

  * **job_type** (_CFGJobType_)

  * **gp** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_addr_ , _func_addr_ , _jumpkind_ , _ret_target =None_, _last_addr =None_, _src_node =None_, _src_ins_addr =None_, _src_stmt_idx =None_, _returning_source =None_, _syscall =False_, _func_edges =None_, _job_type =CFGJobType.NORMAL_, _gp =None_)¶
    

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **ret_target** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **last_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **src_node** (_CFGNode_ _|__None_)

  * **src_ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **src_stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **syscall** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **func_edges** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _|__None_)

  * **job_type** (_CFGJobType_)

  * **gp** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

addr¶
    

func_addr¶
    

jumpkind¶
    

ret_target¶
    

last_addr¶
    

src_node¶
    

src_ins_addr¶
    

src_stmt_idx¶
    

returning_source¶
    

syscall¶
    

job_type¶
    

gp¶
    

add_function_edge(_edge_)¶
    

apply_function_edges(_cfg_ , _clear =False_)¶
    

_class _angr.analyses.cfg.cfg_fast.CFGFast(_binary =None_, _objects =None_, _regions =None_, _pickle_intermediate_results =False_, _symbols =True_, _function_prologues =None_, _resolve_indirect_jumps =True_, _force_segment =False_, _force_smart_scan =None_, _force_complete_scan =False_, _indirect_jump_target_limit =100000_, _data_references =True_, _cross_references =False_, _normalize =False_, _start_at_entry =True_, _function_starts =None_, _extra_memory_regions =None_, _data_type_guessing_handlers =None_, _arch_options =None_, _indirect_jump_resolvers =None_, _base_state =None_, _exclude_sparse_regions =True_, _skip_specific_regions =True_, _heuristic_plt_resolving =None_, _detect_tail_calls =False_, _low_priority =False_, _cfb =None_, _model =None_, _elf_eh_frame =True_, _exceptions =True_, _skip_unmapped_addrs =True_, _nodecode_window_size =512_, _nodecode_threshold =0.3_, _nodecode_step =16483_, _check_funcret_max_job =500_, _indirect_calls_always_return =None_, _jumptable_resolver_resolves_calls =None_, _start =None_, _end =None_, _collect_data_references =None_, _extra_cross_references =None_, _** extra_arch_options_)¶
    

Bases: `ForwardAnalysis`[`CFGNode`, `CFGNode`, `CFGJob`, [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")], `CFGBase`

We find functions inside the given binary, and build a control-flow graph in very fast manners: instead of simulating program executions, keeping track of states, and performing expensive data-flow analysis, CFGFast will only perform light-weight analyses combined with some heuristics, and with some strong assumptions.

In order to identify as many functions as possible, and as accurate as possible, the following operation sequence is followed:

# Active scanning

>   * If the binary has “function symbols” (TODO: this term is not accurate enough), they are starting points of the code scanning
> 
>   * If the binary does not have any “function symbol”, we will first perform a function prologue scanning on the entire binary, and start from those places that look like function beginnings
> 
>   * Otherwise, the binary’s entry point will be the starting point for scanning
> 
> 

# Passive scanning

>   * After all active scans are done, we will go through the whole image and scan all code pieces
> 
> 

Due to the nature of those techniques that are used here, a base address is often not required to use this analysis routine. However, with a correct base address, CFG recovery will almost always yield a much better result. A custom analysis, called GirlScout, is specifically made to recover the base address of a binary blob. After the base address is determined, you may want to reload the binary with the new base address by creating a new Project object, and then re-recover the CFG.

Parameters:
    

  * **function_prologues** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **force_smart_scan** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **indirect_calls_always_return** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **jumptable_resolver_resolves_calls** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

PRINTABLES _ = b'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&\'()*+,-./:;<=>?@[\\\\]^_`{|}~ \t\n\r'_¶
    

SPECIAL_THUNKS _ = {'AMD64': {b'\xe8\x07\x00\x00\x00\xf3\x90\x0f\xae\xe8\xeb\xf9H\x89\x04$\xc3': ('jmp', 'rax'), b'\xe8\x07\x00\x00\x00\xf3\x90\x0f\xae\xe8\xeb\xf9H\x8dd$\x08\xc3': ('ret',)}}_¶
    

tag _: str | None_ _ = 'CFGFast'_¶
    

__init__(_binary =None_, _objects =None_, _regions =None_, _pickle_intermediate_results =False_, _symbols =True_, _function_prologues =None_, _resolve_indirect_jumps =True_, _force_segment =False_, _force_smart_scan =None_, _force_complete_scan =False_, _indirect_jump_target_limit =100000_, _data_references =True_, _cross_references =False_, _normalize =False_, _start_at_entry =True_, _function_starts =None_, _extra_memory_regions =None_, _data_type_guessing_handlers =None_, _arch_options =None_, _indirect_jump_resolvers =None_, _base_state =None_, _exclude_sparse_regions =True_, _skip_specific_regions =True_, _heuristic_plt_resolving =None_, _detect_tail_calls =False_, _low_priority =False_, _cfb =None_, _model =None_, _elf_eh_frame =True_, _exceptions =True_, _skip_unmapped_addrs =True_, _nodecode_window_size =512_, _nodecode_threshold =0.3_, _nodecode_step =16483_, _check_funcret_max_job =500_, _indirect_calls_always_return =None_, _jumptable_resolver_resolves_calls =None_, _start =None_, _end =None_, _collect_data_references =None_, _extra_cross_references =None_, _** extra_arch_options_)¶
    

Parameters:
    

  * **binary** – The binary to recover CFG on. By default the main binary is used.

  * **objects** – A list of objects to recover the CFG on. By default it will recover the CFG of all loaded objects.

  * **regions** (_iterable_) – A list of tuples in the form of (start address, end address) describing memory regions that the CFG should cover.

  * **pickle_intermediate_results** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If we want to store the intermediate results or not.

  * **symbols** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Get function beginnings from symbols in the binary.

  * **function_prologues** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Scan the binary for function prologues, and use those positions as function beginnings

  * **resolve_indirect_jumps** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Try to resolve indirect jumps. This is necessary to resolve jump targets from jump tables, etc.

  * **force_segment** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Force CFGFast to rely on binary segments instead of sections.

  * **force_complete_scan** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Perform a complete scan on the binary and maximize the number of identified code blocks.

  * **data_references** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Enables the collection of references to data used by individual instructions. This does not collect ‘cross-references’, particularly those that involve multiple instructions. For that, see cross_references

  * **cross_references** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether CFGFast should collect “cross-references” from the entire program or not. This will populate the knowledge base with references to and from each recognizable address constant found in the code. Note that, because this performs constant propagation on the entire program, it may be much slower and consume more memory. This option implies data_references=True.

  * **normalize** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Normalize the CFG as well as all function graphs after CFG recovery.

  * **start_at_entry** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Begin CFG recovery at the entry point of this project. Setting it to False prevents CFGFast from viewing the entry point as one of the starting points of code scanning.

  * **function_starts** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A list of extra function starting points. CFGFast will try to resume scanning from each address in the list.

  * **extra_memory_regions** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A list of 2-tuple (start-address, end-address) that shows extra memory regions. Integers falling inside will be considered as pointers.

  * **indirect_jump_resolvers** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A custom list of indirect jump resolvers. If this list is None or empty, default indirect jump resolvers specific to this architecture and binary types will be loaded.

  * **base_state** – A state to use as a backer for all memory loads

  * **detect_tail_calls** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Enable aggressive tail-call optimization detection.

  * **elf_eh_frame** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Retrieve function starts (and maybe sizes later) from the .eh_frame of ELF binaries.

  * **skip_unmapped_addrs** – Ignore all branches into unmapped regions. True by default. You may want to set it to False if you are analyzing manually patched binaries or malware samples.

  * **indirect_calls_always_return** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")]) – Should CFG assume indirect calls must return or not. Assuming indirect calls must return will significantly reduce the number of constant propagation runs, but may reduce the overall CFG recovery precision when facing non-returning indirect calls. By default, we only assume indirect calls always return for large binaries (region > 50KB).

  * **jumptable_resolver_resolves_calls** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")]) – Whether JumpTableResolver should resolve indirect calls or not. Most indirect calls in C++ binaries or UEFI binaries cannot be resolved using jump table resolver and must be resolved using their specific resolvers. By default, we will only disable JumpTableResolver from resolving indirect calls for large binaries (region > 50 KB).

  * **force_smart_scan** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

:param check_funcret_max_job When popping return-site jobs out of the job queue, angr will prioritize jobs
    

for which the callee is known to return. This check may be slow when there are a large amount of jobs in different caller functions, and this situation often occurs in obfuscated binaries where many functions never return. This parameter acts as a threshold to disable this check when the number of jobs in the queue exceeds this threshold.

Parameters:
    

  * **start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – (Deprecated) The beginning address of CFG recovery.

  * **end** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – (Deprecated) The end address of CFG recovery.

  * **arch_options** (_CFGArchOptions_) – Architecture-specific options.

  * **extra_arch_options** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")) – Any key-value pair in kwargs will be seen as an arch-specific option and will be used to set the option value in self._arch_options.

  * **function_prologues** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **force_smart_scan** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **indirect_calls_always_return** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **jumptable_resolver_resolves_calls** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

Extra parameters that angr.Analysis takes:

Parameters:
    

  * **progress_callback** – Specify a callback function to get the progress during CFG recovery.

  * **show_progressbar** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Should CFGFast show a progressbar during CFG recovery or not.

  * **function_prologues** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **force_smart_scan** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **indirect_calls_always_return** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **jumptable_resolver_resolves_calls** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

Returns:
    

None

_property _graph¶
    

_property _memory_data¶
    

_property _jump_tables¶
    

_property _insn_addr_to_memory_data¶
    

do_full_xrefs(_overlay_state =None_)¶
    

Perform xref recovery on all functions.

Parameters:
    

**overlay** (_SimState_) – An overlay state for loading constant data.

Returns:
    

None

indirect_jumps _: dict[int, IndirectJump]_¶
    

project _: Project_¶
    

kb _: KnowledgeBase_¶
    

copy()¶
    

output()¶
    

_class _angr.analyses.cfg.cfg_arch_options.CFGArchOptions(_arch_ , _** options_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Stores architecture-specific options and settings, as well as the detailed explanation of those options and settings.

Suppose ao is the CFGArchOptions object, and there is an option called ret_jumpkind_heuristics, you can access it by ao.ret_jumpkind_heuristics and set its value via ao.ret_jumpkind_heuristics = True

Variables:
    

  * **OPTIONS** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")) – A dict of all default options for different architectures.

  * **arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)")) – The architecture object.

  * **_options** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")) – Values of all CFG options that are specific to the current architecture.

OPTIONS _ = {'ARMCortexM': {'has_arm_code': (<class 'bool'>, False), 'pattern_match_ifuncs': (<class 'bool'>, True), 'ret_jumpkind_heuristics': (<class 'bool'>, True), 'switch_mode_on_nodecode': (<class 'bool'>, False)}, 'ARMEL': {'has_arm_code': (<class 'bool'>, True), 'pattern_match_ifuncs': (<class 'bool'>, True), 'ret_jumpkind_heuristics': (<class 'bool'>, True), 'switch_mode_on_nodecode': (<class 'bool'>, True)}, 'ARMHF': {'has_arm_code': (<class 'bool'>, True), 'pattern_match_ifuncs': (<class 'bool'>, True), 'ret_jumpkind_heuristics': (<class 'bool'>, True), 'switch_mode_on_nodecode': (<class 'bool'>, True)}}_¶
    

__init__(_arch_ , _** options_)¶
    

Constructor.

Parameters:
    

  * **arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)")) – The architecture instance.

  * **options** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")) – Architecture-specific options, which will be used to initialize this object.

arch _ = None_¶
    

_class _angr.analyses.cfg.cfg_job_base.BlockID(_addr_ , _callsite_tuples_ , _jump_type_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A context-sensitive key for a SimRun object.

__init__(_addr_ , _callsite_tuples_ , _jump_type_)¶
    

callsite_repr()¶
    

_static _new(_addr_ , _callstack_suffix_ , _jumpkind_)¶
    

_property _func_addr¶
    

_class _angr.analyses.cfg.cfg_job_base.FunctionKey(_addr_ , _callsite_tuples_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A context-sensitive key for a function.

__init__(_addr_ , _callsite_tuples_)¶
    

callsite_repr()¶
    

_static _new(_addr_ , _callsite_tuples_)¶
    

_class _angr.analyses.cfg.cfg_job_base.CFGJobBase(_addr_ , _state_ , _context_sensitivity_level_ , _block_id =None_, _src_block_id =None_, _src_exit_stmt_idx =None_, _src_ins_addr =None_, _jumpkind =None_, _call_stack =None_, _is_narrowing =False_, _skip =False_, _final_return_address =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Describes an entry in CFG or VFG. Only used internally by the analysis.

Parameters:
    

  * **state** (_SimState_)

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

__init__(_addr_ , _state_ , _context_sensitivity_level_ , _block_id =None_, _src_block_id =None_, _src_exit_stmt_idx =None_, _src_ins_addr =None_, _jumpkind =None_, _call_stack =None_, _is_narrowing =False_, _skip =False_, _final_return_address =None_)¶
    

Parameters:
    

  * **state** (_SimState_)

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

_property _call_stack¶
    

call_stack_copy()¶
    

get_call_stack_suffix()¶
    

_property _func_addr¶
    

_property _current_stack_pointer¶
    

_class _angr.analyses.cfg.indirect_jump_resolvers.amd64_elf_got.AMD64ElfGotResolver(_project_)¶
    

Bases: `IndirectJumpResolver`

A timeless indirect jump resolver that resolves GOT entries on AMD64 ELF binaries.

__init__(_project_)¶
    

filter(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_)¶
    

Check if this resolution method may be able to resolve the indirect jump or not.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Basic block address of this indirect jump.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function that this indirect jump belongs to.

  * **block** – The basic block. The type is determined by the backend being used. It’s pyvex.IRSB if pyvex is used as the backend.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

Returns:
    

True if it is possible for this resolution method to resolve the specific indirect jump, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

resolve(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_ , _func_graph_complete =True_, _** kwargs_)¶
    

Resolve an indirect jump.

Parameters:
    

  * **cfg** – The CFG analysis object.

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Basic block address of this indirect jump.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function that this indirect jump belongs to.

  * **block** – The basic block. The type is determined by the backend being used. It’s pyvex.IRSB if pyvex is used as the backend.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

  * **func_graph_complete** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True if the function graph is complete at this point (except for nodes that this indirect jump node dominates).

Returns:
    

A tuple of a boolean indicating whether the resolution is successful or not, and a list of resolved targets (ints).

Return type:
    

[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

_class _angr.analyses.cfg.indirect_jump_resolvers.arm_elf_fast.ArmElfFastResolver(_project_)¶
    

Bases: `IndirectJumpResolver`

Resolves indirect jumps in ARM ELF binaries

__init__(_project_)¶
    

filter(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_)¶
    

Check if this resolution method may be able to resolve the indirect jump or not.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Basic block address of this indirect jump.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function that this indirect jump belongs to.

  * **block** – The basic block. The type is determined by the backend being used. It’s pyvex.IRSB if pyvex is used as the backend.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

Returns:
    

True if it is possible for this resolution method to resolve the specific indirect jump, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

resolve(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_ , _func_graph_complete =True_, _** kwargs_)¶
    

The main resolving function.

Parameters:
    

  * **cfg** – A CFG instance.

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the IRSB.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function.

  * **block** – The IRSB.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

  * **func_graph_complete** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Returns:
    

Return type:
    

[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

_class _angr.analyses.cfg.indirect_jump_resolvers.x86_pe_iat.X86PeIatResolver(_project_)¶
    

Bases: `IndirectJumpResolver`

A timeless indirect jump resolver for IAT in x86 PEs and xbes.

__init__(_project_)¶
    

filter(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_)¶
    

Check if this resolution method may be able to resolve the indirect jump or not.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Basic block address of this indirect jump.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function that this indirect jump belongs to.

  * **block** – The basic block. The type is determined by the backend being used. It’s pyvex.IRSB if pyvex is used as the backend.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

Returns:
    

True if it is possible for this resolution method to resolve the specific indirect jump, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

resolve(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_ , _func_graph_complete =True_, _** kwargs_)¶
    

Resolve an indirect jump.

Parameters:
    

  * **cfg** – The CFG analysis object.

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Basic block address of this indirect jump.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function that this indirect jump belongs to.

  * **block** – The basic block. The type is determined by the backend being used. It’s pyvex.IRSB if pyvex is used as the backend.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

  * **func_graph_complete** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True if the function graph is complete at this point (except for nodes that this indirect jump node dominates).

Returns:
    

A tuple of a boolean indicating whether the resolution is successful or not, and a list of resolved targets (ints).

Return type:
    

[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

angr.analyses.cfg.indirect_jump_resolvers.mips_elf_fast.enable_profiling()¶
    

angr.analyses.cfg.indirect_jump_resolvers.mips_elf_fast.disable_profiling()¶
    

_class _angr.analyses.cfg.indirect_jump_resolvers.mips_elf_fast.Case2Result(_value_)¶
    

Bases: [`Enum`](https://docs.python.org/3/library/enum.html#enum.Enum "\(in Python v3.13\)")

Describes the result of resolving case 2 function calls.

SUCCESS _ = 0_¶
    

FAILURE _ = 1_¶
    

RESUME _ = 2_¶
    

_class _angr.analyses.cfg.indirect_jump_resolvers.mips_elf_fast.MipsElfFastResolver(_project_)¶
    

Bases: `IndirectJumpResolver`

A timeless indirect jump resolver for R9-based indirect function calls in MIPS ELFs.

__init__(_project_)¶
    

filter(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_)¶
    

Check if this resolution method may be able to resolve the indirect jump or not.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Basic block address of this indirect jump.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function that this indirect jump belongs to.

  * **block** – The basic block. The type is determined by the backend being used. It’s pyvex.IRSB if pyvex is used as the backend.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

Returns:
    

True if it is possible for this resolution method to resolve the specific indirect jump, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

resolve(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_ , _func_graph_complete =True_, _** kwargs_)¶
    

Wrapper for _resolve that slowly increments the max_depth used by Blade for finding sources until we can resolve the addr or we reach the default max_depth

Parameters:
    

  * **cfg** – A CFG instance.

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – IRSB address.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The function address.

  * **block** ([_pyvex.IRSB_](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.IRSB "\(in pyvex\)")) – The IRSB.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

  * **func_graph_complete** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Returns:
    

If it was resolved and targets alongside it

Return type:
    

[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

_class _angr.analyses.cfg.indirect_jump_resolvers.x86_elf_pic_plt.X86ElfPicPltResolver(_project_)¶
    

Bases: `IndirectJumpResolver`

In X86 ELF position-independent code, PLT stubs uses ebx to resolve library calls, where ebx stores the address to the beginning of the GOT. We resolve the target by forcing ebx to be the beginning of the GOT and simulate the execution in fast path mode.

__init__(_project_)¶
    

filter(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_)¶
    

Check if this resolution method may be able to resolve the indirect jump or not.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Basic block address of this indirect jump.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function that this indirect jump belongs to.

  * **block** – The basic block. The type is determined by the backend being used. It’s pyvex.IRSB if pyvex is used as the backend.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

Returns:
    

True if it is possible for this resolution method to resolve the specific indirect jump, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

resolve(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_ , _func_graph_complete =True_, _** kwargs_)¶
    

Resolve an indirect jump.

Parameters:
    

  * **cfg** – The CFG analysis object.

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Basic block address of this indirect jump.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function that this indirect jump belongs to.

  * **block** – The basic block. The type is determined by the backend being used. It’s pyvex.IRSB if pyvex is used as the backend.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

  * **func_graph_complete** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True if the function graph is complete at this point (except for nodes that this indirect jump node dominates).

Returns:
    

A tuple of a boolean indicating whether the resolution is successful or not, and a list of resolved targets (ints).

Return type:
    

[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

angr.analyses.cfg.indirect_jump_resolvers.default_resolvers.default_indirect_jump_resolvers(_obj_ , _project_)¶
    

_exception _angr.analyses.cfg.indirect_jump_resolvers.jumptable.NotAJumpTableNotification¶
    

Bases: `AngrError`

Exception raised to indicate this is not (or does not appear to be) a jump table.

_class _angr.analyses.cfg.indirect_jump_resolvers.jumptable.UninitReadMeta¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Uninitialized read remapping details.

uninit_read_base _ = 201326592_¶
    

_class _angr.analyses.cfg.indirect_jump_resolvers.jumptable.AddressTransformationTypes(_value_)¶
    

Bases: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Enum`](https://docs.python.org/3/library/enum.html#enum.Enum "\(in Python v3.13\)")

Address transformation operations.

Assignment _ = 0_¶
    

SignedExtension _ = 1_¶
    

UnsignedExtension _ = 2_¶
    

Truncation _ = 3_¶
    

Or1 _ = 4_¶
    

ShiftLeft _ = 5_¶
    

ShiftRight _ = 6_¶
    

Add _ = 7_¶
    

Load _ = 8_¶
    

_class _angr.analyses.cfg.indirect_jump_resolvers.jumptable.AddressTransformation(_op_ , _operands_ , _first_load =False_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Describe and record an address transformation operation.

Parameters:
    

  * **op** (_AddressTransformationTypes_)

  * **operands** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)"))

  * **first_load** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_op_ , _operands_ , _first_load =False_)¶
    

Parameters:
    

  * **op** (_AddressTransformationTypes_)

  * **operands** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)"))

  * **first_load** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

_class _angr.analyses.cfg.indirect_jump_resolvers.jumptable.AddressOperand¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

The class for the singleton class AddressSingleton. It represents the address being transformed before using as an indirect jump target.

_class _angr.analyses.cfg.indirect_jump_resolvers.jumptable.Tmp(_tmp_idx_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

For modeling Tmp variables.

__init__(_tmp_idx_)¶
    

_class _angr.analyses.cfg.indirect_jump_resolvers.jumptable.JumpTargetBaseAddr(_stmt_loc_ , _stmt_ , _tmp_ , _base_addr =None_, _tmp_1 =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Model for jump targets and their data origin.

Parameters:
    

  * **stmt** ([_pyvex.stmt.IRStmt_](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.stmt.IRStmt "\(in pyvex\)"))

  * **tmp** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **base_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **tmp_1** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_stmt_loc_ , _stmt_ , _tmp_ , _base_addr =None_, _tmp_1 =None_)¶
    

Parameters:
    

  * **stmt** ([_IRStmt_](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.stmt.IRStmt "\(in pyvex\)"))

  * **tmp** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **base_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **tmp_1** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

_property _base_addr_available¶
    

_class _angr.analyses.cfg.indirect_jump_resolvers.jumptable.JumpTableProcessorState(_arch_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

The state used in JumpTableProcessor.

__init__(_arch_)¶
    

arch¶
    

is_jumptable _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

stmts_to_instrument¶
    

regs_to_initialize¶
    

_class _angr.analyses.cfg.indirect_jump_resolvers.jumptable.RegOffsetAnnotation(_reg_offset_)¶
    

Bases: [`Annotation`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.annotation.Annotation "\(in claripy\)")

Register Offset annotation.

Parameters:
    

**reg_offset** (_RegisterOffset_)

__init__(_reg_offset_)¶
    

Parameters:
    

**reg_offset** (_RegisterOffset_)

reg_offset¶
    

_property _relocatable¶
    

Returns whether this annotation can be relocated in a simplification.

Returns:
    

True if it can be relocated, false otherwise.

_property _eliminatable¶
    

Returns whether this annotation can be eliminated in a simplification.

Returns:
    

True if eliminatable, False otherwise

_class _angr.analyses.cfg.indirect_jump_resolvers.jumptable.JumpTableProcessor(_project_ , _indirect_jump_node_pred_addrs_ , _bp_sp_diff =256_)¶
    

Bases: `SimEngineNostmtVEX`[`JumpTableProcessorState`, [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"), `JumpTableProcessorState`], `ClaripyDataVEXEngineMixin`[`JumpTableProcessorState`, [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"), `JumpTableProcessorState`, [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")]

Implements a simple and stupid data dependency tracking for stack and register variables.

Also determines which statements to instrument during static execution of the slice later. For example, the following example is not uncommon in non-optimized binaries:
    
    
        mov  [rbp+var_54], 1
    loc_4051a6:
        cmp  [rbp+var_54], 6
        ja   loc_405412 (default)
    loc_4051b0:
        mov  eax, [rbp+var_54]
        mov  rax, qword [rax*8+0x223a01]
        jmp  rax
    

We want to instrument the first instruction and replace the constant 1 with a symbolic variable, otherwise we will not be able to recover all jump targets later in block 0x4051b0.

Parameters:
    

**indirect_jump_node_pred_addrs** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]_)

__init__(_project_ , _indirect_jump_node_pred_addrs_ , _bp_sp_diff =256_)¶
    

Parameters:
    

**indirect_jump_node_pred_addrs** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]_)

_class _angr.analyses.cfg.indirect_jump_resolvers.jumptable.StoreHook¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Hook for memory stores.

_static _hook(_state_)¶
    

_class _angr.analyses.cfg.indirect_jump_resolvers.jumptable.LoadHook¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Hook for memory loads.

__init__()¶
    

hook_before(_state_)¶
    

hook_after(_state_)¶
    

_class _angr.analyses.cfg.indirect_jump_resolvers.jumptable.PutHook¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Hook for register writes.

_static _hook(_state_)¶
    

_class _angr.analyses.cfg.indirect_jump_resolvers.jumptable.RegisterInitializerHook(_reg_offset_ , _reg_bits_ , _initial_value_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Hook for register init.

__init__(_reg_offset_ , _reg_bits_ , _initial_value_)¶
    

hook(_state_)¶
    

_class _angr.analyses.cfg.indirect_jump_resolvers.jumptable.BSSHook(_project_ , _bss_regions_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Hook for BSS read/write.

__init__(_project_ , _bss_regions_)¶
    

bss_memory_read_hook(_state_)¶
    

bss_memory_write_hook(_state_)¶
    

_class _angr.analyses.cfg.indirect_jump_resolvers.jumptable.MIPSGPHook(_gp_offset_ , _gp_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Hooks all reads from and writes into the gp register for MIPS32 binaries.

Parameters:
    

  * **gp_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **gp** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_gp_offset_ , _gp_)¶
    

Parameters:
    

  * **gp_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **gp** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

gp_register_read_hook(_state_)¶
    

gp_register_write_hook(_state_)¶
    

_class _angr.analyses.cfg.indirect_jump_resolvers.jumptable.JumpTableResolver(_project_ , _resolve_calls =True_)¶
    

Bases: `IndirectJumpResolver`

A generic jump table resolver.

This is a fast jump table resolution. For performance concerns, we made the following assumptions:
    

  * The final jump target comes from the memory.

  * The final jump target must be directly read out of the memory, without any further modification or altering.

Progressively larger program slices will be analyzed to determine jump table location and size. If the size of the table cannot be determined, a _guess_ will be made based on how many entries in the table _appear_ valid.

Parameters:
    

**resolve_calls** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_project_ , _resolve_calls =True_)¶
    

Parameters:
    

**resolve_calls** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

filter(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_)¶
    

Check if this resolution method may be able to resolve the indirect jump or not.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Basic block address of this indirect jump.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function that this indirect jump belongs to.

  * **block** – The basic block. The type is determined by the backend being used. It’s pyvex.IRSB if pyvex is used as the backend.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

Returns:
    

True if it is possible for this resolution method to resolve the specific indirect jump, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

resolve(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_ , _func_graph_complete =True_, _** kwargs_)¶
    

Resolves jump tables.

Parameters:
    

  * **cfg** – A CFG instance.

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – IRSB address.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The function address.

  * **block** ([_pyvex.IRSB_](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.IRSB "\(in pyvex\)")) – The IRSB.

  * **func_graph_complete** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Returns:
    

A bool indicating whether the indirect jump is resolved successfully, and a list of resolved targets

Return type:
    

[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

angr.analyses.cfg.indirect_jump_resolvers.const_resolver.exists_in_replacements(_replacements_ , _block_loc_ , _tmp_var_)¶
    

_class _angr.analyses.cfg.indirect_jump_resolvers.const_resolver.ConstantResolver(_project_ , _max_func_nodes =512_)¶
    

Bases: `IndirectJumpResolver`

Resolve an indirect jump by running a constant propagation on the entire function and check if the indirect jump can be resolved to a constant value. This resolver must be run after all other more specific resolvers.

Parameters:
    

**max_func_nodes** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_project_ , _max_func_nodes =512_)¶
    

Parameters:
    

**max_func_nodes** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

filter(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_)¶
    

Check if this resolution method may be able to resolve the indirect jump or not.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Basic block address of this indirect jump.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function that this indirect jump belongs to.

  * **block** – The basic block. The type is determined by the backend being used. It’s pyvex.IRSB if pyvex is used as the backend.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

Returns:
    

True if it is possible for this resolution method to resolve the specific indirect jump, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

resolve(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_ , _func_graph_complete =True_, _** kwargs_)¶
    

This function does the actual resolve. Our process is easy: Propagate all values inside the function specified, then extract the tmp_var used for the indirect jump from the basic block. Use the tmp var to locate the constant value stored in the replacements. If not present, returns False tuple.

Parameters:
    

  * **cfg** – CFG with specified function

  * **addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of indirect jump

  * **func_addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of function of indirect jump

  * **block** (`Block`) – Block of indirect jump (Block object)

  * **jumpkind** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – VEX jumpkind (Ijk_Boring or Ijk_Call)

  * **func_graph_complete** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Returns:
    

Bool tuple with replacement address

_class _angr.analyses.cfg.indirect_jump_resolvers.resolver.IndirectJumpResolver(_project_ , _timeless =False_, _base_state =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_project_ , _timeless =False_, _base_state =None_)¶
    

filter(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_)¶
    

Check if this resolution method may be able to resolve the indirect jump or not.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Basic block address of this indirect jump.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function that this indirect jump belongs to.

  * **block** – The basic block. The type is determined by the backend being used. It’s pyvex.IRSB if pyvex is used as the backend.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

Returns:
    

True if it is possible for this resolution method to resolve the specific indirect jump, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

resolve(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_ , _func_graph_complete =True_, _** kwargs_)¶
    

Resolve an indirect jump.

Parameters:
    

  * **cfg** – The CFG analysis object.

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Basic block address of this indirect jump.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function that this indirect jump belongs to.

  * **block** – The basic block. The type is determined by the backend being used. It’s pyvex.IRSB if pyvex is used as the backend.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

  * **func_graph_complete** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True if the function graph is complete at this point (except for nodes that this indirect jump node dominates).

Returns:
    

A tuple of a boolean indicating whether the resolution is successful or not, and a list of resolved targets (ints).

Return type:
    

[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

_class _angr.analyses.cfg.indirect_jump_resolvers.AMD64ElfGotResolver(_project_)¶
    

Bases: `IndirectJumpResolver`

A timeless indirect jump resolver that resolves GOT entries on AMD64 ELF binaries.

__init__(_project_)¶
    

filter(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_)¶
    

Check if this resolution method may be able to resolve the indirect jump or not.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Basic block address of this indirect jump.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function that this indirect jump belongs to.

  * **block** – The basic block. The type is determined by the backend being used. It’s pyvex.IRSB if pyvex is used as the backend.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

Returns:
    

True if it is possible for this resolution method to resolve the specific indirect jump, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

resolve(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_ , _func_graph_complete =True_, _** kwargs_)¶
    

Resolve an indirect jump.

Parameters:
    

  * **cfg** – The CFG analysis object.

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Basic block address of this indirect jump.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function that this indirect jump belongs to.

  * **block** – The basic block. The type is determined by the backend being used. It’s pyvex.IRSB if pyvex is used as the backend.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

  * **func_graph_complete** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True if the function graph is complete at this point (except for nodes that this indirect jump node dominates).

Returns:
    

A tuple of a boolean indicating whether the resolution is successful or not, and a list of resolved targets (ints).

Return type:
    

[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

_class _angr.analyses.cfg.indirect_jump_resolvers.AMD64PeIatResolver(_project_)¶
    

Bases: `IndirectJumpResolver`

A timeless indirect call/jump resolver for IAT in amd64 PEs.

__init__(_project_)¶
    

filter(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_)¶
    

Check if this resolution method may be able to resolve the indirect jump or not.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Basic block address of this indirect jump.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function that this indirect jump belongs to.

  * **block** – The basic block. The type is determined by the backend being used. It’s pyvex.IRSB if pyvex is used as the backend.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

Returns:
    

True if it is possible for this resolution method to resolve the specific indirect jump, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

resolve(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_ , _func_graph_complete =True_, _** kwargs_)¶
    

Resolve an indirect jump.

Parameters:
    

  * **cfg** – The CFG analysis object.

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Basic block address of this indirect jump.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function that this indirect jump belongs to.

  * **block** – The basic block. The type is determined by the backend being used. It’s pyvex.IRSB if pyvex is used as the backend.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

  * **func_graph_complete** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True if the function graph is complete at this point (except for nodes that this indirect jump node dominates).

Returns:
    

A tuple of a boolean indicating whether the resolution is successful or not, and a list of resolved targets (ints).

Return type:
    

[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

_class _angr.analyses.cfg.indirect_jump_resolvers.ArmElfFastResolver(_project_)¶
    

Bases: `IndirectJumpResolver`

Resolves indirect jumps in ARM ELF binaries

__init__(_project_)¶
    

filter(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_)¶
    

Check if this resolution method may be able to resolve the indirect jump or not.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Basic block address of this indirect jump.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function that this indirect jump belongs to.

  * **block** – The basic block. The type is determined by the backend being used. It’s pyvex.IRSB if pyvex is used as the backend.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

Returns:
    

True if it is possible for this resolution method to resolve the specific indirect jump, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

resolve(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_ , _func_graph_complete =True_, _** kwargs_)¶
    

The main resolving function.

Parameters:
    

  * **cfg** – A CFG instance.

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the IRSB.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function.

  * **block** – The IRSB.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

  * **func_graph_complete** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Returns:
    

Return type:
    

[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

_class _angr.analyses.cfg.indirect_jump_resolvers.ConstantResolver(_project_ , _max_func_nodes =512_)¶
    

Bases: `IndirectJumpResolver`

Resolve an indirect jump by running a constant propagation on the entire function and check if the indirect jump can be resolved to a constant value. This resolver must be run after all other more specific resolvers.

Parameters:
    

**max_func_nodes** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_project_ , _max_func_nodes =512_)¶
    

Parameters:
    

**max_func_nodes** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

filter(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_)¶
    

Check if this resolution method may be able to resolve the indirect jump or not.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Basic block address of this indirect jump.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function that this indirect jump belongs to.

  * **block** – The basic block. The type is determined by the backend being used. It’s pyvex.IRSB if pyvex is used as the backend.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

Returns:
    

True if it is possible for this resolution method to resolve the specific indirect jump, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

resolve(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_ , _func_graph_complete =True_, _** kwargs_)¶
    

This function does the actual resolve. Our process is easy: Propagate all values inside the function specified, then extract the tmp_var used for the indirect jump from the basic block. Use the tmp var to locate the constant value stored in the replacements. If not present, returns False tuple.

Parameters:
    

  * **cfg** – CFG with specified function

  * **addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of indirect jump

  * **func_addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of function of indirect jump

  * **block** (`Block`) – Block of indirect jump (Block object)

  * **jumpkind** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – VEX jumpkind (Ijk_Boring or Ijk_Call)

  * **func_graph_complete** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Returns:
    

Bool tuple with replacement address

_class _angr.analyses.cfg.indirect_jump_resolvers.JumpTableResolver(_project_ , _resolve_calls =True_)¶
    

Bases: `IndirectJumpResolver`

A generic jump table resolver.

This is a fast jump table resolution. For performance concerns, we made the following assumptions:
    

  * The final jump target comes from the memory.

  * The final jump target must be directly read out of the memory, without any further modification or altering.

Progressively larger program slices will be analyzed to determine jump table location and size. If the size of the table cannot be determined, a _guess_ will be made based on how many entries in the table _appear_ valid.

Parameters:
    

**resolve_calls** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_project_ , _resolve_calls =True_)¶
    

Parameters:
    

**resolve_calls** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

filter(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_)¶
    

Check if this resolution method may be able to resolve the indirect jump or not.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Basic block address of this indirect jump.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function that this indirect jump belongs to.

  * **block** – The basic block. The type is determined by the backend being used. It’s pyvex.IRSB if pyvex is used as the backend.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

Returns:
    

True if it is possible for this resolution method to resolve the specific indirect jump, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

resolve(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_ , _func_graph_complete =True_, _** kwargs_)¶
    

Resolves jump tables.

Parameters:
    

  * **cfg** – A CFG instance.

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – IRSB address.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The function address.

  * **block** ([_pyvex.IRSB_](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.IRSB "\(in pyvex\)")) – The IRSB.

  * **func_graph_complete** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Returns:
    

A bool indicating whether the indirect jump is resolved successfully, and a list of resolved targets

Return type:
    

[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

_class _angr.analyses.cfg.indirect_jump_resolvers.MemoryLoadResolver(_project_)¶
    

Bases: `IndirectJumpResolver`

Resolve an indirect jump that looks like the following:
    
    
    .text:
    

> call off_3314A8

.data: off_3314A8 dd offset sub_1E426F

This indirect jump resolver may not be the best solution for all cases (e.g., when the .data section can be intentionally altered by the binary itself).

__init__(_project_)¶
    

filter(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_)¶
    

Check if this resolution method may be able to resolve the indirect jump or not.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Basic block address of this indirect jump.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function that this indirect jump belongs to.

  * **block** – The basic block. The type is determined by the backend being used. It’s pyvex.IRSB if pyvex is used as the backend.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

Returns:
    

True if it is possible for this resolution method to resolve the specific indirect jump, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

resolve(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_ , _func_graph_complete =True_, _** kwargs_)¶
    

Parameters:
    

  * **cfg** – CFG with specified function

  * **addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of indirect jump

  * **func_addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of function of indirect jump

  * **block** ([`IRSB`](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.block.IRSB "\(in pyvex\)")) – Block of indirect jump (Block object)

  * **jumpkind** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – VEX jumpkind (Ijk_Boring or Ijk_Call)

  * **func_graph_complete** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Returns:
    

Bool tuple with replacement address

_class _angr.analyses.cfg.indirect_jump_resolvers.MipsElfFastResolver(_project_)¶
    

Bases: `IndirectJumpResolver`

A timeless indirect jump resolver for R9-based indirect function calls in MIPS ELFs.

__init__(_project_)¶
    

filter(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_)¶
    

Check if this resolution method may be able to resolve the indirect jump or not.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Basic block address of this indirect jump.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function that this indirect jump belongs to.

  * **block** – The basic block. The type is determined by the backend being used. It’s pyvex.IRSB if pyvex is used as the backend.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

Returns:
    

True if it is possible for this resolution method to resolve the specific indirect jump, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

resolve(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_ , _func_graph_complete =True_, _** kwargs_)¶
    

Wrapper for _resolve that slowly increments the max_depth used by Blade for finding sources until we can resolve the addr or we reach the default max_depth

Parameters:
    

  * **cfg** – A CFG instance.

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – IRSB address.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The function address.

  * **block** ([_pyvex.IRSB_](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.IRSB "\(in pyvex\)")) – The IRSB.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

  * **func_graph_complete** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Returns:
    

If it was resolved and targets alongside it

Return type:
    

[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

_class _angr.analyses.cfg.indirect_jump_resolvers.MipsElfGotResolver(_project_)¶
    

Bases: `IndirectJumpResolver`

A timeless indirect jump resolver that resolves GOT stub entries in MIPS ELF binaries.

Reference: MIPS Assembly Language Programmer’s Guide, Calling Position Independent Functions

__init__(_project_)¶
    

filter(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_)¶
    

Check if this resolution method may be able to resolve the indirect jump or not.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Basic block address of this indirect jump.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function that this indirect jump belongs to.

  * **block** – The basic block. The type is determined by the backend being used. It’s pyvex.IRSB if pyvex is used as the backend.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

Returns:
    

True if it is possible for this resolution method to resolve the specific indirect jump, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

resolve(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_ , _func_graph_complete =True_, _** kwargs_)¶
    

Resolve an indirect jump.

Parameters:
    

  * **cfg** – The CFG analysis object.

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Basic block address of this indirect jump.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function that this indirect jump belongs to.

  * **block** – The basic block. The type is determined by the backend being used. It’s pyvex.IRSB if pyvex is used as the backend.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

  * **func_graph_complete** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True if the function graph is complete at this point (except for nodes that this indirect jump node dominates).

Returns:
    

A tuple of a boolean indicating whether the resolution is successful or not, and a list of resolved targets (ints).

Return type:
    

[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

_class _angr.analyses.cfg.indirect_jump_resolvers.SyscallResolver(_project_)¶
    

Bases: `IndirectJumpResolver`

Resolve syscalls to SimProcedures.

__init__(_project_)¶
    

filter(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_)¶
    

Check if this resolution method may be able to resolve the indirect jump or not.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Basic block address of this indirect jump.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function that this indirect jump belongs to.

  * **block** – The basic block. The type is determined by the backend being used. It’s pyvex.IRSB if pyvex is used as the backend.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

Returns:
    

True if it is possible for this resolution method to resolve the specific indirect jump, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

resolve(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_ , _func_graph_complete =True_, _** kwargs_)¶
    

Resolve an indirect jump.

Parameters:
    

  * **cfg** – The CFG analysis object.

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Basic block address of this indirect jump.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function that this indirect jump belongs to.

  * **block** (`Block`) – The basic block. The type is determined by the backend being used. It’s pyvex.IRSB if pyvex is used as the backend.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

  * **func_graph_complete** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True if the function graph is complete at this point (except for nodes that this indirect jump node dominates).

Returns:
    

A tuple of a boolean indicating whether the resolution is successful or not, and a list of resolved targets (ints).

Return type:
    

[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

_class _angr.analyses.cfg.indirect_jump_resolvers.X86ElfPicPltResolver(_project_)¶
    

Bases: `IndirectJumpResolver`

In X86 ELF position-independent code, PLT stubs uses ebx to resolve library calls, where ebx stores the address to the beginning of the GOT. We resolve the target by forcing ebx to be the beginning of the GOT and simulate the execution in fast path mode.

__init__(_project_)¶
    

filter(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_)¶
    

Check if this resolution method may be able to resolve the indirect jump or not.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Basic block address of this indirect jump.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function that this indirect jump belongs to.

  * **block** – The basic block. The type is determined by the backend being used. It’s pyvex.IRSB if pyvex is used as the backend.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

Returns:
    

True if it is possible for this resolution method to resolve the specific indirect jump, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

resolve(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_ , _func_graph_complete =True_, _** kwargs_)¶
    

Resolve an indirect jump.

Parameters:
    

  * **cfg** – The CFG analysis object.

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Basic block address of this indirect jump.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function that this indirect jump belongs to.

  * **block** – The basic block. The type is determined by the backend being used. It’s pyvex.IRSB if pyvex is used as the backend.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

  * **func_graph_complete** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True if the function graph is complete at this point (except for nodes that this indirect jump node dominates).

Returns:
    

A tuple of a boolean indicating whether the resolution is successful or not, and a list of resolved targets (ints).

Return type:
    

[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

_class _angr.analyses.cfg.indirect_jump_resolvers.X86PeIatResolver(_project_)¶
    

Bases: `IndirectJumpResolver`

A timeless indirect jump resolver for IAT in x86 PEs and xbes.

__init__(_project_)¶
    

filter(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_)¶
    

Check if this resolution method may be able to resolve the indirect jump or not.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Basic block address of this indirect jump.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function that this indirect jump belongs to.

  * **block** – The basic block. The type is determined by the backend being used. It’s pyvex.IRSB if pyvex is used as the backend.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

Returns:
    

True if it is possible for this resolution method to resolve the specific indirect jump, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

resolve(_cfg_ , _addr_ , _func_addr_ , _block_ , _jumpkind_ , _func_graph_complete =True_, _** kwargs_)¶
    

Resolve an indirect jump.

Parameters:
    

  * **cfg** – The CFG analysis object.

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Basic block address of this indirect jump.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function that this indirect jump belongs to.

  * **block** – The basic block. The type is determined by the backend being used. It’s pyvex.IRSB if pyvex is used as the backend.

  * **jumpkind** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The jumpkind.

  * **func_graph_complete** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True if the function graph is complete at this point (except for nodes that this indirect jump node dominates).

Returns:
    

A tuple of a boolean indicating whether the resolution is successful or not, and a list of resolved targets (ints).

Return type:
    

[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

_class _angr.analyses.cfg.cfg_fast_soot.CFGFastSoot(_support_jni =False_, _** kwargs_)¶
    

Bases: `CFGFast`

__init__(_support_jni =False_, _** kwargs_)¶
    

Parameters:
    

  * **binary** – The binary to recover CFG on. By default the main binary is used.

  * **objects** – A list of objects to recover the CFG on. By default it will recover the CFG of all loaded objects.

  * **regions** (_iterable_) – A list of tuples in the form of (start address, end address) describing memory regions that the CFG should cover.

  * **pickle_intermediate_results** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If we want to store the intermediate results or not.

  * **symbols** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Get function beginnings from symbols in the binary.

  * **function_prologues** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Scan the binary for function prologues, and use those positions as function beginnings

  * **resolve_indirect_jumps** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Try to resolve indirect jumps. This is necessary to resolve jump targets from jump tables, etc.

  * **force_segment** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Force CFGFast to rely on binary segments instead of sections.

  * **force_complete_scan** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Perform a complete scan on the binary and maximize the number of identified code blocks.

  * **data_references** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Enables the collection of references to data used by individual instructions. This does not collect ‘cross-references’, particularly those that involve multiple instructions. For that, see cross_references

  * **cross_references** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether CFGFast should collect “cross-references” from the entire program or not. This will populate the knowledge base with references to and from each recognizable address constant found in the code. Note that, because this performs constant propagation on the entire program, it may be much slower and consume more memory. This option implies data_references=True.

  * **normalize** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Normalize the CFG as well as all function graphs after CFG recovery.

  * **start_at_entry** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Begin CFG recovery at the entry point of this project. Setting it to False prevents CFGFast from viewing the entry point as one of the starting points of code scanning.

  * **function_starts** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A list of extra function starting points. CFGFast will try to resume scanning from each address in the list.

  * **extra_memory_regions** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A list of 2-tuple (start-address, end-address) that shows extra memory regions. Integers falling inside will be considered as pointers.

  * **indirect_jump_resolvers** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A custom list of indirect jump resolvers. If this list is None or empty, default indirect jump resolvers specific to this architecture and binary types will be loaded.

  * **base_state** – A state to use as a backer for all memory loads

  * **detect_tail_calls** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Enable aggressive tail-call optimization detection.

  * **elf_eh_frame** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Retrieve function starts (and maybe sizes later) from the .eh_frame of ELF binaries.

  * **skip_unmapped_addrs** – Ignore all branches into unmapped regions. True by default. You may want to set it to False if you are analyzing manually patched binaries or malware samples.

  * **indirect_calls_always_return** – Should CFG assume indirect calls must return or not. Assuming indirect calls must return will significantly reduce the number of constant propagation runs, but may reduce the overall CFG recovery precision when facing non-returning indirect calls. By default, we only assume indirect calls always return for large binaries (region > 50KB).

  * **jumptable_resolver_resolves_calls** – Whether JumpTableResolver should resolve indirect calls or not. Most indirect calls in C++ binaries or UEFI binaries cannot be resolved using jump table resolver and must be resolved using their specific resolvers. By default, we will only disable JumpTableResolver from resolving indirect calls for large binaries (region > 50 KB).

:param check_funcret_max_job When popping return-site jobs out of the job queue, angr will prioritize jobs
    

for which the callee is known to return. This check may be slow when there are a large amount of jobs in different caller functions, and this situation often occurs in obfuscated binaries where many functions never return. This parameter acts as a threshold to disable this check when the number of jobs in the queue exceeds this threshold.

Parameters:
    

  * **start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – (Deprecated) The beginning address of CFG recovery.

  * **end** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – (Deprecated) The end address of CFG recovery.

  * **arch_options** (_CFGArchOptions_) – Architecture-specific options.

  * **extra_arch_options** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")) – Any key-value pair in kwargs will be seen as an arch-specific option and will be used to set the option value in self._arch_options.

Extra parameters that angr.Analysis takes:

Parameters:
    

  * **progress_callback** – Specify a callback function to get the progress during CFG recovery.

  * **show_progressbar** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Should CFGFast show a progressbar during CFG recovery or not.

Returns:
    

None

normalize()¶
    

Normalize the CFG, making sure that there are no overlapping basic blocks.

Note that this method will not alter transition graphs of each function in self.kb.functions. You may call normalize() on each Function object to normalize their transition graphs.

Returns:
    

None

make_functions()¶
    

Revisit the entire control flow graph, create Function instances accordingly, and correctly put blocks into each function.

Although Function objects are crated during the CFG recovery, they are neither sound nor accurate. With a pre-constructed CFG, this method rebuilds all functions bearing the following rules:

>   * A block may only belong to one function.
> 
>   * Small functions lying inside the startpoint and the endpoint of another function will be merged with the other function
> 
>   * Tail call optimizations are detected.
> 
>   * PLT stubs are aligned by 16.
> 
> 

Returns:
    

None

_class _angr.analyses.cdg.CDG(_cfg_ , _start =None_, _no_construct =False_)¶
    

Bases: `Analysis`

Implements a control dependence graph.

__init__(_cfg_ , _start =None_, _no_construct =False_)¶
    

Constructor.

Parameters:
    

  * **cfg** – The control flow graph upon which this control dependence graph will build

  * **start** – The starting point to begin constructing the control dependence graph

  * **no_construct** – Skip the construction step. Only used in unit-testing.

_property _graph¶
    

get_post_dominators()¶
    

Return the post-dom tree

get_dependants(_run_)¶
    

Return a list of nodes that are control dependent on the given node in the control dependence graph

get_guardians(_run_)¶
    

Return a list of nodes on whom the specific node is control dependent in the control dependence graph

_exception _angr.analyses.datagraph_meta.DataGraphError¶
    

Bases: [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception "\(in Python v3.13\)")

_class _angr.analyses.datagraph_meta.DataGraphMeta¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__()¶
    

get_irsb_at(_addr_)¶
    

pp(_imarks =False_)¶
    

Pretty print the graph. @imarks determine whether the printed graph represents instructions (coarse grained) for easier navigation, or exact statements.

_class _angr.analyses.code_tagging.CodeTags¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

HAS_XOR _ = 'HAS_XOR'_¶
    

HAS_BITSHIFTS _ = 'HAS_BITSHIFTS'_¶
    

HAS_SQL _ = 'HAS_SQL'_¶
    

LARGE_SWITCH _ = 'LARGE_SWITCH'_¶
    

_class _angr.analyses.code_tagging.CodeTagging(_func_)¶
    

Bases: `Analysis`

__init__(_func_)¶
    

analyze()¶
    

has_xor()¶
    

Detects if there is any xor operation in the function.

Returns:
    

Tags

has_bitshifts()¶
    

Detects if there is any bitwise operation in the function.

Returns:
    

Tags.

has_sql()¶
    

Detects if there is any reference to strings that look like SQL queries.

_class _angr.angrdb.AngrDB(_project =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

AngrDB provides a storage solution for an angr project, its knowledge bases, and some other types of data. It is designed to use an SQL-based database as the storage backend.

ALL_TABLES _ = ['objects']_¶
    

VERSION _ = 1_¶
    

__init__(_project =None_)¶
    

_static _open_db(_db_str ='sqlite:///:memory:'_)¶
    

_static _session_scope(_Session_)¶
    

_static _save_info(_session_ , _key_ , _value_)¶
    

Save an information entry to the database.

Parameters:
    

  * **session**

  * **key**

  * **value**

Returns:
    

_static _get_info(_session_ , _key_)¶
    

Get an information entry from the database.

Parameters:
    

  * **session**

  * **key**

Returns:
    

update_dbinfo(_session_ , _extra_info =None_)¶
    

Update the information in database.

Parameters:
    

  * **session**

  * **extra_info** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

Returns:
    

get_dbinfo(_session_ , _extra_info =None_)¶
    

Get database information.

Parameters:
    

  * **session**

  * **extra_info** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

Returns:
    

A dict of information entries.

db_compatible(_version_)¶
    

Checks if the given database version is compatible with the current AngrDB class.

Parameters:
    

**version** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The version of the database.

Returns:
    

True if compatible, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

dump(_db_path_ , _kbs =None_, _extra_info =None_)¶
    

Parameters:
    

  * **kbs** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__KnowledgeBase_ _]__|__None_)

  * **extra_info** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]__|__None_)

load(_db_path_ , _kb_names =None_, _other_kbs =None_, _extra_info =None_)¶
    

Parameters:
    

  * **db_path** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **kb_names** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **other_kbs** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__KnowledgeBase_ _]__|__None_)

  * **extra_info** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]__|__None_)

_class _angr.angrdb.db.AngrDB(_project =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

AngrDB provides a storage solution for an angr project, its knowledge bases, and some other types of data. It is designed to use an SQL-based database as the storage backend.

ALL_TABLES _ = ['objects']_¶
    

VERSION _ = 1_¶
    

__init__(_project =None_)¶
    

_static _open_db(_db_str ='sqlite:///:memory:'_)¶
    

_static _session_scope(_Session_)¶
    

_static _save_info(_session_ , _key_ , _value_)¶
    

Save an information entry to the database.

Parameters:
    

  * **session**

  * **key**

  * **value**

Returns:
    

_static _get_info(_session_ , _key_)¶
    

Get an information entry from the database.

Parameters:
    

  * **session**

  * **key**

Returns:
    

update_dbinfo(_session_ , _extra_info =None_)¶
    

Update the information in database.

Parameters:
    

  * **session**

  * **extra_info** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

Returns:
    

get_dbinfo(_session_ , _extra_info =None_)¶
    

Get database information.

Parameters:
    

  * **session**

  * **extra_info** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

Returns:
    

A dict of information entries.

db_compatible(_version_)¶
    

Checks if the given database version is compatible with the current AngrDB class.

Parameters:
    

**version** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The version of the database.

Returns:
    

True if compatible, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

dump(_db_path_ , _kbs =None_, _extra_info =None_)¶
    

Parameters:
    

  * **kbs** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__KnowledgeBase_ _]__|__None_)

  * **extra_info** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]__|__None_)

load(_db_path_ , _kb_names =None_, _other_kbs =None_, _extra_info =None_)¶
    

Parameters:
    

  * **db_path** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **kb_names** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **other_kbs** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__KnowledgeBase_ _]__|__None_)

  * **extra_info** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]__|__None_)

_class _angr.angrdb.models.DbInformation(_** kwargs_)¶
    

Bases: `Base`

Stores information related to the current database. Basically a key-value store.

id¶
    

key¶
    

value¶
    

__init__(_** kwargs_)¶
    

A simple constructor that allows initialization from kwargs.

Sets attributes on the constructed instance using the names and values in `kwargs`.

Only keys that are present as attributes of the instance’s class are allowed. These could be, for example, any mapped columns or relationships.

_class _angr.angrdb.models.DbObject(_** kwargs_)¶
    

Bases: `Base`

Models a binary object.

id¶
    

main_object¶
    

path¶
    

content¶
    

backend¶
    

backend_args¶
    

__init__(_** kwargs_)¶
    

A simple constructor that allows initialization from kwargs.

Sets attributes on the constructed instance using the names and values in `kwargs`.

Only keys that are present as attributes of the instance’s class are allowed. These could be, for example, any mapped columns or relationships.

_class _angr.angrdb.models.DbKnowledgeBase(_** kwargs_)¶
    

Bases: `Base`

Models a knowledge base.

id¶
    

name¶
    

cfgs¶
    

funcs¶
    

xrefs¶
    

comments¶
    

labels¶
    

var_collections¶
    

structured_code¶
    

__init__(_** kwargs_)¶
    

A simple constructor that allows initialization from kwargs.

Sets attributes on the constructed instance using the names and values in `kwargs`.

Only keys that are present as attributes of the instance’s class are allowed. These could be, for example, any mapped columns or relationships.

_class _angr.angrdb.models.DbCFGModel(_** kwargs_)¶
    

Bases: `Base`

Models a CFGFast instance.

id¶
    

kb_id¶
    

kb¶
    

ident¶
    

blob¶
    

__init__(_** kwargs_)¶
    

A simple constructor that allows initialization from kwargs.

Sets attributes on the constructed instance using the names and values in `kwargs`.

Only keys that are present as attributes of the instance’s class are allowed. These could be, for example, any mapped columns or relationships.

_class _angr.angrdb.models.DbFunction(_** kwargs_)¶
    

Bases: `Base`

Models a Function instance.

id¶
    

kb_id¶
    

kb¶
    

addr¶
    

blob¶
    

__init__(_** kwargs_)¶
    

A simple constructor that allows initialization from kwargs.

Sets attributes on the constructed instance using the names and values in `kwargs`.

Only keys that are present as attributes of the instance’s class are allowed. These could be, for example, any mapped columns or relationships.

_class _angr.angrdb.models.DbVariableCollection(_** kwargs_)¶
    

Bases: `Base`

Models a VariableManagerInternal instance.

id¶
    

kb_id¶
    

kb¶
    

func_addr¶
    

ident¶
    

blob¶
    

__init__(_** kwargs_)¶
    

A simple constructor that allows initialization from kwargs.

Sets attributes on the constructed instance using the names and values in `kwargs`.

Only keys that are present as attributes of the instance’s class are allowed. These could be, for example, any mapped columns or relationships.

_class _angr.angrdb.models.DbStructuredCode(_** kwargs_)¶
    

Bases: `Base`

Models a StructuredCode instance.

id¶
    

kb_id¶
    

kb¶
    

func_addr¶
    

flavor¶
    

expr_comments¶
    

stmt_comments¶
    

configuration¶
    

const_formats¶
    

ite_exprs¶
    

errors¶
    

__init__(_** kwargs_)¶
    

A simple constructor that allows initialization from kwargs.

Sets attributes on the constructed instance using the names and values in `kwargs`.

Only keys that are present as attributes of the instance’s class are allowed. These could be, for example, any mapped columns or relationships.

_class _angr.angrdb.models.DbXRefs(_** kwargs_)¶
    

Bases: `Base`

Models an XRefManager instance.

id¶
    

kb_id¶
    

kb¶
    

blob¶
    

__init__(_** kwargs_)¶
    

A simple constructor that allows initialization from kwargs.

Sets attributes on the constructed instance using the names and values in `kwargs`.

Only keys that are present as attributes of the instance’s class are allowed. These could be, for example, any mapped columns or relationships.

_class _angr.angrdb.models.DbComment(_** kwargs_)¶
    

Bases: `Base`

Models a comment.

id¶
    

kb_id¶
    

kb¶
    

addr¶
    

comment¶
    

type¶
    

__init__(_** kwargs_)¶
    

A simple constructor that allows initialization from kwargs.

Sets attributes on the constructed instance using the names and values in `kwargs`.

Only keys that are present as attributes of the instance’s class are allowed. These could be, for example, any mapped columns or relationships.

_class _angr.angrdb.models.DbLabel(_** kwargs_)¶
    

Bases: `Base`

Models a label.

id¶
    

kb_id¶
    

kb¶
    

addr¶
    

name¶
    

__init__(_** kwargs_)¶
    

A simple constructor that allows initialization from kwargs.

Sets attributes on the constructed instance using the names and values in `kwargs`.

Only keys that are present as attributes of the instance’s class are allowed. These could be, for example, any mapped columns or relationships.

_class _angr.angrdb.serializers.KnowledgeBaseSerializer¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Serialize/unserialize a KnowledgeBase object.

_static _dump(_session_ , _kb_)¶
    

Parameters:
    

  * **session** – The database session object.

  * **kb** (_KnowledgeBase_) – The KnowledgeBase instance to serialize.

Returns:
    

None

_static _load(_session_ , _project_ , _name_)¶
    

Parameters:
    

**session**

Returns:
    

_class _angr.angrdb.serializers.LoaderSerializer¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Serialize/unserialize a CLE Loader object into/from an angr DB.

Corner cases: \- For certain backends (e.g., CART), we do not store the data of the main object. angr will unpack the CART file

> again after loading the database.

NO_MAINBIN_BACKENDS _ = [<class 'cle.backends.cartfile.CARTFile'>]_¶
    

LOAD_ARG_BLACKLIST _ = {'is_main_bin', 'loader'}_¶
    

backend2name _ = {<class 'cle.backends.blob.Blob'>: 'blob', <class 'cle.backends.cartfile.CARTFile'>: 'cart', <class 'cle.backends.cgc.backedcgc.BackedCGC'>: 'backedcgc', <class 'cle.backends.cgc.cgc.CGC'>: 'cgc', <class 'cle.backends.coff.Coff'>: 'COFF', <class 'cle.backends.elf.elf.ELF'>: 'elf', <class 'cle.backends.elf.elfcore.ELFCore'>: 'elfcore', <class 'cle.backends.ihex.Hex'>: 'hex', <class 'cle.backends.java.apk.Apk'>: 'apk', <class 'cle.backends.java.jar.Jar'>: 'jar', <class 'cle.backends.macho.macho.MachO'>: 'mach-o', <class 'cle.backends.minidump.Minidump'>: 'minidump', <class 'cle.backends.named_region.NamedRegion'>: 'named_region', <class 'cle.backends.pe.pe.PE'>: 'pe', <class 'cle.backends.srec.SRec'>: 'srec', <class 'cle.backends.static_archive.StaticArchive'>: 'AR', <class 'cle.backends.te.TE'>: 'te', <class 'cle.backends.uefi_firmware.UefiFirmware'>: 'uefi', <class 'cle.backends.xbe.XBE'>: 'xbe'}_¶
    

_static _json_serialize_load_args(_load_args_)¶
    

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

Parameters:
    

**load_args** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]_)

_static _should_skip_main_binary(_loader_)¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"), [`Backend`](https://docs.angr.io/projects/cle/en/latest/api/backend.html#cle.backends.backend.Backend "\(in cle\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")]

_static _dump(_session_ , _loader_)¶
    

_static _load(_session_)¶
    

_class _angr.angrdb.serializers.cfg_model.CFGModelSerializer¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Serialize/unserialize a CFGModel.

_static _dump(_session_ , _db_kb_ , _ident_ , _cfg_model_)¶
    

Parameters:
    

  * **session**

  * **db_kb** (_DbKnowledgeBase_) – The database object for KnowledgeBase.

  * **ident** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Identifier of the CFG model.

  * **cfg_model** (_CFGModel_) – The CFG model to dump.

Returns:
    

None

_static _load(_session_ , _db_kb_ , _ident_ , _cfg_manager_ , _loader =None_)¶
    

_class _angr.angrdb.serializers.comments.CommentsSerializer¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Serialize/unserialize comments to/from a database session.

_static _dump(_session_ , _db_kb_ , _comments_)¶
    

Parameters:
    

  * **session**

  * **db_kb** (_DbKnowledgeBase_)

  * **comments** (_Comments_)

Returns:
    

None

_static _load(_session_ , _db_kb_ , _kb_)¶
    

Parameters:
    

  * **session**

  * **db_kb** (_DbKnowledgeBase_)

  * **kb** (_KnowledgeBase_)

Returns:
    

_class _angr.angrdb.serializers.funcs.FunctionManagerSerializer¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Serialize/unserialize a function manager and its functions.

_static _dump(_session_ , _db_kb_ , _func_manager_)¶
    

Parameters:
    

  * **session**

  * **db_kb** (_DbKnowledgeBase_)

  * **func_manager** (_FunctionManager_)

Returns:
    

_static _load(_session_ , _db_kb_ , _kb_)¶
    

Parameters:
    

  * **session**

  * **db_kb** (_DbKnowledgeBase_)

  * **kb** (_KnowledgeBase_)

Returns:
    

A loaded function manager.

_class _angr.angrdb.serializers.kb.KnowledgeBaseSerializer¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Serialize/unserialize a KnowledgeBase object.

_static _dump(_session_ , _kb_)¶
    

Parameters:
    

  * **session** – The database session object.

  * **kb** (_KnowledgeBase_) – The KnowledgeBase instance to serialize.

Returns:
    

None

_static _load(_session_ , _project_ , _name_)¶
    

Parameters:
    

**session**

Returns:
    

_class _angr.angrdb.serializers.labels.LabelsSerializer¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Serialize/unserialize labels to/from a database session.

_static _dump(_session_ , _db_kb_ , _labels_)¶
    

Parameters:
    

  * **session**

  * **db_kb** (_DbKnowledgeBase_)

  * **labels** (_Labels_)

Returns:
    

None

_static _load(_session_ , _db_kb_ , _kb_)¶
    

Parameters:
    

  * **session**

  * **db_kb** (_DbKnowledgeBase_)

  * **kb** (_KnowledgeBase_)

Returns:
    

_class _angr.angrdb.serializers.loader.LoadArgsJSONEncoder(_*_ , _skipkeys =False_, _ensure_ascii =True_, _check_circular =True_, _allow_nan =True_, _sort_keys =False_, _indent =None_, _separators =None_, _default =None_)¶
    

Bases: `JSONEncoder`

A JSON encoder that supports serializing bytes.

default(_o_)¶
    

Implement this method in a subclass such that it returns a serializable object for `o`, or calls the base implementation (to raise a `TypeError`).

For example, to support arbitrary iterators, you could implement default like this:
    
    
    def default(self, o):
        try:
            iterable = iter(o)
        except TypeError:
            pass
        else:
            return list(iterable)
        # Let the base class default method raise the TypeError
        return JSONEncoder.default(self, o)
    

_class _angr.angrdb.serializers.loader.LoadArgsJSONDecoder¶
    

Bases: `JSONDecoder`

A JSON decoder that supports unserializing into bytes.

__init__()¶
    

`object_hook`, if specified, will be called with the result of every JSON object decoded and its return value will be used in place of the given `dict`. This can be used to provide custom deserializations (e.g. to support JSON-RPC class hinting).

`object_pairs_hook`, if specified will be called with the result of every JSON object decoded with an ordered list of pairs. The return value of `object_pairs_hook` will be used instead of the `dict`. This feature can be used to implement custom decoders. If `object_hook` is also defined, the `object_pairs_hook` takes priority.

`parse_float`, if specified, will be called with the string of every JSON float to be decoded. By default this is equivalent to float(num_str). This can be used to use another datatype or parser for JSON floats (e.g. decimal.Decimal).

`parse_int`, if specified, will be called with the string of every JSON int to be decoded. By default this is equivalent to int(num_str). This can be used to use another datatype or parser for JSON integers (e.g. float).

`parse_constant`, if specified, will be called with one of the following strings: -Infinity, Infinity, NaN. This can be used to raise an exception if invalid JSON numbers are encountered.

If `strict` is false (true is the default), then control characters will be allowed inside strings. Control characters in this context are those with character codes in the 0-31 range, including `'\t'` (tab), `'\n'`, `'\r'` and `'\0'`.

_class _angr.angrdb.serializers.loader.LoaderSerializer¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Serialize/unserialize a CLE Loader object into/from an angr DB.

Corner cases: \- For certain backends (e.g., CART), we do not store the data of the main object. angr will unpack the CART file

> again after loading the database.

NO_MAINBIN_BACKENDS _ = [<class 'cle.backends.cartfile.CARTFile'>]_¶
    

LOAD_ARG_BLACKLIST _ = {'is_main_bin', 'loader'}_¶
    

backend2name _ = {<class 'cle.backends.blob.Blob'>: 'blob', <class 'cle.backends.cartfile.CARTFile'>: 'cart', <class 'cle.backends.cgc.backedcgc.BackedCGC'>: 'backedcgc', <class 'cle.backends.cgc.cgc.CGC'>: 'cgc', <class 'cle.backends.coff.Coff'>: 'COFF', <class 'cle.backends.elf.elf.ELF'>: 'elf', <class 'cle.backends.elf.elfcore.ELFCore'>: 'elfcore', <class 'cle.backends.ihex.Hex'>: 'hex', <class 'cle.backends.java.apk.Apk'>: 'apk', <class 'cle.backends.java.jar.Jar'>: 'jar', <class 'cle.backends.macho.macho.MachO'>: 'mach-o', <class 'cle.backends.minidump.Minidump'>: 'minidump', <class 'cle.backends.named_region.NamedRegion'>: 'named_region', <class 'cle.backends.pe.pe.PE'>: 'pe', <class 'cle.backends.srec.SRec'>: 'srec', <class 'cle.backends.static_archive.StaticArchive'>: 'AR', <class 'cle.backends.te.TE'>: 'te', <class 'cle.backends.uefi_firmware.UefiFirmware'>: 'uefi', <class 'cle.backends.xbe.XBE'>: 'xbe'}_¶
    

_static _json_serialize_load_args(_load_args_)¶
    

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

Parameters:
    

**load_args** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]_)

_static _should_skip_main_binary(_loader_)¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"), [`Backend`](https://docs.angr.io/projects/cle/en/latest/api/backend.html#cle.backends.backend.Backend "\(in cle\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")]

_static _dump(_session_ , _loader_)¶
    

_static _load(_session_)¶
    

_class _angr.angrdb.serializers.xrefs.XRefsSerializer¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Serialize/unserialize an XRefs object to/from a database session.

_static _dump(_session_ , _db_kb_ , _xrefs_)¶
    

Parameters:
    

  * **session**

  * **db_kb** (_DbKnowledgeBase_)

  * **xrefs** (_XRefManager_)

Returns:
    

_static _load(_session_ , _db_kb_ , _kb_ , _cfg_model =None_)¶
    

Parameters:
    

  * **session**

  * **db_kb** (_DbKnowledgeBase_)

  * **kb** (_KnowledgeBase_)

  * **cfg_model** (_CFGModel_)

Returns:
    

_class _angr.angrdb.serializers.variables.VariableManagerSerializer¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Serialize/unserialize a variable manager and its variables.

_static _dump(_session_ , _db_kb_ , _var_manager_)¶
    

Parameters:
    

  * **db_kb** (_DbKnowledgeBase_)

  * **var_manager** (_VariableManager_)

_static _dump_internal(_session_ , _db_kb_ , _internal_manager_ , _func_addr_ , _ident =None_)¶
    

Parameters:
    

  * **db_kb** (_DbKnowledgeBase_)

  * **internal_manager** (_VariableManagerInternal_)

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_static _load(_session_ , _db_kb_ , _kb_ , _ident =None_)¶
    

Parameters:
    

  * **db_kb** (_DbKnowledgeBase_)

  * **kb** (_KnowledgeBase_)

_static _load_internal(_db_varcoll_ , _variable_manager_)¶
    

Return type:
    

`VariableManagerInternal`

Parameters:
    

**variable_manager** (_VariableManager_)

_class _angr.angrdb.serializers.structured_code.StructuredCodeManagerSerializer¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Serialize/unserialize a structured code manager.

_static _dump(_session_ , _db_kb_ , _code_manager_)¶
    

Parameters:
    

  * **session**

  * **db_kb** (`DbKnowledgeBase`)

  * **code_manager** (`StructuredCodeManager`)

Returns:
    

_static _dict_strkey_to_intkey(_d_)¶
    

Return type:
    

[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]

Parameters:
    

**d** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]_)

_static _load(_session_ , _db_kb_ , _kb_)¶
    

Parameters:
    

  * **session**

  * **db_kb** (`DbKnowledgeBase`)

  * **kb** (`KnowledgeBase`)

Return type:
    

`StructuredCodeManager`

Returns:
    

A loaded structured code manager

_class _angr.analyses.decompiler.structuring.recursive_structurer.RecursiveStructurer(_region_ , _cond_proc =None_, _func =None_, _structurer_cls =None_, _** kwargs_)¶
    

Bases: `Analysis`

Recursively structure a region and all of its subregions.

Parameters:
    

  * **func** (_Function_ _|__None_)

  * **structurer_cls** ([_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _|__None_)

__init__(_region_ , _cond_proc =None_, _func =None_, _structurer_cls =None_, _** kwargs_)¶
    

Parameters:
    

  * **func** (_Function_ _|__None_)

  * **structurer_cls** ([_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _|__None_)

angr.analyses.decompiler.structuring.DEFAULT_STRUCTURER¶
    

alias of `SAILRStructurer`

_class _angr.analyses.decompiler.structuring.DreamStructurer(_region_ , _parent_map =None_, _condition_processor =None_, _func =None_, _case_entry_to_switch_head =None_, _parent_region =None_, _** kwargs_)¶
    

Bases: `StructurerBase`

Structure a region using a structuring algorithm that is similar to the one in Dream decompiler (described in the “no more gotos” paper). Note that this implementation has quite a few improvements over the original described version and _should not_ be used to evaluate the performance of the original algorithm described in that paper.

The current function graph is provided so that we can detect certain edge cases, for example, jump table entries no longer exist due to empty node removal during structuring or prior steps.

Parameters:
    

  * **func** (_Function_ _|__None_)

  * **case_entry_to_switch_head** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

NAME _: str_ _ = 'dream'_¶
    

__init__(_region_ , _parent_map =None_, _condition_processor =None_, _func =None_, _case_entry_to_switch_head =None_, _parent_region =None_, _** kwargs_)¶
    

Parameters:
    

  * **func** (_Function_ _|__None_)

  * **case_entry_to_switch_head** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

_class _angr.analyses.decompiler.structuring.PhoenixStructurer(_region_ , _parent_map =None_, _condition_processor =None_, _func =None_, _case_entry_to_switch_head =None_, _parent_region =None_, _improve_algorithm =False_, _use_multistmtexprs =MultiStmtExprMode.MAX_ONE_CALL_, _multistmtexpr_stmt_threshold =5_, _** kwargs_)¶
    

Bases: `StructurerBase`

Structure a region using a structuring algorithm that is similar to the one in Phoenix decompiler (described in the “phoenix decompiler” paper). Note that this implementation has quite a few improvements over the original described version and _should not_ be used to evaluate the performance of the original algorithm described in that paper.

Parameters:
    

  * **func** (_Function_ _|__None_)

  * **case_entry_to_switch_head** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **use_multistmtexprs** (_MultiStmtExprMode_)

  * **multistmtexpr_stmt_threshold** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

NAME _: str_ _ = 'phoenix'_¶
    

__init__(_region_ , _parent_map =None_, _condition_processor =None_, _func =None_, _case_entry_to_switch_head =None_, _parent_region =None_, _improve_algorithm =False_, _use_multistmtexprs =MultiStmtExprMode.MAX_ONE_CALL_, _multistmtexpr_stmt_threshold =5_, _** kwargs_)¶
    

Parameters:
    

  * **func** (_Function_ _|__None_)

  * **case_entry_to_switch_head** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **use_multistmtexprs** (_MultiStmtExprMode_)

  * **multistmtexpr_stmt_threshold** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

replace_nodes(_graph_ , _old_node_0_ , _new_node_ , _old_node_1 =None_, _self_loop =True_)¶
    

_static _dump_graph(_graph_ , _path_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **graph** (_DiGraph_)

  * **path** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_static _switch_case_entry_node_has_common_successor_case_1(_graph_ , _jump_table_ , _case_nodes_ , _node_pred_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_static _switch_case_entry_node_has_common_successor_case_2(_graph_ , _jump_table_ , _case_nodes_ , _node_pred_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.analyses.decompiler.structuring.RecursiveStructurer(_region_ , _cond_proc =None_, _func =None_, _structurer_cls =None_, _** kwargs_)¶
    

Bases: `Analysis`

Recursively structure a region and all of its subregions.

Parameters:
    

  * **func** (_Function_ _|__None_)

  * **structurer_cls** ([_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _|__None_)

__init__(_region_ , _cond_proc =None_, _func =None_, _structurer_cls =None_, _** kwargs_)¶
    

Parameters:
    

  * **func** (_Function_ _|__None_)

  * **structurer_cls** ([_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _|__None_)

_class _angr.analyses.decompiler.structuring.SAILRStructurer(_region_ , _improve_phoenix =True_, _postdom_max_edges =10_, _postdom_max_graph_size =50_, _** kwargs_)¶
    

Bases: `PhoenixStructurer`

The SAILR structuring algorithm is the phoenix-based algorithm from the USENIX 2024 paper SAILR. The entirety of the algorithm is implemented across this class and various optimization passes in the decompiler. To find each optimization class, simply search for optimizations which reference this class.NAME.

At a high-level, SAILR does three things different from the traditional Phoenix schema-based algorithm: 1\. It recursively structures the graph, rather than doing it in a single pass. This allows decisions to be made

> based on the current state of what the decompilation would look like.

  2. It performs deoptimizations targeting specific optimizations that introduces gotos and mis-structured code.
    

It can only do this because of the recursive nature of the algorithm.

  3. It uses a more advanced heuristic for virtualizing edges, which is implemented in this class.

Additionally, some changes in Phoenix are only activated when SAILR is used.

NAME _: str_ _ = 'sailr'_¶
    

__init__(_region_ , _improve_phoenix =True_, _postdom_max_edges =10_, _postdom_max_graph_size =50_, _** kwargs_)¶
    

angr.analyses.decompiler.structuring.structurer_class_from_name(_name_)¶
    

Return type:
    

[`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.analyses.decompiler.structuring.dream.DreamStructurer(_region_ , _parent_map =None_, _condition_processor =None_, _func =None_, _case_entry_to_switch_head =None_, _parent_region =None_, _** kwargs_)¶
    

Bases: `StructurerBase`

Structure a region using a structuring algorithm that is similar to the one in Dream decompiler (described in the “no more gotos” paper). Note that this implementation has quite a few improvements over the original described version and _should not_ be used to evaluate the performance of the original algorithm described in that paper.

The current function graph is provided so that we can detect certain edge cases, for example, jump table entries no longer exist due to empty node removal during structuring or prior steps.

Parameters:
    

  * **func** (_Function_ _|__None_)

  * **case_entry_to_switch_head** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

NAME _: str_ _ = 'dream'_¶
    

__init__(_region_ , _parent_map =None_, _condition_processor =None_, _func =None_, _case_entry_to_switch_head =None_, _parent_region =None_, _** kwargs_)¶
    

Parameters:
    

  * **func** (_Function_ _|__None_)

  * **case_entry_to_switch_head** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

project _: Project_¶
    

kb _: KnowledgeBase_¶
    

_exception _angr.analyses.decompiler.structuring.structurer_nodes.EmptyBlockNotice¶
    

Bases: [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception "\(in Python v3.13\)")

_class _angr.analyses.decompiler.structuring.structurer_nodes.MultiNode(_nodes_ , _addr =None_, _idx =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_nodes_ , _addr =None_, _idx =None_)¶
    

nodes¶
    

addr¶
    

idx¶
    

copy()¶
    

dbg_repr(_indent =0_)¶
    

_class _angr.analyses.decompiler.structuring.structurer_nodes.BaseNode¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

_static _test_empty_node(_node_)¶
    

_static _test_empty_condition_node(_cond_node_)¶
    

addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

dbg_repr(_indent =0_)¶
    

_class _angr.analyses.decompiler.structuring.structurer_nodes.SequenceNode(_addr_ , _nodes =None_)¶
    

Bases: `BaseNode`

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_addr_ , _nodes =None_)¶
    

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

nodes¶
    

add_node(_node_)¶
    

insert_node(_pos_ , _node_)¶
    

remove_node(_node_)¶
    

node_position(_node_)¶
    

copy()¶
    

dbg_repr(_indent =0_)¶
    

_class _angr.analyses.decompiler.structuring.structurer_nodes.CodeNode(_node_ , _reaching_condition_)¶
    

Bases: `BaseNode`

__init__(_node_ , _reaching_condition_)¶
    

node¶
    

reaching_condition¶
    

_property _addr¶
    

_property _idx¶
    

dbg_repr(_indent =0_)¶
    

copy()¶
    

_class _angr.analyses.decompiler.structuring.structurer_nodes.ConditionNode(_addr_ , _reaching_condition_ , _condition_ , _true_node_ , _false_node =None_)¶
    

Bases: `BaseNode`

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_addr_ , _reaching_condition_ , _condition_ , _true_node_ , _false_node =None_)¶
    

addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

reaching_condition¶
    

condition¶
    

true_node¶
    

false_node¶
    

dbg_repr(_indent =0_)¶
    

node¶
    

_class _angr.analyses.decompiler.structuring.structurer_nodes.CascadingConditionNode(_addr_ , _condition_and_nodes_ , _else_node =None_)¶
    

Bases: `BaseNode`

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **condition_and_nodes** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__Any_ _,__BaseNode_ _|__ailment.Block_ _|__MultiNode_ _]__]_)

  * **else_node** (_BaseNode_ _|__None_)

__init__(_addr_ , _condition_and_nodes_ , _else_node =None_)¶
    

Parameters:
    

  * **condition_and_nodes** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _,__BaseNode_ _|__Block_ _|__MultiNode_ _]__]_)

  * **else_node** (_BaseNode_ _|__None_)

addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

condition_and_nodes¶
    

else_node¶
    

_class _angr.analyses.decompiler.structuring.structurer_nodes.LoopNode(_sort_ , _condition_ , _sequence_node_ , _addr =None_, _continue_addr =None_, _initializer =None_, _iterator =None_)¶
    

Bases: `BaseNode`

Parameters:
    

  * **sort** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **condition** (_ailment.Expr.Expression_ _|__None_)

  * **sequence_node** (_SequenceNode_)

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **continue_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **initializer** (_ailment.Stmt.Assignment_ _|__None_)

  * **iterator** (_ailment.Stmt.Assignment_ _|__None_)

__init__(_sort_ , _condition_ , _sequence_node_ , _addr =None_, _continue_addr =None_, _initializer =None_, _iterator =None_)¶
    

Parameters:
    

  * **sort** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **condition** (_Expression_ _|__None_)

  * **sequence_node** (_SequenceNode_)

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **continue_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **initializer** (_Assignment_ _|__None_)

  * **iterator** (_Assignment_ _|__None_)

sort _: [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")_¶
    

condition _: `Expression` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

sequence_node _: `SequenceNode`_¶
    

initializer _: `Assignment` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

iterator _: `Assignment` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

copy()¶
    

_property _addr¶
    

_property _continue_addr¶
    

dbg_repr(_indent =0_)¶
    

_class _angr.analyses.decompiler.structuring.structurer_nodes.BreakNode(_addr_ , _target_)¶
    

Bases: `BaseNode`

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_addr_ , _target_)¶
    

addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

target¶
    

dbg_repr(_indent =0_)¶
    

_class _angr.analyses.decompiler.structuring.structurer_nodes.ContinueNode(_addr_ , _target_)¶
    

Bases: `BaseNode`

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_addr_ , _target_)¶
    

addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

target¶
    

dbg_repr(_indent =0_)¶
    

_class _angr.analyses.decompiler.structuring.structurer_nodes.ConditionalBreakNode(_addr_ , _condition_ , _target_)¶
    

Bases: `BreakNode`

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_addr_ , _condition_ , _target_)¶
    

condition¶
    

dbg_repr(_indent =0_)¶
    

_class _angr.analyses.decompiler.structuring.structurer_nodes.SwitchCaseNode(_switch_expr_ , _cases_ , _default_node_ , _addr =None_)¶
    

Bases: `BaseNode`

Parameters:
    

  * **cases** (_OrderedDict_ _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__...__]__,__SequenceNode_ _]_)

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_switch_expr_ , _cases_ , _default_node_ , _addr =None_)¶
    

Parameters:
    

**cases** ([_OrderedDict_](https://docs.python.org/3/library/collections.html#collections.OrderedDict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__...__]__,__SequenceNode_ _]_)

switch_expr¶
    

cases _: [`OrderedDict`](https://docs.python.org/3/library/collections.html#collections.OrderedDict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`...`](https://docs.python.org/3/library/constants.html#Ellipsis "\(in Python v3.13\)")], `SequenceNode`]_¶
    

default_node¶
    

addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

dbg_repr(_indent =0_)¶
    

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

_class _angr.analyses.decompiler.structuring.structurer_nodes.IncompleteSwitchCaseNode(_addr_ , _head_ , _cases_)¶
    

Bases: `BaseNode`

Describes an incomplete set of switch-case nodes. Usually an intermediate result. Should always be restructured into a SwitchCaseNode by the end of structuring. Only used in Phoenix structurer.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **cases** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)"))

__init__(_addr_ , _head_ , _cases_)¶
    

Parameters:
    

**cases** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)"))

addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

head¶
    

cases _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")_¶
    

_class _angr.analyses.decompiler.structuring.structurer_nodes.IncompleteSwitchCaseHeadStatement(_* args_, _** kwargs_)¶
    

Bases: `Statement`

Describes a switch-case head. This is only created by LoweredSwitchSimplifier.

__init__(_idx_ , _switch_variable_ , _case_addrs_ , _** kwargs_)¶
    

switch_variable¶
    

case_addrs _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`Block`, [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"), [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)"), [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]]_¶
    

replace(_old_expr_ , _new_expr_)¶
    

likes(_other_)¶
    

addr¶
    

matches(_other_)¶
    

_class _angr.analyses.decompiler.structuring.structurer_base.StructurerBase(_region_ , _parent_map =None_, _condition_processor =None_, _func =None_, _case_entry_to_switch_head =None_, _parent_region =None_, _jump_tables =None_, _** kwargs_)¶
    

Bases: `Analysis`

The base class for analysis passes that structures a region.

The current function graph is provided so that we can detect certain edge cases, for example, jump table entries no longer exist due to empty node removal during structuring or prior steps.

Parameters:
    

  * **func** (_Function_ _|__None_)

  * **case_entry_to_switch_head** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **jump_tables** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__IndirectJump_ _]__|__None_)

NAME _: str_ _ = 'StructurerBase'_¶
    

__init__(_region_ , _parent_map =None_, _condition_processor =None_, _func =None_, _case_entry_to_switch_head =None_, _parent_region =None_, _jump_tables =None_, _** kwargs_)¶
    

Parameters:
    

  * **func** (_Function_ _|__None_)

  * **case_entry_to_switch_head** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **jump_tables** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__IndirectJump_ _]__|__None_)

replace_nodes(_graph_ , _old_node_0_ , _new_node_ , _old_node_1 =None_, _self_loop =True_)¶
    

_static _replace_node_in_node(_parent_node_ , _old_node_ , _new_node_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **parent_node** (_BaseNode_)

  * **old_node** (_BaseNode_ _|__Block_ _|__MultiNode_)

  * **new_node** (_BaseNode_ _|__Block_ _|__MultiNode_)

_static _is_a_jump_target(_stmt_ , _addr_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

  * **stmt** (_ConditionalJump_ _|__Jump_ _|__Statement_)

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_static _has_nonlabel_nonphi_statements(_node_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**node** (_BaseNode_)

_exception _angr.analyses.decompiler.structuring.phoenix.GraphChangedNotification¶
    

Bases: [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception "\(in Python v3.13\)")

A notification for graph that is currently worked on being changed. Once this notification is caught, the graph schema matching process for the current region restarts.

_class _angr.analyses.decompiler.structuring.phoenix.MultiStmtExprMode(_value_)¶
    

Bases: [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"), [`Enum`](https://docs.python.org/3/library/enum.html#enum.Enum "\(in Python v3.13\)")

Mode of multi-statement expression creation during structuring.

NEVER _ = 'Never'_¶
    

ALWAYS _ = 'Always'_¶
    

MAX_ONE_CALL _ = 'Only when less than one call'_¶
    

_class _angr.analyses.decompiler.structuring.phoenix.PhoenixStructurer(_region_ , _parent_map =None_, _condition_processor =None_, _func =None_, _case_entry_to_switch_head =None_, _parent_region =None_, _improve_algorithm =False_, _use_multistmtexprs =MultiStmtExprMode.MAX_ONE_CALL_, _multistmtexpr_stmt_threshold =5_, _** kwargs_)¶
    

Bases: `StructurerBase`

Structure a region using a structuring algorithm that is similar to the one in Phoenix decompiler (described in the “phoenix decompiler” paper). Note that this implementation has quite a few improvements over the original described version and _should not_ be used to evaluate the performance of the original algorithm described in that paper.

Parameters:
    

  * **func** (_Function_ _|__None_)

  * **case_entry_to_switch_head** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **use_multistmtexprs** (_MultiStmtExprMode_)

  * **multistmtexpr_stmt_threshold** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

NAME _: str_ _ = 'phoenix'_¶
    

__init__(_region_ , _parent_map =None_, _condition_processor =None_, _func =None_, _case_entry_to_switch_head =None_, _parent_region =None_, _improve_algorithm =False_, _use_multistmtexprs =MultiStmtExprMode.MAX_ONE_CALL_, _multistmtexpr_stmt_threshold =5_, _** kwargs_)¶
    

Parameters:
    

  * **func** (_Function_ _|__None_)

  * **case_entry_to_switch_head** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **use_multistmtexprs** (_MultiStmtExprMode_)

  * **multistmtexpr_stmt_threshold** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

whitelist_edges _: set[tuple[int, int]]_¶
    

switch_case_known_heads _: set[Block]_¶
    

dowhile_known_tail_nodes _: set_¶
    

replace_nodes(_graph_ , _old_node_0_ , _new_node_ , _old_node_1 =None_, _self_loop =True_)¶
    

_static _dump_graph(_graph_ , _path_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **graph** (_DiGraph_)

  * **path** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_static _switch_case_entry_node_has_common_successor_case_1(_graph_ , _jump_table_ , _case_nodes_ , _node_pred_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_static _switch_case_entry_node_has_common_successor_case_2(_graph_ , _jump_table_ , _case_nodes_ , _node_pred_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

project _: Project_¶
    

kb _: KnowledgeBase_¶
    

_class _angr.analyses.decompiler.AILSimplifier(_func_ , _func_graph =None_, _remove_dead_memdefs =False_, _stack_arg_offsets =None_, _unify_variables =False_, _ail_manager =None_, _gp =None_, _narrow_expressions =False_, _only_consts =False_, _fold_callexprs_into_conditions =False_, _use_callee_saved_regs_at_return =True_, _rewrite_ccalls =True_, _removed_vvar_ids =None_, _arg_vvars =None_, _avoid_vvar_ids =None_, _secondary_stackvars =None_)¶
    

Bases: `Analysis`

Perform function-level simplifications.

Parameters:
    

  * **stack_arg_offsets** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__]__|__None_)

  * **ail_manager** (_Manager_ _|__None_)

  * **gp** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **removed_vvar_ids** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **arg_vvars** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__VirtualVariable_ _,__SimVariable_ _]__]__|__None_)

  * **avoid_vvar_ids** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **secondary_stackvars** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

__init__(_func_ , _func_graph =None_, _remove_dead_memdefs =False_, _stack_arg_offsets =None_, _unify_variables =False_, _ail_manager =None_, _gp =None_, _narrow_expressions =False_, _only_consts =False_, _fold_callexprs_into_conditions =False_, _use_callee_saved_regs_at_return =True_, _rewrite_ccalls =True_, _removed_vvar_ids =None_, _arg_vvars =None_, _avoid_vvar_ids =None_, _secondary_stackvars =None_)¶
    

Parameters:
    

  * **stack_arg_offsets** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__]__|__None_)

  * **ail_manager** (_Manager_ _|__None_)

  * **gp** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **removed_vvar_ids** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **arg_vvars** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__VirtualVariable_ _,__SimVariable_ _]__]__|__None_)

  * **avoid_vvar_ids** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **secondary_stackvars** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

_class _angr.analyses.decompiler.BlockSimplifier(_block_ , _func_addr =None_, _stack_pointer_tracker =None_, _peephole_optimizations =None_, _preserve_vvar_ids =None_, _type_hints =None_, _cached_reaching_definitions =None_, _cached_propagator =None_)¶
    

Bases: `Analysis`

Simplify an AIL block.

Parameters:
    

  * **block** (_Block_ _|__None_)

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **peephole_optimizations** (_None_ _|__Iterable_ _[_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__PeepholeOptimizationStmtBase_ _]__|_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__PeepholeOptimizationExprBase_ _]__]_)

  * **preserve_vvar_ids** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **type_hints** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__atoms.VirtualVariable_ _|__atoms.MemoryLocation_ _,_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__]__|__None_)

__init__(_block_ , _func_addr =None_, _stack_pointer_tracker =None_, _peephole_optimizations =None_, _preserve_vvar_ids =None_, _type_hints =None_, _cached_reaching_definitions =None_, _cached_propagator =None_)¶
    

Parameters:
    

  * **block** (`Block` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")) – The AIL block to simplify. Setting it to None to skip calling self._analyze(), which is useful in test cases.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **peephole_optimizations** (_None_ _|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__PeepholeOptimizationStmtBase_ _]__|_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__PeepholeOptimizationExprBase_ _]__]_)

  * **preserve_vvar_ids** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **type_hints** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__VirtualVariable_ _|__MemoryLocation_ _,_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__]__|__None_)

_class _angr.analyses.decompiler.CStructuredCodeGenerator(_func_ , _sequence_ , _indent =0_, _cfg =None_, _variable_kb =None_, _func_args =None_, _binop_depth_cutoff =16_, _show_casts =True_, _braces_on_own_lines =True_, _use_compound_assignments =True_, _show_local_types =True_, _comment_gotos =False_, _cstyle_null_cmp =True_, _flavor =None_, _stmt_comments =None_, _expr_comments =None_, _show_externs =True_, _externs =None_, _const_formats =None_, _show_demangled_name =True_, _show_disambiguated_name =True_, _ail_graph =None_, _simplify_else_scope =True_, _cstyle_ifs =True_, _omit_func_header =False_, _display_block_addrs =False_, _display_vvar_ids =False_, _min_data_addr =4194304_)¶
    

Bases: `BaseStructuredCodeGenerator`, `Analysis`

Parameters:
    

  * **func_args** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__SimVariable_ _]__|__None_)

  * **binop_depth_cutoff** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **min_data_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_func_ , _sequence_ , _indent =0_, _cfg =None_, _variable_kb =None_, _func_args =None_, _binop_depth_cutoff =16_, _show_casts =True_, _braces_on_own_lines =True_, _use_compound_assignments =True_, _show_local_types =True_, _comment_gotos =False_, _cstyle_null_cmp =True_, _flavor =None_, _stmt_comments =None_, _expr_comments =None_, _show_externs =True_, _externs =None_, _const_formats =None_, _show_demangled_name =True_, _show_disambiguated_name =True_, _ail_graph =None_, _simplify_else_scope =True_, _cstyle_ifs =True_, _omit_func_header =False_, _display_block_addrs =False_, _display_vvar_ids =False_, _min_data_addr =4194304_)¶
    

Parameters:
    

  * **func_args** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__SimVariable_ _]__|__None_)

  * **binop_depth_cutoff** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **min_data_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

reapply_options(_options_)¶
    

cleanup()¶
    

Remove existing rendering results.

regenerate_text()¶
    

Re-render text and re-generate all sorts of mapping information.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

RENDER_TYPE¶
    

alias of [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"), `PositionMapping`, `PositionMapping`, `InstructionMapping`, [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"), [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]]

render_text(_cfunc_)¶
    

Return type:
    

RENDER_TYPE

Parameters:
    

**cfunc** (_CFunction_)

reload_variable_types()¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

default_simtype_from_bits(_n_ , _signed =True_)¶
    

Return type:
    

`SimType`

Parameters:
    

  * **n** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **signed** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

_class _angr.analyses.decompiler.CallSiteMaker(_block_ , _reaching_definitions =None_, _stack_pointer_tracker =None_, _ail_manager =None_)¶
    

Bases: `Analysis`

Add calling convention, declaration, and args to a call site.

Parameters:
    

**ail_manager** (_Manager_ _|__None_)

__init__(_block_ , _reaching_definitions =None_, _stack_pointer_tracker =None_, _ail_manager =None_)¶
    

Parameters:
    

**ail_manager** (_Manager_ _|__None_)

_class _angr.analyses.decompiler.Clinic(_func_ , _remove_dead_memdefs =False_, _exception_edges =False_, _sp_tracker_track_memory =True_, _fold_callexprs_into_conditions =False_, _insert_labels =True_, _optimization_passes =None_, _cfg =None_, _peephole_optimizations =None_, _must_struct =None_, _variable_kb =None_, _reset_variable_names =False_, _rewrite_ites_to_diamonds =True_, _cache =None_, _mode =ClinicMode.DECOMPILE_, _sp_shift =0_, _inline_functions =None_, _inlined_counts =None_, _inlining_parents =None_, _vvar_id_start =0_, _optimization_scratch =None_, _desired_variables =None_, _force_loop_single_exit =True_, _complete_successors =False_, _max_type_constraints =100000_, _type_constraint_set_degradation_threshold =150_, _ail_graph =None_, _arg_vvars =None_, _start_stage =ClinicStage.INITIALIZATION_)¶
    

Bases: `Analysis`

A Clinic deals with AILments.

Parameters:
    

  * **peephole_optimizations** (_None_ _|__Iterable_ _[_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__PeepholeOptimizationStmtBase_ _]__|_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__PeepholeOptimizationExprBase_ _]__]_)

  * **must_struct** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **cache** (_DecompilationCache_ _|__None_)

  * **mode** (_ClinicMode_)

  * **sp_shift** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **inline_functions** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Function_ _]__|__None_)

  * **inlined_counts** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **inlining_parents** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **vvar_id_start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **optimization_scratch** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__Any_ _]__|__None_)

  * **desired_variables** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **force_loop_single_exit** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **complete_successors** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **max_type_constraints** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **type_constraint_set_degradation_threshold** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **ail_graph** (_networkx.DiGraph_ _|__None_)

  * **arg_vvars** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__ailment.Expr.VirtualVariable_ _,__SimVariable_ _]__]__|__None_)

  * **start_stage** (_ClinicStage_ _|__None_)

__init__(_func_ , _remove_dead_memdefs =False_, _exception_edges =False_, _sp_tracker_track_memory =True_, _fold_callexprs_into_conditions =False_, _insert_labels =True_, _optimization_passes =None_, _cfg =None_, _peephole_optimizations =None_, _must_struct =None_, _variable_kb =None_, _reset_variable_names =False_, _rewrite_ites_to_diamonds =True_, _cache =None_, _mode =ClinicMode.DECOMPILE_, _sp_shift =0_, _inline_functions =None_, _inlined_counts =None_, _inlining_parents =None_, _vvar_id_start =0_, _optimization_scratch =None_, _desired_variables =None_, _force_loop_single_exit =True_, _complete_successors =False_, _max_type_constraints =100000_, _type_constraint_set_degradation_threshold =150_, _ail_graph =None_, _arg_vvars =None_, _start_stage =ClinicStage.INITIALIZATION_)¶
    

Parameters:
    

  * **peephole_optimizations** (_None_ _|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__PeepholeOptimizationStmtBase_ _]__|_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__PeepholeOptimizationExprBase_ _]__]_)

  * **must_struct** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **cache** (_DecompilationCache_ _|__None_)

  * **mode** (_ClinicMode_)

  * **sp_shift** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **inline_functions** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Function_ _]__|__None_)

  * **inlined_counts** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **inlining_parents** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **vvar_id_start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **optimization_scratch** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]__|__None_)

  * **desired_variables** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **force_loop_single_exit** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **complete_successors** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **max_type_constraints** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **type_constraint_set_degradation_threshold** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **ail_graph** (_DiGraph_ _|__None_)

  * **arg_vvars** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__VirtualVariable_ _,__SimVariable_ _]__]__|__None_)

  * **start_stage** (_ClinicStage_ _|__None_)

block(_addr_ , _size_)¶
    

Get the converted block at the given specific address with the given size.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

Returns:
    

dbg_repr()¶
    

Returns:
    

calculate_stack_depth()¶
    

copy_graph(_graph =None_)¶
    

Return type:
    

`DiGraph`

parse_variable_addr(_addr_)¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]

Parameters:
    

**addr** (_Expression_)

new_block_addr()¶
    

Return a block address that does not conflict with any existing blocks.

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

Returns:
    

The block address.

_static _remove_empty_nodes(_graph_)¶
    

Return type:
    

`DiGraph`

Parameters:
    

**graph** (_DiGraph_)

_class _angr.analyses.decompiler.Decompiler(_func_ , _cfg =None_, _options =None_, _preset =None_, _optimization_passes =None_, _sp_tracker_track_memory =True_, _variable_kb =None_, _peephole_optimizations =None_, _vars_must_struct =None_, _flavor ='pseudocode'_, _expr_comments =None_, _stmt_comments =None_, _ite_exprs =None_, _binop_operators =None_, _decompile =True_, _regen_clinic =True_, _inline_functions =frozenset({})_, _desired_variables =frozenset({})_, _update_memory_data =True_, _generate_code =True_, _use_cache =True_, _expr_collapse_depth =16_, _clinic_graph =None_, _clinic_arg_vvars =None_, _clinic_start_stage =None_)¶
    

Bases: `Analysis`

The decompiler analysis.

Run this on a Function object for which a normalized CFG has been constructed. The fully processed output can be found in result.codegen.text

Parameters:
    

  * **func** (_Function_ _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **cfg** (_CFGFast_ _|__CFGModel_ _|__None_)

  * **preset** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__DecompilationPreset_ _|__None_)

  * **peephole_optimizations** (__PEEPHOLE_OPTIMIZATIONS_TYPE_)

  * **vars_must_struct** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **update_memory_data** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **generate_code** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **use_cache** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **expr_collapse_depth** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_func_ , _cfg =None_, _options =None_, _preset =None_, _optimization_passes =None_, _sp_tracker_track_memory =True_, _variable_kb =None_, _peephole_optimizations =None_, _vars_must_struct =None_, _flavor ='pseudocode'_, _expr_comments =None_, _stmt_comments =None_, _ite_exprs =None_, _binop_operators =None_, _decompile =True_, _regen_clinic =True_, _inline_functions =frozenset({})_, _desired_variables =frozenset({})_, _update_memory_data =True_, _generate_code =True_, _use_cache =True_, _expr_collapse_depth =16_, _clinic_graph =None_, _clinic_arg_vvars =None_, _clinic_start_stage =None_)¶
    

Parameters:
    

  * **func** (_Function_ _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **cfg** (_CFGFast_ _|__CFGModel_ _|__None_)

  * **preset** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__DecompilationPreset_ _|__None_)

  * **peephole_optimizations** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__PeepholeOptimizationStmtBase_ _]__|_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__PeepholeOptimizationExprBase_ _]__]__|__None_)

  * **vars_must_struct** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **update_memory_data** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **generate_code** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **use_cache** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **expr_collapse_depth** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

reflow_variable_types(_type_constraints_ , _func_typevar_ , _var_to_typevar_ , _codegen_)¶
    

Re-run type inference on an existing variable recovery result, then rerun codegen to generate new results.

Returns:
    

Parameters:
    

  * **type_constraints** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__TypeVariable_ _,_[_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__TypeConstraint_ _]__]_)

  * **var_to_typevar** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)"))

find_data_references_and_update_memory_data(_seq_node_)¶
    

Parameters:
    

**seq_node** (_SequenceNode_)

transform_graph_from_ssa(_ail_graph_)¶
    

Translate an SSA AIL graph out of SSA form. This is useful for producing a non-SSA AIL graph for displaying in angr management.

Parameters:
    

**ail_graph** (`DiGraph`) – The AIL graph to transform out of SSA form.

Return type:
    

`DiGraph`

Returns:
    

The translated AIL graph.

transform_seqnode_from_ssa(_seq_node_)¶
    

Return type:
    

`SequenceNode`

Parameters:
    

**seq_node** (_SequenceNode_)

_static _options_to_params(_options_)¶
    

Convert decompilation options to a dict of params.

Parameters:
    

**options** ([`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`DecompilationOption`, [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – The decompilation options.

Return type:
    

[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]

Returns:
    

A dict of keyword arguments.

_class _angr.analyses.decompiler.GraphDephication(_func_ , _ail_graph_ , _vvar_to_vvar_mapping =None_, _rewrite =False_, _variable_kb =None_)¶
    

Bases: `DephicationBase`

GraphDephication removes phi expressions from an AIL graph, essentially transforms a partial-SSA form of AIL graph to a normal AIL graph.

Parameters:
    

  * **func** (_Function_ _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **vvar_to_vvar_mapping** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **rewrite** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **variable_kb** (_KnowledgeBase_ _|__None_)

__init__(_func_ , _ail_graph_ , _vvar_to_vvar_mapping =None_, _rewrite =False_, _variable_kb =None_)¶
    

Parameters:
    

  * **func** (`Function` | [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The subject of the analysis: a function, or a single basic block

  * **ail_graph** – The AIL graph to transform.

  * **vvar_to_vvar_mapping** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **rewrite** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **variable_kb** (_KnowledgeBase_ _|__None_)

_class _angr.analyses.decompiler.ImportSourceCode(_function_ , _flavor ='source'_, _source_root =None_, _encoding ='utf-8'_)¶
    

Bases: `BaseStructuredCodeGenerator`, `Analysis`

__init__(_function_ , _flavor ='source'_, _source_root =None_, _encoding ='utf-8'_)¶
    

regenerate_text()¶
    

_class _angr.analyses.decompiler.RegionIdentifier(_func_ , _cond_proc =None_, _graph =None_, _update_graph =True_, _largest_successor_tree_outside_loop =True_, _force_loop_single_exit =True_, _complete_successors =False_, _entry_node_addr =None_)¶
    

Bases: `Analysis`

Identifies regions within a function graph and creates a recursive GraphRegion object. Note, that the analysis may modify the graph in-place. If you want to keep the original graph, set the update_graph parameter to False.

Parameters:
    

**entry_node_addr** ([_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_ _]__|__None_)

__init__(_func_ , _cond_proc =None_, _graph =None_, _update_graph =True_, _largest_successor_tree_outside_loop =True_, _force_loop_single_exit =True_, _complete_successors =False_, _entry_node_addr =None_)¶
    

Parameters:
    

**entry_node_addr** ([_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_ _]__|__None_)

_static _slice_graph(_graph_ , _node_ , _frontier_ , _include_frontier =False_)¶
    

Generate a slice of the graph from the head node to the given frontier.

Parameters:
    

  * **graph** (_networkx.DiGraph_) – The graph to work on.

  * **node** – The starting node in the graph.

  * **frontier** – A list of frontier nodes.

  * **include_frontier** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether the frontier nodes are included in the slice or not.

Returns:
    

A subgraph.

Return type:
    

networkx.DiGraph

test_reducibility()¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.analyses.decompiler.RegionSimplifier(_func_ , _region_ , _arg_vvars =None_, _simplify_switches =True_, _simplify_ifelse =True_)¶
    

Bases: `Analysis`

Simplifies a given region.

Parameters:
    

  * **arg_vvars** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **simplify_switches** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **simplify_ifelse** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_func_ , _region_ , _arg_vvars =None_, _simplify_switches =True_, _simplify_ifelse =True_)¶
    

Parameters:
    

  * **arg_vvars** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **simplify_switches** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **simplify_ifelse** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

_class _angr.analyses.decompiler.SeqNodeDephication(_func_ , _seq_node_ , _vvar_to_vvar_mapping =None_, _rewrite =False_, _variable_kb =None_)¶
    

Bases: `DephicationBase`

SeqNodeDephication removes phi expressions from a SequenceNode and its children. It also removes redundant variable assignments, e.g., vvar_2 = vvar_1 where both vvar_1 and vvar_2 are mapped to the same variable.

Parameters:
    

  * **func** (_Function_ _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **vvar_to_vvar_mapping** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **rewrite** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **variable_kb** (_KnowledgeBase_ _|__None_)

__init__(_func_ , _seq_node_ , _vvar_to_vvar_mapping =None_, _rewrite =False_, _variable_kb =None_)¶
    

Parameters:
    

  * **func** (_Function_ _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **vvar_to_vvar_mapping** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **rewrite** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **variable_kb** (_KnowledgeBase_ _|__None_)

_class _angr.analyses.decompiler.Ssailification(_func_ , _ail_graph_ , _entry =None_, _canonical_size =8_, _stack_pointer_tracker =None_, _func_addr =None_, _ail_manager =None_, _ssa_stackvars =False_, _ssa_tmps =False_, _func_args =None_, _vvar_id_start =0_)¶
    

Bases: `Analysis`

Ssailification (SSA-AIL-ification) transforms an AIL graph to its partial-SSA form.

Parameters:
    

  * **func** (_Function_ _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **ssa_stackvars** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **ssa_tmps** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **func_args** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__VirtualVariable_ _]__|__None_)

  * **vvar_id_start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_func_ , _ail_graph_ , _entry =None_, _canonical_size =8_, _stack_pointer_tracker =None_, _func_addr =None_, _ail_manager =None_, _ssa_stackvars =False_, _ssa_tmps =False_, _func_args =None_, _vvar_id_start =0_)¶
    

Parameters:
    

  * **func** (`Function` | [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The subject of the analysis: a function, or a single basic block

  * **ail_graph** – The AIL graph to transform.

  * **canonical_size** – The sizes (in bytes) that objects with an UNKNOWN_SIZE are treated as for operations where sizes are necessary.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **ssa_stackvars** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **ssa_tmps** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **func_args** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__VirtualVariable_ _]__|__None_)

  * **vvar_id_start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

angr.analyses.decompiler.StructuredCodeGenerator¶
    

alias of `CStructuredCodeGenerator`

_exception _angr.analyses.decompiler.ail_simplifier.HasCallNotification¶
    

Bases: [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception "\(in Python v3.13\)")

Notifies the existence of a call statement.

_exception _angr.analyses.decompiler.ail_simplifier.HasVVarNotification¶
    

Bases: [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception "\(in Python v3.13\)")

Notifies the existence of a VirtualVariable.

_exception _angr.analyses.decompiler.ail_simplifier.HasRefVVarNotification¶
    

Bases: [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception "\(in Python v3.13\)")

Notifies the existence of a reference to a VirtualVariable.

_class _angr.analyses.decompiler.ail_simplifier.AILBlockTempCollector(_** kwargs_)¶
    

Bases: `AILBlockWalker`

Collects any temporaries used in a block.

__init__(_** kwargs_)¶
    

_class _angr.analyses.decompiler.ail_simplifier.DefEqRelation(_value_)¶
    

Bases: [`Enum`](https://docs.python.org/3/library/enum.html#enum.Enum "\(in Python v3.13\)")

Describes the location relationship between a virtual variable definition and the equivalence statement.

UNKNOWN _ = 0_¶
    

DEF_IS_FUNCARG _ = 1_¶
    

DEF_EQ_SAME_BLOCK _ = 2_¶
    

DEF_IN_EQ_PRED_BLOCK _ = 3_¶
    

_class _angr.analyses.decompiler.ail_simplifier.PartialConstantExprRewriter(_varid_ , _zero_high_bits_)¶
    

Bases: `AILBlockWalker`

Rewrites expressions whose high bits are definitely zero to constants (if possible) or mask them with masks properly.

Parameters:
    

  * **varid** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **zero_high_bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_varid_ , _zero_high_bits_)¶
    

Parameters:
    

  * **varid** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **zero_high_bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_class _angr.analyses.decompiler.ail_simplifier.AILSimplifier(_func_ , _func_graph =None_, _remove_dead_memdefs =False_, _stack_arg_offsets =None_, _unify_variables =False_, _ail_manager =None_, _gp =None_, _narrow_expressions =False_, _only_consts =False_, _fold_callexprs_into_conditions =False_, _use_callee_saved_regs_at_return =True_, _rewrite_ccalls =True_, _removed_vvar_ids =None_, _arg_vvars =None_, _avoid_vvar_ids =None_, _secondary_stackvars =None_)¶
    

Bases: `Analysis`

Perform function-level simplifications.

Parameters:
    

  * **stack_arg_offsets** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__]__|__None_)

  * **ail_manager** (_Manager_ _|__None_)

  * **gp** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **removed_vvar_ids** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **arg_vvars** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__VirtualVariable_ _,__SimVariable_ _]__]__|__None_)

  * **avoid_vvar_ids** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **secondary_stackvars** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

__init__(_func_ , _func_graph =None_, _remove_dead_memdefs =False_, _stack_arg_offsets =None_, _unify_variables =False_, _ail_manager =None_, _gp =None_, _narrow_expressions =False_, _only_consts =False_, _fold_callexprs_into_conditions =False_, _use_callee_saved_regs_at_return =True_, _rewrite_ccalls =True_, _removed_vvar_ids =None_, _arg_vvars =None_, _avoid_vvar_ids =None_, _secondary_stackvars =None_)¶
    

Parameters:
    

  * **stack_arg_offsets** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__]__|__None_)

  * **ail_manager** (_Manager_ _|__None_)

  * **gp** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **removed_vvar_ids** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **arg_vvars** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__VirtualVariable_ _,__SimVariable_ _]__]__|__None_)

  * **avoid_vvar_ids** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **secondary_stackvars** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

_exception _angr.analyses.decompiler.ailgraph_walker.RemoveNodeNotice¶
    

Bases: [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception "\(in Python v3.13\)")

_class _angr.analyses.decompiler.ailgraph_walker.AILGraphWalker(_graph_ , _handler_ , _replace_nodes =False_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Walks an AIL graph and optionally replaces each node with a new node.

Parameters:
    

**replace_nodes** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_graph_ , _handler_ , _replace_nodes =False_)¶
    

Parameters:
    

**replace_nodes** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

walk()¶
    

_class _angr.analyses.decompiler.block_simplifier.HasCallExprWalker¶
    

Bases: `AILBlockWalkerBase`

Test if an expression contains a call expression inside.

__init__()¶
    

_class _angr.analyses.decompiler.block_simplifier.BlockSimplifier(_block_ , _func_addr =None_, _stack_pointer_tracker =None_, _peephole_optimizations =None_, _preserve_vvar_ids =None_, _type_hints =None_, _cached_reaching_definitions =None_, _cached_propagator =None_)¶
    

Bases: `Analysis`

Simplify an AIL block.

Parameters:
    

  * **block** (_Block_ _|__None_)

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **peephole_optimizations** (_None_ _|__Iterable_ _[_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__PeepholeOptimizationStmtBase_ _]__|_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__PeepholeOptimizationExprBase_ _]__]_)

  * **preserve_vvar_ids** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **type_hints** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__atoms.VirtualVariable_ _|__atoms.MemoryLocation_ _,_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__]__|__None_)

__init__(_block_ , _func_addr =None_, _stack_pointer_tracker =None_, _peephole_optimizations =None_, _preserve_vvar_ids =None_, _type_hints =None_, _cached_reaching_definitions =None_, _cached_propagator =None_)¶
    

Parameters:
    

  * **block** (`Block` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")) – The AIL block to simplify. Setting it to None to skip calling self._analyze(), which is useful in test cases.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **peephole_optimizations** (_None_ _|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__PeepholeOptimizationStmtBase_ _]__|_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__PeepholeOptimizationExprBase_ _]__]_)

  * **preserve_vvar_ids** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **type_hints** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__VirtualVariable_ _|__MemoryLocation_ _,_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__]__|__None_)

_class _angr.analyses.decompiler.callsite_maker.CallSiteMaker(_block_ , _reaching_definitions =None_, _stack_pointer_tracker =None_, _ail_manager =None_)¶
    

Bases: `Analysis`

Add calling convention, declaration, and args to a call site.

Parameters:
    

**ail_manager** (_Manager_ _|__None_)

__init__(_block_ , _reaching_definitions =None_, _stack_pointer_tracker =None_, _ail_manager =None_)¶
    

Parameters:
    

**ail_manager** (_Manager_ _|__None_)

_class _angr.analyses.decompiler.ccall_rewriters.rewriter_base.CCallRewriterBase(_ccall_ , _arch_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

The base class for CCall rewriters.

Parameters:
    

**ccall** (_ailment.Expr.VEXCCallExpression_)

__init__(_ccall_ , _arch_)¶
    

Parameters:
    

**ccall** (_VEXCCallExpression_)

arch¶
    

result _: `Expression` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

_class _angr.analyses.decompiler.ccall_rewriters.amd64_ccalls.AMD64CCallRewriter(_ccall_ , _arch_)¶
    

Bases: `CCallRewriterBase`

Implements VEX ccall rewriter for AMD64.

Parameters:
    

**ccall** (_ailment.Expr.VEXCCallExpression_)

_class _angr.analyses.decompiler.clinic.BlockCache(_rd_ , _prop_)¶
    

Bases: [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

prop¶
    

Alias for field number 1

rd¶
    

Alias for field number 0

_class _angr.analyses.decompiler.clinic.ClinicMode(_value_)¶
    

Bases: [`Enum`](https://docs.python.org/3/library/enum.html#enum.Enum "\(in Python v3.13\)")

Analysis mode for Clinic.

DECOMPILE _ = 1_¶
    

COLLECT_DATA_REFS _ = 2_¶
    

_class _angr.analyses.decompiler.clinic.DataRefDesc(_data_addr_ , _data_size_ , _block_addr_ , _stmt_idx_ , _ins_addr_ , _data_type_str_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

The fields of this class is compatible with items inside IRSB.data_refs.

Parameters:
    

  * **data_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **data_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **data_type_str** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

data_addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

data_size _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

block_addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

stmt_idx _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

ins_addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

data_type_str _: [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")_¶
    

__init__(_data_addr_ , _data_size_ , _block_addr_ , _stmt_idx_ , _ins_addr_ , _data_type_str_)¶
    

Parameters:
    

  * **data_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **data_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **data_type_str** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

Return type:
    

None

_class _angr.analyses.decompiler.clinic.ClinicStage(_value_)¶
    

Bases: [`IntEnum`](https://docs.python.org/3/library/enum.html#enum.IntEnum "\(in Python v3.13\)")

Different stages of treating an ailment.

INITIALIZATION _ = 0_¶
    

AIL_GRAPH_CONVERSION _ = 1_¶
    

MAKE_RETURN_SITES _ = 2_¶
    

MAKE_ARGUMENT_LIST _ = 3_¶
    

PRE_SSA_LEVEL0_FIXUPS _ = 4_¶
    

SSA_LEVEL0_TRANSFORMATION _ = 5_¶
    

CONSTANT_PROPAGATION _ = 6_¶
    

TRACK_STACK_POINTERS _ = 7_¶
    

PRE_SSA_LEVEL1_SIMPLIFICATIONS _ = 8_¶
    

SSA_LEVEL1_TRANSFORMATION _ = 9_¶
    

POST_SSA_LEVEL1_SIMPLIFICATIONS _ = 10_¶
    

MAKE_CALLSITES _ = 11_¶
    

POST_CALLSITES _ = 12_¶
    

RECOVER_VARIABLES _ = 13_¶
    

_class _angr.analyses.decompiler.clinic.Clinic(_func_ , _remove_dead_memdefs =False_, _exception_edges =False_, _sp_tracker_track_memory =True_, _fold_callexprs_into_conditions =False_, _insert_labels =True_, _optimization_passes =None_, _cfg =None_, _peephole_optimizations =None_, _must_struct =None_, _variable_kb =None_, _reset_variable_names =False_, _rewrite_ites_to_diamonds =True_, _cache =None_, _mode =ClinicMode.DECOMPILE_, _sp_shift =0_, _inline_functions =None_, _inlined_counts =None_, _inlining_parents =None_, _vvar_id_start =0_, _optimization_scratch =None_, _desired_variables =None_, _force_loop_single_exit =True_, _complete_successors =False_, _max_type_constraints =100000_, _type_constraint_set_degradation_threshold =150_, _ail_graph =None_, _arg_vvars =None_, _start_stage =ClinicStage.INITIALIZATION_)¶
    

Bases: `Analysis`

A Clinic deals with AILments.

Parameters:
    

  * **peephole_optimizations** (_None_ _|__Iterable_ _[_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__PeepholeOptimizationStmtBase_ _]__|_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__PeepholeOptimizationExprBase_ _]__]_)

  * **must_struct** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **cache** (_DecompilationCache_ _|__None_)

  * **mode** (_ClinicMode_)

  * **sp_shift** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **inline_functions** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Function_ _]__|__None_)

  * **inlined_counts** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **inlining_parents** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **vvar_id_start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **optimization_scratch** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__Any_ _]__|__None_)

  * **desired_variables** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **force_loop_single_exit** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **complete_successors** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **max_type_constraints** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **type_constraint_set_degradation_threshold** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **ail_graph** (_networkx.DiGraph_ _|__None_)

  * **arg_vvars** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__ailment.Expr.VirtualVariable_ _,__SimVariable_ _]__]__|__None_)

  * **start_stage** (_ClinicStage_ _|__None_)

__init__(_func_ , _remove_dead_memdefs =False_, _exception_edges =False_, _sp_tracker_track_memory =True_, _fold_callexprs_into_conditions =False_, _insert_labels =True_, _optimization_passes =None_, _cfg =None_, _peephole_optimizations =None_, _must_struct =None_, _variable_kb =None_, _reset_variable_names =False_, _rewrite_ites_to_diamonds =True_, _cache =None_, _mode =ClinicMode.DECOMPILE_, _sp_shift =0_, _inline_functions =None_, _inlined_counts =None_, _inlining_parents =None_, _vvar_id_start =0_, _optimization_scratch =None_, _desired_variables =None_, _force_loop_single_exit =True_, _complete_successors =False_, _max_type_constraints =100000_, _type_constraint_set_degradation_threshold =150_, _ail_graph =None_, _arg_vvars =None_, _start_stage =ClinicStage.INITIALIZATION_)¶
    

Parameters:
    

  * **peephole_optimizations** (_None_ _|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__PeepholeOptimizationStmtBase_ _]__|_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__PeepholeOptimizationExprBase_ _]__]_)

  * **must_struct** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **cache** (_DecompilationCache_ _|__None_)

  * **mode** (_ClinicMode_)

  * **sp_shift** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **inline_functions** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Function_ _]__|__None_)

  * **inlined_counts** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **inlining_parents** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **vvar_id_start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **optimization_scratch** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]__|__None_)

  * **desired_variables** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **force_loop_single_exit** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **complete_successors** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **max_type_constraints** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **type_constraint_set_degradation_threshold** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **ail_graph** (_DiGraph_ _|__None_)

  * **arg_vvars** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__VirtualVariable_ _,__SimVariable_ _]__]__|__None_)

  * **start_stage** (_ClinicStage_ _|__None_)

block(_addr_ , _size_)¶
    

Get the converted block at the given specific address with the given size.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

Returns:
    

dbg_repr()¶
    

Returns:
    

calculate_stack_depth()¶
    

copy_graph(_graph =None_)¶
    

Return type:
    

`DiGraph`

parse_variable_addr(_addr_)¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]

Parameters:
    

**addr** (_Expression_)

new_block_addr()¶
    

Return a block address that does not conflict with any existing blocks.

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

Returns:
    

The block address.

_static _remove_empty_nodes(_graph_)¶
    

Return type:
    

`DiGraph`

Parameters:
    

**graph** (_DiGraph_)

_class _angr.analyses.decompiler.condition_processor.ConditionProcessor(_arch_ , _condition_mapping =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Convert between claripy AST and AIL expressions. Also calculates reaching conditions of all nodes on a graph.

__init__(_arch_ , _condition_mapping =None_)¶
    

clear()¶
    

have_opposite_edge_conditions(_graph_ , _src_ , _dst0_ , _dst1_)¶
    

Check if the edge conditions of two edges (src, dst0) and (src, dst1) are opposite to each other. Try to avoid condition translation if possible.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**graph** (_DiGraph_)

recover_edge_condition(_graph_ , _src_ , _dst_)¶
    

Parameters:
    

**graph** (_DiGraph_)

recover_edge_conditions(_region_ , _graph =None_)¶
    

Return type:
    

[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")

recover_reaching_conditions(_region_ , _graph =None_, _with_successors =False_, _case_entry_to_switch_head =None_, _simplify_conditions =True_)¶
    

Recover the reaching conditions for each block in an acyclic graph. Note that we assume the graph that’s passed in is acyclic.

Parameters:
    

  * **case_entry_to_switch_head** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **simplify_conditions** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

remove_claripy_bool_asts(_node_ , _memo =None_)¶
    

_classmethod _get_last_statement(_block_)¶
    

This is the buggy version of get_last_statements, because, you know, there can always be more than one last statement due to the existence of branching statements (like, If-then-else). All methods using get_last_statement() should switch to get_last_statements() and properly handle multiple last statements.

_classmethod _get_last_statements(_block_)¶
    

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`Statement` | `ConditionalBreakNode` | `BreakNode` | `ContinueNode` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")]

EXC_COUNTER _ = 1000_¶
    

convert_claripy_bool_ast(_cond_ , _memo =None_)¶
    

Convert recovered reaching conditions from claripy ASTs to ailment Expressions

Returns:
    

None

convert_claripy_bool_ast_core(_cond_ , _memo_)¶
    

claripy_ast_from_ail_condition(_condition_ , _*_ , _nobool =False_, _must_bool =False_, _ins_addr =0_)¶
    

Return type:
    

[`Bool`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bool.Bool "\(in claripy\)") | [`Bits`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bits.Bits "\(in claripy\)")

Parameters:
    

  * **nobool** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **must_bool** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_static _claripy_ast_to_sympy_expr(_ast_ , _memo =None_)¶
    

_static _sympy_expr_to_claripy_ast(_expr_ , _memo_)¶
    

Parameters:
    

**memo** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)"))

_static _simplify_condition(_cond_ , _depth_limit =8_, _variables_limit =8_)¶
    

create_jump_target_var(_jumptable_head_addr_)¶
    

Parameters:
    

**jumptable_head_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_class _angr.analyses.decompiler.decompilation_options.DecompilationOption(_name_ , _description_ , _value_type_ , _cls_ , _param_ , _value_range =None_, _category ='General'_, _default_value =None_, _clears_cache =True_, _candidate_values =None_, _convert =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Describes a decompilation option.

Parameters:
    

  * **candidate_values** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _|__None_)

  * **convert** (_Callable_ _|__None_)

__init__(_name_ , _description_ , _value_type_ , _cls_ , _param_ , _value_range =None_, _category ='General'_, _default_value =None_, _clears_cache =True_, _candidate_values =None_, _convert =None_)¶
    

Parameters:
    

  * **candidate_values** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _|__None_)

  * **convert** ([_Callable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)") _|__None_)

angr.analyses.decompiler.decompilation_options.O¶
    

alias of `DecompilationOption`

angr.analyses.decompiler.decompilation_options.get_structurer_option()¶
    

Return type:
    

`DecompilationOption` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

_class _angr.analyses.decompiler.decompilation_cache.DecompilationCache(_addr_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Caches key data structures that can be used later for refining decompilation results, such as retyping variables.

__init__(_addr_)¶
    

parameters _: [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]_¶
    

addr¶
    

type_constraints _: [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[`TypeVariable`, [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`TypeConstraint`]] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

func_typevar _: `TypeVariable` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

var_to_typevar _: [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

codegen _: `BaseStructuredCodeGenerator` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

clinic _: `Clinic` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

ite_exprs _: [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

binop_operators _: [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[`OpDescriptor`, [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

errors _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]_¶
    

_property _local_types¶
    

_class _angr.analyses.decompiler.decompiler.Decompiler(_func_ , _cfg =None_, _options =None_, _preset =None_, _optimization_passes =None_, _sp_tracker_track_memory =True_, _variable_kb =None_, _peephole_optimizations =None_, _vars_must_struct =None_, _flavor ='pseudocode'_, _expr_comments =None_, _stmt_comments =None_, _ite_exprs =None_, _binop_operators =None_, _decompile =True_, _regen_clinic =True_, _inline_functions =frozenset({})_, _desired_variables =frozenset({})_, _update_memory_data =True_, _generate_code =True_, _use_cache =True_, _expr_collapse_depth =16_, _clinic_graph =None_, _clinic_arg_vvars =None_, _clinic_start_stage =None_)¶
    

Bases: `Analysis`

The decompiler analysis.

Run this on a Function object for which a normalized CFG has been constructed. The fully processed output can be found in result.codegen.text

Parameters:
    

  * **func** (_Function_ _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **cfg** (_CFGFast_ _|__CFGModel_ _|__None_)

  * **preset** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__DecompilationPreset_ _|__None_)

  * **peephole_optimizations** (__PEEPHOLE_OPTIMIZATIONS_TYPE_)

  * **vars_must_struct** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **update_memory_data** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **generate_code** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **use_cache** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **expr_collapse_depth** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_func_ , _cfg =None_, _options =None_, _preset =None_, _optimization_passes =None_, _sp_tracker_track_memory =True_, _variable_kb =None_, _peephole_optimizations =None_, _vars_must_struct =None_, _flavor ='pseudocode'_, _expr_comments =None_, _stmt_comments =None_, _ite_exprs =None_, _binop_operators =None_, _decompile =True_, _regen_clinic =True_, _inline_functions =frozenset({})_, _desired_variables =frozenset({})_, _update_memory_data =True_, _generate_code =True_, _use_cache =True_, _expr_collapse_depth =16_, _clinic_graph =None_, _clinic_arg_vvars =None_, _clinic_start_stage =None_)¶
    

Parameters:
    

  * **func** (_Function_ _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **cfg** (_CFGFast_ _|__CFGModel_ _|__None_)

  * **preset** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__DecompilationPreset_ _|__None_)

  * **peephole_optimizations** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__PeepholeOptimizationStmtBase_ _]__|_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__PeepholeOptimizationExprBase_ _]__]__|__None_)

  * **vars_must_struct** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **update_memory_data** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **generate_code** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **use_cache** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **expr_collapse_depth** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

reflow_variable_types(_type_constraints_ , _func_typevar_ , _var_to_typevar_ , _codegen_)¶
    

Re-run type inference on an existing variable recovery result, then rerun codegen to generate new results.

Returns:
    

Parameters:
    

  * **type_constraints** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__TypeVariable_ _,_[_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__TypeConstraint_ _]__]_)

  * **var_to_typevar** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)"))

find_data_references_and_update_memory_data(_seq_node_)¶
    

Parameters:
    

**seq_node** (_SequenceNode_)

transform_graph_from_ssa(_ail_graph_)¶
    

Translate an SSA AIL graph out of SSA form. This is useful for producing a non-SSA AIL graph for displaying in angr management.

Parameters:
    

**ail_graph** (`DiGraph`) – The AIL graph to transform out of SSA form.

Return type:
    

`DiGraph`

Returns:
    

The translated AIL graph.

transform_seqnode_from_ssa(_seq_node_)¶
    

Return type:
    

`SequenceNode`

Parameters:
    

**seq_node** (_SequenceNode_)

_static _options_to_params(_options_)¶
    

Convert decompilation options to a dict of params.

Parameters:
    

**options** ([`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`DecompilationOption`, [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – The decompilation options.

Return type:
    

[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]

Returns:
    

A dict of keyword arguments.

_class _angr.analyses.decompiler.empty_node_remover.EmptyNodeRemover(_node_ , _claripy_ast_conditions =True_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Rewrites a node and its children to remove empty nodes.

The following optimizations are performed at the same time: \- Convert if (A) { } else { … } to if(!A) { … } else { }

Variables:
    

**_claripy_ast_conditions** – True if all node conditions are claripy ASTs. False if all node conditions are AIL expressions.

Parameters:
    

**claripy_ast_conditions** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_node_ , _claripy_ast_conditions =True_)¶
    

Parameters:
    

**claripy_ast_conditions** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

_class _angr.analyses.decompiler.expression_narrower.ExprNarrowingInfo(_narrowable_ , _to_size =None_, _use_exprs =None_, _phi_vars =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Stores the analysis result of _narrowing_needed().

Parameters:
    

  * **narrowable** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **to_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **use_exprs** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__atoms.VirtualVariable_ _,__CodeLocation_ _,_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__Expression_ _,__...__]__]__]__]__|__None_)

  * **phi_vars** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__VirtualVariable_ _]__|__None_)

__init__(_narrowable_ , _to_size =None_, _use_exprs =None_, _phi_vars =None_)¶
    

Parameters:
    

  * **narrowable** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **to_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **use_exprs** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__VirtualVariable_ _,__CodeLocation_ _,_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__Expression_ _,__...__]__]__]__]__|__None_)

  * **phi_vars** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__VirtualVariable_ _]__|__None_)

narrowable¶
    

to_size¶
    

use_exprs¶
    

phi_vars¶
    

_class _angr.analyses.decompiler.expression_narrower.NarrowingInfoExtractor(_target_expr_)¶
    

Bases: `AILBlockWalkerBase`

Walks a statement or an expression and extracts the operations that are applied on the given expression.

For example, for target expression rax, (rax & 0xff) + 0x1 means the following operations are applied on rax: rax & 0xff (rax & 0xff) + 0x1

The previous expression is always used in the succeeding expression.

Parameters:
    

**target_expr** (_Expression_)

__init__(_target_expr_)¶
    

Parameters:
    

**target_expr** (_Expression_)

_class _angr.analyses.decompiler.expression_narrower.ExpressionNarrower(_project_ , _rd_ , _narrowables_ , _addr2blocks_ , _new_blocks_)¶
    

Bases: `AILBlockWalker`

Narrows an expression regardless of whether the expression is a definition or a use.

Parameters:
    

  * **addr2blocks** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_ _]__,__Block_ _]_)

  * **new_blocks** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__Block_ _,__Block_ _]_)

__init__(_project_ , _rd_ , _narrowables_ , _addr2blocks_ , _new_blocks_)¶
    

Parameters:
    

  * **addr2blocks** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_ _]__,__Block_ _]_)

  * **new_blocks** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__Block_ _,__Block_ _]_)

walk(_block_)¶
    

Walk the block and rebuild it if necessary. The block will be rebuilt in-place (by updating statements in the original block when self._update_block is set to True), or a new block will be created and returned.

Parameters:
    

**block** (`Block`) – The block to walk.

Returns:
    

The new block that is rebuilt, or None if the block is not changed or when self._update_block is set to True.

_class _angr.analyses.decompiler.graph_region.GraphRegion(_head_ , _graph_ , _successors_ , _graph_with_successors_ , _cyclic_ , _full_graph_ , _cyclic_ancestor =False_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

GraphRegion represents a region of nodes.

Variables:
    

  * **head** – The head of the region.

  * **graph** – The region graph.

  * **successors** – A set of successors of nodes in the graph. These successors do not belong to the current region.

  * **graph_with_successors** – The region graph that includes successor nodes.

Parameters:
    

  * **successors** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _|__None_)

  * **graph_with_successors** (_networkx.DiGraph_ _|__None_)

  * **full_graph** (_networkx.DiGraph_ _|__None_)

  * **cyclic_ancestor** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_head_ , _graph_ , _successors_ , _graph_with_successors_ , _cyclic_ , _full_graph_ , _cyclic_ancestor =False_)¶
    

Parameters:
    

  * **successors** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _|__None_)

  * **graph_with_successors** (_DiGraph_ _|__None_)

  * **full_graph** (_DiGraph_ _|__None_)

  * **cyclic_ancestor** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

head¶
    

graph¶
    

successors¶
    

graph_with_successors¶
    

full_graph¶
    

cyclic¶
    

cyclic_ancestor¶
    

copy()¶
    

Return type:
    

`GraphRegion`

recursive_copy(_nodes_map =None_)¶
    

_property _addr¶
    

_static _dbg_get_repr(_obj_ , _ident =0_)¶
    

dbg_print(_ident =0_)¶
    

replace_region(_sub_region_ , _updated_sub_region_ , _replace_with_ , _virtualized_edges_)¶
    

Parameters:
    

  * **sub_region** (_GraphRegion_)

  * **updated_sub_region** (_GraphRegion_)

  * **virtualized_edges** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]__]_)

replace_region_with_region(_sub_region_ , _replace_with_)¶
    

Parameters:
    

  * **sub_region** (_GraphRegion_)

  * **replace_with** (_GraphRegion_)

_class _angr.analyses.decompiler.jump_target_collector.JumpTargetCollector(_node_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Collect all jump targets.

__init__(_node_)¶
    

_class _angr.analyses.decompiler.jumptable_entry_condition_rewriter.JumpTableEntryConditionRewriter(_jumptable_entry_conds_)¶
    

Bases: `SequenceWalker`

Remove artificial jump table entry conditions that ConditionProcessor introduced when dealing with jump tables.

__init__(_jumptable_entry_conds_)¶
    

_class _angr.analyses.decompiler.optimization_passes.BasePointerSaveSimplifier(_func_ , _** kwargs_)¶
    

Bases: `OptimizationPass`

Removes the effects of base pointer stack storage at function invocation and restoring at function return.

ARCHES _ = ['X86', 'AMD64', 'ARMEL', 'ARMHF', 'ARMCortexM', 'MIPS32', 'MIPS64']_¶
    

PLATFORMS _ = None_¶
    

STAGE _: OptimizationPassStage_ _ = 5_¶
    

NAME _ = 'Simplify base pointer saving'_¶
    

DESCRIPTION _ = 'Removes the effects of base pointer stack storage at function invocation and restoring at function return.'_¶
    

__init__(_func_ , _** kwargs_)¶
    

_class _angr.analyses.decompiler.optimization_passes.CallStatementRewriter(_func_ , _** kwargs_)¶
    

Bases: `OptimizationPass`

Rewrite call statements to assignments if needed.

ARCHES _ = None_¶
    

PLATFORMS _ = None_¶
    

STAGE _: OptimizationPassStage_ _ = 4_¶
    

NAME _ = 'Unify call statements on demand.'_¶
    

DESCRIPTION _ = 'Rewrite call statements to assignments if needed.'_¶
    

__init__(_func_ , _** kwargs_)¶
    

_class _angr.analyses.decompiler.optimization_passes.CodeMotionOptimization(_func_ , _* args_, _max_iters =10_, _node_idx_start =0_, _** kwargs_)¶
    

Bases: `OptimizationPass`

Moves common statements out of blocks that share the same predecessors or the same successors. This is done to reduce the number of statements in a block and to make the blocks more similar to each other.

As an example: if (x) {

> b = 2; a = 1; c = 3;

} else {
    

b = 2; c = 3;

}

Will be turned into: if (x) {

> a = 1;

} b = 2; c = 3;

Current limitations (for very conservative operations): \- moving statements above conditional jumps is not supported \- only immediate children and parents are considered for moving statements \- when moving statements down, a block is only considered if already has a matching statement at the end

Parameters:
    

**node_idx_start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

ARCHES _ = None_¶
    

PLATFORMS _ = None_¶
    

NAME _ = 'Merge common statements in sub-scopes'_¶
    

STAGE _: OptimizationPassStage_ _ = 5_¶
    

DESCRIPTION _ = '\n Moves common statements out of blocks that share the same predecessors or the same\n successors. This is done to reduce the number of statements in a block and to make the\n blocks more similar to each other.\n\n As an example:\n if (x) {\n b = 2;\n a = 1;\n c = 3;\n } else {\n b = 2;\n c = 3;\n }\n\n Will be turned into:\n if (x) {\n a = 1;\n }\n b = 2;\n c = 3;\n\n Current limitations (for very conservative operations):\n - moving statements above conditional jumps is not supported\n - only immediate children and parents are considered for moving statements\n - when moving statements down, a block is only considered if already has a matching statement at the end\n '_¶
    

__init__(_func_ , _* args_, _max_iters =10_, _node_idx_start =0_, _** kwargs_)¶
    

Parameters:
    

**node_idx_start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_static _update_graph_with_super_edits(_original_graph_ , _super_graph_ , _updated_blocks_)¶
    

This function updates an graph when doing block edits on a supergraph version of that same graph. The updated blocks must be provided as a dictionary where the keys are original block in the supergraph and the values are the new blocks that should replace them.

The supergraph MUST be generated using the to_ail_supergraph function, since it stores the original nodes each super node represents. This is necessary to update the original graph with the new super nodes.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

  * **original_graph** (_DiGraph_)

  * **super_graph** (_DiGraph_)

  * **updated_blocks** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__Block_ _,__Block_ _]_)

_class _angr.analyses.decompiler.optimization_passes.ConditionConstantPropagation(_func_ , _** kwargs_)¶
    

Bases: `OptimizationPass`

Reason about constant propagation opportunities from conditionals and propagate constants in the graph accordingly.

ARCHES _ = None_¶
    

PLATFORMS _ = None_¶
    

STAGE _: OptimizationPassStage_ _ = 2_¶
    

NAME _ = 'Propagate constants using information deduced from conditionals.'_¶
    

DESCRIPTION _ = 'Reason about constant propagation opportunities from conditionals and propagate constants in the graph accordingly.'_¶
    

__init__(_func_ , _** kwargs_)¶
    

_class _angr.analyses.decompiler.optimization_passes.ConstPropOptReverter(_func_ , _region_identifier =None_, _reaching_definitions =None_, _** kwargs_)¶
    

Bases: `OptimizationPass`

This optimization reverts the effects of constant propagation done by the compiler as discussed in the USENIX 2024 paper SAILR. This optimization’s main goal is to enable later optimizations that rely on symbolic variables to be more effective. This optimization pass will convert two statements with a difference of a const and a symbolic variable into two statements with the symbolic variables.

As an example: x = 75 puts(x) puts(75)

will be converted to: x = 75 puts(x) puts(x)

ARCHES _ = None_¶
    

PLATFORMS _ = None_¶
    

STRUCTURING _: list[str] | None_ _ = ['sailr', 'dream']_¶
    

STAGE _: OptimizationPassStage_ _ = 9_¶
    

NAME _ = 'Revert Constant Propagation Optimizations'_¶
    

DESCRIPTION _ = "This optimization reverts the effects of constant propagation done by the compiler as discussed in the\n USENIX 2024 paper SAILR. This optimization's main goal is to enable later optimizations that rely on\n symbolic variables to be more effective. This optimization pass will convert two statements with a difference of\n a const and a symbolic variable into two statements with the symbolic variables.\n\n As an example:\n x = 75\n puts(x)\n puts(75)\n\n will be converted to:\n x = 75\n puts(x)\n puts(x)"_¶
    

__init__(_func_ , _region_identifier =None_, _reaching_definitions =None_, _** kwargs_)¶
    

_static _find_conflicting_call_args(_call0_ , _call1_)¶
    

Parameters:
    

  * **call0** (_Call_)

  * **call1** (_Call_)

_class _angr.analyses.decompiler.optimization_passes.ConstantDereferencesSimplifier(_func_ , _** kwargs_)¶
    

Bases: `OptimizationPass`

Makes the following simplifications:
    
    
    *(*(const_addr))  ==>  *(value) iff  *const_addr == value
    

ARCHES _ = None_¶
    

PLATFORMS _ = None_¶
    

STAGE _: OptimizationPassStage_ _ = 2_¶
    

NAME _ = 'Simplify constant dereferences'_¶
    

DESCRIPTION _ = 'Makes the following simplifications::\n\n *(*(const_addr)) ==> *(value) iff *const_addr == value'_¶
    

__init__(_func_ , _** kwargs_)¶
    

_class _angr.analyses.decompiler.optimization_passes.CrossJumpReverter(_func_ , _node_idx_start =0_, _max_opt_iters =3_, _max_call_duplications =1_, _** kwargs_)¶
    

Bases: `StructuringOptimizationPass`

This is an implementation to revert the compiler optimization Cross Jumping, and ISC optimization discussed in the USENIX 2024 paper SAILR. This optimization is somewhat aggressive and as such should be run last in your decompiler deoptimization chain. This deoptimization will take any goto it finds and attempt to duplicate its target block if its target only has one outgoing edge.

There are some heuristics in place to prevent duplication everywhere. First, this deoptimization will only run a max of max_opt_iters times. Second, it will not duplicate a block with too many calls.

Parameters:
    

  * **node_idx_start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **max_opt_iters** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **max_call_duplications** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

STAGE _: OptimizationPassStage_ _ = 9_¶
    

NAME _ = 'Duplicate linear blocks with gotos'_¶
    

DESCRIPTION _ = 'This is an implementation to revert the compiler optimization Cross Jumping, and ISC optimization discussed\nin the USENIX 2024 paper SAILR. This optimization is somewhat aggressive and as such should be run last in your\ndecompiler deoptimization chain. This deoptimization will take any goto it finds and attempt to duplicate its\ntarget block if its target only has one outgoing edge.\n\nThere are some heuristics in place to prevent duplication everywhere. First, this deoptimization will only run\na max of max_opt_iters times. Second, it will not duplicate a block with too many calls.'_¶
    

__init__(_func_ , _node_idx_start =0_, _max_opt_iters =3_, _max_call_duplications =1_, _** kwargs_)¶
    

Parameters:
    

  * **node_idx_start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **max_opt_iters** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **max_call_duplications** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_class _angr.analyses.decompiler.optimization_passes.DeadblockRemover(_func_ , _node_cutoff =200_, _** kwargs_)¶
    

Bases: `OptimizationPass`

Removes condition-unreachable blocks from the graph.

Parameters:
    

**node_cutoff** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

ARCHES _ = None_¶
    

PLATFORMS _ = None_¶
    

STAGE _: OptimizationPassStage_ _ = 8_¶
    

NAME _ = 'Remove blocks with unsatisfiable conditions'_¶
    

DESCRIPTION _ = 'Removes condition-unreachable blocks from the graph.'_¶
    

__init__(_func_ , _node_cutoff =200_, _** kwargs_)¶
    

Parameters:
    

**node_cutoff** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_class _angr.analyses.decompiler.optimization_passes.DivSimplifier(_func_ , _** kwargs_)¶
    

Bases: `OptimizationPass`

Simplifies various division optimizations back to “div”.

ARCHES _ = ['X86', 'AMD64', 'ARMCortexM', 'ARMHF', 'ARMEL']_¶
    

PLATFORMS _ = None_¶
    

STAGE _: OptimizationPassStage_ _ = 5_¶
    

NAME _ = 'Simplify arithmetic division'_¶
    

DESCRIPTION _ = 'Simplifies various division optimizations back to "div".'_¶
    

__init__(_func_ , _** kwargs_)¶
    

_class _angr.analyses.decompiler.optimization_passes.DuplicationReverter(_func_ , _max_guarding_conditions =4_, _** kwargs_)¶
    

Bases: `StructuringOptimizationPass`

This (de)optimization reverts the effects of many compiler optimizations that cause code duplication in the decompilation. This deoptimization is the implementation of the USENIX 2024 paper SAILR’s ISD doptimization. As such, the main goal of this optimization is to remove code duplication by merging semantically similar blocks in the AIL graph.

NAME _ = 'Revert Statement Duplication Optimizations'_¶
    

DESCRIPTION _ = "This (de)optimization reverts the effects of many compiler optimizations that cause code duplication in\n the decompilation. This deoptimization is the implementation of the USENIX 2024 paper SAILR's ISD\n doptimization. As such, the main goal of this optimization is to remove code duplication by merging\n semantically similar blocks in the AIL graph."_¶
    

__init__(_func_ , _max_guarding_conditions =4_, _** kwargs_)¶
    

_static _boolean_operators_in_condition(_condition_)¶
    

TODO: this entire boolean checking semantic we use needs to be removed, see how it is used for other dels needed we need to replace it with a boolean variable insertion on both branches that lead to the new block say we have: if (A()) {

> do_thing();

} if (B()) {

> do_thing():

}

We want to translate it to: int should_do_thing = 0; if (A())

> should_do_thing = 1;

if (B())
    

should_do_thing = 1;

if (should_do_thing):
    

do_thing();

Although longer, this code can be optimized to look like: int should_do_thing = A() || B(); if (should_do_thing)

> do_thing();

Parameters:
    

**condition** (_Expression_)

stmt_can_move_to(_stmt_ , _block_ , _new_idx_ , _io_finder =None_)¶
    

maximize_similarity_of_blocks(_block1_ , _block2_ , _graph_)¶
    

This attempts to rearrange the order of statements in block1 and block2 to maximize the similarity between them. This implementation is a little outdated since CodeMotion optimization was implemented, but it should be disabled until we have a good SSA implementation.

TODO: reimplement me when we have better SSA

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`Block`, `Block`]

create_merged_subgraph(_blocks_ , _graph_ , _maximize_similarity =False_)¶
    

Return type:
    

`AILMergeGraph`

Parameters:
    

**graph** (_DiGraph_)

similar_conditional_when_single_corrected(_block1_ , _block2_ , _graph_)¶
    

Parameters:
    

  * **block1** (_Block_)

  * **block2** (_Block_)

  * **graph** (_DiGraph_)

collect_conditions_between_nodes(_graph_ , _source_ , _sinks_ , _max_depth =15_)¶
    

Parameters:
    

  * **source** (_Block_)

  * **sinks** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__Block_ _]_)

shared_common_conditional_dom(_nodes_ , _graph_)¶
    

Takes n nodes and returns True only if all the nodes are dominated by the same node, which must be a ConditionalJump

@param nodes: @param graph: @return:

Parameters:
    

**graph** (_DiGraph_)

_class _angr.analyses.decompiler.optimization_passes.EagerStdStringConcatenationPass(_func_ , _** kwargs_)¶
    

Bases: `OptimizationPass`

TODO: Unfinished

ARCHES _ = None_¶
    

PLATFORMS _ = None_¶
    

STAGE _: OptimizationPassStage_ _ = 6_¶
    

NAME _ = 'Condense multiple constant std::string creation calls into one when possible'_¶
    

DESCRIPTION _ = 'TODO: Unfinished'_¶
    

__init__(_func_ , _** kwargs_)¶
    

_class _angr.analyses.decompiler.optimization_passes.ExprOpSwapper(_func_ , _binop_operators =None_, _** kwargs_)¶
    

Bases: `SequenceOptimizationPass`

Swap operands (and the operator accordingly) in a BinOp expression.

Parameters:
    

**binop_operators** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__OpDescriptor_ _,_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

ARCHES _ = ['X86', 'AMD64', 'ARMEL', 'ARMHF', 'ARMCortexM', 'MIPS32', 'MIPS64']_¶
    

PLATFORMS _ = ['windows', 'linux', 'cgc']_¶
    

STAGE _: OptimizationPassStage_ _ = 10_¶
    

NAME _ = 'Swap operands of expressions as requested'_¶
    

DESCRIPTION _ = 'Swap operands (and the operator accordingly) in a BinOp expression.'_¶
    

__init__(_func_ , _binop_operators =None_, _** kwargs_)¶
    

Parameters:
    

**binop_operators** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__OpDescriptor_ _,_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

_class _angr.analyses.decompiler.optimization_passes.FlipBooleanCmp(_func_ , _flip_size =9_, _** kwargs_)¶
    

Bases: `SequenceOptimizationPass`

In the scenario in which a false node has no apparent successors, flip the condition on that if-stmt. This is only useful when StructuredCodeGenerator has simplify_else_scopes enabled, as this will allow the flipped if-stmt to remove the redundant else.

ARCHES _ = None_¶
    

PLATFORMS _ = None_¶
    

STAGE _: OptimizationPassStage_ _ = 10_¶
    

NAME _ = 'Flip small ret booleans'_¶
    

DESCRIPTION _ = 'When false node has no successors, flip condition so else scope can be simplified later'_¶
    

__init__(_func_ , _flip_size =9_, _** kwargs_)¶
    

_class _angr.analyses.decompiler.optimization_passes.ITEExprConverter(_func_ , _ite_exprs =None_, _** kwargs_)¶
    

Bases: `OptimizationPass`

Transform specific expressions into If-Then-Else expressions, or tertiary expressions in C when given a single-use expression address. Requires outside analysis to provide the target expressions.

ARCHES _ = ['X86', 'AMD64', 'ARMEL', 'ARMHF', 'ARMCortexM', 'MIPS32', 'MIPS64']_¶
    

PLATFORMS _ = ['windows', 'linux', 'cgc']_¶
    

STAGE _: OptimizationPassStage_ _ = 9_¶
    

NAME _ = 'Transform single-use expressions that were assigned to in different If-Else branches into ternary expressions'_¶
    

DESCRIPTION _ = 'Transform specific expressions into If-Then-Else expressions, or tertiary expressions in C when\n given a single-use expression address. Requires outside analysis to provide the target expressions.'_¶
    

__init__(_func_ , _ite_exprs =None_, _** kwargs_)¶
    

_class _angr.analyses.decompiler.optimization_passes.ITERegionConverter(_func_ , _max_updates =10_, _** kwargs_)¶
    

Bases: `OptimizationPass`

Transform regions of the form if (c) {x = a} else {x = b} into x = c ? a : b.

ARCHES _ = ['X86', 'AMD64', 'ARMEL', 'ARMHF', 'ARMCortexM', 'MIPS32', 'MIPS64']_¶
    

PLATFORMS _ = ['windows', 'linux', 'cgc']_¶
    

STAGE _: OptimizationPassStage_ _ = 5_¶
    

NAME _ = 'Transform ITE-assignment regions into ternary expression assignments'_¶
    

DESCRIPTION _ = 'Transform regions of the form `if (c) {x = a} else {x = b}` into `x = c ? a : b`.'_¶
    

__init__(_func_ , _max_updates =10_, _** kwargs_)¶
    

_class _angr.analyses.decompiler.optimization_passes.InlinedStringTransformationSimplifier(_func_ , _** kwargs_)¶
    

Bases: `OptimizationPass`

Simplifies inlined string transformation routines.

ARCHES _ = None_¶
    

PLATFORMS _ = None_¶
    

STAGE _: OptimizationPassStage_ _ = 5_¶
    

NAME _ = 'Simplify string transformations'_¶
    

DESCRIPTION _ = 'Simplify string transformations that are commonly used in obfuscated functions.'_¶
    

__init__(_func_ , _** kwargs_)¶
    

_class _angr.analyses.decompiler.optimization_passes.LoweredSwitchSimplifier(_func_ , _min_distinct_cases =2_, _** kwargs_)¶
    

Bases: `StructuringOptimizationPass`

This optimization recognizes and reverts switch cases that have been lowered and possibly split into multiple if-else statements. This optimization, discussed in the USENIX 2024 paper SAILR, aims to undo the compiler optimization known as “Switch Lowering”, present in both GCC and Clang. An in-depth discussion of this optimization can be found in the paper or in our documentation of the optimization: <https://github.com/mahaloz/sailr-eval/issues/14#issue-2232616411>

Note, this optimization does not occur in MSVC, which uses a different optimization strategy for switch cases. As a hack for now, we only run this deoptimization on Linux binaries.

PLATFORMS _ = ['linux']_¶
    

NAME _ = 'Convert lowered switch-cases (if-else) to switch-cases'_¶
    

DESCRIPTION _ = 'Convert lowered switch-cases (if-else) to switch-cases. Only works when the Phoenix structuring algorithm is in use.'_¶
    

__init__(_func_ , _min_distinct_cases =2_, _** kwargs_)¶
    

_static _restore_graph(_node_ , _last_stmt_ , _graph_ , _full_graph_)¶
    

Parameters:
    

  * **last_stmt** (_IncompleteSwitchCaseHeadStatement_)

  * **graph** (_DiGraph_)

  * **full_graph** (_DiGraph_)

_static _cases_issubset(_cases_0_ , _cases_1_)¶
    

Test if cases_0 is a subset of cases_1.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

  * **cases_0** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__Case_ _]_)

  * **cases_1** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__Case_ _]_)

_class _angr.analyses.decompiler.optimization_passes.ModSimplifier(_func_ , _** kwargs_)¶
    

Bases: `OptimizationPass`

Simplifies optimized forms of modulo computation back to “mod”.

ARCHES _ = ['X86', 'AMD64', 'ARMCortexM', 'ARMHF', 'ARMEL']_¶
    

PLATFORMS _ = ['linux', 'windows']_¶
    

STAGE _: OptimizationPassStage_ _ = 5_¶
    

NAME _ = 'Simplify optimized mod forms'_¶
    

DESCRIPTION _ = 'Simplifies optimized forms of modulo computation back to "mod".'_¶
    

__init__(_func_ , _** kwargs_)¶
    

_class _angr.analyses.decompiler.optimization_passes.OptimizationPassStage(_value_)¶
    

Bases: [`Enum`](https://docs.python.org/3/library/enum.html#enum.Enum "\(in Python v3.13\)")

Enums about optimization pass stages.

Note that the region identification pass (RegionIdentifier) may modify existing AIL blocks _without updating the topology of the original AIL graph_. For example, loop successor refinement may modify create a new AIL block with an artificial address, and alter existing jump targets of jump statements and conditional jump statements to point to this new block. However, loop successor refinement does not update the topology of the original AIL graph, which means this new AIL block does not exist in the original AIL graph. As a result, until this behavior of RegionIdentifier changes in the future, DURING_REGION_IDENTIFICATION optimization passes should not modify existing jump targets.

AFTER_AIL_GRAPH_CREATION _ = 0_¶
    

BEFORE_SSA_LEVEL0_TRANSFORMATION _ = 1_¶
    

AFTER_SINGLE_BLOCK_SIMPLIFICATION _ = 2_¶
    

BEFORE_SSA_LEVEL1_TRANSFORMATION _ = 3_¶
    

AFTER_MAKING_CALLSITES _ = 4_¶
    

AFTER_GLOBAL_SIMPLIFICATION _ = 5_¶
    

BEFORE_VARIABLE_RECOVERY _ = 6_¶
    

AFTER_VARIABLE_RECOVERY _ = 7_¶
    

BEFORE_REGION_IDENTIFICATION _ = 8_¶
    

DURING_REGION_IDENTIFICATION _ = 9_¶
    

AFTER_STRUCTURING _ = 10_¶
    

_class _angr.analyses.decompiler.optimization_passes.RegisterSaveAreaSimplifier(_func_ , _** kwargs_)¶
    

Bases: `OptimizationPass`

Optimizes away register spilling effects, including callee-saved registers.

This optimization runs between SSA-level0 and SSA-level1, which means registers are converted to vvars but stack accesses stay unchanged.

ARCHES _ = None_¶
    

PLATFORMS _ = None_¶
    

STAGE _: OptimizationPassStage_ _ = 2_¶
    

NAME _ = 'Simplify register save areas'_¶
    

DESCRIPTION _ = 'Optimizes away register spilling effects, including callee-saved registers.\n\n This optimization runs between SSA-level0 and SSA-level1, which means registers are converted to vvars but stack\n accesses stay unchanged.'_¶
    

__init__(_func_ , _** kwargs_)¶
    

_class _angr.analyses.decompiler.optimization_passes.RetAddrSaveSimplifier(_func_ , _** kwargs_)¶
    

Bases: `OptimizationPass`

Removes code in function prologues and epilogues for saving and restoring return address registers (ra, lr, etc.), generally seen in non-leaf functions.

ARCHES _ = ['MIPS32', 'MIPS64']_¶
    

PLATFORMS _ = ['linux']_¶
    

STAGE _: OptimizationPassStage_ _ = 5_¶
    

NAME _ = 'Simplify return address storage'_¶
    

DESCRIPTION _ = 'Removes code in function prologues and epilogues for saving and restoring return address registers (ra, lr, etc.),\n generally seen in non-leaf functions.'_¶
    

__init__(_func_ , _** kwargs_)¶
    

_class _angr.analyses.decompiler.optimization_passes.ReturnDeduplicator(_func_ , _** kwargs_)¶
    

Bases: `OptimizationPass`

Transforms: \- if (cond) { … return x; } return x;

into: \- if (cond) { … } return x;

TODO: its possible that this can be expanded to all rets that are equivalent. Testing needed.

ARCHES _ = ['X86', 'AMD64', 'ARMEL', 'ARMHF', 'ARMCortexM', 'MIPS32', 'MIPS64']_¶
    

PLATFORMS _ = ['windows', 'linux', 'cgc']_¶
    

STAGE _: OptimizationPassStage_ _ = 9_¶
    

NAME _ = 'Deduplicates return statements that may have been duplicated'_¶
    

DESCRIPTION _ = 'Transforms:\n - if (cond) { ... return x; } return x;\n\n into:\n - if (cond) { ... } return x;\n\n TODO: its possible that this can be expanded to all rets that are equivalent. Testing needed.'_¶
    

STRUCTURING _: list[str] | None_ _ = ['sailr', 'dream']_¶
    

__init__(_func_ , _** kwargs_)¶
    

_class _angr.analyses.decompiler.optimization_passes.ReturnDuplicatorHigh(_func_ , _*_ , _vvar_id_start_ , _max_calls_in_regions =2_, _minimize_copies_for_regions =True_, _scratch =None_, _** kwargs_)¶
    

Bases: `OptimizationPass`, `ReturnDuplicatorBase`

This is a light-level goto-less version of the ReturnDuplicator optimization pass. It will only duplicate return-only blocks.

Parameters:
    

  * **vvar_id_start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **max_calls_in_regions** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **minimize_copies_for_regions** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **scratch** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__Any_ _]__|__None_)

ARCHES _ = None_¶
    

PLATFORMS _ = None_¶
    

STAGE _: OptimizationPassStage_ _ = 5_¶
    

NAME _ = 'Duplicate return-only blocks (high)'_¶
    

DESCRIPTION _ = '\n This is a light-level goto-less version of the ReturnDuplicator optimization pass. It will only\n duplicate return-only blocks.\n '_¶
    

STRUCTURING _: list[str] | None_ _ = ['sailr', 'dream']_¶
    

__init__(_func_ , _*_ , _vvar_id_start_ , _max_calls_in_regions =2_, _minimize_copies_for_regions =True_, _scratch =None_, _** kwargs_)¶
    

Parameters:
    

  * **vvar_id_start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **max_calls_in_regions** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **minimize_copies_for_regions** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **scratch** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]__|__None_)

_class _angr.analyses.decompiler.optimization_passes.ReturnDuplicatorLow(_func_ , _max_opt_iters =4_, _max_calls_in_regions =2_, _prevent_new_gotos =True_, _minimize_copies_for_regions =True_, _region_identifier =None_, _vvar_id_start =None_, _scratch =None_, _max_func_blocks =500_, _** kwargs_)¶
    

Bases: `StructuringOptimizationPass`, `ReturnDuplicatorBase`

An optimization pass that reverts a subset of Irreducible Statement Condensing (ISC) optimizations, as described in the USENIX 2024 paper SAILR. This is the heavy/goto version of the ReturnDuplicator optimization pass.

Some compilers, including GCC, Clang, and MSVC, apply various optimizations to reduce the number of statements in code. These optimizations will take equivalent statements, or a subset of them, and replace them with a single copy that is jumped to by gotos – optimizing for space and sometimes speed.

This optimization pass will revert those gotos by re-duplicating the condensed blocks. Since Return statements are the most common, we use this optimization pass to revert only gotos to return statements. Additionally, we perform some additional readability fixups, like not re-duplicating returns to shared components.

Parameters:
    

  * **func** – The function to optimize.

  * **node_idx_start** – The index to start at when creating new nodes. This is used by Clinic to ensure that node indices are unique across multiple passes.

  * **max_opt_iters** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The maximum number of optimization iterations to perform.

  * **max_calls_in_regions** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The maximum number of calls that can be in a region. This is used to prevent duplicating too much code.

  * **prevent_new_gotos** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If True, this optimization pass will prevent new gotos from being created.

  * **minimize_copies_for_regions** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If True, this optimization pass will minimize the number of copies by doing only a single copy for connected in_edges that form a region.

  * **vvar_id_start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **scratch** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__Any_ _]__|__None_)

  * **max_func_blocks** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

ARCHES _ = None_¶
    

PLATFORMS _ = None_¶
    

NAME _ = 'Duplicate returns connect with gotos (low)'_¶
    

DESCRIPTION _ = 'An optimization pass that reverts a subset of Irreducible Statement Condensing (ISC) optimizations, as described\nin the USENIX 2024 paper SAILR. This is the heavy/goto version of the ReturnDuplicator optimization pass.\n\nSome compilers, including GCC, Clang, and MSVC, apply various optimizations to reduce the number of statements in\ncode. These optimizations will take equivalent statements, or a subset of them, and replace them with a single\ncopy that is jumped to by gotos \-- optimizing for space and sometimes speed.\n\nThis optimization pass will revert those gotos by re-duplicating the condensed blocks. Since Return statements\nare the most common, we use this optimization pass to revert only gotos to return statements. Additionally, we\nperform some additional readability fixups, like not re-duplicating returns to shared components.'_¶
    

__init__(_func_ , _max_opt_iters =4_, _max_calls_in_regions =2_, _prevent_new_gotos =True_, _minimize_copies_for_regions =True_, _region_identifier =None_, _vvar_id_start =None_, _scratch =None_, _max_func_blocks =500_, _** kwargs_)¶
    

Parameters:
    

  * **max_opt_iters** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **max_calls_in_regions** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **prevent_new_gotos** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **minimize_copies_for_regions** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **vvar_id_start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **scratch** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]__|__None_)

  * **max_func_blocks** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_class _angr.analyses.decompiler.optimization_passes.StackCanarySimplifier(_func_ , _** kwargs_)¶
    

Bases: `OptimizationPass`

Removes stack canary checks from decompilation results.

ARCHES _ = ['X86', 'AMD64']_¶
    

PLATFORMS _ = ['cgc', 'linux']_¶
    

STAGE _: OptimizationPassStage_ _ = 5_¶
    

NAME _ = 'Simplify stack canaries'_¶
    

DESCRIPTION _ = 'Removes stack canary checks from decompilation results.'_¶
    

__init__(_func_ , _** kwargs_)¶
    

_class _angr.analyses.decompiler.optimization_passes.SwitchDefaultCaseDuplicator(_func_ , _** kwargs_)¶
    

Bases: `OptimizationPass`

For each switch-case construct (identified by jump tables), duplicate the default-case node when we detect situations where the default-case node is seemingly reused by edges outside the switch-case construct. This code reuse is usually caused by compiler code deduplication.

Ideally this pass should be implemented as an ISC optimization reversion.

ARCHES _ = None_¶
    

PLATFORMS _ = None_¶
    

STAGE _: OptimizationPassStage_ _ = 0_¶
    

NAME _ = 'Duplicate default-case nodes to undo default-case node reuse caused by compiler code deduplication'_¶
    

DESCRIPTION _ = 'For each switch-case construct (identified by jump tables), duplicate the default-case node when we detect\n situations where the default-case node is seemingly reused by edges outside the switch-case construct. This code\n reuse is usually caused by compiler code deduplication.\n\n Ideally this pass should be implemented as an ISC optimization reversion.'_¶
    

__init__(_func_ , _** kwargs_)¶
    

_class _angr.analyses.decompiler.optimization_passes.SwitchReusedEntryRewriter(_func_ , _** kwargs_)¶
    

Bases: `OptimizationPass`

For each switch-case construct (identified by jump tables), rewrite the entry into a goto block when we detect situations where an entry node is reused by edges in switch-case constructs that are not the current one. This code reuse is usually caused by compiler code deduplication.

ARCHES _ = None_¶
    

PLATFORMS _ = None_¶
    

STAGE _: OptimizationPassStage_ _ = 0_¶
    

NAME _ = 'Rewrite switch-case entry nodes with multiple predecessors into goto statements.'_¶
    

DESCRIPTION _ = 'For each switch-case construct (identified by jump tables), rewrite the entry into a goto block when we detect\n situations where an entry node is reused by edges in switch-case constructs that are not the current one. This code\n reuse is usually caused by compiler code deduplication.'_¶
    

__init__(_func_ , _** kwargs_)¶
    

_class _angr.analyses.decompiler.optimization_passes.TagSlicer(_func_ , _** kwargs_)¶
    

Bases: `OptimizationPass`

Removes unmarked statements from the graph.

ARCHES _ = None_¶
    

PLATFORMS _ = None_¶
    

STAGE _: OptimizationPassStage_ _ = 7_¶
    

NAME _ = 'Remove unmarked statements from the graph.'_¶
    

DESCRIPTION _ = 'Removes unmarked statements from the graph.'_¶
    

__init__(_func_ , _** kwargs_)¶
    

_class _angr.analyses.decompiler.optimization_passes.WinStackCanarySimplifier(_func_ , _** kwargs_)¶
    

Bases: `OptimizationPass`

Removes stack canary checks from decompilation results for Windows PE files.

we need to run this pass before performing any full-function simplification. Otherwise the effects of _security_cookie will be propagated.

ARCHES _ = ['X86', 'AMD64']_¶
    

PLATFORMS _ = ['windows']_¶
    

STAGE _: OptimizationPassStage_ _ = 2_¶
    

NAME _ = 'Simplify stack canaries in Windows PE files'_¶
    

DESCRIPTION _ = 'Removes stack canary checks from decompilation results for Windows PE files.\n\n we need to run this pass before performing any full-function simplification. Otherwise the effects of\n _security_cookie will be propagated.'_¶
    

__init__(_func_ , _** kwargs_)¶
    

_class _angr.analyses.decompiler.optimization_passes.X86GccGetPcSimplifier(_func_ , _** kwargs_)¶
    

Bases: `OptimizationPass`

Simplifies __x86.get_pc_thunk calls.

ARCHES _ = ['X86']_¶
    

PLATFORMS _ = ['linux']_¶
    

STAGE _: OptimizationPassStage_ _ = 1_¶
    

NAME _ = 'Simplify getpc()'_¶
    

DESCRIPTION _ = 'Simplifies __x86.get_pc_thunk calls.'_¶
    

__init__(_func_ , _** kwargs_)¶
    

angr.analyses.decompiler.optimization_passes.get_optimization_passes(_arch_ , _platform_)¶
    

angr.analyses.decompiler.optimization_passes.register_optimization_pass(_opt_pass_ , _*_ , _presets =None_)¶
    

Parameters:
    

**presets** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__DecompilationPreset_ _]__|__None_)

_class _angr.analyses.decompiler.optimization_passes.const_derefs.BlockWalker(_project_)¶
    

Bases: `AILBlockWalker`

Parameters:
    

**project** (_Project_)

__init__(_project_)¶
    

Parameters:
    

**project** (_Project_)

walk(_block_)¶
    

Walk the block and rebuild it if necessary. The block will be rebuilt in-place (by updating statements in the original block when self._update_block is set to True), or a new block will be created and returned.

Parameters:
    

**block** (`Block`) – The block to walk.

Returns:
    

The new block that is rebuilt, or None if the block is not changed or when self._update_block is set to True.

_class _angr.analyses.decompiler.optimization_passes.const_derefs.ConstantDereferencesSimplifier(_func_ , _** kwargs_)¶
    

Bases: `OptimizationPass`

Makes the following simplifications:
    
    
    *(*(const_addr))  ==>  *(value) iff  *const_addr == value
    

ARCHES _ = None_¶
    

PLATFORMS _ = None_¶
    

STAGE _: OptimizationPassStage_ _ = 2_¶
    

NAME _ = 'Simplify constant dereferences'_¶
    

DESCRIPTION _ = 'Makes the following simplifications::\n\n *(*(const_addr)) ==> *(value) iff *const_addr == value'_¶
    

__init__(_func_ , _** kwargs_)¶
    

entry_node_addr _: tuple[int, int | None]_¶
    

out_graph _: networkx.DiGraph | None_¶
    

stack_items _: dict[int, StackItem]_¶
    

_class _angr.analyses.decompiler.optimization_passes.optimization_pass.BlockCache(_rd_ , _prop_)¶
    

Bases: [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

prop¶
    

Alias for field number 1

rd¶
    

Alias for field number 0

_exception _angr.analyses.decompiler.optimization_passes.optimization_pass.MultipleBlocksException¶
    

Bases: [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception "\(in Python v3.13\)")

An exception that is raised in _get_block() where multiple blocks satisfy the criteria but only one block was requested.

_class _angr.analyses.decompiler.optimization_passes.optimization_pass.OptimizationPassStage(_value_)¶
    

Bases: [`Enum`](https://docs.python.org/3/library/enum.html#enum.Enum "\(in Python v3.13\)")

Enums about optimization pass stages.

Note that the region identification pass (RegionIdentifier) may modify existing AIL blocks _without updating the topology of the original AIL graph_. For example, loop successor refinement may modify create a new AIL block with an artificial address, and alter existing jump targets of jump statements and conditional jump statements to point to this new block. However, loop successor refinement does not update the topology of the original AIL graph, which means this new AIL block does not exist in the original AIL graph. As a result, until this behavior of RegionIdentifier changes in the future, DURING_REGION_IDENTIFICATION optimization passes should not modify existing jump targets.

AFTER_AIL_GRAPH_CREATION _ = 0_¶
    

BEFORE_SSA_LEVEL0_TRANSFORMATION _ = 1_¶
    

AFTER_SINGLE_BLOCK_SIMPLIFICATION _ = 2_¶
    

BEFORE_SSA_LEVEL1_TRANSFORMATION _ = 3_¶
    

AFTER_MAKING_CALLSITES _ = 4_¶
    

AFTER_GLOBAL_SIMPLIFICATION _ = 5_¶
    

BEFORE_VARIABLE_RECOVERY _ = 6_¶
    

AFTER_VARIABLE_RECOVERY _ = 7_¶
    

BEFORE_REGION_IDENTIFICATION _ = 8_¶
    

DURING_REGION_IDENTIFICATION _ = 9_¶
    

AFTER_STRUCTURING _ = 10_¶
    

_class _angr.analyses.decompiler.optimization_passes.optimization_pass.BaseOptimizationPass(_func_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

The base class for any optimization pass.

ARCHES _ = []_¶
    

PLATFORMS _ = []_¶
    

STAGE _: `OptimizationPassStage`_¶
    

STRUCTURING _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

NAME _ = 'N/A'_¶
    

DESCRIPTION _ = 'N/A'_¶
    

__init__(_func_)¶
    

_property _project _: Project_¶
    

_property _kb¶
    

analyze()¶
    

_class _angr.analyses.decompiler.optimization_passes.optimization_pass.OptimizationPass(_func_ , _*_ , _graph_ , _blocks_by_addr =None_, _blocks_by_addr_and_idx =None_, _variable_kb =None_, _region_identifier =None_, _reaching_definitions =None_, _vvar_id_start =0_, _entry_node_addr =None_, _scratch =None_, _force_loop_single_exit =True_, _complete_successors =False_, _avoid_vvar_ids =None_, _arg_vvars =None_, _peephole_optimizations =None_, _stack_pointer_tracker =None_, _** kwargs_)¶
    

Bases: `BaseOptimizationPass`

The base class for any function-level graph optimization pass.

Parameters:
    

  * **vvar_id_start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **scratch** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__Any_ _]__|__None_)

  * **force_loop_single_exit** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **complete_successors** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **avoid_vvar_ids** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **arg_vvars** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

__init__(_func_ , _*_ , _graph_ , _blocks_by_addr =None_, _blocks_by_addr_and_idx =None_, _variable_kb =None_, _region_identifier =None_, _reaching_definitions =None_, _vvar_id_start =0_, _entry_node_addr =None_, _scratch =None_, _force_loop_single_exit =True_, _complete_successors =False_, _avoid_vvar_ids =None_, _arg_vvars =None_, _peephole_optimizations =None_, _stack_pointer_tracker =None_, _** kwargs_)¶
    

Parameters:
    

  * **vvar_id_start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **scratch** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]__|__None_)

  * **force_loop_single_exit** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **complete_successors** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **avoid_vvar_ids** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **arg_vvars** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

_property _blocks_by_addr _: [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [set](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[Block]]_¶
    

_property _blocks_by_addr_and_idx _: [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")], Block]_¶
    

bfs_nodes(_depth =None_, _start_node =None_)¶
    

Return type:
    

[`Generator`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Generator "\(in Python v3.13\)")[`Block`]

Parameters:
    

  * **depth** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **start_node** (_Block_ _|__None_)

new_block_addr()¶
    

Return a block address that does not conflict with any existing blocks.

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

Returns:
    

The block address.

_class _angr.analyses.decompiler.optimization_passes.optimization_pass.SequenceOptimizationPass(_func_ , _seq =None_, _** kwargs_)¶
    

Bases: `BaseOptimizationPass`

The base class for any sequence node optimization pass.

__init__(_func_ , _seq =None_, _** kwargs_)¶
    

_class _angr.analyses.decompiler.optimization_passes.optimization_pass.StructuringOptimizationPass(_func_ , _require_structurable_graph =True_, _prevent_new_gotos =True_, _strictly_less_gotos =False_, _recover_structure_fails =True_, _must_improve_rel_quality =True_, _max_opt_iters =1_, _simplify_ail =True_, _require_gotos =True_, _readd_labels =False_, _edges_to_remove =None_, _** kwargs_)¶
    

Bases: `OptimizationPass`

The base class for any optimization pass that requires structuring. Optimization passes that inherit from this class should directly depend on structuring artifacts, such as regions and gotos. Otherwise, they should use OptimizationPass. This is the heaviest (computation time) optimization pass class.

By default this type of optimization should work: \- on any architecture \- on any platform \- during region identification (to have iterative structuring) \- only with the SAILR structuring algorithm

Parameters:
    

  * **require_structurable_graph** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **prevent_new_gotos** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **strictly_less_gotos** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **recover_structure_fails** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **must_improve_rel_quality** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **max_opt_iters** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **simplify_ail** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **require_gotos** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **readd_labels** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **edges_to_remove** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_ _]__,_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_ _]__]__]__|__None_)

ARCHES _ = None_¶
    

PLATFORMS _ = None_¶
    

STRUCTURING _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = ['sailr']_¶
    

STAGE _: `OptimizationPassStage`_ _ = 9_¶
    

__init__(_func_ , _require_structurable_graph =True_, _prevent_new_gotos =True_, _strictly_less_gotos =False_, _recover_structure_fails =True_, _must_improve_rel_quality =True_, _max_opt_iters =1_, _simplify_ail =True_, _require_gotos =True_, _readd_labels =False_, _edges_to_remove =None_, _** kwargs_)¶
    

Parameters:
    

  * **require_structurable_graph** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **prevent_new_gotos** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **strictly_less_gotos** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **recover_structure_fails** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **must_improve_rel_quality** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **max_opt_iters** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **simplify_ail** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **require_gotos** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **readd_labels** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **edges_to_remove** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_ _]__,_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_ _]__]__]__|__None_)

analyze()¶
    

Wrapper for _analyze() that verifies the graph is structurable before and after the optimization.

_class _angr.analyses.decompiler.optimization_passes.stack_canary_simplifier.StackCanarySimplifier(_func_ , _** kwargs_)¶
    

Bases: `OptimizationPass`

Removes stack canary checks from decompilation results.

ARCHES _ = ['X86', 'AMD64']_¶
    

PLATFORMS _ = ['cgc', 'linux']_¶
    

STAGE _: OptimizationPassStage_ _ = 5_¶
    

NAME _ = 'Simplify stack canaries'_¶
    

DESCRIPTION _ = 'Removes stack canary checks from decompilation results.'_¶
    

__init__(_func_ , _** kwargs_)¶
    

entry_node_addr _: tuple[int, int | None]_¶
    

out_graph _: networkx.DiGraph | None_¶
    

stack_items _: dict[int, StackItem]_¶
    

_class _angr.analyses.decompiler.optimization_passes.base_ptr_save_simplifier.BasePointerSaveSimplifier(_func_ , _** kwargs_)¶
    

Bases: `OptimizationPass`

Removes the effects of base pointer stack storage at function invocation and restoring at function return.

ARCHES _ = ['X86', 'AMD64', 'ARMEL', 'ARMHF', 'ARMCortexM', 'MIPS32', 'MIPS64']_¶
    

PLATFORMS _ = None_¶
    

STAGE _: OptimizationPassStage_ _ = 5_¶
    

NAME _ = 'Simplify base pointer saving'_¶
    

DESCRIPTION _ = 'Removes the effects of base pointer stack storage at function invocation and restoring at function return.'_¶
    

__init__(_func_ , _** kwargs_)¶
    

entry_node_addr _: tuple[int, int | None]_¶
    

out_graph _: networkx.DiGraph | None_¶
    

stack_items _: dict[int, StackItem]_¶
    

_class _angr.analyses.decompiler.optimization_passes.div_simplifier.DivSimplifierAILEngine(_* args_, _** kwargs_)¶
    

Bases: `SimplifierAILEngine`

An AIL pass for the div simplifier

_class _angr.analyses.decompiler.optimization_passes.div_simplifier.DivSimplifier(_func_ , _** kwargs_)¶
    

Bases: `OptimizationPass`

Simplifies various division optimizations back to “div”.

ARCHES _ = ['X86', 'AMD64', 'ARMCortexM', 'ARMHF', 'ARMEL']_¶
    

PLATFORMS _ = None_¶
    

STAGE _: OptimizationPassStage_ _ = 5_¶
    

NAME _ = 'Simplify arithmetic division'_¶
    

DESCRIPTION _ = 'Simplifies various division optimizations back to "div".'_¶
    

__init__(_func_ , _** kwargs_)¶
    

entry_node_addr _: tuple[int, int | None]_¶
    

out_graph _: networkx.DiGraph | None_¶
    

stack_items _: dict[int, StackItem]_¶
    

_exception _angr.analyses.decompiler.optimization_passes.ite_expr_converter.NodeFoundNotification¶
    

Bases: [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception "\(in Python v3.13\)")

A notification that the target node has been found.

_class _angr.analyses.decompiler.optimization_passes.ite_expr_converter.BlockLocator(_block_)¶
    

Bases: `RegionWalker`

Recursively locate block in a GraphRegion instance.

It might be reasonable to move this class into its own file.

__init__(_block_)¶
    

walk_node(_region_ , _node_)¶
    

_class _angr.analyses.decompiler.optimization_passes.ite_expr_converter.ExpressionReplacer(_block_addr_ , _target_expr_ , _callback_)¶
    

Bases: `AILBlockWalker`

Replace expressions.

__init__(_block_addr_ , _target_expr_ , _callback_)¶
    

_class _angr.analyses.decompiler.optimization_passes.ite_expr_converter.ITEExprConverter(_func_ , _ite_exprs =None_, _** kwargs_)¶
    

Bases: `OptimizationPass`

Transform specific expressions into If-Then-Else expressions, or tertiary expressions in C when given a single-use expression address. Requires outside analysis to provide the target expressions.

ARCHES _ = ['X86', 'AMD64', 'ARMEL', 'ARMHF', 'ARMCortexM', 'MIPS32', 'MIPS64']_¶
    

PLATFORMS _ = ['windows', 'linux', 'cgc']_¶
    

STAGE _: OptimizationPassStage_ _ = 9_¶
    

NAME _ = 'Transform single-use expressions that were assigned to in different If-Else branches into ternary expressions'_¶
    

DESCRIPTION _ = 'Transform specific expressions into If-Then-Else expressions, or tertiary expressions in C when\n given a single-use expression address. Requires outside analysis to provide the target expressions.'_¶
    

__init__(_func_ , _ite_exprs =None_, _** kwargs_)¶
    

entry_node_addr _: tuple[int, int | None]_¶
    

out_graph _: networkx.DiGraph | None_¶
    

stack_items _: dict[int, StackItem]_¶
    

_class _angr.analyses.decompiler.optimization_passes.lowered_switch_simplifier.Case(_original_node_ , _node_type_ , _variable_hash_ , _expr_ , _value_ , _target_ , _target_idx_ , _next_addr_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Describes a case in a switch-case construct.

Parameters:
    

  * **node_type** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **value** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **target_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_original_node_ , _node_type_ , _variable_hash_ , _expr_ , _value_ , _target_ , _target_idx_ , _next_addr_)¶
    

Parameters:
    

  * **node_type** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **value** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **target_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

original_node¶
    

node_type¶
    

variable_hash¶
    

expr¶
    

value¶
    

target¶
    

target_idx¶
    

next_addr¶
    

_class _angr.analyses.decompiler.optimization_passes.lowered_switch_simplifier.StableVarExprHasher(_expr_)¶
    

Bases: `AILBlockWalkerBase`

Obtain a stable hash of an AIL expression with respect to all variables and all operations applied on variables.

Parameters:
    

**expr** (_Expression_)

__init__(_expr_)¶
    

Parameters:
    

**expr** (_Expression_)

_class _angr.analyses.decompiler.optimization_passes.lowered_switch_simplifier.LoweredSwitchSimplifier(_func_ , _min_distinct_cases =2_, _** kwargs_)¶
    

Bases: `StructuringOptimizationPass`

This optimization recognizes and reverts switch cases that have been lowered and possibly split into multiple if-else statements. This optimization, discussed in the USENIX 2024 paper SAILR, aims to undo the compiler optimization known as “Switch Lowering”, present in both GCC and Clang. An in-depth discussion of this optimization can be found in the paper or in our documentation of the optimization: <https://github.com/mahaloz/sailr-eval/issues/14#issue-2232616411>

Note, this optimization does not occur in MSVC, which uses a different optimization strategy for switch cases. As a hack for now, we only run this deoptimization on Linux binaries.

PLATFORMS _ = ['linux']_¶
    

NAME _ = 'Convert lowered switch-cases (if-else) to switch-cases'_¶
    

DESCRIPTION _ = 'Convert lowered switch-cases (if-else) to switch-cases. Only works when the Phoenix structuring algorithm is in use.'_¶
    

__init__(_func_ , _min_distinct_cases =2_, _** kwargs_)¶
    

_static _restore_graph(_node_ , _last_stmt_ , _graph_ , _full_graph_)¶
    

Parameters:
    

  * **last_stmt** (_IncompleteSwitchCaseHeadStatement_)

  * **graph** (_DiGraph_)

  * **full_graph** (_DiGraph_)

_static _cases_issubset(_cases_0_ , _cases_1_)¶
    

Test if cases_0 is a subset of cases_1.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

  * **cases_0** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__Case_ _]_)

  * **cases_1** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__Case_ _]_)

entry_node_addr _: tuple[int, int | None]_¶
    

out_graph _: networkx.DiGraph | None_¶
    

stack_items _: dict[int, StackItem]_¶
    

_class _angr.analyses.decompiler.optimization_passes.mod_simplifier.ModSimplifierAILEngine(_* args_, _** kwargs_)¶
    

Bases: `SimplifierAILEngine`

_class _angr.analyses.decompiler.optimization_passes.mod_simplifier.ModSimplifier(_func_ , _** kwargs_)¶
    

Bases: `OptimizationPass`

Simplifies optimized forms of modulo computation back to “mod”.

ARCHES _ = ['X86', 'AMD64', 'ARMCortexM', 'ARMHF', 'ARMEL']_¶
    

PLATFORMS _ = ['linux', 'windows']_¶
    

STAGE _: OptimizationPassStage_ _ = 5_¶
    

NAME _ = 'Simplify optimized mod forms'_¶
    

DESCRIPTION _ = 'Simplifies optimized forms of modulo computation back to "mod".'_¶
    

__init__(_func_ , _** kwargs_)¶
    

entry_node_addr _: tuple[int, int | None]_¶
    

out_graph _: networkx.DiGraph | None_¶
    

stack_items _: dict[int, StackItem]_¶
    

_class _angr.analyses.decompiler.optimization_passes.engine_base.SimplifierAILState(_arch_ , _variables =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

The abstract state used in SimplifierAILEngine.

__init__(_arch_ , _variables =None_)¶
    

copy()¶
    

merge(_* others_)¶
    

store_variable(_old_ , _new_)¶
    

Parameters:
    

**old** (_VirtualVariable_)

get_variable(_old_)¶
    

Parameters:
    

**old** (_VirtualVariable_)

remove_variable(_old_)¶
    

_class _angr.analyses.decompiler.optimization_passes.engine_base.SimplifierAILEngine(_* args_, _** kwargs_)¶
    

Bases: `SimEngineLightAIL`[`SimplifierAILState`, `Expression`, `Statement`, `Block`]

Essentially implements a peephole optimization engine for AIL statements (because we do not perform memory or register loads).

_class _angr.analyses.decompiler.optimization_passes.expr_op_swapper.OuterWalker(_desc_)¶
    

Bases: `SequenceWalker`

A sequence walker that finds nodes and invokes expression replacer to replace expressions.

__init__(_desc_)¶
    

_class _angr.analyses.decompiler.optimization_passes.expr_op_swapper.ExpressionReplacer(_block_addr_ , _target_expr_predicate_ , _callback_)¶
    

Bases: `AILBlockWalker`

Replace expressions.

__init__(_block_addr_ , _target_expr_predicate_ , _callback_)¶
    

_class _angr.analyses.decompiler.optimization_passes.expr_op_swapper.OpDescriptor(_block_addr_ , _stmt_idx_ , _ins_addr_ , _op_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Describes a specific operator.

Parameters:
    

  * **block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **op** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

__init__(_block_addr_ , _stmt_idx_ , _ins_addr_ , _op_)¶
    

Parameters:
    

  * **block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **op** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.analyses.decompiler.optimization_passes.expr_op_swapper.ExprOpSwapper(_func_ , _binop_operators =None_, _** kwargs_)¶
    

Bases: `SequenceOptimizationPass`

Swap operands (and the operator accordingly) in a BinOp expression.

Parameters:
    

**binop_operators** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__OpDescriptor_ _,_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

ARCHES _ = ['X86', 'AMD64', 'ARMEL', 'ARMHF', 'ARMCortexM', 'MIPS32', 'MIPS64']_¶
    

PLATFORMS _ = ['windows', 'linux', 'cgc']_¶
    

STAGE _: OptimizationPassStage_ _ = 10_¶
    

NAME _ = 'Swap operands of expressions as requested'_¶
    

DESCRIPTION _ = 'Swap operands (and the operator accordingly) in a BinOp expression.'_¶
    

__init__(_func_ , _binop_operators =None_, _** kwargs_)¶
    

Parameters:
    

**binop_operators** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__OpDescriptor_ _,_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

_class _angr.analyses.decompiler.optimization_passes.register_save_area_simplifier.RegisterSaveAreaSimplifier(_func_ , _** kwargs_)¶
    

Bases: `OptimizationPass`

Optimizes away register spilling effects, including callee-saved registers.

This optimization runs between SSA-level0 and SSA-level1, which means registers are converted to vvars but stack accesses stay unchanged.

ARCHES _ = None_¶
    

PLATFORMS _ = None_¶
    

STAGE _: OptimizationPassStage_ _ = 2_¶
    

NAME _ = 'Simplify register save areas'_¶
    

DESCRIPTION _ = 'Optimizes away register spilling effects, including callee-saved registers.\n\n This optimization runs between SSA-level0 and SSA-level1, which means registers are converted to vvars but stack\n accesses stay unchanged.'_¶
    

__init__(_func_ , _** kwargs_)¶
    

entry_node_addr _: tuple[int, int | None]_¶
    

out_graph _: networkx.DiGraph | None_¶
    

stack_items _: dict[int, StackItem]_¶
    

_class _angr.analyses.decompiler.optimization_passes.ret_addr_save_simplifier.RetAddrSaveSimplifier(_func_ , _** kwargs_)¶
    

Bases: `OptimizationPass`

Removes code in function prologues and epilogues for saving and restoring return address registers (ra, lr, etc.), generally seen in non-leaf functions.

ARCHES _ = ['MIPS32', 'MIPS64']_¶
    

PLATFORMS _ = ['linux']_¶
    

STAGE _: OptimizationPassStage_ _ = 5_¶
    

NAME _ = 'Simplify return address storage'_¶
    

DESCRIPTION _ = 'Removes code in function prologues and epilogues for saving and restoring return address registers (ra, lr, etc.),\n generally seen in non-leaf functions.'_¶
    

__init__(_func_ , _** kwargs_)¶
    

entry_node_addr _: tuple[int, int | None]_¶
    

out_graph _: networkx.DiGraph | None_¶
    

stack_items _: dict[int, StackItem]_¶
    

_class _angr.analyses.decompiler.optimization_passes.x86_gcc_getpc_simplifier.X86GccGetPcSimplifier(_func_ , _** kwargs_)¶
    

Bases: `OptimizationPass`

Simplifies __x86.get_pc_thunk calls.

ARCHES _ = ['X86']_¶
    

PLATFORMS _ = ['linux']_¶
    

STAGE _: OptimizationPassStage_ _ = 1_¶
    

NAME _ = 'Simplify getpc()'_¶
    

DESCRIPTION _ = 'Simplifies __x86.get_pc_thunk calls.'_¶
    

__init__(_func_ , _** kwargs_)¶
    

entry_node_addr _: tuple[int, int | None]_¶
    

out_graph _: networkx.DiGraph | None_¶
    

stack_items _: dict[int, StackItem]_¶
    

_class _angr.analyses.decompiler.peephole_optimizations.base.PeepholeOptimizationStmtBase(_project_ , _kb_ , _func_addr =None_, _preserve_vvar_ids =None_, _type_hints =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

The base class for all peephole optimizations that are applied on AIL statements.

Parameters:
    

  * **project** (_Project_ _|__None_)

  * **kb** (_KnowledgeBase_ _|__None_)

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **preserve_vvar_ids** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]_)

  * **type_hints** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__VirtualVariable_ _|__MemoryLocation_ _,_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__]_)

NAME _ = 'Peephole Optimization - Statement'_¶
    

DESCRIPTION _ = 'Peephole Optimization - Statement'_¶
    

stmt_classes _ = None_¶
    

__init__(_project_ , _kb_ , _func_addr =None_, _preserve_vvar_ids =None_, _type_hints =None_)¶
    

Parameters:
    

  * **project** (_Project_ _|__None_)

  * **kb** (_KnowledgeBase_ _|__None_)

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **preserve_vvar_ids** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **type_hints** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__VirtualVariable_ _|__MemoryLocation_ _,_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__]__|__None_)

project _: `Project` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

kb _: `KnowledgeBase` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

func_addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

preserve_vvar_ids _: [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]_¶
    

type_hints _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`VirtualVariable` | `MemoryLocation`, [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]]_¶
    

optimize(_stmt_ , _stmt_idx =None_, _block =None_, _** kwargs_)¶
    

Parameters:
    

**stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

_class _angr.analyses.decompiler.peephole_optimizations.base.PeepholeOptimizationMultiStmtBase(_project_ , _kb_ , _func_addr =None_, _preserve_vvar_ids =None_, _type_hints =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

The base class for all peephole optimizations that are applied on multiple AIL statements at once.

Parameters:
    

  * **project** (_Project_ _|__None_)

  * **kb** (_KnowledgeBase_ _|__None_)

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **preserve_vvar_ids** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]_)

  * **type_hints** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__VirtualVariable_ _|__MemoryLocation_ _,_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__]_)

NAME _ = 'Peephole Optimization - Multi-statement'_¶
    

DESCRIPTION _ = 'Peephole Optimization - Multi-statement'_¶
    

stmt_classes _ = None_¶
    

__init__(_project_ , _kb_ , _func_addr =None_, _preserve_vvar_ids =None_, _type_hints =None_)¶
    

Parameters:
    

  * **project** (_Project_ _|__None_)

  * **kb** (_KnowledgeBase_ _|__None_)

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **preserve_vvar_ids** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **type_hints** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__VirtualVariable_ _|__MemoryLocation_ _,_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__]__|__None_)

project _: `Project` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

kb _: `KnowledgeBase` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

func_addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

preserve_vvar_ids _: [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]_¶
    

type_hints _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`VirtualVariable` | `MemoryLocation`, [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]]_¶
    

optimize(_stmts_ , _stmt_idx =None_, _block =None_, _** kwargs_)¶
    

Parameters:
    

  * **stmts** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__Statement_ _]_)

  * **stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

_class _angr.analyses.decompiler.peephole_optimizations.base.PeepholeOptimizationExprBase(_project_ , _kb_ , _func_addr =None_, _preserve_vvar_ids =None_, _type_hints =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

The base class for all peephole optimizations that are applied on AIL expressions.

Parameters:
    

  * **project** (_Project_ _|__None_)

  * **kb** (_KnowledgeBase_ _|__None_)

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **preserve_vvar_ids** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]_)

  * **type_hints** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__VirtualVariable_ _|__MemoryLocation_ _,_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__]_)

NAME _ = 'Peephole Optimization - Expression'_¶
    

DESCRIPTION _ = 'Peephole Optimization - Expression'_¶
    

expr_classes _ = None_¶
    

__init__(_project_ , _kb_ , _func_addr =None_, _preserve_vvar_ids =None_, _type_hints =None_)¶
    

Parameters:
    

  * **project** (_Project_ _|__None_)

  * **kb** (_KnowledgeBase_ _|__None_)

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **preserve_vvar_ids** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **type_hints** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__VirtualVariable_ _|__MemoryLocation_ _,_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__]__|__None_)

project _: `Project` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

kb _: `KnowledgeBase` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

func_addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

preserve_vvar_ids _: [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]_¶
    

type_hints _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`VirtualVariable` | `MemoryLocation`, [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]]_¶
    

optimize(_expr_ , _stmt_idx =None_, _block =None_, _** kwargs_)¶
    

Parameters:
    

**stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

_static _find_definition(_ail_expr_ , _stmt_idx_ , _block_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **ail_expr** (_Expression_)

  * **stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **block** (_Block_)

_static _is_bool_expr(_ail_expr_)¶
    

_class _angr.analyses.decompiler.region_identifier.RegionIdentifier(_func_ , _cond_proc =None_, _graph =None_, _update_graph =True_, _largest_successor_tree_outside_loop =True_, _force_loop_single_exit =True_, _complete_successors =False_, _entry_node_addr =None_)¶
    

Bases: `Analysis`

Identifies regions within a function graph and creates a recursive GraphRegion object. Note, that the analysis may modify the graph in-place. If you want to keep the original graph, set the update_graph parameter to False.

Parameters:
    

**entry_node_addr** ([_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_ _]__|__None_)

__init__(_func_ , _cond_proc =None_, _graph =None_, _update_graph =True_, _largest_successor_tree_outside_loop =True_, _force_loop_single_exit =True_, _complete_successors =False_, _entry_node_addr =None_)¶
    

Parameters:
    

**entry_node_addr** ([_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_ _]__|__None_)

_static _slice_graph(_graph_ , _node_ , _frontier_ , _include_frontier =False_)¶
    

Generate a slice of the graph from the head node to the given frontier.

Parameters:
    

  * **graph** (_networkx.DiGraph_) – The graph to work on.

  * **node** – The starting node in the graph.

  * **frontier** – A list of frontier nodes.

  * **include_frontier** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether the frontier nodes are included in the slice or not.

Returns:
    

A subgraph.

Return type:
    

networkx.DiGraph

test_reducibility()¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.analyses.decompiler.region_simplifiers.RegionSimplifier(_func_ , _region_ , _arg_vvars =None_, _simplify_switches =True_, _simplify_ifelse =True_)¶
    

Bases: `Analysis`

Simplifies a given region.

Parameters:
    

  * **arg_vvars** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **simplify_switches** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **simplify_ifelse** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_func_ , _region_ , _arg_vvars =None_, _simplify_switches =True_, _simplify_ifelse =True_)¶
    

Parameters:
    

  * **arg_vvars** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **simplify_switches** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **simplify_ifelse** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

_class _angr.analyses.decompiler.region_simplifiers.cascading_cond_transformer.CascadingConditionTransformer(_node_)¶
    

Bases: `SequenceWalker`

Identifies and transforms if { … } else { if { … } else { … } } to if { … } else if { … } else if { … }.

__init__(_node_)¶
    

_class _angr.analyses.decompiler.region_simplifiers.cascading_ifs.CascadingIfsRemover(_node_)¶
    

Bases: `SequenceWalker`

Coalesce cascading If constructs. Transforming the following construct:
    
    
    if (cond_a) {
        if (cond_b) {
            true_body
        } else { }
    } else { }
    

into:
    
    
    if (cond_a and cond_b) {
        true_body
    } else { }
    

__init__(_node_)¶
    

_class _angr.analyses.decompiler.region_simplifiers.expr_folding.LocationBase¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

_class _angr.analyses.decompiler.region_simplifiers.expr_folding.StatementLocation(_block_addr_ , _block_idx_ , _stmt_idx_ , _phi_stmt =False_)¶
    

Bases: `LocationBase`

Describes the location of a statement.

Parameters:
    

**phi_stmt** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_block_addr_ , _block_idx_ , _stmt_idx_ , _phi_stmt =False_)¶
    

Parameters:
    

**phi_stmt** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

block_addr¶
    

block_idx¶
    

stmt_idx¶
    

phi_stmt¶
    

copy()¶
    

_class _angr.analyses.decompiler.region_simplifiers.expr_folding.ExpressionLocation(_block_addr_ , _block_idx_ , _stmt_idx_ , _expr_idx_ , _phi_stmt =False_)¶
    

Bases: `LocationBase`

Describes the location of an expression.

Parameters:
    

**phi_stmt** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_block_addr_ , _block_idx_ , _stmt_idx_ , _expr_idx_ , _phi_stmt =False_)¶
    

Parameters:
    

**phi_stmt** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

block_addr¶
    

block_idx¶
    

stmt_idx¶
    

expr_idx¶
    

phi_stmt¶
    

statement_location()¶
    

Return type:
    

`StatementLocation`

_class _angr.analyses.decompiler.region_simplifiers.expr_folding.ConditionLocation(_cond_node_addr_ , _case_idx =None_)¶
    

Bases: `LocationBase`

Describes the location of a condition.

Parameters:
    

**case_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_cond_node_addr_ , _case_idx =None_)¶
    

Parameters:
    

**case_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

node_addr¶
    

case_idx¶
    

_class _angr.analyses.decompiler.region_simplifiers.expr_folding.ConditionalBreakLocation(_node_addr_)¶
    

Bases: `LocationBase`

Describes the location of a conditional break.

__init__(_node_addr_)¶
    

node_addr¶
    

_class _angr.analyses.decompiler.region_simplifiers.expr_folding.LoopNodeFinder(_node_)¶
    

Bases: `SequenceWalker`

Returns all loops in a given region.

Parameters:
    

**node** (_SequenceNode_)

__init__(_node_)¶
    

Parameters:
    

**node** (_SequenceNode_)

_class _angr.analyses.decompiler.region_simplifiers.expr_folding.MultiStatementExpressionAssignmentFinder(_stmt_handler_)¶
    

Bases: `AILBlockWalker`

Process statements in MultiStatementExpression objects and find assignments.

__init__(_stmt_handler_)¶
    

_class _angr.analyses.decompiler.region_simplifiers.expr_folding.ExpressionUseFinder¶
    

Bases: `AILBlockWalker`

Find where each variable is used.

Additionally, determine if the expression being walked has load expressions inside. Such expressions can only be safely folded if there are no Store statements between the expression defining location and its use sites. For example, we can only safely fold variable assignments that use Load() when there are no Store()s between the assignment and its use site. Otherwise, the loaded expression may get updated later by a Store() statement.

Here is a real AIL block:
    
    
    v16 = ((int)v23->field_5) + 1 & 255;
    v23->field_5 = ((char)(((int)v23->field_5) + 1 & 255));
    v13 = printf("Recieved packet %d for connection with %d\n", v16, a0 & 255);
    

In this case, folding v16 into the last printf() expression would be incorrect, since v23->field_5 is updated by the second statement.

__init__()¶
    

uses _: defaultdict[int, set[tuple[Expression, ExpressionLocation | None]]]_¶
    

has_load¶
    

_class _angr.analyses.decompiler.region_simplifiers.expr_folding.ExpressionCounter(_node_)¶
    

Bases: `SequenceWalker`

Find all expressions that are assigned once and only used once.

__init__(_node_)¶
    

_class _angr.analyses.decompiler.region_simplifiers.expr_folding.ExpressionSpotter¶
    

Bases: `VVarUsesCollector`

ExpressionSpotter collects uses of vvars and existence of Call expressions.

__init__()¶
    

_class _angr.analyses.decompiler.region_simplifiers.expr_folding.InterferenceChecker(_assignments_ , _uses_ , _node_)¶
    

Bases: `SequenceWalker`

Detect for every pair of definition (assignment) - use if there is anything that may interfere with the definition.

Interferences may be caused by:

  * another call

  * function return

  * store statements

  * load expressions

  * Condition and CascadingCondition nodes

Parameters:
    

  * **assignments** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__Any_ _]_)

  * **uses** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__Any_ _]_)

__init__(_assignments_ , _uses_ , _node_)¶
    

Parameters:
    

  * **assignments** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]_)

  * **uses** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]_)

_class _angr.analyses.decompiler.region_simplifiers.expr_folding.ExpressionReplacer(_assignments_ , _uses_)¶
    

Bases: `AILBlockWalker`

Parameters:
    

  * **assignments** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__Any_ _]_)

  * **uses** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__Any_ _]_)

__init__(_assignments_ , _uses_)¶
    

Parameters:
    

  * **assignments** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]_)

  * **uses** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]_)

_class _angr.analyses.decompiler.region_simplifiers.expr_folding.ExpressionFolder(_assignments_ , _uses_ , _node_)¶
    

Bases: `SequenceWalker`

Parameters:
    

  * **assignments** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__Any_ _]_)

  * **uses** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__Any_ _]_)

__init__(_assignments_ , _uses_ , _node_)¶
    

Parameters:
    

  * **assignments** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]_)

  * **uses** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]_)

_class _angr.analyses.decompiler.region_simplifiers.expr_folding.StoreStatementFinder(_node_ , _intervals_)¶
    

Bases: `SequenceWalker`

Determine if there are any Store statements between two given statements.

This class overrides _handle_Sequence() and _handle_MultiNode() to ensure they traverse nodes from top to bottom.

Parameters:
    

**intervals** (_Iterable_ _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__StatementLocation_ _,__LocationBase_ _]__]_)

__init__(_node_ , _intervals_)¶
    

Parameters:
    

**intervals** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__StatementLocation_ _,__LocationBase_ _]__]_)

has_store(_start_ , _end_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

  * **start** (_StatementLocation_)

  * **end** (_StatementLocation_)

_class _angr.analyses.decompiler.region_simplifiers.goto.GotoSimplifier(_node_ , _function =None_, _kb =None_)¶
    

Bases: `SequenceWalker`

Remove unnecessary Jump statements. This simplifier also has the side effect of detecting Gotos that can’t be reduced in the structuring and eventual decompilation output. Because of this, when this analysis is run, gotos in decompilation will be detected and stored in the kb.gotos. See the _handle_irreducible_goto function below.

TODO: Move the recording of Gotos outside this function

__init__(_node_ , _function =None_, _kb =None_)¶
    

_class _angr.analyses.decompiler.region_simplifiers.if_.IfSimplifier(_node_)¶
    

Bases: `SequenceWalker`

Remove unnecessary jump or conditional jump statements if they jump to the successor right afterwards.

__init__(_node_)¶
    

_class _angr.analyses.decompiler.region_simplifiers.ifelse.IfElseFlattener(_node_ , _functions_)¶
    

Bases: `SequenceWalker`

Remove unnecessary else branches and make the else node a direct successor of the previous If node if the If node always returns.

__init__(_node_ , _functions_)¶
    

_class _angr.analyses.decompiler.region_simplifiers.loop.LoopSimplifier(_node_ , _functions_)¶
    

Bases: `SequenceWalker`

Simplifies loops.

__init__(_node_ , _functions_)¶
    

_class _angr.analyses.decompiler.region_simplifiers.node_address_finder.NodeAddressFinder(_node_)¶
    

Bases: `SequenceWalker`

Walk the entire node and collect all addresses of nodes.

__init__(_node_)¶
    

_class _angr.analyses.decompiler.region_simplifiers.region_simplifier.RegionSimplifier(_func_ , _region_ , _arg_vvars =None_, _simplify_switches =True_, _simplify_ifelse =True_)¶
    

Bases: `Analysis`

Simplifies a given region.

Parameters:
    

  * **arg_vvars** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **simplify_switches** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **simplify_ifelse** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_func_ , _region_ , _arg_vvars =None_, _simplify_switches =True_, _simplify_ifelse =True_)¶
    

Parameters:
    

  * **arg_vvars** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **simplify_switches** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **simplify_ifelse** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

_class _angr.analyses.decompiler.region_simplifiers.switch_cluster_simplifier.CmpOp(_value_)¶
    

Bases: [`Enum`](https://docs.python.org/3/library/enum.html#enum.Enum "\(in Python v3.13\)")

All supported comparison operators.

LT _ = 0_¶
    

GT _ = 1_¶
    

EQ _ = 2_¶
    

NE _ = 3_¶
    

_class _angr.analyses.decompiler.region_simplifiers.switch_cluster_simplifier.ConditionalRegion(_variable_ , _op_ , _value_ , _node_ , _parent =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Describes a conditional region.

Parameters:
    

  * **op** (_CmpOp_)

  * **value** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **node** (_ConditionNode_ _|__ailment.Block_)

__init__(_variable_ , _op_ , _value_ , _node_ , _parent =None_)¶
    

Parameters:
    

  * **op** (_CmpOp_)

  * **value** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **node** (_ConditionNode_ _|__Block_)

variable¶
    

op¶
    

value¶
    

node¶
    

parent¶
    

_class _angr.analyses.decompiler.region_simplifiers.switch_cluster_simplifier.SwitchCaseRegion(_variable_ , _node_ , _parent =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Describes an already-recovered switch region.

Parameters:
    

**node** (_SwitchCaseNode_)

__init__(_variable_ , _node_ , _parent =None_)¶
    

Parameters:
    

**node** (_SwitchCaseNode_)

variable¶
    

node¶
    

parent¶
    

_class _angr.analyses.decompiler.region_simplifiers.switch_cluster_simplifier.SwitchClusterFinder(_node_)¶
    

Bases: `SequenceWalker`

Find comparisons and switches in order to identify switch clusters.

__init__(_node_)¶
    

_class _angr.analyses.decompiler.region_simplifiers.switch_cluster_simplifier.SwitchClusterReplacer(_region_ , _to_replace_ , _replace_with_)¶
    

Bases: `SequenceWalker`

Replace an identified switch cluster with a newly created SwitchCase node.

__init__(_region_ , _to_replace_ , _replace_with_)¶
    

angr.analyses.decompiler.region_simplifiers.switch_cluster_simplifier.is_simple_jump_node(_node_ , _case_addrs_ , _targets =None_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**targets** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

angr.analyses.decompiler.region_simplifiers.switch_cluster_simplifier.filter_cond_regions(_cond_regions_ , _case_addrs_)¶
    

Remove all conditional regions that cannot be merged into switch(es).

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`ConditionalRegion`]

Parameters:
    

  * **cond_regions** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__ConditionalRegion_ _]_)

  * **case_addrs** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]_)

angr.analyses.decompiler.region_simplifiers.switch_cluster_simplifier.update_switch_case_list(_cases_ , _old_case_id_ , _new_case_id_)¶
    

Update cases in-place. Make new_case_id directly jump to old_case_id.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **cases** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__...__]__,__SequenceNode_ _]__]_)

  * **old_case_id** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__...__]_)

  * **new_case_id** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

angr.analyses.decompiler.region_simplifiers.switch_cluster_simplifier.simplify_switch_clusters(_region_ , _var2condnodes_ , _var2switches_)¶
    

Identify switch clusters and simplify each of them.

Parameters:
    

  * **region** – The region to simplify.

  * **var2condnodes** ([`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"), [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`ConditionalRegion`]]) – A dict that stores the mapping from (potential) switch variables to conditional regions.

  * **var2switches** ([`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"), [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`SwitchCaseRegion`]]) – A dict that stores the mapping from switch variables to switch-case regions.

Returns:
    

None

angr.analyses.decompiler.region_simplifiers.switch_cluster_simplifier.simplify_lowered_switches(_region_ , _var2condnodes_ , _functions_)¶
    

Identify a lowered switch and simplify it into a switch-case if possible.

Parameters:
    

  * **region** (`SequenceNode`) – The region to simplify.

  * **var2condnodes** ([`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"), [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`ConditionalRegion`]]) – A dict that stores the mapping from (potential) switch variables to conditional regions.

Returns:
    

None

angr.analyses.decompiler.region_simplifiers.switch_cluster_simplifier.simplify_lowered_switches_core(_region_ , _var_ , _condnodes_ , _functions_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**region** (_SequenceNode_)

_class _angr.analyses.decompiler.region_simplifiers.switch_cluster_simplifier.FindFirstNodeInSet(_node_set_)¶
    

Bases: `SequenceWalker`

Find the first node out of a set of node appearing in a SequenceNode (and its tree).

Parameters:
    

**node_set** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__BaseNode_ _]_)

__init__(_node_set_)¶
    

Parameters:
    

**node_set** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__BaseNode_ _]_)

_class _angr.analyses.decompiler.region_simplifiers.switch_expr_simplifier.SwitchExpressionSimplifier(_node_)¶
    

Bases: `SequenceWalker`

Identifies switch expressions that adds or minuses a constant, removes the constant from the switch expression, and adjust all case expressions accordingly.

__init__(_node_)¶
    

_class _angr.analyses.decompiler.region_walker.RegionWalker¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A simple traverser class that walks GraphRegion instances.

__init__()¶
    

walk(_region_)¶
    

Parameters:
    

**region** (_GraphRegion_)

walk_node(_region_ , _node_)¶
    

_class _angr.analyses.decompiler.redundant_label_remover.RedundantLabelRemover(_node_ , _jump_targets_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Remove redundant labels.

This optimization pass contains two separate passes. The first pass (self._walker0) finds all redundant labels (e.g., two or more labels for the same location) and records the replacement label for redundant labels in self._new_jump_target. The second pass (self._walker1) removes all redundant labels that (a) are not referenced anywhere (determined by jump_targets), or (b) are deemed replaceable by the first pass.

Parameters:
    

**jump_targets** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_ _]__]_)

__init__(_node_ , _jump_targets_)¶
    

Parameters:
    

**jump_targets** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_ _]__]_)

_class _angr.analyses.decompiler.sequence_walker.SequenceWalker(_handlers =None_, _exception_on_unsupported =False_, _update_seqnode_in_place =True_, _force_forward_scan =False_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Walks a SequenceNode and all its nodes, recursively.

Parameters:
    

**force_forward_scan** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_handlers =None_, _exception_on_unsupported =False_, _update_seqnode_in_place =True_, _force_forward_scan =False_)¶
    

Parameters:
    

**force_forward_scan** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

walk(_sequence_)¶
    

_class _angr.analyses.decompiler.structured_codegen.BaseStructuredCodeGenerator(_flavor =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_flavor =None_)¶
    

reapply_options(_options_)¶
    

regenerate_text()¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

reload_variable_types()¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

_class _angr.analyses.decompiler.structured_codegen.CStructuredCodeGenerator(_func_ , _sequence_ , _indent =0_, _cfg =None_, _variable_kb =None_, _func_args =None_, _binop_depth_cutoff =16_, _show_casts =True_, _braces_on_own_lines =True_, _use_compound_assignments =True_, _show_local_types =True_, _comment_gotos =False_, _cstyle_null_cmp =True_, _flavor =None_, _stmt_comments =None_, _expr_comments =None_, _show_externs =True_, _externs =None_, _const_formats =None_, _show_demangled_name =True_, _show_disambiguated_name =True_, _ail_graph =None_, _simplify_else_scope =True_, _cstyle_ifs =True_, _omit_func_header =False_, _display_block_addrs =False_, _display_vvar_ids =False_, _min_data_addr =4194304_)¶
    

Bases: `BaseStructuredCodeGenerator`, `Analysis`

Parameters:
    

  * **func_args** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__SimVariable_ _]__|__None_)

  * **binop_depth_cutoff** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **min_data_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_func_ , _sequence_ , _indent =0_, _cfg =None_, _variable_kb =None_, _func_args =None_, _binop_depth_cutoff =16_, _show_casts =True_, _braces_on_own_lines =True_, _use_compound_assignments =True_, _show_local_types =True_, _comment_gotos =False_, _cstyle_null_cmp =True_, _flavor =None_, _stmt_comments =None_, _expr_comments =None_, _show_externs =True_, _externs =None_, _const_formats =None_, _show_demangled_name =True_, _show_disambiguated_name =True_, _ail_graph =None_, _simplify_else_scope =True_, _cstyle_ifs =True_, _omit_func_header =False_, _display_block_addrs =False_, _display_vvar_ids =False_, _min_data_addr =4194304_)¶
    

Parameters:
    

  * **func_args** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__SimVariable_ _]__|__None_)

  * **binop_depth_cutoff** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **min_data_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

reapply_options(_options_)¶
    

cleanup()¶
    

Remove existing rendering results.

regenerate_text()¶
    

Re-render text and re-generate all sorts of mapping information.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

RENDER_TYPE¶
    

alias of [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"), `PositionMapping`, `PositionMapping`, `InstructionMapping`, [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"), [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]]

render_text(_cfunc_)¶
    

Return type:
    

RENDER_TYPE

Parameters:
    

**cfunc** (_CFunction_)

reload_variable_types()¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

default_simtype_from_bits(_n_ , _signed =True_)¶
    

Return type:
    

`SimType`

Parameters:
    

  * **n** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **signed** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

_class _angr.analyses.decompiler.structured_codegen.CStructuredCodeWalker¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

handle(_obj_)¶
    

handle_default(_obj_)¶
    

handle_CFunction(_obj_)¶
    

handle_CStatements(_obj_)¶
    

handle_CWhileLoop(_obj_)¶
    

handle_CDoWhileLoop(_obj_)¶
    

handle_CForLoop(_obj_)¶
    

handle_CIfElse(_obj_)¶
    

handle_CIfBreak(_obj_)¶
    

handle_CSwitchCase(_obj_)¶
    

handle_CAssignment(_obj_)¶
    

handle_CFunctionCall(_obj_)¶
    

handle_CReturn(_obj_)¶
    

handle_CGoto(_obj_)¶
    

handle_CIndexedVariable(_obj_)¶
    

handle_CVariableField(_obj_)¶
    

handle_CUnaryOp(_obj_)¶
    

handle_CBinaryOp(_obj_)¶
    

handle_CTypeCast(_obj_)¶
    

handle_CITE(_obj_)¶
    

_class _angr.analyses.decompiler.structured_codegen.DummyStructuredCodeGenerator(_flavor_ , _expr_comments =None_, _stmt_comments =None_, _configuration =None_, _const_formats =None_)¶
    

Bases: `BaseStructuredCodeGenerator`

A dummy structured code generator that only stores user-specified information.

Parameters:
    

**flavor** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

__init__(_flavor_ , _expr_comments =None_, _stmt_comments =None_, _configuration =None_, _const_formats =None_)¶
    

Parameters:
    

**flavor** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.analyses.decompiler.structured_codegen.ImportSourceCode(_function_ , _flavor ='source'_, _source_root =None_, _encoding ='utf-8'_)¶
    

Bases: `BaseStructuredCodeGenerator`, `Analysis`

__init__(_function_ , _flavor ='source'_, _source_root =None_, _encoding ='utf-8'_)¶
    

regenerate_text()¶
    

_class _angr.analyses.decompiler.structured_codegen.InstructionMapping¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__()¶
    

items()¶
    

add_mapping(_ins_addr_ , _posmap_pos_)¶
    

get_nearest_pos(_ins_addr_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_class _angr.analyses.decompiler.structured_codegen.InstructionMappingElement(_ins_addr_ , _posmap_pos_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_ins_addr_ , _posmap_pos_)¶
    

ins_addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

posmap_pos _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.analyses.decompiler.structured_codegen.PositionMapping¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

DUPLICATION_CHECK _ = True_¶
    

__init__()¶
    

items()¶
    

add_mapping(_start_pos_ , _length_ , _obj_)¶
    

get_node(_pos_)¶
    

Parameters:
    

**pos** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_element(_pos_)¶
    

Return type:
    

`PositionMappingElement` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**pos** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_class _angr.analyses.decompiler.structured_codegen.PositionMappingElement(_start_ , _length_ , _obj_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_start_ , _length_ , _obj_)¶
    

start _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

length _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

obj¶
    

_class _angr.analyses.decompiler.structured_codegen.base.PositionMappingElement(_start_ , _length_ , _obj_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Parameters:
    

  * **start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **length** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_start_ , _length_ , _obj_)¶
    

start _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

length _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

obj¶
    

_class _angr.analyses.decompiler.structured_codegen.base.PositionMapping¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

DUPLICATION_CHECK _ = True_¶
    

__init__()¶
    

items()¶
    

add_mapping(_start_pos_ , _length_ , _obj_)¶
    

get_node(_pos_)¶
    

Parameters:
    

**pos** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_element(_pos_)¶
    

Return type:
    

`PositionMappingElement` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**pos** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_class _angr.analyses.decompiler.structured_codegen.base.InstructionMappingElement(_ins_addr_ , _posmap_pos_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Parameters:
    

  * **ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **posmap_pos** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_ins_addr_ , _posmap_pos_)¶
    

ins_addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

posmap_pos _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.analyses.decompiler.structured_codegen.base.InstructionMapping¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__()¶
    

items()¶
    

add_mapping(_ins_addr_ , _posmap_pos_)¶
    

get_nearest_pos(_ins_addr_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_class _angr.analyses.decompiler.structured_codegen.base.BaseStructuredCodeGenerator(_flavor =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_flavor =None_)¶
    

reapply_options(_options_)¶
    

regenerate_text()¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

reload_variable_types()¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

angr.analyses.decompiler.structured_codegen.c.qualifies_for_simple_cast(_ty1_ , _ty2_)¶
    

angr.analyses.decompiler.structured_codegen.c.qualifies_for_implicit_cast(_ty1_ , _ty2_)¶
    

angr.analyses.decompiler.structured_codegen.c.extract_terms(_expr_)¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), `CExpression`]]]

Parameters:
    

**expr** (_CExpression_)

angr.analyses.decompiler.structured_codegen.c.is_machine_word_size_type(_type__ , _arch_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

  * **type_** (_SimType_)

  * **arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)"))

angr.analyses.decompiler.structured_codegen.c.guess_value_type(_value_ , _project_)¶
    

Return type:
    

`SimType` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **value** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **project** (_Project_)

angr.analyses.decompiler.structured_codegen.c.type_equals(_t0_ , _t1_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

  * **t0** (_SimType_)

  * **t1** (_SimType_)

angr.analyses.decompiler.structured_codegen.c.type_to_c_repr_chunks(_ty_ , _name =None_, _name_type =None_, _full =False_, _indent_str =''_)¶
    

Helper generator function to turn a SimType into generated tuples of (C-string, AST node).

Parameters:
    

**ty** (_SimType_)

_class _angr.analyses.decompiler.structured_codegen.c.CConstruct(_codegen_ , _tags =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Represents a program construct in C. Acts as the base class for all other representation constructions.

__init__(_codegen_ , _tags =None_)¶
    

tags¶
    

codegen _: `CStructuredCodeGenerator`_¶
    

c_repr(_indent =0_, _pos_to_node =None_, _pos_to_addr =None_, _addr_to_pos =None_)¶
    

Creates the C representation of the code and displays it by constructing a large string. This function is called by each program function that needs to be decompiled. The map_pos_to_node and map_pos_to_addr act as position maps for the location of each variable and statement to be tracked for later GUI operations. The map_pos_to_addr also contains expressions that are nested inside of statements.

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

_static _indent_str(_indent =0_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CFunction(_addr_ , _name_ , _functy_ , _arg_list_ , _statements_ , _variables_in_use_ , _variable_manager_ , _demangled_name =None_, _show_demangled_name =True_, _omit_header =False_, _** kwargs_)¶
    

Bases: `CConstruct`

Represents a function in C.

Parameters:
    

  * **functy** (_SimTypeFunction_)

  * **arg_list** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__CVariable_ _]_)

__init__(_addr_ , _name_ , _functy_ , _arg_list_ , _statements_ , _variables_in_use_ , _variable_manager_ , _demangled_name =None_, _show_demangled_name =True_, _omit_header =False_, _** kwargs_)¶
    

Parameters:
    

  * **functy** (_SimTypeFunction_)

  * **arg_list** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__CVariable_ _]_)

addr¶
    

name¶
    

functy¶
    

arg_list¶
    

statements¶
    

variables_in_use¶
    

variable_manager _: `VariableManagerInternal`_¶
    

demangled_name¶
    

unified_local_vars _: [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[`SimVariable`, [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`CVariable`, `SimType`]]]_¶
    

show_demangled_name¶
    

omit_header¶
    

get_unified_local_vars()¶
    

Return type:
    

[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[`SimVariable`, [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`CVariable`, `SimType`]]]

variable_list_repr_chunks(_indent =0_)¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

headerless_c_repr_chunks(_indent =0_)¶
    

full_c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CStatement(_tags =None_, _codegen =None_)¶
    

Bases: `CConstruct`

Represents a statement in C.

Parameters:
    

**codegen** (_CStructuredCodeGenerator_)

__init__(_tags =None_, _codegen =None_)¶
    

codegen _: `CStructuredCodeGenerator`_¶
    

tags¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CExpression(_collapsed =False_, _tags =None_, _codegen =None_)¶
    

Bases: `CConstruct`

Base class for C expressions.

Parameters:
    

**codegen** (_CStructuredCodeGenerator_)

__init__(_collapsed =False_, _tags =None_, _codegen =None_)¶
    

collapsed¶
    

_property _type¶
    

set_type(_v_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CStatements(_statements_ , _addr =None_, _** kwargs_)¶
    

Bases: `CStatement`

Represents a sequence of statements in C.

__init__(_statements_ , _addr =None_, _** kwargs_)¶
    

statements¶
    

addr¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CAILBlock(_block_ , _** kwargs_)¶
    

Bases: `CStatement`

Represents a block of AIL statements.

__init__(_block_ , _** kwargs_)¶
    

block¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CLoop(_tags =None_, _codegen =None_)¶
    

Bases: `CStatement`

Represents a loop in C.

Parameters:
    

**codegen** (_CStructuredCodeGenerator_)

_class _angr.analyses.decompiler.structured_codegen.c.CWhileLoop(_condition_ , _body_ , _** kwargs_)¶
    

Bases: `CLoop`

Represents a while loop in C.

__init__(_condition_ , _body_ , _** kwargs_)¶
    

condition¶
    

body¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CDoWhileLoop(_condition_ , _body_ , _** kwargs_)¶
    

Bases: `CLoop`

Represents a do-while loop in C.

__init__(_condition_ , _body_ , _** kwargs_)¶
    

condition¶
    

body¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CForLoop(_initializer_ , _condition_ , _iterator_ , _body_ , _** kwargs_)¶
    

Bases: `CStatement`

Represents a for-loop in C.

__init__(_initializer_ , _condition_ , _iterator_ , _body_ , _** kwargs_)¶
    

initializer¶
    

condition¶
    

iterator¶
    

body¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CIfElse(_condition_and_nodes_ , _else_node =None_, _simplify_else_scope =False_, _cstyle_ifs =True_, _** kwargs_)¶
    

Bases: `CStatement`

Represents an if-else construct in C.

Parameters:
    

**condition_and_nodes** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__CExpression_ _,__CStatement_ _|__None_ _]__]_)

__init__(_condition_and_nodes_ , _else_node =None_, _simplify_else_scope =False_, _cstyle_ifs =True_, _** kwargs_)¶
    

Parameters:
    

**condition_and_nodes** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__CExpression_ _,__CStatement_ _|__None_ _]__]_)

condition_and_nodes¶
    

else_node¶
    

simplify_else_scope¶
    

cstyle_ifs¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CIfBreak(_condition_ , _cstyle_ifs =True_, _** kwargs_)¶
    

Bases: `CStatement`

Represents an if-break statement in C.

__init__(_condition_ , _cstyle_ifs =True_, _** kwargs_)¶
    

condition¶
    

cstyle_ifs¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CBreak(_** kwargs_)¶
    

Bases: `CStatement`

Represents a break statement in C.

__init__(_** kwargs_)¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CContinue(_** kwargs_)¶
    

Bases: `CStatement`

Represents a continue statement in C.

__init__(_** kwargs_)¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CSwitchCase(_switch_ , _cases_ , _default_ , _** kwargs_)¶
    

Bases: `CStatement`

Represents a switch-case statement in C.

__init__(_switch_ , _cases_ , _default_ , _** kwargs_)¶
    

switch¶
    

cases _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")], `CStatements`]]_¶
    

default¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CIncompleteSwitchCase(_head_ , _cases_ , _** kwargs_)¶
    

Bases: `CStatement`

Represents an incomplete switch-case construct; this only appear in the decompilation output when switch-case structuring fails (for whatever reason).

__init__(_head_ , _cases_ , _** kwargs_)¶
    

head¶
    

cases _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), `CStatements`]]_¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CAssignment(_lhs_ , _rhs_ , _** kwargs_)¶
    

Bases: `CStatement`

a = b

__init__(_lhs_ , _rhs_ , _** kwargs_)¶
    

lhs¶
    

rhs¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CFunctionCall(_callee_target_ , _callee_func_ , _args_ , _returning =True_, _ret_expr =None_, _is_expr =False_, _show_demangled_name =True_, _show_disambiguated_name =True_, _prettify_thiscall =True_, _tags =None_, _codegen =None_, _** kwargs_)¶
    

Bases: `CStatement`, `CExpression`

func(arg0, arg1)

Variables:
    

  * **callee_func** (_Function_) – The function getting called.

  * **is_expr** – True if the return value of the function is written to ret_expr; Essentially, ret_expr = call().

Parameters:
    

  * **is_expr** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **show_disambiguated_name** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **prettify_thiscall** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **codegen** (_CStructuredCodeGenerator_)

__init__(_callee_target_ , _callee_func_ , _args_ , _returning =True_, _ret_expr =None_, _is_expr =False_, _show_demangled_name =True_, _show_disambiguated_name =True_, _prettify_thiscall =True_, _tags =None_, _codegen =None_, _** kwargs_)¶
    

Parameters:
    

  * **is_expr** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **show_disambiguated_name** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **prettify_thiscall** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

callee_target¶
    

callee_func _: `Function` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

args¶
    

returning¶
    

ret_expr¶
    

is_expr¶
    

show_demangled_name¶
    

show_disambiguated_name¶
    

prettify_thiscall¶
    

_property _prototype _: SimTypeFunction | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

_property _type¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

Parameters:
    

  * **indent** – Number of whitespace indentation characters.

  * **asexpr** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True if this call is used as an expression (which means we will skip the generation of semicolons and newlines at the end of the call).

_class _angr.analyses.decompiler.structured_codegen.c.CReturn(_retval_ , _** kwargs_)¶
    

Bases: `CStatement`

__init__(_retval_ , _** kwargs_)¶
    

retval¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CGoto(_target_ , _target_idx_ , _** kwargs_)¶
    

Bases: `CStatement`

__init__(_target_ , _target_idx_ , _** kwargs_)¶
    

target _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | `CExpression`_¶
    

target_idx¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CUnsupportedStatement(_stmt_ , _** kwargs_)¶
    

Bases: `CStatement`

A wrapper for unsupported AIL statement.

__init__(_stmt_ , _** kwargs_)¶
    

stmt¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CDirtyStatement(_dirty_ , _** kwargs_)¶
    

Bases: `CExpression`

Parameters:
    

**dirty** (_CDirtyExpression_)

__init__(_dirty_ , _** kwargs_)¶
    

Parameters:
    

**dirty** (_CDirtyExpression_)

dirty¶
    

_property _type¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CLabel(_name_ , _ins_addr_ , _block_idx_ , _** kwargs_)¶
    

Bases: `CStatement`

Represents a label in C code.

Parameters:
    

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **block_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_name_ , _ins_addr_ , _block_idx_ , _** kwargs_)¶
    

Parameters:
    

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **block_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

name¶
    

ins_addr¶
    

block_idx¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CStructField(_struct_type_ , _offset_ , _field_ , _** kwargs_)¶
    

Bases: `CExpression`

Parameters:
    

**struct_type** (_SimStruct_)

__init__(_struct_type_ , _offset_ , _field_ , _** kwargs_)¶
    

Parameters:
    

**struct_type** (_SimStruct_)

struct_type¶
    

offset¶
    

field¶
    

_property _type¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CFakeVariable(_name_ , _ty_ , _** kwargs_)¶
    

Bases: `CExpression`

An uninterpreted name to display in the decompilation output. Pretty much always represents an error?

Parameters:
    

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **ty** (_SimType_)

__init__(_name_ , _ty_ , _** kwargs_)¶
    

Parameters:
    

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **ty** (_SimType_)

name¶
    

_property _type¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CVariable(_variable_ , _unified_variable =None_, _variable_type =None_, _vvar_id =None_, _** kwargs_)¶
    

Bases: `CExpression`

CVariable represents access to a variable with the specified type (variable_type).

variable must be a SimVariable.

Parameters:
    

**variable** (_SimVariable_)

__init__(_variable_ , _unified_variable =None_, _variable_type =None_, _vvar_id =None_, _** kwargs_)¶
    

Parameters:
    

**variable** (_SimVariable_)

variable _: `SimVariable`_¶
    

unified_variable _: `SimVariable` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

variable_type _: `SimType` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

vvar_id¶
    

_property _type¶
    

_property _name¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CIndexedVariable(_variable_ , _index_ , _variable_type =None_, _** kwargs_)¶
    

Bases: `CExpression`

Represent a variable (an array) that is indexed.

Parameters:
    

  * **variable** (_CExpression_)

  * **index** (_CExpression_)

__init__(_variable_ , _index_ , _variable_type =None_, _** kwargs_)¶
    

Parameters:
    

  * **variable** (_CExpression_)

  * **index** (_CExpression_)

_property _type¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

collapsed¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CVariableField(_variable_ , _field_ , _var_is_ptr =False_, _** kwargs_)¶
    

Bases: `CExpression`

Represent a field of a variable.

Parameters:
    

  * **variable** (_CExpression_)

  * **field** (_CStructField_)

  * **var_is_ptr** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_variable_ , _field_ , _var_is_ptr =False_, _** kwargs_)¶
    

Parameters:
    

  * **variable** (_CExpression_)

  * **field** (_CStructField_)

  * **var_is_ptr** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

_property _type¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

collapsed¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CUnaryOp(_op_ , _operand_ , _** kwargs_)¶
    

Bases: `CExpression`

Unary operations.

Parameters:
    

**operand** (_CExpression_)

__init__(_op_ , _operand_ , _** kwargs_)¶
    

Parameters:
    

**operand** (_CExpression_)

op¶
    

operand¶
    

_property _type¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CBinaryOp(_op_ , _lhs_ , _rhs_ , _** kwargs_)¶
    

Bases: `CExpression`

Binary operations.

__init__(_op_ , _lhs_ , _rhs_ , _** kwargs_)¶
    

op¶
    

lhs¶
    

rhs¶
    

common_type¶
    

_static _compute_common_type(_op_ , _lhs_ty_ , _rhs_ty_)¶
    

Return type:
    

`SimType`

Parameters:
    

  * **op** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **lhs_ty** (_SimType_)

  * **rhs_ty** (_SimType_)

_property _type¶
    

_property _op_precedence¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CTypeCast(_src_type_ , _dst_type_ , _expr_ , _** kwargs_)¶
    

Bases: `CExpression`

Parameters:
    

  * **src_type** (_SimType_ _|__None_)

  * **dst_type** (_SimType_)

  * **expr** (_CExpression_)

__init__(_src_type_ , _dst_type_ , _expr_ , _** kwargs_)¶
    

Parameters:
    

  * **src_type** (_SimType_ _|__None_)

  * **dst_type** (_SimType_)

  * **expr** (_CExpression_)

src_type¶
    

dst_type¶
    

expr¶
    

_property _type¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CConstant(_value_ , _type__ , _reference_values =None_, _** kwargs_)¶
    

Bases: `CExpression`

Parameters:
    

**type_** (_SimType_)

__init__(_value_ , _type__ , _reference_values =None_, _** kwargs_)¶
    

Parameters:
    

**type_** (_SimType_)

value¶
    

reference_values¶
    

_property _fmt¶
    

_property _fmt_hex¶
    

_property _fmt_neg¶
    

_property _fmt_char¶
    

_property _fmt_float¶
    

_property _fmt_double¶
    

_property _type¶
    

_static _str_to_c_str(__str_ , _prefix =''_)¶
    

Parameters:
    

**prefix** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

fmt_int(_value_)¶
    

Format an integer using the format setup of the current node.

Parameters:
    

**value** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The integer value to format.

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

Returns:
    

The formatted string.

_class _angr.analyses.decompiler.structured_codegen.c.CRegister(_reg_ , _** kwargs_)¶
    

Bases: `CExpression`

__init__(_reg_ , _** kwargs_)¶
    

reg¶
    

_property _type¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CITE(_cond_ , _iftrue_ , _iffalse_ , _** kwargs_)¶
    

Bases: `CExpression`

__init__(_cond_ , _iftrue_ , _iffalse_ , _** kwargs_)¶
    

cond¶
    

iftrue¶
    

iffalse¶
    

_property _type¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CMultiStatementExpression(_stmts_ , _expr_ , _** kwargs_)¶
    

Bases: `CExpression`

(stmt0, stmt1, stmt2, expr)

Parameters:
    

  * **stmts** (_CStatements_)

  * **expr** (_CExpression_)

__init__(_stmts_ , _expr_ , _** kwargs_)¶
    

Parameters:
    

  * **stmts** (_CStatements_)

  * **expr** (_CExpression_)

stmts¶
    

expr¶
    

_property _type¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CVEXCCallExpression(_callee_ , _operands_ , _** kwargs_)¶
    

Bases: `CExpression`

ccall_name(arg0, arg1, …)

Parameters:
    

  * **callee** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **operands** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__CExpression_ _]_)

__init__(_callee_ , _operands_ , _** kwargs_)¶
    

Parameters:
    

  * **callee** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **operands** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__CExpression_ _]_)

callee¶
    

operands¶
    

_property _type¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CDirtyExpression(_dirty_ , _** kwargs_)¶
    

Bases: `CExpression`

Ideally all dirty expressions should be handled and converted to proper conversions during conversion from VEX to AIL. Eventually this class should not be used at all.

__init__(_dirty_ , _** kwargs_)¶
    

dirty¶
    

_property _type¶
    

c_repr_chunks(_indent =0_, _asexpr =False_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CClosingObject(_opening_symbol_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A class to represent all objects that can be closed by it’s correspodning character. Examples: (), {}, []

__init__(_opening_symbol_)¶
    

opening_symbol¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CArrayTypeLength(_text_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A class to represent the type information of fixed-size array lengths. Examples: In “char foo[20]”, this would be the “[20]”.

__init__(_text_)¶
    

text¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CStructFieldNameDef(_name_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A class to represent the name of a defined field in a struct. Needed because it’s not a CVariable or a CStructField (because CStructField is the access of a CStructField). Example: In “struct foo { int bar; }, this would be “bar”.

__init__(_name_)¶
    

name¶
    

_class _angr.analyses.decompiler.structured_codegen.c.CStructuredCodeGenerator(_func_ , _sequence_ , _indent =0_, _cfg =None_, _variable_kb =None_, _func_args =None_, _binop_depth_cutoff =16_, _show_casts =True_, _braces_on_own_lines =True_, _use_compound_assignments =True_, _show_local_types =True_, _comment_gotos =False_, _cstyle_null_cmp =True_, _flavor =None_, _stmt_comments =None_, _expr_comments =None_, _show_externs =True_, _externs =None_, _const_formats =None_, _show_demangled_name =True_, _show_disambiguated_name =True_, _ail_graph =None_, _simplify_else_scope =True_, _cstyle_ifs =True_, _omit_func_header =False_, _display_block_addrs =False_, _display_vvar_ids =False_, _min_data_addr =4194304_)¶
    

Bases: `BaseStructuredCodeGenerator`, `Analysis`

Parameters:
    

  * **func_args** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__SimVariable_ _]__|__None_)

  * **binop_depth_cutoff** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **min_data_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_func_ , _sequence_ , _indent =0_, _cfg =None_, _variable_kb =None_, _func_args =None_, _binop_depth_cutoff =16_, _show_casts =True_, _braces_on_own_lines =True_, _use_compound_assignments =True_, _show_local_types =True_, _comment_gotos =False_, _cstyle_null_cmp =True_, _flavor =None_, _stmt_comments =None_, _expr_comments =None_, _show_externs =True_, _externs =None_, _const_formats =None_, _show_demangled_name =True_, _show_disambiguated_name =True_, _ail_graph =None_, _simplify_else_scope =True_, _cstyle_ifs =True_, _omit_func_header =False_, _display_block_addrs =False_, _display_vvar_ids =False_, _min_data_addr =4194304_)¶
    

Parameters:
    

  * **func_args** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__SimVariable_ _]__|__None_)

  * **binop_depth_cutoff** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **min_data_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

reapply_options(_options_)¶
    

cleanup()¶
    

Remove existing rendering results.

regenerate_text()¶
    

Re-render text and re-generate all sorts of mapping information.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

RENDER_TYPE¶
    

alias of [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"), `PositionMapping`, `PositionMapping`, `InstructionMapping`, [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"), [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]]

render_text(_cfunc_)¶
    

Return type:
    

RENDER_TYPE

Parameters:
    

**cfunc** (_CFunction_)

reload_variable_types()¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

default_simtype_from_bits(_n_ , _signed =True_)¶
    

Return type:
    

`SimType`

Parameters:
    

  * **n** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **signed** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

_class _angr.analyses.decompiler.structured_codegen.c.CStructuredCodeWalker¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

handle(_obj_)¶
    

handle_default(_obj_)¶
    

handle_CFunction(_obj_)¶
    

handle_CStatements(_obj_)¶
    

handle_CWhileLoop(_obj_)¶
    

handle_CDoWhileLoop(_obj_)¶
    

handle_CForLoop(_obj_)¶
    

handle_CIfElse(_obj_)¶
    

handle_CIfBreak(_obj_)¶
    

handle_CSwitchCase(_obj_)¶
    

handle_CAssignment(_obj_)¶
    

handle_CFunctionCall(_obj_)¶
    

handle_CReturn(_obj_)¶
    

handle_CGoto(_obj_)¶
    

handle_CIndexedVariable(_obj_)¶
    

handle_CVariableField(_obj_)¶
    

handle_CUnaryOp(_obj_)¶
    

handle_CBinaryOp(_obj_)¶
    

handle_CTypeCast(_obj_)¶
    

handle_CITE(_obj_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.MakeTypecastsImplicit¶
    

Bases: `CStructuredCodeWalker`

_classmethod _collapse(_dst_ty_ , _child_)¶
    

Return type:
    

`CExpression`

Parameters:
    

  * **dst_ty** (_SimType_)

  * **child** (_CExpression_)

handle_CAssignment(_obj_)¶
    

handle_CFunctionCall(_obj_)¶
    

Parameters:
    

**obj** (_CFunctionCall_)

handle_CReturn(_obj_)¶
    

Parameters:
    

**obj** (_CReturn_)

handle_CBinaryOp(_obj_)¶
    

Parameters:
    

**obj** (_CBinaryOp_)

handle_CTypeCast(_obj_)¶
    

Parameters:
    

**obj** (_CTypeCast_)

_class _angr.analyses.decompiler.structured_codegen.c.FieldReferenceCleanup¶
    

Bases: `CStructuredCodeWalker`

handle_CTypeCast(_obj_)¶
    

_class _angr.analyses.decompiler.structured_codegen.c.PointerArithmeticFixer¶
    

Bases: `CStructuredCodeWalker`

Before calling this fixer class, pointer arithmetics are purely integer-based and ignoring the pointer type.

For example, in the following case:

struct A* a_ptr; // assume struct A is 24 bytes in size a_ptr = a_ptr + 24;

It means adding 24 to the address of a_ptr, without considering the size of struct A. This fixer class will make pointer arithmetics aware of the pointer type. In this case, the fixer class will convert the code to a_ptr = a_ptr + 1.

handle_CBinaryOp(_obj_)¶
    

Parameters:
    

**obj** (_CBinaryOp_)

angr.analyses.decompiler.structured_codegen.c.StructuredCodeGenerator¶
    

alias of `CStructuredCodeGenerator`

_class _angr.analyses.decompiler.structured_codegen.dwarf_import.ImportedLine(_addr_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_addr_)¶
    

_class _angr.analyses.decompiler.structured_codegen.dwarf_import.ImportSourceCode(_function_ , _flavor ='source'_, _source_root =None_, _encoding ='utf-8'_)¶
    

Bases: `BaseStructuredCodeGenerator`, `Analysis`

__init__(_function_ , _flavor ='source'_, _source_root =None_, _encoding ='utf-8'_)¶
    

regenerate_text()¶
    

_class _angr.analyses.decompiler.structured_codegen.dummy.DummyStructuredCodeGenerator(_flavor_ , _expr_comments =None_, _stmt_comments =None_, _configuration =None_, _const_formats =None_)¶
    

Bases: `BaseStructuredCodeGenerator`

A dummy structured code generator that only stores user-specified information.

Parameters:
    

**flavor** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

__init__(_flavor_ , _expr_comments =None_, _stmt_comments =None_, _configuration =None_, _const_formats =None_)¶
    

Parameters:
    

**flavor** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

angr.analyses.decompiler.utils.remove_last_statement(_node_)¶
    

angr.analyses.decompiler.utils.remove_last_statements(_node_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

angr.analyses.decompiler.utils.append_statement(_node_ , _stmt_)¶
    

angr.analyses.decompiler.utils.replace_last_statement(_node_ , _old_stmt_ , _new_stmt_)¶
    

angr.analyses.decompiler.utils.extract_jump_targets(_stmt_)¶
    

Extract concrete goto targets from a Jump or a ConditionalJump statement.

Parameters:
    

**stmt** – The statement to analyze.

Returns:
    

A list of known concrete jump targets.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

angr.analyses.decompiler.utils.switch_extract_cmp_bounds(_last_stmt_)¶
    

Check the last statement of the switch-case header node, and extract lower+upper bounds for the comparison.

Parameters:
    

**last_stmt** (`ConditionalJump` | `Statement`) – The last statement of the switch-case header node.

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"), [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

A tuple of (comparison expression, lower bound, upper bound), or None

angr.analyses.decompiler.utils.switch_extract_switch_expr_from_jump_target(_target_)¶
    

Extract the switch expression from the indirect jump target expression.

Parameters:
    

**target** (`Expression`) – The target of the indirect jump statement.

Return type:
    

`Expression` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

The extracted expression if successful, or None otherwise.

angr.analyses.decompiler.utils.switch_extract_bitwiseand_jumptable_info(_last_stmt_)¶
    

Check the last statement of the switch-case header node (whose address is loaded from a jump table and computed using an index) and extract necessary information for rebuilding the switch-case construct.

An example of the statement:

Goto(Conv(32->s64, (
    

Load(addr=(0x4530e4<64> \+ (Conv(32->64, (Conv(64->32, vvar_287{reg 32}) & 0x3<32>)) * 0x4<64>)),
    

size=4, endness=Iend_LE) + 0x4530e4<32>))

)

Parameters:
    

**last_stmt** (`Jump`) – The last statement of the switch-case header node.

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"), [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

A tuple of (index expression, lower bound, upper bound), or None

angr.analyses.decompiler.utils.get_ast_subexprs(_claripy_ast_)¶
    

angr.analyses.decompiler.utils.insert_node(_parent_ , _insert_location_ , _node_ , _node_idx_ , _label =None_)¶
    

Parameters:
    

  * **insert_location** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **node_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

angr.analyses.decompiler.utils.to_ail_supergraph(_transition_graph_ , _allow_fake =False_)¶
    

Takes an AIL graph and converts it into a AIL graph that treats calls and redundant jumps as parts of a bigger block instead of transitions. Calls to returning functions do not terminate basic blocks.

Based on region_identifier super_graph

Return type:
    

`DiGraph`

Returns:
    

A converted super transition graph

Parameters:
    

**transition_graph** (_DiGraph_)

angr.analyses.decompiler.utils.is_empty_node(_node_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

angr.analyses.decompiler.utils.is_empty_or_label_only_node(_node_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

angr.analyses.decompiler.utils.has_nonlabel_statements(_block_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**block** (_Block_)

angr.analyses.decompiler.utils.has_nonlabel_nonphi_statements(_block_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**block** (_Block_)

angr.analyses.decompiler.utils.first_nonlabel_statement(_block_)¶
    

Return type:
    

`Statement` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**block** (_Block_ _|__MultiNode_)

angr.analyses.decompiler.utils.first_nonlabel_statement_id(_block_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**block** (_Block_)

angr.analyses.decompiler.utils.first_nonlabel_nonphi_statement(_block_)¶
    

Return type:
    

`Statement` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**block** (_Block_ _|__MultiNode_)

angr.analyses.decompiler.utils.last_nonlabel_statement(_block_)¶
    

Return type:
    

`Statement` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**block** (_Block_)

angr.analyses.decompiler.utils.first_nonlabel_node(_seq_)¶
    

Return type:
    

`BaseNode` | `Block` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**seq** (_SequenceNode_)

angr.analyses.decompiler.utils.first_nonlabel_nonphi_node(_seq_)¶
    

Return type:
    

`BaseNode` | `Block` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**seq** (_SequenceNode_)

angr.analyses.decompiler.utils.remove_labels(_graph_)¶
    

Parameters:
    

**graph** (_DiGraph_)

angr.analyses.decompiler.utils.add_labels(_graph_)¶
    

Parameters:
    

**graph** (_DiGraph_)

angr.analyses.decompiler.utils.update_labels(_graph_)¶
    

A utility function to recreate the labels for every node in an AIL graph. This useful when you are working with a graph where only _some_ of the nodes have labels.

Parameters:
    

**graph** (_DiGraph_)

angr.analyses.decompiler.utils.structured_node_has_multi_predecessors(_node_ , _graph_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

  * **node** (_SequenceNode_ _|__MultiNode_)

  * **graph** (_DiGraph_)

angr.analyses.decompiler.utils.structured_node_is_simple_return(_node_ , _graph_ , _use_packed_successors =False_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

  * **node** (_SequenceNode_ _|__MultiNode_)

  * **graph** (_DiGraph_)

Will check if a “simple return” is contained within the node a simple returns looks like this: if (cond) {

> // simple return … return 0;

### }¶

Returns true on any block ending in linear statements and a return.

angr.analyses.decompiler.utils.structured_node_is_simple_return_strict(_node_)¶
    

Returns True iff the node exclusively contains a return statement.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**node** (_BaseNode_ _|__SequenceNode_ _|__MultiNode_ _|__Block_)

angr.analyses.decompiler.utils.is_statement_terminating(_stmt_ , _functions_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**stmt** (_Statement_)

angr.analyses.decompiler.utils.peephole_optimize_exprs(_block_ , _expr_opts_)¶
    

angr.analyses.decompiler.utils.peephole_optimize_expr(_expr_ , _expr_opts_)¶
    

angr.analyses.decompiler.utils.copy_graph(_graph_)¶
    

Copy AIL Graph.

Returns:
    

A copy of the AIl graph.

Parameters:
    

**graph** (_DiGraph_)

angr.analyses.decompiler.utils.peephole_optimize_stmts(_block_ , _stmt_opts_)¶
    

angr.analyses.decompiler.utils.match_stmt_classes(_all_stmts_ , _idx_ , _stmt_class_seq_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

  * **all_stmts** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)"))

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **stmt_class_seq** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _]_)

angr.analyses.decompiler.utils.peephole_optimize_multistmts(_block_ , _stmt_opts_)¶
    

angr.analyses.decompiler.utils.decompile_functions(_path_ , _functions =None_, _structurer =None_, _catch_errors =False_, _show_casts =True_, _base_address =None_, _preset =None_)¶
    

Decompile a binary into a set of functions.

Parameters:
    

  * **path** – The path to the binary to decompile.

  * **functions** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]]) – The functions to decompile. If None, all functions will be decompiled.

  * **structurer** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]) – The structuring algorithms to use.

  * **catch_errors** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – The structuring algorithms to use.

  * **show_casts** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether to show casts in the decompiled output.

  * **base_address** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – The base address of the binary.

  * **preset** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]) – The configuration preset to use during decompilation.

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

The decompilation of all functions appended in order.

angr.analyses.decompiler.utils.calls_in_graph(_graph_)¶
    

Counts the number of calls in an graph full of AIL Blocks

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

Parameters:
    

**graph** (_DiGraph_)

angr.analyses.decompiler.utils.find_block_by_addr(_graph_ , _addr_ , _insn_addr =False_)¶
    

Parameters:
    

**graph** (_DiGraph_)

angr.analyses.decompiler.utils.sequence_to_blocks(_seq_)¶
    

Converts a sequence node (BaseNode) to a list of ailment blocks contained in it and all its children.

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`Block`]

Parameters:
    

**seq** (_BaseNode_)

angr.analyses.decompiler.utils.sequence_to_statements(_seq_ , _exclude=( <class 'angr.ailment.statement.Jump'>_, _< class 'angr.ailment.statement.Jump'>)_)¶
    

Converts a sequence node (BaseNode) to a list of ailment Statements contained in it and all its children. May exclude certain types of statements.

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`Statement`]

Parameters:
    

**seq** (_BaseNode_)

angr.analyses.decompiler.utils.remove_edges_in_ailgraph(_ail_graph_ , _edges_to_remove_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **ail_graph** (_DiGraph_)

  * **edges_to_remove** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_ _]__,_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_ _]__]__]_)

_class _angr.analyses.ddg.AST(_op_ , _* operands_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A mini implementation for AST

__init__(_op_ , _* operands_)¶
    

_class _angr.analyses.ddg.ProgramVariable(_variable_ , _location_ , _initial =False_, _arch =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Describes a variable in the program at a specific location.

Variables:
    

  * **variable** (_SimVariable_) – The variable.

  * **location** (_CodeLocation_) – Location of the variable.

__init__(_variable_ , _location_ , _initial =False_, _arch =None_)¶
    

_property _short_repr¶
    

_class _angr.analyses.ddg.DDGJob(_cfg_node_ , _call_depth_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_cfg_node_ , _call_depth_)¶
    

_class _angr.analyses.ddg.LiveDefinitions¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A collection of live definitions with some handy interfaces for definition killing and lookups.

__init__()¶
    

Constructor.

branch()¶
    

Create a branch of the current live definition collection.

Returns:
    

A new LiveDefinition instance.

Return type:
    

angr.analyses.ddg.LiveDefinitions

copy()¶
    

Make a hard copy of self.

Returns:
    

A new LiveDefinition instance.

Return type:
    

angr.analyses.ddg.LiveDefinitions

add_def(_variable_ , _location_ , _size_threshold =32_)¶
    

Add a new definition of variable.

Parameters:
    

  * **variable** (_SimVariable_) – The variable being defined.

  * **location** (_CodeLocation_) – Location of the variable being defined.

  * **size_threshold** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The maximum bytes to consider for the variable.

Returns:
    

True if the definition was new, False otherwise

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

add_defs(_variable_ , _locations_ , _size_threshold =32_)¶
    

Add a collection of new definitions of a variable.

Parameters:
    

  * **variable** (_SimVariable_) – The variable being defined.

  * **locations** (_iterable_) – A collection of locations where the variable was defined.

  * **size_threshold** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The maximum bytes to consider for the variable.

Returns:
    

True if any of the definition was new, False otherwise

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

kill_def(_variable_ , _location_ , _size_threshold =32_)¶
    

Add a new definition for variable and kill all previous definitions.

Parameters:
    

  * **variable** (_SimVariable_) – The variable to kill.

  * **location** (_CodeLocation_) – The location where this variable is defined.

  * **size_threshold** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The maximum bytes to consider for the variable.

Returns:
    

None

lookup_defs(_variable_ , _size_threshold =32_)¶
    

Find all definitions of the variable.

Parameters:
    

  * **variable** (_SimVariable_) – The variable to lookup for.

  * **size_threshold** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The maximum bytes to consider for the variable. For example, if the variable is 100 byte long, only the first size_threshold bytes are considered.

Returns:
    

A set of code locations where the variable is defined.

Return type:
    

[set](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")

items()¶
    

An iterator that returns all live definitions.

Returns:
    

The iterator.

Return type:
    

iter

itervariables()¶
    

An iterator that returns all live variables.

Returns:
    

The iterator.

Return type:
    

iter

_class _angr.analyses.ddg.DDGViewItem(_ddg_ , _variable_ , _simplified =False_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_ddg_ , _variable_ , _simplified =False_)¶
    

_property _depends_on¶
    

_property _dependents¶
    

_class _angr.analyses.ddg.DDGViewInstruction(_cfg_ , _ddg_ , _insn_addr_ , _simplified =False_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_cfg_ , _ddg_ , _insn_addr_ , _simplified =False_)¶
    

_property _definitions _: [list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[DDGViewItem]_¶
    

Get all definitions located at the current instruction address.

Returns:
    

A list of ProgramVariable instances.

_class _angr.analyses.ddg.DDGView(_cfg_ , _ddg_ , _simplified =False_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A view of the data dependence graph.

__init__(_cfg_ , _ddg_ , _simplified =False_)¶
    

_class _angr.analyses.ddg.DDG(_cfg_ , _start =None_, _call_depth =None_, _block_addrs =None_)¶
    

Bases: `Analysis`

This is a fast data dependence graph directly generated from our CFG analysis result. The only reason for its existence is the speed. There is zero guarantee for being sound or accurate. You are supposed to use it only when you want to track the simplest data dependence, and you do not care about soundness or accuracy.

For a better data dependence graph, please consider performing a better static analysis first (like Value-set Analysis), and then construct a dependence graph on top of the analysis result (for example, the VFG in angr).

The DDG is based on a CFG, which should ideally be a CFGEmulated generated with the following options:

>   * keep_state=True to keep all input states
> 
>   * state_add_options=angr.options.refs to store memory, register, and temporary value accesses
> 
> 

You may want to consider a high value for context_sensitivity_level as well when generating the CFG.

Also note that since we are using states from CFG, any improvement in analysis performed on CFG (like a points-to analysis) will directly benefit the DDG.

__init__(_cfg_ , _start =None_, _call_depth =None_, _block_addrs =None_)¶
    

Parameters:
    

  * **cfg** – Control flow graph. Please make sure each node has an associated state with it, e.g. by passing the keep_state=True and state_add_options=angr.options.refs arguments to CFGEmulated.

  * **start** – An address, Specifies where we start the generation of this data dependence graph.

  * **call_depth** – None or integers. A non-negative integer specifies how deep we would like to track in the call tree. None disables call_depth limit.

  * **block_addrs** (_iterable_ _or_ _None_) – A collection of block addresses that the DDG analysis should be performed on.

_property _graph¶
    

A networkx DiGraph instance representing the dependence relations between statements. :rtype: networkx.DiGraph

Type:
    

returns

_property _data_graph¶
    

Get the data dependence graph.

Returns:
    

A networkx DiGraph instance representing data dependence.

Return type:
    

networkx.DiGraph

_property _simplified_data_graph¶
    

return:

_property _ast_graph¶
    

pp()¶
    

Pretty printing.

dbg_repr()¶
    

Representation for debugging.

get_predecessors(_code_location_)¶
    

Returns all predecessors of the code location.

Parameters:
    

**code_location** – A CodeLocation instance.

Returns:
    

A list of all predecessors.

function_dependency_graph(_func_)¶
    

Get a dependency graph for the function func.

Parameters:
    

**func** – The Function object in CFG.function_manager.

Returns:
    

A networkx.DiGraph instance.

data_sub_graph(_pv_ , _simplified =True_, _killing_edges =False_, _excluding_types =None_)¶
    

Get a subgraph from the data graph or the simplified data graph that starts from node pv.

Parameters:
    

  * **pv** (_ProgramVariable_) – The starting point of the subgraph.

  * **simplified** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – When True, the simplified data graph is used, otherwise the data graph is used.

  * **killing_edges** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Are killing edges included or not.

  * **excluding_types** (_iterable_) – Excluding edges whose types are among those excluded types.

Returns:
    

A subgraph.

Return type:
    

networkx.MultiDiGraph

find_definitions(_variable_ , _location =None_, _simplified_graph =True_)¶
    

Find all definitions of the given variable.

Parameters:
    

  * **variable** (_SimVariable_)

  * **simplified_graph** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True if you just want to search in the simplified graph instead of the normal graph. Usually the simplified graph suffices for finding definitions of register or memory variables.

Returns:
    

A collection of all variable definitions to the specific variable.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

find_consumers(_var_def_ , _simplified_graph =True_)¶
    

Find all consumers to the specified variable definition.

Parameters:
    

  * **var_def** (_ProgramVariable_) – The variable definition.

  * **simplified_graph** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True if we want to search in the simplified graph, False otherwise.

Returns:
    

A collection of all consumers to the specified variable definition.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

find_killers(_var_def_ , _simplified_graph =True_)¶
    

Find all killers to the specified variable definition.

Parameters:
    

  * **var_def** (_ProgramVariable_) – The variable definition.

  * **simplified_graph** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True if we want to search in the simplified graph, False otherwise.

Returns:
    

A collection of all killers to the specified variable definition.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

find_sources(_var_def_ , _simplified_graph =True_)¶
    

Find all sources to the specified variable definition.

Parameters:
    

  * **var_def** (_ProgramVariable_) – The variable definition.

  * **simplified_graph** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – True if we want to search in the simplified graph, False otherwise.

Returns:
    

A collection of all sources to the specified variable definition.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

_class _angr.analyses.flirt.FlirtAnalysis(_sig =None_, _max_mismatched_bytes =0_)¶
    

Bases: `Analysis`

FlirtAnalysis accomplishes two purposes:

  * If a FLIRT signature file is specified, it will match the given signature file against the current binary and rename recognized functions accordingly.

  * If no FLIRT signature file is specified, it will use strings to determine possible libraries embedded in the current binary, and then match all possible signatures for the architecture.

Parameters:
    

  * **sig** (_FlirtSignature_ _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **max_mismatched_bytes** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_sig =None_, _max_mismatched_bytes =0_)¶
    

Parameters:
    

  * **sig** (_FlirtSignature_ _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **max_mismatched_bytes** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_class _angr.analyses.flirt.FlirtSignature(_arch_ , _platform_ , _sig_name_ , _sig_path_ , _unique_strings =None_, _compiler =None_, _compiler_version =None_, _os_name =None_, _os_version =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

This class describes a FLIRT signature without any internal data that is only available after parsing.

Parameters:
    

  * **arch** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **platform** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **sig_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **sig_path** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **unique_strings** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **compiler** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **compiler_version** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **os_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **os_version** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

__init__(_arch_ , _platform_ , _sig_name_ , _sig_path_ , _unique_strings =None_, _compiler =None_, _compiler_version =None_, _os_name =None_, _os_version =None_)¶
    

Parameters:
    

  * **arch** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **platform** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **sig_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **sig_path** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **unique_strings** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **compiler** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **compiler_version** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **os_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **os_version** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

_exception _angr.analyses.flirt.FlirtSignatureError¶
    

Bases: `AngrError`

Describes errors related to FLIRT signatures, especially parsing.

_class _angr.analyses.flirt.FlirtSignatureParsed(_version_ , _arch_ , _file_types_ , _os_types_ , _app_types_ , _features_ , _crc_ , _ctype_ , _ctypes_crc_ , _nfuncs_ , _pattern_size_ , _libname_ , _root_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Describes a FLIRT signature file after parsing.

Parameters:
    

  * **version** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **arch** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **file_types** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **os_types** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **app_types** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **features** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **crc** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **ctype** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **ctypes_crc** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **nfuncs** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **pattern_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **libname** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **root** (_FlirtNode_ _|__None_)

__init__(_version_ , _arch_ , _file_types_ , _os_types_ , _app_types_ , _features_ , _crc_ , _ctype_ , _ctypes_crc_ , _nfuncs_ , _pattern_size_ , _libname_ , _root_)¶
    

Parameters:
    

  * **version** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **arch** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **file_types** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **os_types** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **app_types** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **features** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **crc** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **ctype** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **ctypes_crc** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **nfuncs** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **pattern_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **libname** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **root** (_FlirtNode_ _|__None_)

version¶
    

arch¶
    

file_types¶
    

os_types¶
    

app_types¶
    

features¶
    

crc¶
    

ctype¶
    

ctypes_crc¶
    

nfuncs¶
    

pattern_size¶
    

libname¶
    

root¶
    

parse_tree(_file_obj_ , _root =False_)¶
    

Parse a FLIRT function tree.

Return type:
    

`FlirtNode`

Parameters:
    

**root** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

parse_public_function(_file_obj_ , _offset_)¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`FlirtFunction`, [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]

Parameters:
    

**offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

parse_referenced_functions(_file_obj_)¶
    

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`FlirtFunction`]

parse_tail_bytes(_file_obj_)¶
    

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]]

parse_modules(_file_obj_)¶
    

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`FlirtModule`]

parse_module(_file_obj_)¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`FlirtModule`, [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]

_static _parse_variant_mask(_file_obj_ , _length_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

Parameters:
    

**length** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_static _is_bit_set_be(_mask_ , _mask_len_ , _bit_offset_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

  * **mask** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **mask_len** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **bit_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_static _parse_node(_file_obj_ , _length_ , _variant_mask_)¶
    

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]

Parameters:
    

  * **length** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **variant_mask** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_classmethod _parse(_file_obj_)¶
    

Parse a FLIRT signature file.

The following struct definitions come from radare2

// FLIRT v5+ ut8 magic[6]; ut8 version; ut8 arch; ut32 file_types; ut16 os_types; ut16 app_types; ut16 features; ut16 old_n_functions; ut16 crc16; ut8 ctype[12]; ut8 library_name_len; ut16 ctypes_crc16;

// FLIRT v6+ ut32 nfuncs;

// FLIRT v8+ ut16 pattern_size;

// FLIRT v10 ut16 unknown;

Return type:
    

`FlirtSignatureParsed`

angr.analyses.flirt.flirt_arch_to_arch_name(_flirt_arch_ , _app_types_)¶
    

Convert FLIRT architecture ID to architecture name.

Parameters:
    

  * **flirt_arch** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – FLIRT architecture ID.

  * **app_types** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – FLIRT application types.

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

Returns:
    

Architecture name.

angr.analyses.flirt.flirt_os_type_to_os_name(_os_type_)¶
    

Convert FLIRT OS type to OS name.

Parameters:
    

**os_type** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – FLIRT OS type.

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

Returns:
    

OS name.

_class _angr.engines.light.data.ArithmeticExpression(_op_ , _operands_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Add _ = 0_¶
    

Sub _ = 1_¶
    

Or _ = 2_¶
    

And _ = 4_¶
    

RShift _ = 8_¶
    

LShift _ = 16_¶
    

Mul _ = 32_¶
    

Xor _ = 64_¶
    

CONST_TYPES _ = (<class 'int'>, <class 'angr.ailment.expression.Const'>)_¶
    

__init__(_op_ , _operands_)¶
    

op¶
    

operands¶
    

_static _try_unpack_const(_expr_)¶
    

_class _angr.engines.light.data.RegisterOffset(_bits_ , _reg_ , _offset_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_bits_ , _reg_ , _offset_)¶
    

reg¶
    

offset¶
    

_property _bits¶
    

_property _symbolic¶
    

_class _angr.engines.light.data.SpOffset(_bits_ , _offset_ , _is_base =False_)¶
    

Bases: `RegisterOffset`

__init__(_bits_ , _offset_ , _is_base =False_)¶
    

is_base¶
    

_class _angr.engines.light.ArithmeticExpression(_op_ , _operands_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Add _ = 0_¶
    

Sub _ = 1_¶
    

Or _ = 2_¶
    

And _ = 4_¶
    

RShift _ = 8_¶
    

LShift _ = 16_¶
    

Mul _ = 32_¶
    

Xor _ = 64_¶
    

CONST_TYPES _ = (<class 'int'>, <class 'angr.ailment.expression.Const'>)_¶
    

__init__(_op_ , _operands_)¶
    

op¶
    

operands¶
    

_static _try_unpack_const(_expr_)¶
    

_class _angr.engines.light.RegisterOffset(_bits_ , _reg_ , _offset_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_bits_ , _reg_ , _offset_)¶
    

reg¶
    

offset¶
    

_property _bits¶
    

_property _symbolic¶
    

_class _angr.engines.light.SimEngineLight(_project_ , _logger =None_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`StateType`, `DataType_co`, `BlockType`, `ResultType`], `SimEngine`[`StateType`, `ResultType`]

A full-featured engine base class, suitable for static analysis

Parameters:
    

**project** (_Project_)

block _: [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`BlockType`, bound= `BlockProtocol`)_¶
    

state _: [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`StateType`)_¶
    

stmt_idx _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

ins_addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

tmps _: [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`DataType_co`, covariant=True)]_¶
    

__init__(_project_ , _logger =None_)¶
    

Parameters:
    

**project** (_Project_)

_abstract _process(_state_ , _*_ , _block =None_, _** kwargs_)¶
    

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`ResultType`)

Parameters:
    

  * **state** (_StateType_)

  * **block** (_BlockType_ _|__None_)

lift(_state_)¶
    

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`BlockType`, bound= `BlockProtocol`)

Parameters:
    

**state** (_StateType_)

_static _sp_offset(_bits_ , _offset_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_static _extract_offset_to_sp(_spoffset_expr_)¶
    

Extract the offset to the original stack pointer.

Parameters:
    

**spoffset_expr** ([`Base`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)")) – The claripy AST to parse.

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

The offset to the original stack pointer, or None if spoffset_expr is not a supported type of SpOffset expression.

_class _angr.engines.light.SimEngineLightAIL(_* args_, _** kwargs_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`StateType`, `DataType_co`, `StmtDataType`, `ResultType`], `SimEngineLight`[`StateType`, `DataType_co`, `Block`, `ResultType`]

A mixin for doing static analysis on AIL

__init__(_* args_, _** kwargs_)¶
    

process(_state_ , _*_ , _block =None_, _whitelist =None_, _** kwargs_)¶
    

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`ResultType`)

Parameters:
    

  * **state** (_StateType_)

  * **block** (_Block_ _|__None_)

  * **whitelist** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

_class _angr.engines.light.SimEngineLightVEX(_* args_, _** kwargs_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`StateType`, `DataType_co`, `ResultType`, `StmtDataType`], `SimEngineLight`[`StateType`, `DataType_co`, `Block`, `ResultType`]

A mixin for doing static analysis on VEX

tyenv _: [`IRTypeEnv`](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.block.IRTypeEnv "\(in pyvex\)")_¶
    

_static _unop_handler(_f_)¶
    

Return type:
    

[`Callable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)")[[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`T`), [`Unop`](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.expr.Unop "\(in pyvex\)")], [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`DataType_co`, covariant=True)]

Parameters:
    

**f** ([_Callable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)") _[__[__T_ _,_[_Unop_](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.expr.Unop "\(in pyvex\)") _]__,__DataType_co_ _]_)

_static _binop_handler(_f_)¶
    

Return type:
    

[`Callable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)")[[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`T`), [`Binop`](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.expr.Binop "\(in pyvex\)")], [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`DataType_co`, covariant=True)]

Parameters:
    

**f** ([_Callable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)") _[__[__T_ _,_[_Binop_](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.expr.Binop "\(in pyvex\)") _]__,__DataType_co_ _]_)

_static _binopv_handler(_f_)¶
    

Return type:
    

[`Callable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)")[[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`T`), [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Binop`](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.expr.Binop "\(in pyvex\)")], [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`DataType_co`, covariant=True)]

Parameters:
    

**f** ([_Callable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)") _[__[__T_ _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_Binop_](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.expr.Binop "\(in pyvex\)") _]__,__DataType_co_ _]_)

_static _triop_handler(_f_)¶
    

Return type:
    

[`Callable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)")[[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`T`), [`Triop`](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.expr.Triop "\(in pyvex\)")], [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`DataType_co`, covariant=True)]

Parameters:
    

**f** ([_Callable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)") _[__[__T_ _,_[_Triop_](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.expr.Triop "\(in pyvex\)") _]__,__DataType_co_ _]_)

_static _qop_handler(_f_)¶
    

Return type:
    

[`Callable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)")[[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`T`), [`Qop`](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.expr.Qop "\(in pyvex\)")], [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`DataType_co`, covariant=True)]

Parameters:
    

**f** ([_Callable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)") _[__[__T_ _,_[_Qop_](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.expr.Qop "\(in pyvex\)") _]__,__DataType_co_ _]_)

_static _ccall_handler(_f_)¶
    

Return type:
    

[`Callable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)")[[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`T`), [`CCall`](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.expr.CCall "\(in pyvex\)")], [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`DataType_co`, covariant=True)]

Parameters:
    

**f** ([_Callable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)") _[__[__T_ _,_[_CCall_](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.expr.CCall "\(in pyvex\)") _]__,__DataType_co_ _]_)

_static _dirty_handler(_f_)¶
    

Return type:
    

[`Callable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)")[[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`T`), [`Dirty`](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.stmt.Dirty "\(in pyvex\)")], [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`StmtDataType`)]

Parameters:
    

**f** ([_Callable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)") _[__[__T_ _,_[_Dirty_](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.stmt.Dirty "\(in pyvex\)") _]__,__StmtDataType_ _]_)

__init__(_* args_, _** kwargs_)¶
    

process(_state_ , _*_ , _block =None_, _whitelist =None_, _** kwargs_)¶
    

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`ResultType`)

Parameters:
    

  * **state** (_StateType_)

  * **block** (_Block_ _|__None_)

  * **whitelist** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

_class _angr.engines.light.SimEngineNoexprAIL(_* args_, _** kwargs_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`StateType`, `DataType_co`, `StmtDataType`, `ResultType`], `SimEngineLightAIL`[`StateType`, `DataType_co` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)"), `StmtDataType`, `ResultType`]

A base class of SimEngineLightAIL that has default handlers for expressions if they just need to return None, so you don’t have to implement every single expression handler as `return None`.

_class _angr.engines.light.SimEngineNostmtAIL(_* args_, _** kwargs_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`StateType`, `DataType_co`, `StmtDataType`, `ResultType`], `SimEngineLightAIL`[`StateType`, `DataType_co`, `StmtDataType` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)"), `ResultType`]

A base class of SimEngineLightAIL that has default handlers for statements if they just need to return None, so you don’t have to implement every single statement handler as `return None`.

_class _angr.engines.light.SimEngineNostmtVEX(_* args_, _** kwargs_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`StateType`, `DataType_co`, `ResultType`], `SimEngineLightVEX`[`StateType`, `DataType_co`, `ResultType`, [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")]

A base class of SimEngineLightVEX that has default handlers for statements if they just need to return None, so you don’t have to implement every single statement handler as `return None`.

_class _angr.engines.light.SpOffset(_bits_ , _offset_ , _is_base =False_)¶
    

Bases: `RegisterOffset`

__init__(_bits_ , _offset_ , _is_base =False_)¶
    

is_base¶
    

_class _angr.engines.light.engine.BlockProtocol(_* args_, _** kwargs_)¶
    

Bases: [`Protocol`](https://docs.python.org/3/library/typing.html#typing.Protocol "\(in Python v3.13\)")

The minimum protocol that a block an engine can process should adhere to. Requires just an addr attribute.

addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

__init__(_* args_, _** kwargs_)¶
    

_class _angr.engines.light.engine.IRTop(_ty_)¶
    

Bases: [`IRExpr`](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.expr.IRExpr "\(in pyvex\)")

A dummy IRExpr used for intra-engine communication and code-reuse.

Parameters:
    

**ty** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

__init__(_ty_)¶
    

Parameters:
    

**ty** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

result_type(_tyenv_)¶
    

_class _angr.engines.light.engine.SimEngineLight(_project_ , _logger =None_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`StateType`, `DataType_co`, `BlockType`, `ResultType`], `SimEngine`[`StateType`, `ResultType`]

A full-featured engine base class, suitable for static analysis

Parameters:
    

**project** (_Project_)

block _: [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`BlockType`, bound= `BlockProtocol`)_¶
    

state _: [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`StateType`)_¶
    

stmt_idx _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

ins_addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

tmps _: [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`DataType_co`, covariant=True)]_¶
    

__init__(_project_ , _logger =None_)¶
    

Parameters:
    

**project** (_Project_)

_abstract _process(_state_ , _*_ , _block =None_, _** kwargs_)¶
    

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`ResultType`)

Parameters:
    

  * **state** (_StateType_)

  * **block** (_BlockType_ _|__None_)

lift(_state_)¶
    

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`BlockType`, bound= `BlockProtocol`)

Parameters:
    

**state** (_StateType_)

_static _sp_offset(_bits_ , _offset_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

  * **bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_static _extract_offset_to_sp(_spoffset_expr_)¶
    

Extract the offset to the original stack pointer.

Parameters:
    

**spoffset_expr** ([`Base`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)")) – The claripy AST to parse.

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

The offset to the original stack pointer, or None if spoffset_expr is not a supported type of SpOffset expression.

angr.engines.light.engine.longest_prefix_lookup(_haystack_ , _mapping_)¶
    

Return type:
    

[`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`T`)]

Parameters:
    

  * **haystack** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **mapping** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,__T_ _]_)

_class _angr.engines.light.engine.SimEngineLightVEX(_* args_, _** kwargs_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`StateType`, `DataType_co`, `ResultType`, `StmtDataType`], `SimEngineLight`[`StateType`, `DataType_co`, `Block`, `ResultType`]

A mixin for doing static analysis on VEX

tyenv _: [`IRTypeEnv`](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.block.IRTypeEnv "\(in pyvex\)")_¶
    

_static _unop_handler(_f_)¶
    

Return type:
    

[`Callable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)")[[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`T`), [`Unop`](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.expr.Unop "\(in pyvex\)")], [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`DataType_co`, covariant=True)]

Parameters:
    

**f** ([_Callable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)") _[__[__T_ _,_[_Unop_](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.expr.Unop "\(in pyvex\)") _]__,__DataType_co_ _]_)

_static _binop_handler(_f_)¶
    

Return type:
    

[`Callable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)")[[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`T`), [`Binop`](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.expr.Binop "\(in pyvex\)")], [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`DataType_co`, covariant=True)]

Parameters:
    

**f** ([_Callable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)") _[__[__T_ _,_[_Binop_](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.expr.Binop "\(in pyvex\)") _]__,__DataType_co_ _]_)

_static _binopv_handler(_f_)¶
    

Return type:
    

[`Callable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)")[[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`T`), [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`Binop`](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.expr.Binop "\(in pyvex\)")], [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`DataType_co`, covariant=True)]

Parameters:
    

**f** ([_Callable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)") _[__[__T_ _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_Binop_](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.expr.Binop "\(in pyvex\)") _]__,__DataType_co_ _]_)

_static _triop_handler(_f_)¶
    

Return type:
    

[`Callable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)")[[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`T`), [`Triop`](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.expr.Triop "\(in pyvex\)")], [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`DataType_co`, covariant=True)]

Parameters:
    

**f** ([_Callable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)") _[__[__T_ _,_[_Triop_](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.expr.Triop "\(in pyvex\)") _]__,__DataType_co_ _]_)

_static _qop_handler(_f_)¶
    

Return type:
    

[`Callable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)")[[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`T`), [`Qop`](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.expr.Qop "\(in pyvex\)")], [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`DataType_co`, covariant=True)]

Parameters:
    

**f** ([_Callable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)") _[__[__T_ _,_[_Qop_](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.expr.Qop "\(in pyvex\)") _]__,__DataType_co_ _]_)

_static _ccall_handler(_f_)¶
    

Return type:
    

[`Callable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)")[[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`T`), [`CCall`](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.expr.CCall "\(in pyvex\)")], [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`DataType_co`, covariant=True)]

Parameters:
    

**f** ([_Callable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)") _[__[__T_ _,_[_CCall_](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.expr.CCall "\(in pyvex\)") _]__,__DataType_co_ _]_)

_static _dirty_handler(_f_)¶
    

Return type:
    

[`Callable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)")[[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`T`), [`Dirty`](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.stmt.Dirty "\(in pyvex\)")], [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`StmtDataType`)]

Parameters:
    

**f** ([_Callable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)") _[__[__T_ _,_[_Dirty_](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.stmt.Dirty "\(in pyvex\)") _]__,__StmtDataType_ _]_)

__init__(_* args_, _** kwargs_)¶
    

process(_state_ , _*_ , _block =None_, _whitelist =None_, _** kwargs_)¶
    

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`ResultType`)

Parameters:
    

  * **state** (_StateType_)

  * **block** (_Block_ _|__None_)

  * **whitelist** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

block _: [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`BlockType`, bound= `BlockProtocol`)_¶
    

state _: [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`StateType`)_¶
    

stmt_idx _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

ins_addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

tmps _: [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`DataType_co`, covariant=True)]_¶
    

_class _angr.engines.light.engine.SimEngineNostmtVEX(_* args_, _** kwargs_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`StateType`, `DataType_co`, `ResultType`], `SimEngineLightVEX`[`StateType`, `DataType_co`, `ResultType`, [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")]

A base class of SimEngineLightVEX that has default handlers for statements if they just need to return None, so you don’t have to implement every single statement handler as `return None`.

_class _angr.engines.light.engine.SimEngineLightAIL(_* args_, _** kwargs_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`StateType`, `DataType_co`, `StmtDataType`, `ResultType`], `SimEngineLight`[`StateType`, `DataType_co`, `Block`, `ResultType`]

A mixin for doing static analysis on AIL

__init__(_* args_, _** kwargs_)¶
    

process(_state_ , _*_ , _block =None_, _whitelist =None_, _** kwargs_)¶
    

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`ResultType`)

Parameters:
    

  * **state** (_StateType_)

  * **block** (_Block_ _|__None_)

  * **whitelist** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

_class _angr.engines.light.engine.SimEngineNostmtAIL(_* args_, _** kwargs_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`StateType`, `DataType_co`, `StmtDataType`, `ResultType`], `SimEngineLightAIL`[`StateType`, `DataType_co`, `StmtDataType` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)"), `ResultType`]

A base class of SimEngineLightAIL that has default handlers for statements if they just need to return None, so you don’t have to implement every single statement handler as `return None`.

_class _angr.engines.light.engine.SimEngineNoexprAIL(_* args_, _** kwargs_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`StateType`, `DataType_co`, `StmtDataType`, `ResultType`], `SimEngineLightAIL`[`StateType`, `DataType_co` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)"), `StmtDataType`, `ResultType`]

A base class of SimEngineLightAIL that has default handlers for expressions if they just need to return None, so you don’t have to implement every single expression handler as `return None`.

_class _angr.analyses.propagator.PropagatorAnalysis(_func =None_, _block =None_, _func_graph =None_, _base_state =None_, _max_iterations =30_, _load_callback =None_, _stack_pointer_tracker =None_, _only_consts =False_, _completed_funcs =None_, _do_binops =True_, _store_tops =True_, _vex_cross_insn_opt =False_, _func_addr =None_, _gp =None_, _cache_results =False_, _key_prefix =None_, _profiling =False_)¶
    

Bases: `ForwardAnalysis`, `Analysis`

PropagatorAnalysis implements copy propagation. It propagates values (either constant values or variables) and expressions inside a block or across a function.

PropagatorAnalysis only supports VEX. For AIL, please use SPropagator.

PropagatorAnalysis performs certain arithmetic operations between constants, including but are not limited to:

  * addition

  * subtraction

  * multiplication

  * division

  * xor

It also performs the following memory operations:

  * Loading values from a known address

  * Writing values to a stack variable

Parameters:
    

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **gp** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **cache_results** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **key_prefix** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **profiling** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_func =None_, _block =None_, _func_graph =None_, _base_state =None_, _max_iterations =30_, _load_callback =None_, _stack_pointer_tracker =None_, _only_consts =False_, _completed_funcs =None_, _do_binops =True_, _store_tops =True_, _vex_cross_insn_opt =False_, _func_addr =None_, _gp =None_, _cache_results =False_, _key_prefix =None_, _profiling =False_)¶
    

Constructor

Parameters:
    

  * **order_jobs** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If all jobs should be ordered or not.

  * **allow_merging** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If job merging is allowed.

  * **allow_widening** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If job widening is allowed.

  * **graph_visitor** (_GraphVisitor_ _or_ _None_) – A graph visitor to provide successors.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **gp** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **cache_results** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **key_prefix** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **profiling** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Returns:
    

None

_property _prop_key _: [tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)"), [str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"), [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"), [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"), [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")]_¶
    

Gets a key that represents the function and the “flavor” of the propagation result.

_property _replacements¶
    

_class _angr.analyses.propagator.values.Top(_size_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_size_)¶
    

size¶
    

_property _bits¶
    

_class _angr.analyses.propagator.values.Bottom¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

_class _angr.analyses.propagator.vex_vars.VEXVariable¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

_class _angr.analyses.propagator.vex_vars.VEXMemVar(_addr_ , _size_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_addr_ , _size_)¶
    

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

addr¶
    

size¶
    

_class _angr.analyses.propagator.vex_vars.VEXReg(_offset_ , _size_)¶
    

Bases: `VEXVariable`

__init__(_offset_ , _size_)¶
    

offset¶
    

size¶
    

_class _angr.analyses.propagator.vex_vars.VEXTmp(_tmp_)¶
    

Bases: `VEXVariable`

__init__(_tmp_)¶
    

tmp¶
    

_class _angr.analyses.propagator.engine_base.SimEnginePropagatorBaseMixin(_project_ , _stack_pointer_tracker =None_, _propagate_tmps =True_, _reaching_definitions =None_, _bp_as_gpr =False_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`StateType`, `DataType_co`, `BlockType`], `SimEngineLight`[`StateType`, `DataType_co`, `BlockType`, `StateType`]

The base class for the propagator VEX engine.

Parameters:
    

  * **project** (_Project_)

  * **reaching_definitions** (_ReachingDefinitionsModel_ _|__None_)

  * **bp_as_gpr** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_project_ , _stack_pointer_tracker =None_, _propagate_tmps =True_, _reaching_definitions =None_, _bp_as_gpr =False_)¶
    

Parameters:
    

  * **project** (_Project_)

  * **reaching_definitions** (_ReachingDefinitionsModel_ _|__None_)

  * **bp_as_gpr** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

process(_state_ , _*_ , _block =None_, _base_state =None_, _load_callback =None_, _** kwargs_)¶
    

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`StateType`)

Parameters:
    

  * **state** (_StateType_)

  * **block** (_BlockType_ _|__None_)

_class _angr.analyses.propagator.engine_vex.SimEnginePropagatorVEX(_project_ , _stack_pointer_tracker =None_, _propagate_tmps =True_, _reaching_definitions =None_, _bp_as_gpr =False_)¶
    

Bases: `ClaripyDataVEXEngineMixin`[`PropagatorVEXState`, [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"), `PropagatorVEXState`, [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")], `SimEnginePropagatorBaseMixin`[`PropagatorVEXState`, [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"), `Block`], `SimEngineNostmtVEX`[`PropagatorVEXState`, [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"), `PropagatorVEXState`]

Parameters:
    

  * **project** (_Project_)

  * **reaching_definitions** (_ReachingDefinitionsModel_ _|__None_)

  * **bp_as_gpr** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

_class _angr.analyses.propagator.propagator.PropagatorAnalysis(_func =None_, _block =None_, _func_graph =None_, _base_state =None_, _max_iterations =30_, _load_callback =None_, _stack_pointer_tracker =None_, _only_consts =False_, _completed_funcs =None_, _do_binops =True_, _store_tops =True_, _vex_cross_insn_opt =False_, _func_addr =None_, _gp =None_, _cache_results =False_, _key_prefix =None_, _profiling =False_)¶
    

Bases: `ForwardAnalysis`, `Analysis`

PropagatorAnalysis implements copy propagation. It propagates values (either constant values or variables) and expressions inside a block or across a function.

PropagatorAnalysis only supports VEX. For AIL, please use SPropagator.

PropagatorAnalysis performs certain arithmetic operations between constants, including but are not limited to:

  * addition

  * subtraction

  * multiplication

  * division

  * xor

It also performs the following memory operations:

  * Loading values from a known address

  * Writing values to a stack variable

Parameters:
    

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **gp** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **cache_results** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **key_prefix** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **profiling** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_func =None_, _block =None_, _func_graph =None_, _base_state =None_, _max_iterations =30_, _load_callback =None_, _stack_pointer_tracker =None_, _only_consts =False_, _completed_funcs =None_, _do_binops =True_, _store_tops =True_, _vex_cross_insn_opt =False_, _func_addr =None_, _gp =None_, _cache_results =False_, _key_prefix =None_, _profiling =False_)¶
    

Constructor

Parameters:
    

  * **order_jobs** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If all jobs should be ordered or not.

  * **allow_merging** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If job merging is allowed.

  * **allow_widening** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If job widening is allowed.

  * **graph_visitor** (_GraphVisitor_ _or_ _None_) – A graph visitor to provide successors.

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **gp** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **cache_results** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **key_prefix** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **profiling** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Returns:
    

None

_property _prop_key _: [tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)"), [str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"), [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"), [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"), [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")]_¶
    

Gets a key that represents the function and the “flavor” of the propagation result.

_property _replacements¶
    

_class _angr.analyses.propagator.top_checker_mixin.ClaripyDataEngineMixin(_project_ , _logger =None_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`StateType`, `DataType_co`, `BlockType`, `ResultType`], `SimEngineLight`[`StateType`, `DataType_co` | [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"), `BlockType`, `ResultType`]

Parameters:
    

**project** (_Project_)

_class _angr.analyses.propagator.top_checker_mixin.ClaripyDataVEXEngineMixin(_* args_, _** kwargs_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`StateType`, `DataType_co`, `ResultType`, `StmtDataType`], `ClaripyDataEngineMixin`[`StateType`, `DataType_co`, `Block`, `ResultType`], `SimEngineLightVEX`[`StateType`, `DataType_co` | [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"), `ResultType`, `StmtDataType`]

_class _angr.analyses.reaching_definitions.Atom(_size_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

This class represents a data storage location manipulated by IR instructions.

It could either be a Tmp (temporary variable), a Register, a MemoryLocation.

__init__(_size_)¶
    

Parameters:
    

**size** – The size of the atom in bytes

size¶
    

_property _bits _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_static _from_ail_expr(_expr_ , _arch_ , _full_reg =False_)¶
    

Return type:
    

`Register`

Parameters:
    

  * **expr** (_Expression_)

  * **arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)"))

  * **full_reg** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

_static _from_argument(_argument_ , _arch_ , _full_reg =False_, _sp =None_)¶
    

Instantiate an Atom from a given argument.

Parameters:
    

  * **argument** (`SimFunctionArgument`) – The argument to create a new atom from.

  * **arch** ([`Arch`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)")) – The argument representing archinfo architecture for argument.

  * **full_reg** – Whether to return an atom indicating the entire register if the argument only specifies a slice of the register.

  * **sp** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – The current stack offset. Optional. Only used when argument is a SimStackArg.

Return type:
    

`Register` | `MemoryLocation`

_static _reg(_thing_ , _size =None_, _arch =None_)¶
    

Create a Register atom.

Parameters:
    

  * **thing** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`RegisterOffset`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.types.RegisterOffset "\(in archinfo\)")) – The register offset (e.g., project.arch.registers[“rax”][0]) or the register name (e.g., “rax”).

  * **size** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – Size of the register atom. Must be provided when creating the atom using a register offset.

  * **arch** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`Arch`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)")]) – The architecture. Must be provided when creating the atom using a register name.

Return type:
    

`Register`

Returns:
    

The Register Atom object.

_static _register(_thing_ , _size =None_, _arch =None_)¶
    

Create a Register atom.

Parameters:
    

  * **thing** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`RegisterOffset`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.types.RegisterOffset "\(in archinfo\)")) – The register offset (e.g., project.arch.registers[“rax”][0]) or the register name (e.g., “rax”).

  * **size** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – Size of the register atom. Must be provided when creating the atom using a register offset.

  * **arch** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`Arch`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)")]) – The architecture. Must be provided when creating the atom using a register name.

Return type:
    

`Register`

Returns:
    

The Register Atom object.

_static _mem(_addr_ , _size_ , _endness =None_)¶
    

Create a MemoryLocation atom,

Parameters:
    

  * **addr** (`SpOffset` | `HeapAddress` | [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The memory location. Can be an SpOffset for stack variables, an int for global memory variables, or a HeapAddress for items on the heap.

  * **size** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Size of the atom.

  * **endness** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`Endness`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.types.Endness "\(in archinfo\)")]) – Optional, either “Iend_LE” or “Iend_BE”.

Return type:
    

`MemoryLocation`

Returns:
    

The MemoryLocation Atom object.

_static _memory(_addr_ , _size_ , _endness =None_)¶
    

Create a MemoryLocation atom,

Parameters:
    

  * **addr** (`SpOffset` | `HeapAddress` | [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The memory location. Can be an SpOffset for stack variables, an int for global memory variables, or a HeapAddress for items on the heap.

  * **size** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Size of the atom.

  * **endness** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`Endness`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.types.Endness "\(in archinfo\)")]) – Optional, either “Iend_LE” or “Iend_BE”.

Return type:
    

`MemoryLocation`

Returns:
    

The MemoryLocation Atom object.

_class _angr.analyses.reaching_definitions.AtomKind(_value_)¶
    

Bases: [`Enum`](https://docs.python.org/3/library/enum.html#enum.Enum "\(in Python v3.13\)")

An enum indicating the class of an atom

REGISTER _ = 1_¶
    

MEMORY _ = 2_¶
    

TMP _ = 3_¶
    

GUARD _ = 4_¶
    

CONSTANT _ = 5_¶
    

_class _angr.analyses.reaching_definitions.ConstantSrc(_value_ , _size_)¶
    

Bases: `Atom`

Represents a constant.

Parameters:
    

  * **value** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_value_ , _size_)¶
    

Parameters:
    

  * **size** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The size of the atom in bytes

  * **value** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

value _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.analyses.reaching_definitions.Definition(_atom_ , _codeloc_ , _dummy =False_, _tags =None_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`A`]

An atom definition.

Variables:
    

  * **atom** – The atom being defined.

  * **codeloc** – Where this definition is created in the original binary code.

  * **dummy** – Tell whether the definition should be considered dummy or not. During simplification by AILment, definitions marked as dummy will not be removed.

  * **tags** – A set of tags containing information about the definition gathered during analyses.

Parameters:
    

  * **atom** (_A_)

  * **codeloc** (_CodeLocation_)

  * **dummy** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **tags** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Tag_ _]__|__None_)

__init__(_atom_ , _codeloc_ , _dummy =False_, _tags =None_)¶
    

Parameters:
    

  * **atom** (_A_)

  * **codeloc** (_CodeLocation_)

  * **dummy** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **tags** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Tag_ _]__|__None_)

atom _: [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`A`, bound= `Atom`)_¶
    

codeloc _: `CodeLocation`_¶
    

dummy _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

tags¶
    

_property _offset _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_property _size _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

matches(_** kwargs_)¶
    

Return whether this definition has certain characteristics.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.analyses.reaching_definitions.FunctionCallData(_callsite_codeloc_ , _function_codeloc_ , _address_multi_ , _address=None_ , _symbol=None_ , _function=None_ , _name=None_ , _cc=None_ , _prototype=None_ , _args_atoms=None_ , _args_values=None_ , _ret_atoms=None_ , _redefine_locals=True_ , _visited_blocks=None_ , _effects= <factory>_, _ret_values=None_ , _ret_values_deps=None_ , _caller_will_handle_single_ret=False_ , _guessed_cc=False_ , _guessed_prototype=False_ , _retaddr_popped=False_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A bundle of intermediate data used when computing the sum effect of a function during ReachingDefinitionsAnalysis.

RDA engine contract:

  * Construct one of these before calling FunctionHandler.handle_function. Fill it with as many fields as you can realistically provide without duplicating effort.

  * Provide callsite_codeloc as either the call statement (AIL) or the default exit of the default statement of the calling block (VEX)

  * Provide function_codeloc as the callee address with stmt_idx=0`.

Function handler contract:

  * If redefine_locals is unset, do not adjust any artifacts of the function call abstraction, such as the stack pointer, the caller saved registers, etc.

  * If caller_will_handle_single_ret is set, and there is a single entry in ret_atoms, do not apply to the state effects modifying this atom. Instead, set ret_values and ret_values_deps to the values and deps which are used constructing these values.

Parameters:
    

  * **callsite_codeloc** (_CodeLocation_)

  * **function_codeloc** (_CodeLocation_)

  * **address_multi** (_MultiValues_ _[_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _|_[_FP_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)") _]__|__None_)

  * **address** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **symbol** ([_Symbol_](https://docs.angr.io/projects/cle/en/latest/api/backend.html#cle.backends.symbol.Symbol "\(in cle\)") _|__None_)

  * **function** (_Function_ _|__None_)

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **cc** (_SimCC_ _|__None_)

  * **prototype** (_SimTypeFunction_ _|__None_)

  * **args_atoms** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Atom_ _]__]__|__None_)

  * **args_values** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__MultiValues_ _[_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _|_[_FP_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)") _]__]__|__None_)

  * **ret_atoms** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Atom_ _]__|__None_)

  * **redefine_locals** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **visited_blocks** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **effects** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__FunctionEffect_ _]_)

  * **ret_values** (_MultiValues_ _[_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _|_[_FP_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)") _]__|__None_)

  * **ret_values_deps** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Definition_ _]__|__None_)

  * **caller_will_handle_single_ret** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **guessed_cc** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **guessed_prototype** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **retaddr_popped** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

callsite_codeloc _: `CodeLocation`_¶
    

function_codeloc _: `CodeLocation`_¶
    

address_multi _: [`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[`MultiValues`[[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`FP`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)")]]_¶
    

address _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

symbol _: [`Symbol`](https://docs.angr.io/projects/cle/en/latest/api/backend.html#cle.backends.symbol.Symbol "\(in cle\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

function _: `Function` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

name _: [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

cc _: `SimCC` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

prototype _: `SimTypeFunction` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

args_atoms _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Atom`]] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

args_values _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`MultiValues`[[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`FP`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)")]] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

ret_atoms _: [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Atom`] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

redefine_locals _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_ _ = True_¶
    

visited_blocks _: [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

effects _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`FunctionEffect`]_¶
    

ret_values _: [`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[`MultiValues`[[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`FP`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)")]]__ = None_¶
    

ret_values_deps _: [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

caller_will_handle_single_ret _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_ _ = False_¶
    

guessed_cc _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_ _ = False_¶
    

guessed_prototype _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_ _ = False_¶
    

retaddr_popped _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_ _ = False_¶
    

has_clobbered(_dest_)¶
    

Determines whether the given atom already has effects applied

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**dest** (_Atom_)

depends(_dest_ , _* sources_, _value =None_, _apply_at_callsite =False_, _tags =None_)¶
    

Mark a single effect of the current function, including the atom being modified, the input atoms on which that output atom depends, the precise (or imprecise!) value to store, and whether the effect should be applied during the function or afterwards, at the callsite.

The tags are used to annotate the Definition of the Atom that will be created, when the function effects are applied to the state.

The atom being modified may be None to mark uses of the source atoms which do not have any explicit sinks.

Parameters:
    

  * **dest** (_Atom_ _|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Atom_ _]__|__None_)

  * **sources** (_Atom_ _|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Atom_ _]_)

  * **value** (_MultiValues_ _|_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _|_[_bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **apply_at_callsite** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **tags** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Tag_ _]__|__None_)

reset_prototype(_prototype_ , _state_ , _soft_reset =False_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Atom`]

Parameters:
    

  * **prototype** (_SimTypeFunction_)

  * **state** (_ReachingDefinitionsState_)

  * **soft_reset** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_callsite_codeloc_ , _function_codeloc_ , _address_multi_ , _address=None_ , _symbol=None_ , _function=None_ , _name=None_ , _cc=None_ , _prototype=None_ , _args_atoms=None_ , _args_values=None_ , _ret_atoms=None_ , _redefine_locals=True_ , _visited_blocks=None_ , _effects= <factory>_, _ret_values=None_ , _ret_values_deps=None_ , _caller_will_handle_single_ret=False_ , _guessed_cc=False_ , _guessed_prototype=False_ , _retaddr_popped=False_)¶
    

Parameters:
    

  * **callsite_codeloc** (_CodeLocation_)

  * **function_codeloc** (_CodeLocation_)

  * **address_multi** (_MultiValues_ _[_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _|_[_FP_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)") _]__|__None_)

  * **address** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **symbol** ([_Symbol_](https://docs.angr.io/projects/cle/en/latest/api/backend.html#cle.backends.symbol.Symbol "\(in cle\)") _|__None_)

  * **function** (_Function_ _|__None_)

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **cc** (_SimCC_ _|__None_)

  * **prototype** (_SimTypeFunction_ _|__None_)

  * **args_atoms** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Atom_ _]__]__|__None_)

  * **args_values** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__MultiValues_ _[_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _|_[_FP_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)") _]__]__|__None_)

  * **ret_atoms** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Atom_ _]__|__None_)

  * **redefine_locals** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **visited_blocks** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **effects** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__FunctionEffect_ _]_)

  * **ret_values** (_MultiValues_ _[_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _|_[_FP_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)") _]__|__None_)

  * **ret_values_deps** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Definition_ _]__|__None_)

  * **caller_will_handle_single_ret** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **guessed_cc** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **guessed_prototype** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **retaddr_popped** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Return type:
    

None

_class _angr.analyses.reaching_definitions.FunctionCallRelationships(_callsite_ , _target_ , _args_defns_ , _other_input_defns_ , _ret_defns_ , _other_output_defns_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Produced by the function handler, provides associated callsite info and function input/output definitions.

Parameters:
    

  * **callsite** (_CodeLocation_)

  * **target** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **args_defns** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Definition_ _]__]_)

  * **other_input_defns** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Definition_ _]_)

  * **ret_defns** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Definition_ _]_)

  * **other_output_defns** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Definition_ _]_)

callsite _: `CodeLocation`_¶
    

target _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

args_defns _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]]_¶
    

other_input_defns _: [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]_¶
    

ret_defns _: [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]_¶
    

other_output_defns _: [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]_¶
    

__init__(_callsite_ , _target_ , _args_defns_ , _other_input_defns_ , _ret_defns_ , _other_output_defns_)¶
    

Parameters:
    

  * **callsite** (_CodeLocation_)

  * **target** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **args_defns** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Definition_ _]__]_)

  * **other_input_defns** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Definition_ _]_)

  * **ret_defns** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Definition_ _]_)

  * **other_output_defns** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Definition_ _]_)

Return type:
    

None

_class _angr.analyses.reaching_definitions.FunctionHandler(_interfunction_level =0_, _extra_impls =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A mechanism for summarizing a function call’s effect on a program for ReachingDefinitionsAnalysis.

Parameters:
    

  * **interfunction_level** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **extra_impls** (_Iterable_ _[_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__FunctionHandler_ _]__]__|__None_)

__init__(_interfunction_level =0_, _extra_impls =None_)¶
    

Parameters:
    

  * **interfunction_level** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Maximum depth in to continue local function exploration

  * **extra_impls** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`Iterable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)")[[`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`FunctionHandler`]]]) – FunctionHandler classes to implement beyond what’s implemented in function_handler_library

hook(_analysis_)¶
    

Attach this instance of the function handler to an instance of RDA.

Return type:
    

`FunctionHandler`

Parameters:
    

**analysis** (_ReachingDefinitionsAnalysis_)

make_function_codeloc(_target_ , _callsite_ , _callsite_func_addr_)¶
    

The RDA engine will call this function to transform a callsite CodeLocation into a callee CodeLocation.

Parameters:
    

  * **target** (_None_ _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__MultiValues_)

  * **callsite** (_CodeLocation_)

  * **callsite_func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

handle_function(_state_ , _data_)¶
    

The main entry point for the function handler. Called with a RDA state and a FunctionCallData, it is expected to update the state and the data as per the contracts described on FunctionCallData.

You can override this method to take full control over how data is processed, or override any of the following to use the higher-level interface (data.depends()):

  * handle_impl_<function name> \- used for <function name>.

  * handle_local_function \- used for any function (excluding plt stubs) whose address is inside the main binary.

  * handle_external_function \- used for any function or plt stub whose address is outside the main binary.

  * handle_indirect_function \- used for any function whose target cannot be resolved.

  * handle_generic_function \- used as a default if none of the above are overridden.

Each of them take the same signature as handle_function.

Parameters:
    

  * **state** (_ReachingDefinitionsState_)

  * **data** (_FunctionCallData_)

handle_generic_function(_state_ , _data_)¶
    

Parameters:
    

  * **state** (_ReachingDefinitionsState_)

  * **data** (_FunctionCallData_)

handle_indirect_function(_state_ , _data_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **state** (_ReachingDefinitionsState_)

  * **data** (_FunctionCallData_)

handle_local_function(_state_ , _data_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **state** (_ReachingDefinitionsState_)

  * **data** (_FunctionCallData_)

handle_external_function(_state_ , _data_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **state** (_ReachingDefinitionsState_)

  * **data** (_FunctionCallData_)

recurse_analysis(_state_ , _data_)¶
    

Precondition: `data.function` MUST NOT BE NONE in order to call this method.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **state** (_ReachingDefinitionsState_)

  * **data** (_FunctionCallData_)

_static _c_args_as_atoms(_state_ , _cc_ , _prototype_)¶
    

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Atom`]]

Parameters:
    

  * **state** (_ReachingDefinitionsState_)

  * **cc** (_SimCC_)

  * **prototype** (_SimTypeFunction_)

_static _c_return_as_atoms(_state_ , _cc_ , _prototype_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Atom`]

Parameters:
    

  * **state** (_ReachingDefinitionsState_)

  * **cc** (_SimCC_)

  * **prototype** (_SimTypeFunction_)

_static _caller_saved_regs_as_atoms(_state_ , _cc_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Register`]

Parameters:
    

  * **state** (_ReachingDefinitionsState_)

  * **cc** (_SimCC_)

_static _stack_pointer_as_atom(_state_)¶
    

Return type:
    

`Register`

_class _angr.analyses.reaching_definitions.GuardUse(_target_)¶
    

Bases: `Atom`

Implements a guard use.

__init__(_target_)¶
    

Parameters:
    

**size** – The size of the atom in bytes

target¶
    

_class _angr.analyses.reaching_definitions.LiveDefinitions(_arch_ , _track_tmps =False_, _canonical_size =8_, _registers =None_, _stack =None_, _memory =None_, _heap =None_, _tmps =None_, _others =None_, _register_uses =None_, _stack_uses =None_, _heap_uses =None_, _memory_uses =None_, _tmp_uses =None_, _other_uses =None_, _element_limit =5_, _merge_into_tops =True_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A LiveDefinitions instance contains definitions and uses for register, stack, memory, and temporary variables, uncovered during the analysis.

Parameters:
    

  * **arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

  * **track_tmps** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **registers** (_MultiValuedMemory_)

  * **stack** (_MultiValuedMemory_)

  * **memory** (_MultiValuedMemory_)

  * **heap** (_MultiValuedMemory_)

  * **tmps** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Definition_ _]__]_)

  * **others** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__Atom_ _,__MultiValues_ _]_)

  * **tmp_uses** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__CodeLocation_ _]__]_)

  * **merge_into_tops** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

INITIAL_SP_32BIT _ = 2147418112_¶
    

INITIAL_SP_64BIT _ = 140737488289792_¶
    

__init__(_arch_ , _track_tmps =False_, _canonical_size =8_, _registers =None_, _stack =None_, _memory =None_, _heap =None_, _tmps =None_, _others =None_, _register_uses =None_, _stack_uses =None_, _heap_uses =None_, _memory_uses =None_, _tmp_uses =None_, _other_uses =None_, _element_limit =5_, _merge_into_tops =True_)¶
    

Parameters:
    

  * **arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)"))

  * **track_tmps** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **merge_into_tops** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

project _: `Project` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

arch¶
    

track_tmps¶
    

registers _: `MultiValuedMemory`_¶
    

stack _: `MultiValuedMemory`_¶
    

memory _: `MultiValuedMemory`_¶
    

heap _: `MultiValuedMemory`_¶
    

tmps _: [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]]_¶
    

others _: [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[`Atom`, `MultiValues`]_¶
    

register_uses¶
    

stack_uses¶
    

heap_uses¶
    

memory_uses¶
    

tmp_uses _: [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`CodeLocation`]]_¶
    

other_uses¶
    

uses_by_codeloc _: [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[`CodeLocation`, [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]]_¶
    

copy(_discard_tmpdefs =False_)¶
    

Return type:
    

`LiveDefinitions`

reset_uses()¶
    

_static _top(_bits_)¶
    

Get a TOP value.

Parameters:
    

**bits** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Width of the TOP value (in bits).

Returns:
    

The TOP value.

_static _is_top(_expr_)¶
    

Check if the given expression is a TOP value.

Parameters:
    

**expr** – The given expression.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

True if the expression is TOP, False otherwise.

stack_address(_offset_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

**offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_static _is_stack_address(_addr_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**addr** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

_static _get_stack_offset(_addr_ , _had_stack_base =False_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**addr** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

_static _annotate_with_def(_symvar_ , _definition_)¶
    

Parameters:
    

  * **symvar** ([`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`MVType`, bound= [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`FP`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)")))

  * **definition** (`Definition`)

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`MVType`, bound= [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`FP`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)"))

Returns:
    

_static _extract_defs(_symvar_)¶
    

Return type:
    

[`Generator`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Generator "\(in Python v3.13\)")[`Definition`]

Parameters:
    

**symvar** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

_static _extract_defs_from_annotations(_annos_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]

Parameters:
    

**annos** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[_[_Annotation_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.annotation.Annotation "\(in claripy\)") _]_)

_static _extract_defs_from_mv(_mv_)¶
    

Return type:
    

[`Generator`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Generator "\(in Python v3.13\)")[`Definition`]

Parameters:
    

**mv** (_MultiValues_)

get_sp()¶
    

Return the concrete value contained by the stack pointer.

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

get_sp_offset()¶
    

Return the offset of the stack pointer.

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

get_stack_address(_offset_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**offset** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

stack_offset_to_stack_addr(_offset_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

merge(_* others_)¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`LiveDefinitions`, [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")]

Parameters:
    

**others** (_LiveDefinitions_)

compare(_other_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**other** (_LiveDefinitions_)

kill_definitions(_atom_)¶
    

Overwrite existing definitions w.r.t ‘atom’ with a dummy definition instance. A dummy definition will not be removed during simplification.

Parameters:
    

**atom** (`Atom`)

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

None

kill_and_add_definition(_atom_ , _code_loc_ , _data_ , _dummy =False_, _tags =None_, _endness =None_, _annotated =False_)¶
    

Return type:
    

`MultiValues` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **atom** (_Atom_)

  * **code_loc** (_CodeLocation_)

  * **data** (_MultiValues_)

  * **tags** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Tag_ _]__|__None_)

add_use(_atom_ , _code_loc_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **atom** (_Atom_)

  * **code_loc** (_CodeLocation_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_use_by_def(_definition_ , _code_loc_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **definition** (_Definition_)

  * **code_loc** (_CodeLocation_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

get_definitions(_thing_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`[`Atom`]]

Parameters:
    

**thing** (_Atom_ _|__Definition_ _[__Atom_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Atom_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _[__Atom_ _]__]__|__MultiValues_)

get_tmp_definitions(_tmp_idx_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]

Parameters:
    

**tmp_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_register_definitions(_reg_offset_ , _size_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]

Parameters:
    

  * **reg_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_stack_values(_stack_offset_ , _size_ , _endness_)¶
    

Return type:
    

`MultiValues` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **stack_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

get_stack_definitions(_stack_offset_ , _size_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]

Parameters:
    

  * **stack_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_heap_definitions(_heap_addr_ , _size_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]

Parameters:
    

  * **heap_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_memory_definitions(_addr_ , _size_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_values(_spec_ , _endness =None_)¶
    

Return type:
    

`MultiValues` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **spec** (_A_ _|__Definition_ _[__A_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__A_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _[__A_ _]__]_)

  * **endness** ([_Endness_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.types.Endness "\(in archinfo\)") _|__None_)

get_one_value(_spec_ , _strip_annotations =False_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **spec** (_A_ _|__Definition_ _[__A_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__A_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _[__A_ _]__]_)

  * **strip_annotations** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

get_concrete_value(_spec_ , _cast_to= <class 'int'>_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **spec** (_A_ _|__Definition_ _[__A_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__A_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _[__A_ _]__]_)

  * **cast_to** ([_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[_[_bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") _]_)

add_register_use(_reg_offset_ , _size_ , _code_loc_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **reg_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **code_loc** (_CodeLocation_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_register_use_by_def(_def__ , _code_loc_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **def_** (_Definition_)

  * **code_loc** (_CodeLocation_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_stack_use(_atom_ , _code_loc_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **atom** (_MemoryLocation_)

  * **code_loc** (_CodeLocation_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_stack_use_by_def(_def__ , _code_loc_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **def_** (_Definition_)

  * **code_loc** (_CodeLocation_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_heap_use(_atom_ , _code_loc_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **atom** (_MemoryLocation_)

  * **code_loc** (_CodeLocation_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_heap_use_by_def(_def__ , _code_loc_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **def_** (_Definition_)

  * **code_loc** (_CodeLocation_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_memory_use(_atom_ , _code_loc_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **atom** (_MemoryLocation_)

  * **code_loc** (_CodeLocation_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_memory_use_by_def(_def__ , _code_loc_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **def_** (_Definition_)

  * **code_loc** (_CodeLocation_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_tmp_use(_atom_ , _code_loc_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **atom** (_Tmp_)

  * **code_loc** (_CodeLocation_)

add_tmp_use_by_def(_def__ , _code_loc_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **def_** (_Definition_)

  * **code_loc** (_CodeLocation_)

deref(_pointer_ , _size_ , _endness =Endness.BE_)¶
    

_static _is_heap_address(_addr_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**addr** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

_static _get_heap_offset(_addr_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**addr** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

heap_address(_offset_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

**offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__HeapAddress_)

_class _angr.analyses.reaching_definitions.MemoryLocation(_addr_ , _size_ , _endness =None_)¶
    

Bases: `Atom`

Represents a memory slice.

It is characterized by its address and its size.

Parameters:
    

  * **addr** (_SpOffset_ _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **endness** (_Endness_ _|__None_)

__init__(_addr_ , _size_ , _endness =None_)¶
    

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address of the beginning memory location slice.

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The size of the represented memory location, in bytes.

  * **endness** ([_Endness_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.types.Endness "\(in archinfo\)") _|__None_)

addr _: `SpOffset` | [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")_¶
    

endness¶
    

_property _is_on_stack _: [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

True if this memory location is located on the stack.

_property _symbolic _: [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

_class _angr.analyses.reaching_definitions.ObservationPointType(_value_)¶
    

Bases: [`IntEnum`](https://docs.python.org/3/library/enum.html#enum.IntEnum "\(in Python v3.13\)")

Enum to replace the previously generic constants This makes it possible to annotate where they are expected by typing something as ObservationPointType instead of Literal[0,1]

OP_BEFORE _ = 0_¶
    

OP_AFTER _ = 1_¶
    

_class _angr.analyses.reaching_definitions.ReachingDefinitionsAnalysis(_subject_ , _func_graph =None_, _max_iterations =30_, _track_tmps =False_, _track_consts =True_, _observation_points =None_, _init_state =None_, _init_context =None_, _state_initializer =None_, _cc =None_, _function_handler =None_, _observe_all =False_, _visited_blocks =None_, _dep_graph =True_, _observe_callback =None_, _canonical_size =8_, _stack_pointer_tracker =None_, _use_callee_saved_regs_at_return =True_, _interfunction_level =0_, _track_liveness =True_, _func_addr =None_, _element_limit =5_, _merge_into_tops =True_)¶
    

Bases: `ForwardAnalysis`[`ReachingDefinitionsState`, `NodeType`, [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)"), [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")], `Analysis`

ReachingDefinitionsAnalysis is a text-book implementation of a static data-flow analysis that works on either a function or a block. It supports both VEX and AIL. By registering observers to observation points, users may use this analysis to generate use-def chains, def-use chains, and reaching definitions, and perform other traditional data-flow analyses such as liveness analysis.

  * I’ve always wanted to find a better name for this analysis. Now I gave up and decided to live with this name for the foreseeable future (until a better name is proposed by someone else).

  * Aliasing is definitely a problem, and I forgot how aliasing is resolved in this implementation. I’ll leave this as a post-graduation TODO.

  * Some more documentation and examples would be nice.

Parameters:
    

  * **subject** (_Subject_ _|__ailment.Block_ _|__Block_ _|__Function_ _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **observation_points** (_Iterable_ _[__ObservationPoint_ _]__|__None_)

  * **init_state** (_ReachingDefinitionsState_ _|__None_)

  * **state_initializer** (_RDAStateInitializer_ _|__None_)

  * **function_handler** (_FunctionHandler_ _|__None_)

  * **dep_graph** (_DepGraph_ _|_[_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **interfunction_level** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **track_liveness** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **element_limit** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **merge_into_tops** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_subject_ , _func_graph =None_, _max_iterations =30_, _track_tmps =False_, _track_consts =True_, _observation_points =None_, _init_state =None_, _init_context =None_, _state_initializer =None_, _cc =None_, _function_handler =None_, _observe_all =False_, _visited_blocks =None_, _dep_graph =True_, _observe_callback =None_, _canonical_size =8_, _stack_pointer_tracker =None_, _use_callee_saved_regs_at_return =True_, _interfunction_level =0_, _track_liveness =True_, _func_addr =None_, _element_limit =5_, _merge_into_tops =True_)¶
    

Parameters:
    

  * **subject** (`Subject` | `Block` | `Block` | `Function` | [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The subject of the analysis: a function, or a single basic block

  * **func_graph** – Alternative graph for function.graph.

  * **max_iterations** – The maximum number of iterations before the analysis is terminated.

  * **track_tmps** – Whether or not temporary variables should be taken into consideration during the analysis.

  * **observation_points** (_iterable_) – A collection of tuples of (“node”|”insn”, ins_addr, OP_TYPE) defining where reaching definitions should be copied and stored. OP_TYPE can be OP_BEFORE or OP_AFTER.

  * **init_state** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[`ReachingDefinitionsState`]) – An optional initialization state. The analysis creates and works on a copy. Default to None: the analysis then initialize its own abstract state, based on the given <Subject>.

  * **init_context** – If init_state is not given, this is used to initialize the context field of the initial state’s CodeLocation. The only default-supported type which may go here is a tuple of integers, i.e. a callstack. Anything else requires a custom FunctionHandler.

  * **cc** – Calling convention of the function.

  * **function_handler** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[`FunctionHandler`]) – The function handler to update the analysis state and results on function calls.

  * **observe_all** – Observe every statement, both before and after.

  * **visited_blocks** – A set of previously visited blocks.

  * **dep_graph** (`DepGraph` | [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")) – An initial dependency graph to add the result of the analysis to. Set it to None to skip dependency graph generation.

  * **canonical_size** – The sizes (in bytes) that objects with an UNKNOWN_SIZE are treated as for operations where sizes are necessary.

  * **dep_graph** – Set this to True to generate a dependency graph for the subject. It will be available as result.dep_graph.

  * **interfunction_level** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The number of functions we should recurse into. This parameter is only used if function_handler is not provided.

  * **track_liveness** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether to track liveness information. This can consume sizeable amounts of RAM on large functions. (e.g. ~15GB for a function with 4k nodes)

  * **merge_into_tops** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Merge known values into TOP if TOP is present. If True: {TOP} V {0xabc} = {TOP} If False: {TOP} V {0xabc} = {TOP, 0xabc}

  * **state_initializer** (_RDAStateInitializer_ _|__None_)

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **element_limit** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_property _observed_results _: [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"), [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")], LiveDefinitions]_¶
    

_property _all_definitions¶
    

_property _all_uses¶
    

_property _one_result¶
    

_property _dep_graph _: DepGraph_¶
    

_property _visited_blocks¶
    

get_reaching_definitions_by_insn(_ins_addr_ , _op_type_)¶
    

get_reaching_definitions_by_node(_node_addr_ , _op_type_)¶
    

node_observe(_node_addr_ , _state_ , _op_type_ , _node_idx =None_)¶
    

Parameters:
    

  * **node_addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the node.

  * **state** (`ReachingDefinitionsState`) – The analysis state.

  * **op_type** (`ObservationPointType`) – Type of the observation point. Must be one of the following: OP_BEFORE, OP_AFTER.

  * **node_idx** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – ID of the node. Used in AIL to differentiate blocks with the same address.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

insn_observe(_insn_addr_ , _stmt_ , _block_ , _state_ , _op_type_)¶
    

Parameters:
    

  * **insn_addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the instruction.

  * **stmt** (`Statement` | [`IRStmt`](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.stmt.IRStmt "\(in pyvex\)")) – The statement.

  * **block** (`Block` | `Block`) – The current block.

  * **state** (`ReachingDefinitionsState`) – The abstract analysis state.

  * **op_type** (`ObservationPointType`) – Type of the observation point. Must be one of the following: OP_BEORE, OP_AFTER.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

stmt_observe(_stmt_idx_ , _stmt_ , _block_ , _state_ , _op_type_)¶
    

Parameters:
    

  * **stmt_idx** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **stmt** (`Statement` | [`IRStmt`](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.stmt.IRStmt "\(in pyvex\)"))

  * **block** (`Block` | `Block`)

  * **state** (`ReachingDefinitionsState`)

  * **op_type** (`ObservationPointType`)

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

exit_observe(_node_addr_ , _exit_stmt_idx_ , _block_ , _state_ , _node_idx =None_)¶
    

Parameters:
    

  * **node_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **exit_stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **block** (_Block_ _|__Block_)

  * **state** (_ReachingDefinitionsState_)

  * **node_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

_property _subject¶
    

callsites_to(_target_)¶
    

Return type:
    

[`Iterable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)")[`FunctionCallRelationships`]

Parameters:
    

**target** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__Function_)

_class _angr.analyses.reaching_definitions.ReachingDefinitionsModel(_func_addr =None_, _track_liveness =True_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Models the definitions, uses, and memory of a ReachingDefinitionState object

Parameters:
    

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **track_liveness** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_func_addr =None_, _track_liveness =True_)¶
    

Parameters:
    

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **track_liveness** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

add_def(_d_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**d** (_Definition_)

kill_def(_d_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**d** (_Definition_)

at_new_stmt(_codeloc_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**codeloc** (_CodeLocation_)

at_new_block(_code_loc_ , _pred_codelocs_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **code_loc** (_CodeLocation_)

  * **pred_codelocs** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__CodeLocation_ _]_)

make_liveness_snapshot()¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

find_defs_at(_code_loc_ , _op =ObservationPointType.OP_BEFORE_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]

Parameters:
    

  * **code_loc** (_CodeLocation_)

  * **op** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_defs(_atom_ , _code_loc_ , _op_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]

Parameters:
    

  * **atom** (_Atom_)

  * **code_loc** (_CodeLocation_)

  * **op** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

copy()¶
    

Return type:
    

`ReachingDefinitionsModel`

merge(_model_)¶
    

Parameters:
    

**model** (_ReachingDefinitionsModel_)

get_observation_by_insn(_ins_addr_ , _kind_)¶
    

Return type:
    

`LiveDefinitions` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__CodeLocation_)

  * **kind** (_ObservationPointType_)

get_observation_by_node(_node_addr_ , _kind_ , _node_idx =None_)¶
    

Return type:
    

`LiveDefinitions` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **node_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__CodeLocation_)

  * **kind** (_ObservationPointType_)

  * **node_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

get_observation_by_stmt(_arg1_ , _arg2_ , _arg3 =None_, _*_ , _block_idx =None_)¶
    

get_observation_by_exit(_node_addr_ , _stmt_idx_ , _src_node_idx =None_)¶
    

Return type:
    

`LiveDefinitions` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **node_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **src_node_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

_class _angr.analyses.reaching_definitions.ReachingDefinitionsState(_codeloc_ , _arch_ , _subject_ , _analysis_ , _track_tmps =False_, _track_consts =False_, _rtoc_value =None_, _live_definitions =None_, _canonical_size =8_, _heap_allocator =None_, _environment =None_, _sp_adjusted =False_, _all_definitions =None_, _initializer =None_, _element_limit =5_, _merge_into_tops =True_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Represents the internal state of the ReachingDefinitionsAnalysis.

It contains a data class LiveDefinitions, which stores both definitions and uses for register, stack, memory, and temporary variables, uncovered during the analysis.

Parameters:
    

  * **subject** (`Subject`) – The subject being analyzed.

  * **track_tmps** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Only tells whether or not temporary variables should be taken into consideration when representing the state of the analysis. Should be set to true when the analysis has counted uses and definitions for temporary variables, false otherwise.

  * **analysis** (`ReachingDefinitionsAnalysis`) – The analysis that generated the state represented by this object.

  * **rtoc_value** – When the targeted architecture is ppc64, the initial function needs to know the rtoc_value.

  * **live_definitions** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[`LiveDefinitions`])

  * **canonical_size** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The sizes (in bytes) that objects with an UNKNOWN_SIZE are treated as for operations where sizes are necessary.

  * **heap_allocator** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[`HeapAllocator`]) – Mechanism to model the management of heap memory.

  * **environment** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[`Environment`]) – Representation of the environment of the analyzed program.

  * **codeloc** (_CodeLocation_)

  * **arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

  * **track_consts** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **sp_adjusted** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **all_definitions** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Definition_ _[__A_ _]__]__|__None_)

  * **initializer** (_RDAStateInitializer_ _|__None_)

  * **element_limit** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **merge_into_tops** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Variables:
    

**arch** – The architecture targeted by the program.

__init__(_codeloc_ , _arch_ , _subject_ , _analysis_ , _track_tmps =False_, _track_consts =False_, _rtoc_value =None_, _live_definitions =None_, _canonical_size =8_, _heap_allocator =None_, _environment =None_, _sp_adjusted =False_, _all_definitions =None_, _initializer =None_, _element_limit =5_, _merge_into_tops =True_)¶
    

Parameters:
    

  * **codeloc** (_CodeLocation_)

  * **arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)"))

  * **subject** (_Subject_)

  * **analysis** (_ReachingDefinitionsAnalysis_)

  * **track_tmps** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **track_consts** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **live_definitions** (_LiveDefinitions_ _|__None_)

  * **canonical_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **heap_allocator** (_HeapAllocator_ _|__None_)

  * **environment** (_Environment_ _|__None_)

  * **sp_adjusted** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **all_definitions** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Definition_ _[__A_ _]__]__|__None_)

  * **initializer** (_RDAStateInitializer_ _|__None_)

  * **element_limit** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **merge_into_tops** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

codeloc¶
    

arch _: [`Arch`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)")_¶
    

analysis¶
    

all_definitions _: [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]_¶
    

heap_allocator¶
    

codeloc_uses _: [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]_¶
    

exit_observed _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

live_definitions¶
    

top(_bits_)¶
    

Parameters:
    

**bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

is_top(_* args_)¶
    

heap_address(_offset_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

**offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__HeapAddress_)

_static _is_heap_address(_addr_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**addr** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

_static _get_heap_offset(_addr_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**addr** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

stack_address(_offset_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

**offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

is_stack_address(_addr_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**addr** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

get_stack_offset(_addr_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**addr** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

annotate_with_def(_symvar_ , _definition_)¶
    

Parameters:
    

  * **symvar** ([`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`MVType`, bound= [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`FP`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)")))

  * **definition** (`Definition`[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")])

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`MVType`, bound= [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`FP`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)"))

Returns:
    

annotate_mv_with_def(_mv_ , _definition_)¶
    

Return type:
    

`MultiValues`[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`MVType`, bound= [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`FP`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)"))]

Parameters:
    

  * **mv** (_MultiValues_ _[__MVType_ _]_)

  * **definition** (_Definition_ _[__A_ _]_)

extract_defs(_symvar_)¶
    

Return type:
    

[`Iterator`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterator "\(in Python v3.13\)")[`Definition`[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]

Parameters:
    

**symvar** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

_property _tmps¶
    

_property _tmp_uses¶
    

_property _registers _: MultiValuedMemory_¶
    

_property _register_uses¶
    

_property _stack _: MultiValuedMemory_¶
    

_property _stack_uses¶
    

_property _heap _: MultiValuedMemory_¶
    

_property _heap_uses¶
    

_property _memory _: MultiValuedMemory_¶
    

_property _memory_uses¶
    

_property _others _: [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[Atom, MultiValues]_¶
    

_property _uses_by_codeloc¶
    

get_sp()¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

get_stack_address(_offset_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**offset** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

_property _environment¶
    

_property _dep_graph¶
    

copy(_discard_tmpdefs =False_)¶
    

Return type:
    

`Self`

merge(_* others_)¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`Self`, [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")]

Parameters:
    

**others** (_Self_)

compare(_other_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**other** (_ReachingDefinitionsState_)

move_codelocs(_new_codeloc_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**new_codeloc** (_CodeLocation_)

kill_definitions(_atom_)¶
    

Overwrite existing definitions w.r.t ‘atom’ with a dummy definition instance. A dummy definition will not be removed during simplification.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**atom** (_Atom_)

kill_and_add_definition(_atom_ , _data_ , _dummy =False_, _tags =None_, _endness =None_, _annotated =False_, _uses =None_, _override_codeloc =None_)¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`MultiValues` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)"), [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`A`, bound= `Atom`)]]]

Parameters:
    

  * **atom** (_Atom_)

  * **data** (_MultiValues_)

  * **tags** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Tag_ _]__|__None_)

  * **annotated** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **uses** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Definition_ _[__A_ _]__]__|__None_)

  * **override_codeloc** (_CodeLocation_ _|__None_)

add_use(_atom_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **atom** (_Atom_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_use_by_def(_definition_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **definition** (_Definition_ _[__A_ _]_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_tmp_use(_tmp_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **tmp** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_tmp_use_by_defs(_defs_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **defs** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _[__A_ _]__]_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_register_use(_reg_offset_ , _size_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **reg_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_register_use_by_defs(_defs_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **defs** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _[__A_ _]__]_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_stack_use(_stack_offset_ , _size_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **stack_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_stack_use_by_defs(_defs_ , _expr =None_)¶
    

Parameters:
    

  * **defs** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _[__A_ _]__]_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_heap_use(_heap_offset_ , _size_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **heap_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_heap_use_by_defs(_defs_ , _expr =None_)¶
    

Parameters:
    

  * **defs** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _[__A_ _]__]_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_memory_use_by_def(_definition_ , _expr =None_)¶
    

Parameters:
    

  * **definition** (_Definition_ _[__A_ _]_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_memory_use_by_defs(_defs_ , _expr =None_)¶
    

Parameters:
    

  * **defs** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _[__A_ _]__]_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

get_definitions(_atom_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`[`Atom`]]

Parameters:
    

**atom** (_Atom_ _|__Definition_ _[__Atom_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Atom_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _[__Atom_ _]__]__|__MultiValues_)

get_values(_spec_)¶
    

Return type:
    

`MultiValues` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**spec** (_A_ _|__Definition_ _[__A_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__A_ _]_)

get_one_value(_spec_ , _strip_annotations =False_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **spec** (_A_ _|__Definition_ _[__A_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__A_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _[__A_ _]__]_)

  * **strip_annotations** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

get_concrete_value(_spec_ , _cast_to= <class 'int'>_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **spec** (_Atom_ _|__Definition_ _[__Atom_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Atom_ _]_)

  * **cast_to** ([_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[_[_bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") _]_)

mark_guard(_target_)¶
    

mark_const(_value_ , _size_)¶
    

Parameters:
    

  * **value** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

downsize()¶
    

deref(_pointer_ , _size_ , _endness =Endness.BE_)¶
    

Parameters:
    

  * **pointer** (_MultiValues_ _[_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _]__|__Atom_ _|__Definition_ _[__Atom_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Atom_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _[__Atom_ _]__]__|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _|__HeapAddress_ _|__SpOffset_)

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__DerefSize_)

  * **endness** ([_Endness_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.types.Endness "\(in archinfo\)"))

_class _angr.analyses.reaching_definitions.Register(_reg_offset_ , _size_ , _arch =None_)¶
    

Bases: `Atom`

Represents a given CPU register.

As an IR abstracts the CPU design to target different architectures, registers are represented as a separated memory space. Thus a register is defined by its offset from the base of this memory and its size.

Variables:
    

  * **reg_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The offset from the base to define its place in the memory bloc.

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The size, in number of bytes.

Parameters:
    

  * **reg_offset** (_RegisterOffset_ _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **arch** (_Arch_ _|__None_)

__init__(_reg_offset_ , _size_ , _arch =None_)¶
    

Parameters:
    

  * **size** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The size of the atom in bytes

  * **reg_offset** ([_RegisterOffset_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.types.RegisterOffset "\(in archinfo\)") _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)") _|__None_)

reg_offset¶
    

arch¶
    

_property _name _: [str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")_¶
    

_class _angr.analyses.reaching_definitions.Tmp(_tmp_idx_ , _size_)¶
    

Bases: `Atom`

Represents a variable used by the IR to store intermediate values.

Parameters:
    

  * **tmp_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_tmp_idx_ , _size_)¶
    

Parameters:
    

  * **size** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The size of the atom in bytes

  * **tmp_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

tmp_idx¶
    

angr.analyses.reaching_definitions.get_all_definitions(_region_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]

Parameters:
    

**region** (_MultiValuedMemory_)

_class _angr.analyses.reaching_definitions.call_trace.CallSite(_caller_func_addr_ , _block_addr_ , _callee_func_addr_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Describes a call site on a CFG.

Parameters:
    

  * **caller_func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **callee_func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_caller_func_addr_ , _block_addr_ , _callee_func_addr_)¶
    

Parameters:
    

  * **caller_func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **callee_func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

caller_func_addr¶
    

callee_func_addr¶
    

block_addr¶
    

_class _angr.analyses.reaching_definitions.call_trace.CallTrace(_target_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Describes a series of functions calls to get from one function (current_function_address()) to another function or a basic block (self.target).

Parameters:
    

**target** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_target_)¶
    

Parameters:
    

**target** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

target¶
    

callsites _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`CallSite`]_¶
    

current_function_address()¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

step_back(_caller_func_addr_ , _block_addr_ , _callee_func_addr_)¶
    

Return type:
    

`CallTrace`

Parameters:
    

  * **caller_func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

includes_function(_func_addr_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

copy()¶
    

Return type:
    

`CallTrace`

_class _angr.analyses.reaching_definitions.engine_vex.SimEngineRDVEX(_project_ , _function_handler_ , _functions_)¶
    

Bases: `SimEngineNostmtVEX`[`ReachingDefinitionsState`, `MultiValues`[[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`FP`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)")], `ReachingDefinitionsState`]

Implements the VEX execution engine for reaching definition analysis.

Parameters:
    

  * **function_handler** (_FunctionHandler_)

  * **functions** (_FunctionManager_)

__init__(_project_ , _function_handler_ , _functions_)¶
    

Parameters:
    

  * **function_handler** (_FunctionHandler_)

  * **functions** (_FunctionManager_)

process(_state_ , _*_ , _block =None_, _fail_fast =False_, _visited_blocks =None_, _dep_graph =None_, _whitelist =None_, _** kwargs_)¶
    

_class _angr.analyses.reaching_definitions.reaching_definitions.ReachingDefinitionsAnalysis(_subject_ , _func_graph =None_, _max_iterations =30_, _track_tmps =False_, _track_consts =True_, _observation_points =None_, _init_state =None_, _init_context =None_, _state_initializer =None_, _cc =None_, _function_handler =None_, _observe_all =False_, _visited_blocks =None_, _dep_graph =True_, _observe_callback =None_, _canonical_size =8_, _stack_pointer_tracker =None_, _use_callee_saved_regs_at_return =True_, _interfunction_level =0_, _track_liveness =True_, _func_addr =None_, _element_limit =5_, _merge_into_tops =True_)¶
    

Bases: `ForwardAnalysis`[`ReachingDefinitionsState`, `NodeType`, [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)"), [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")], `Analysis`

ReachingDefinitionsAnalysis is a text-book implementation of a static data-flow analysis that works on either a function or a block. It supports both VEX and AIL. By registering observers to observation points, users may use this analysis to generate use-def chains, def-use chains, and reaching definitions, and perform other traditional data-flow analyses such as liveness analysis.

  * I’ve always wanted to find a better name for this analysis. Now I gave up and decided to live with this name for the foreseeable future (until a better name is proposed by someone else).

  * Aliasing is definitely a problem, and I forgot how aliasing is resolved in this implementation. I’ll leave this as a post-graduation TODO.

  * Some more documentation and examples would be nice.

Parameters:
    

  * **subject** (_Subject_ _|__ailment.Block_ _|__Block_ _|__Function_ _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **observation_points** (_Iterable_ _[__ObservationPoint_ _]__|__None_)

  * **init_state** (_ReachingDefinitionsState_ _|__None_)

  * **state_initializer** (_RDAStateInitializer_ _|__None_)

  * **function_handler** (_FunctionHandler_ _|__None_)

  * **dep_graph** (_DepGraph_ _|_[_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **interfunction_level** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **track_liveness** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **element_limit** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **merge_into_tops** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_subject_ , _func_graph =None_, _max_iterations =30_, _track_tmps =False_, _track_consts =True_, _observation_points =None_, _init_state =None_, _init_context =None_, _state_initializer =None_, _cc =None_, _function_handler =None_, _observe_all =False_, _visited_blocks =None_, _dep_graph =True_, _observe_callback =None_, _canonical_size =8_, _stack_pointer_tracker =None_, _use_callee_saved_regs_at_return =True_, _interfunction_level =0_, _track_liveness =True_, _func_addr =None_, _element_limit =5_, _merge_into_tops =True_)¶
    

Parameters:
    

  * **subject** (`Subject` | `Block` | `Block` | `Function` | [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The subject of the analysis: a function, or a single basic block

  * **func_graph** – Alternative graph for function.graph.

  * **max_iterations** – The maximum number of iterations before the analysis is terminated.

  * **track_tmps** – Whether or not temporary variables should be taken into consideration during the analysis.

  * **observation_points** (_iterable_) – A collection of tuples of (“node”|”insn”, ins_addr, OP_TYPE) defining where reaching definitions should be copied and stored. OP_TYPE can be OP_BEFORE or OP_AFTER.

  * **init_state** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[`ReachingDefinitionsState`]) – An optional initialization state. The analysis creates and works on a copy. Default to None: the analysis then initialize its own abstract state, based on the given <Subject>.

  * **init_context** – If init_state is not given, this is used to initialize the context field of the initial state’s CodeLocation. The only default-supported type which may go here is a tuple of integers, i.e. a callstack. Anything else requires a custom FunctionHandler.

  * **cc** – Calling convention of the function.

  * **function_handler** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[`FunctionHandler`]) – The function handler to update the analysis state and results on function calls.

  * **observe_all** – Observe every statement, both before and after.

  * **visited_blocks** – A set of previously visited blocks.

  * **dep_graph** (`DepGraph` | [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")) – An initial dependency graph to add the result of the analysis to. Set it to None to skip dependency graph generation.

  * **canonical_size** – The sizes (in bytes) that objects with an UNKNOWN_SIZE are treated as for operations where sizes are necessary.

  * **dep_graph** – Set this to True to generate a dependency graph for the subject. It will be available as result.dep_graph.

  * **interfunction_level** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The number of functions we should recurse into. This parameter is only used if function_handler is not provided.

  * **track_liveness** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether to track liveness information. This can consume sizeable amounts of RAM on large functions. (e.g. ~15GB for a function with 4k nodes)

  * **merge_into_tops** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Merge known values into TOP if TOP is present. If True: {TOP} V {0xabc} = {TOP} If False: {TOP} V {0xabc} = {TOP, 0xabc}

  * **state_initializer** (_RDAStateInitializer_ _|__None_)

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **element_limit** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_property _observed_results _: [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"), [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")], LiveDefinitions]_¶
    

_property _all_definitions¶
    

_property _all_uses¶
    

_property _one_result¶
    

_property _dep_graph _: DepGraph_¶
    

_property _visited_blocks¶
    

get_reaching_definitions_by_insn(_ins_addr_ , _op_type_)¶
    

get_reaching_definitions_by_node(_node_addr_ , _op_type_)¶
    

node_observe(_node_addr_ , _state_ , _op_type_ , _node_idx =None_)¶
    

Parameters:
    

  * **node_addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the node.

  * **state** (`ReachingDefinitionsState`) – The analysis state.

  * **op_type** (`ObservationPointType`) – Type of the observation point. Must be one of the following: OP_BEFORE, OP_AFTER.

  * **node_idx** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – ID of the node. Used in AIL to differentiate blocks with the same address.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

insn_observe(_insn_addr_ , _stmt_ , _block_ , _state_ , _op_type_)¶
    

Parameters:
    

  * **insn_addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the instruction.

  * **stmt** (`Statement` | [`IRStmt`](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.stmt.IRStmt "\(in pyvex\)")) – The statement.

  * **block** (`Block` | `Block`) – The current block.

  * **state** (`ReachingDefinitionsState`) – The abstract analysis state.

  * **op_type** (`ObservationPointType`) – Type of the observation point. Must be one of the following: OP_BEORE, OP_AFTER.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

stmt_observe(_stmt_idx_ , _stmt_ , _block_ , _state_ , _op_type_)¶
    

Parameters:
    

  * **stmt_idx** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **stmt** (`Statement` | [`IRStmt`](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.stmt.IRStmt "\(in pyvex\)"))

  * **block** (`Block` | `Block`)

  * **state** (`ReachingDefinitionsState`)

  * **op_type** (`ObservationPointType`)

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

exit_observe(_node_addr_ , _exit_stmt_idx_ , _block_ , _state_ , _node_idx =None_)¶
    

Parameters:
    

  * **node_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **exit_stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **block** (_Block_ _|__Block_)

  * **state** (_ReachingDefinitionsState_)

  * **node_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

_property _subject¶
    

callsites_to(_target_)¶
    

Return type:
    

[`Iterable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)")[`FunctionCallRelationships`]

Parameters:
    

**target** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__Function_)

_class _angr.analyses.reaching_definitions.dep_graph.DepGraph(_graph =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

The representation of a dependency graph: a directed graph, where nodes are definitions, and edges represent uses.

Mostly a wrapper around a <networkx.DiGraph>.

Parameters:
    

**graph** (_networkx.DiGraph_ _[__Definition_ _]__|__None_)

__init__(_graph =None_)¶
    

Parameters:
    

**graph** – A graph where nodes are definitions, and edges represent uses.

_property _graph _: networkx.DiGraph[Definition]_¶
    

add_node(_node_)¶
    

Parameters:
    

**node** (`Definition`) – The definition to add to the definition-use graph.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

add_edge(_source_ , _destination_ , _** labels_)¶
    

The edge to add to the definition-use graph. Will create nodes that are not yet present.

Parameters:
    

  * **source** (`Definition`) – The “source” definition, used by the “destination”.

  * **destination** (`Definition`) – The “destination” definition, using the variable defined by “source”.

  * **labels** – Optional keyword arguments to represent edge labels.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

nodes()¶
    

Return type:
    

[`Iterator`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterator "\(in Python v3.13\)")[`Definition`]

predecessors(_node_)¶
    

Parameters:
    

**node** (`Definition`) – The definition to get the predecessors of.

Return type:
    

[`Iterator`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterator "\(in Python v3.13\)")[`Definition`]

transitive_closure(_definition_)¶
    

Compute the “transitive closure” of a given definition. Obtained by transitively aggregating the ancestors of this definition in the graph.

Note: Each definition is memoized to avoid any kind of recomputation across the lifetime of this object.

Parameters:
    

**definition** – The Definition to get transitive closure for.

Returns:
    

A graph of the transitive closure of the given definition.

Return type:
    

networkx.DiGraph[Definition[Atom]]

contains_atom(_atom_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**atom** (_Atom_)

add_dependencies_for_concrete_pointers_of(_values_ , _definition_ , _cfg_ , _loader_)¶
    

When a given definition holds concrete pointers, make sure the <MemoryLocation>s they point to are present in the dependency graph; Adds them if necessary.

Parameters:
    

  * **values** ([`Iterable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)")[[`Base`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)") | [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")])

  * **definition** (`Definition`) – The definition which has data that can contain concrete pointers.

  * **cfg** (`CFGModel` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")) – The CFG, containing information about memory data.

  * **loader** ([`Loader`](https://docs.angr.io/projects/cle/en/latest/api/loader.html#cle.Loader "\(in cle\)"))

find_definitions(_** kwargs_)¶
    

Filter the definitions present in the graph based on various criteria. Parameters can be any valid keyword args to DefinitionMatchPredicate

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`Definition`]

find_all_predecessors(_starts_ , _** kwargs_)¶
    

Filter the ancestors of the given start node or nodes that match various criteria. Parameters can be any valid keyword args to DefinitionMatchPredicate

find_all_successors(_starts_ , _** kwargs_)¶
    

Filter the descendents of the given start node or nodes that match various criteria. Parameters can be any valid keyword args to DefinitionMatchPredicate

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`Definition`]

Parameters:
    

**starts** (_Definition_ _|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _]_)

find_path(_starts_ , _ends_ , _** kwargs_)¶
    

Find a path between the given start node or nodes and the given end node or nodes. All the intermediate steps in the path must match the criteria given in kwargs. The kwargs can be any valid parameters to DefinitionMatchPredicate.

This algorithm has exponential time and space complexity. Use at your own risk. Want to do better? Do it yourself or use networkx and eat the cost of indirection and/or cloning.

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`Definition`, [`...`](https://docs.python.org/3/library/constants.html#Ellipsis "\(in Python v3.13\)")] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **starts** (_Definition_ _|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _]_)

  * **ends** (_Definition_ _|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _]_)

find_paths(_starts_ , _ends_ , _** kwargs_)¶
    

Find all non-overlapping simple paths between the given start node or nodes and the given end node or nodes. All the intermediate steps in the path must match the criteria given in kwargs. The kwargs can be any valid parameters to DefinitionMatchPredicate.

This algorithm has exponential time and space complexity. Use at your own risk. Want to do better? Do it yourself or use networkx and eat the cost of indirection and/or cloning.

Return type:
    

[`Iterator`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterator "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`Definition`, [`...`](https://docs.python.org/3/library/constants.html#Ellipsis "\(in Python v3.13\)")]]

Parameters:
    

  * **starts** (_Definition_ _|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _]_)

  * **ends** (_Definition_ _|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _]_)

_class _angr.analyses.reaching_definitions.heap_allocator.HeapAllocator(_canonical_size_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A simple modelisation to help represent heap memory management during a <ReachingDefinitionsAnalysis>: \- Act as if allocations were always done in consecutive memory segments; \- Take care of the size not to screw potential pointer arithmetic (avoid overlapping segments).

The content of the heap itself is modeled using a <KeyedRegion> attribute in the <LiveDefinitions> state; This class serves to generate consistent heap addresses to be used by the aforementioned.

_Note:_ This has **NOT** been made to help detect heap vulnerabilities.

Parameters:
    

**canonical_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_canonical_size_)¶
    

Parameters:
    

**canonical_size** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The concrete size an <UNKNOWN_SIZE> defaults to.

allocate(_size_)¶
    

Gives an address for a new memory chunk of <size> bytes.

Parameters:
    

**size** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | `UnknownSize`) – The requested size for the chunk, in number of bytes.

Return type:
    

`HeapAddress`

Returns:
    

The address of the chunk.

free(_address_)¶
    

Mark the chunk pointed by <address> as freed.

Parameters:
    

**address** (`Undefined` | `HeapAddress`) – The address of the chunk to free.

_property _allocated_addresses¶
    

The list of addresses that are currently allocated on the heap.

Type:
    

return

angr.analyses.reaching_definitions.function_handler.get_exit_livedefinitions(_func_ , _rda_model_)¶
    

Get LiveDefinitions at all exits of a function, merge them, and return.

Parameters:
    

  * **func** (_Function_)

  * **rda_model** (_ReachingDefinitionsModel_)

_class _angr.analyses.reaching_definitions.function_handler.FunctionEffect(_dest_ , _sources_ , _value =None_, _sources_defns =None_, _apply_at_callsite =False_, _tags =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A single effect that a function summary may apply to the state. This is largely an implementation detail; use FunctionCallData.depends instead.

Parameters:
    

  * **dest** (_Atom_ _|__None_)

  * **sources** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Atom_ _]_)

  * **value** (_MultiValues_ _|__None_)

  * **sources_defns** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Definition_ _]__|__None_)

  * **apply_at_callsite** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **tags** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Tag_ _]__|__None_)

dest _: `Atom` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

sources _: [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Atom`]_¶
    

value _: `MultiValues` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

sources_defns _: [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

apply_at_callsite _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_ _ = False_¶
    

tags _: [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Tag`] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

__init__(_dest_ , _sources_ , _value =None_, _sources_defns =None_, _apply_at_callsite =False_, _tags =None_)¶
    

Parameters:
    

  * **dest** (_Atom_ _|__None_)

  * **sources** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Atom_ _]_)

  * **value** (_MultiValues_ _|__None_)

  * **sources_defns** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Definition_ _]__|__None_)

  * **apply_at_callsite** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **tags** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Tag_ _]__|__None_)

Return type:
    

None

_class _angr.analyses.reaching_definitions.function_handler.FunctionCallData(_callsite_codeloc_ , _function_codeloc_ , _address_multi_ , _address=None_ , _symbol=None_ , _function=None_ , _name=None_ , _cc=None_ , _prototype=None_ , _args_atoms=None_ , _args_values=None_ , _ret_atoms=None_ , _redefine_locals=True_ , _visited_blocks=None_ , _effects= <factory>_, _ret_values=None_ , _ret_values_deps=None_ , _caller_will_handle_single_ret=False_ , _guessed_cc=False_ , _guessed_prototype=False_ , _retaddr_popped=False_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A bundle of intermediate data used when computing the sum effect of a function during ReachingDefinitionsAnalysis.

RDA engine contract:

  * Construct one of these before calling FunctionHandler.handle_function. Fill it with as many fields as you can realistically provide without duplicating effort.

  * Provide callsite_codeloc as either the call statement (AIL) or the default exit of the default statement of the calling block (VEX)

  * Provide function_codeloc as the callee address with stmt_idx=0`.

Function handler contract:

  * If redefine_locals is unset, do not adjust any artifacts of the function call abstraction, such as the stack pointer, the caller saved registers, etc.

  * If caller_will_handle_single_ret is set, and there is a single entry in ret_atoms, do not apply to the state effects modifying this atom. Instead, set ret_values and ret_values_deps to the values and deps which are used constructing these values.

Parameters:
    

  * **callsite_codeloc** (_CodeLocation_)

  * **function_codeloc** (_CodeLocation_)

  * **address_multi** (_MultiValues_ _[_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _|_[_FP_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)") _]__|__None_)

  * **address** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **symbol** ([_Symbol_](https://docs.angr.io/projects/cle/en/latest/api/backend.html#cle.backends.symbol.Symbol "\(in cle\)") _|__None_)

  * **function** (_Function_ _|__None_)

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **cc** (_SimCC_ _|__None_)

  * **prototype** (_SimTypeFunction_ _|__None_)

  * **args_atoms** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Atom_ _]__]__|__None_)

  * **args_values** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__MultiValues_ _[_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _|_[_FP_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)") _]__]__|__None_)

  * **ret_atoms** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Atom_ _]__|__None_)

  * **redefine_locals** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **visited_blocks** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **effects** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__FunctionEffect_ _]_)

  * **ret_values** (_MultiValues_ _[_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _|_[_FP_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)") _]__|__None_)

  * **ret_values_deps** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Definition_ _]__|__None_)

  * **caller_will_handle_single_ret** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **guessed_cc** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **guessed_prototype** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **retaddr_popped** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

callsite_codeloc _: `CodeLocation`_¶
    

function_codeloc _: `CodeLocation`_¶
    

address_multi _: [`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[`MultiValues`[[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`FP`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)")]]_¶
    

address _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

symbol _: [`Symbol`](https://docs.angr.io/projects/cle/en/latest/api/backend.html#cle.backends.symbol.Symbol "\(in cle\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

function _: `Function` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

name _: [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

cc _: `SimCC` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

prototype _: `SimTypeFunction` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

args_atoms _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Atom`]] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

args_values _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`MultiValues`[[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`FP`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)")]] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

ret_atoms _: [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Atom`] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

redefine_locals _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_ _ = True_¶
    

visited_blocks _: [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

effects _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`FunctionEffect`]_¶
    

ret_values _: [`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[`MultiValues`[[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`FP`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)")]]__ = None_¶
    

ret_values_deps _: [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_ _ = None_¶
    

caller_will_handle_single_ret _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_ _ = False_¶
    

guessed_cc _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_ _ = False_¶
    

guessed_prototype _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_ _ = False_¶
    

retaddr_popped _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_ _ = False_¶
    

has_clobbered(_dest_)¶
    

Determines whether the given atom already has effects applied

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**dest** (_Atom_)

depends(_dest_ , _* sources_, _value =None_, _apply_at_callsite =False_, _tags =None_)¶
    

Mark a single effect of the current function, including the atom being modified, the input atoms on which that output atom depends, the precise (or imprecise!) value to store, and whether the effect should be applied during the function or afterwards, at the callsite.

The tags are used to annotate the Definition of the Atom that will be created, when the function effects are applied to the state.

The atom being modified may be None to mark uses of the source atoms which do not have any explicit sinks.

Parameters:
    

  * **dest** (_Atom_ _|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Atom_ _]__|__None_)

  * **sources** (_Atom_ _|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Atom_ _]_)

  * **value** (_MultiValues_ _|_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _|_[_bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **apply_at_callsite** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **tags** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Tag_ _]__|__None_)

reset_prototype(_prototype_ , _state_ , _soft_reset =False_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Atom`]

Parameters:
    

  * **prototype** (_SimTypeFunction_)

  * **state** (_ReachingDefinitionsState_)

  * **soft_reset** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_callsite_codeloc_ , _function_codeloc_ , _address_multi_ , _address=None_ , _symbol=None_ , _function=None_ , _name=None_ , _cc=None_ , _prototype=None_ , _args_atoms=None_ , _args_values=None_ , _ret_atoms=None_ , _redefine_locals=True_ , _visited_blocks=None_ , _effects= <factory>_, _ret_values=None_ , _ret_values_deps=None_ , _caller_will_handle_single_ret=False_ , _guessed_cc=False_ , _guessed_prototype=False_ , _retaddr_popped=False_)¶
    

Parameters:
    

  * **callsite_codeloc** (_CodeLocation_)

  * **function_codeloc** (_CodeLocation_)

  * **address_multi** (_MultiValues_ _[_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _|_[_FP_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)") _]__|__None_)

  * **address** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **symbol** ([_Symbol_](https://docs.angr.io/projects/cle/en/latest/api/backend.html#cle.backends.symbol.Symbol "\(in cle\)") _|__None_)

  * **function** (_Function_ _|__None_)

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **cc** (_SimCC_ _|__None_)

  * **prototype** (_SimTypeFunction_ _|__None_)

  * **args_atoms** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Atom_ _]__]__|__None_)

  * **args_values** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__MultiValues_ _[_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _|_[_FP_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)") _]__]__|__None_)

  * **ret_atoms** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Atom_ _]__|__None_)

  * **redefine_locals** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **visited_blocks** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **effects** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__FunctionEffect_ _]_)

  * **ret_values** (_MultiValues_ _[_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _|_[_FP_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)") _]__|__None_)

  * **ret_values_deps** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Definition_ _]__|__None_)

  * **caller_will_handle_single_ret** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **guessed_cc** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **guessed_prototype** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **retaddr_popped** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Return type:
    

None

_class _angr.analyses.reaching_definitions.function_handler.FunctionCallDataUnwrapped(_inner_)¶
    

Bases: `FunctionCallData`

A subclass of FunctionCallData which asserts that many of its members are non-None at construction time. Typechecks be gone!

Parameters:
    

**inner** (_FunctionCallData_)

address_multi _: `MultiValues`_¶
    

__init__(_inner_)¶
    

Parameters:
    

**inner** (_FunctionCallData_)

_static _decorate(_wrapper_ , _*_ , _wrapped= <function FunctionCallDataUnwrapped.decorate>_, _assigned=('__module__'_ , _'__name__'_ , _'__qualname__'_ , _'__doc__'_ , _'__annotations__')_ , _updated=('__dict__'_ , _)_)¶
    

Update a wrapper function to look like the wrapped function

wrapper is the function to be updated wrapped is the original function assigned is a tuple naming the attributes assigned directly from the wrapped function to the wrapper function (defaults to functools.WRAPPER_ASSIGNMENTS) updated is a tuple naming the attributes of the wrapper that are updated with the corresponding attribute from the wrapped function (defaults to functools.WRAPPER_UPDATES)

_class _angr.analyses.reaching_definitions.function_handler.FunctionCallRelationships(_callsite_ , _target_ , _args_defns_ , _other_input_defns_ , _ret_defns_ , _other_output_defns_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Produced by the function handler, provides associated callsite info and function input/output definitions.

Parameters:
    

  * **callsite** (_CodeLocation_)

  * **target** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **args_defns** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Definition_ _]__]_)

  * **other_input_defns** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Definition_ _]_)

  * **ret_defns** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Definition_ _]_)

  * **other_output_defns** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Definition_ _]_)

callsite _: `CodeLocation`_¶
    

target _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

args_defns _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]]_¶
    

other_input_defns _: [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]_¶
    

ret_defns _: [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]_¶
    

other_output_defns _: [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`]_¶
    

__init__(_callsite_ , _target_ , _args_defns_ , _other_input_defns_ , _ret_defns_ , _other_output_defns_)¶
    

Parameters:
    

  * **callsite** (_CodeLocation_)

  * **target** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **args_defns** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Definition_ _]__]_)

  * **other_input_defns** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Definition_ _]_)

  * **ret_defns** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Definition_ _]_)

  * **other_output_defns** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Definition_ _]_)

Return type:
    

None

_class _angr.analyses.reaching_definitions.function_handler.FunctionHandler(_interfunction_level =0_, _extra_impls =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A mechanism for summarizing a function call’s effect on a program for ReachingDefinitionsAnalysis.

Parameters:
    

  * **interfunction_level** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **extra_impls** (_Iterable_ _[_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[__FunctionHandler_ _]__]__|__None_)

__init__(_interfunction_level =0_, _extra_impls =None_)¶
    

Parameters:
    

  * **interfunction_level** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Maximum depth in to continue local function exploration

  * **extra_impls** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`Iterable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)")[[`type`](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")[`FunctionHandler`]]]) – FunctionHandler classes to implement beyond what’s implemented in function_handler_library

hook(_analysis_)¶
    

Attach this instance of the function handler to an instance of RDA.

Return type:
    

`FunctionHandler`

Parameters:
    

**analysis** (_ReachingDefinitionsAnalysis_)

make_function_codeloc(_target_ , _callsite_ , _callsite_func_addr_)¶
    

The RDA engine will call this function to transform a callsite CodeLocation into a callee CodeLocation.

Parameters:
    

  * **target** (_None_ _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__MultiValues_)

  * **callsite** (_CodeLocation_)

  * **callsite_func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

handle_function(_state_ , _data_)¶
    

The main entry point for the function handler. Called with a RDA state and a FunctionCallData, it is expected to update the state and the data as per the contracts described on FunctionCallData.

You can override this method to take full control over how data is processed, or override any of the following to use the higher-level interface (data.depends()):

  * handle_impl_<function name> \- used for <function name>.

  * handle_local_function \- used for any function (excluding plt stubs) whose address is inside the main binary.

  * handle_external_function \- used for any function or plt stub whose address is outside the main binary.

  * handle_indirect_function \- used for any function whose target cannot be resolved.

  * handle_generic_function \- used as a default if none of the above are overridden.

Each of them take the same signature as handle_function.

Parameters:
    

  * **state** (_ReachingDefinitionsState_)

  * **data** (_FunctionCallData_)

handle_generic_function(_state_ , _data_)¶
    

Parameters:
    

  * **state** (_ReachingDefinitionsState_)

  * **data** (_FunctionCallData_)

handle_indirect_function(_state_ , _data_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **state** (_ReachingDefinitionsState_)

  * **data** (_FunctionCallData_)

handle_local_function(_state_ , _data_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **state** (_ReachingDefinitionsState_)

  * **data** (_FunctionCallData_)

handle_external_function(_state_ , _data_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **state** (_ReachingDefinitionsState_)

  * **data** (_FunctionCallData_)

recurse_analysis(_state_ , _data_)¶
    

Precondition: `data.function` MUST NOT BE NONE in order to call this method.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **state** (_ReachingDefinitionsState_)

  * **data** (_FunctionCallData_)

_static _c_args_as_atoms(_state_ , _cc_ , _prototype_)¶
    

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Atom`]]

Parameters:
    

  * **state** (_ReachingDefinitionsState_)

  * **cc** (_SimCC_)

  * **prototype** (_SimTypeFunction_)

_static _c_return_as_atoms(_state_ , _cc_ , _prototype_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Atom`]

Parameters:
    

  * **state** (_ReachingDefinitionsState_)

  * **cc** (_SimCC_)

  * **prototype** (_SimTypeFunction_)

_static _caller_saved_regs_as_atoms(_state_ , _cc_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Register`]

Parameters:
    

  * **state** (_ReachingDefinitionsState_)

  * **cc** (_SimCC_)

_static _stack_pointer_as_atom(_state_)¶
    

Return type:
    

`Register`

_class _angr.analyses.reaching_definitions.rd_state.ReachingDefinitionsState(_codeloc_ , _arch_ , _subject_ , _analysis_ , _track_tmps =False_, _track_consts =False_, _rtoc_value =None_, _live_definitions =None_, _canonical_size =8_, _heap_allocator =None_, _environment =None_, _sp_adjusted =False_, _all_definitions =None_, _initializer =None_, _element_limit =5_, _merge_into_tops =True_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Represents the internal state of the ReachingDefinitionsAnalysis.

It contains a data class LiveDefinitions, which stores both definitions and uses for register, stack, memory, and temporary variables, uncovered during the analysis.

Parameters:
    

  * **subject** (`Subject`) – The subject being analyzed.

  * **track_tmps** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Only tells whether or not temporary variables should be taken into consideration when representing the state of the analysis. Should be set to true when the analysis has counted uses and definitions for temporary variables, false otherwise.

  * **analysis** (`ReachingDefinitionsAnalysis`) – The analysis that generated the state represented by this object.

  * **rtoc_value** – When the targeted architecture is ppc64, the initial function needs to know the rtoc_value.

  * **live_definitions** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[`LiveDefinitions`])

  * **canonical_size** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The sizes (in bytes) that objects with an UNKNOWN_SIZE are treated as for operations where sizes are necessary.

  * **heap_allocator** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[`HeapAllocator`]) – Mechanism to model the management of heap memory.

  * **environment** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[`Environment`]) – Representation of the environment of the analyzed program.

  * **codeloc** (_CodeLocation_)

  * **arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)"))

  * **track_consts** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **sp_adjusted** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **all_definitions** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Definition_ _[_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]__]_)

  * **initializer** (_RDAStateInitializer_ _|__None_)

  * **element_limit** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **merge_into_tops** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Variables:
    

**arch** – The architecture targeted by the program.

__init__(_codeloc_ , _arch_ , _subject_ , _analysis_ , _track_tmps =False_, _track_consts =False_, _rtoc_value =None_, _live_definitions =None_, _canonical_size =8_, _heap_allocator =None_, _environment =None_, _sp_adjusted =False_, _all_definitions =None_, _initializer =None_, _element_limit =5_, _merge_into_tops =True_)¶
    

Parameters:
    

  * **codeloc** (_CodeLocation_)

  * **arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)"))

  * **subject** (_Subject_)

  * **analysis** (_ReachingDefinitionsAnalysis_)

  * **track_tmps** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **track_consts** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **live_definitions** (_LiveDefinitions_ _|__None_)

  * **canonical_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **heap_allocator** (_HeapAllocator_ _|__None_)

  * **environment** (_Environment_ _|__None_)

  * **sp_adjusted** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **all_definitions** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Definition_ _[__A_ _]__]__|__None_)

  * **initializer** (_RDAStateInitializer_ _|__None_)

  * **element_limit** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **merge_into_tops** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

codeloc¶
    

arch _: [`Arch`](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)")_¶
    

analysis¶
    

all_definitions _: [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]_¶
    

heap_allocator¶
    

codeloc_uses _: [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]_¶
    

exit_observed _: [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

live_definitions¶
    

top(_bits_)¶
    

Parameters:
    

**bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

is_top(_* args_)¶
    

heap_address(_offset_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

**offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__HeapAddress_)

_static _is_heap_address(_addr_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**addr** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

_static _get_heap_offset(_addr_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**addr** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

stack_address(_offset_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

**offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

is_stack_address(_addr_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**addr** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

get_stack_offset(_addr_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**addr** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

annotate_with_def(_symvar_ , _definition_)¶
    

Parameters:
    

  * **symvar** ([`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`MVType`, bound= [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`FP`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)")))

  * **definition** (`Definition`[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")])

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`MVType`, bound= [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`FP`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)"))

Returns:
    

annotate_mv_with_def(_mv_ , _definition_)¶
    

Return type:
    

`MultiValues`[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`MVType`, bound= [`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`FP`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)"))]

Parameters:
    

  * **mv** (_MultiValues_ _[__MVType_ _]_)

  * **definition** (_Definition_ _[__A_ _]_)

extract_defs(_symvar_)¶
    

Return type:
    

[`Iterator`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterator "\(in Python v3.13\)")[`Definition`[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]

Parameters:
    

**symvar** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

_property _tmps¶
    

_property _tmp_uses¶
    

_property _registers _: MultiValuedMemory_¶
    

_property _register_uses¶
    

_property _stack _: MultiValuedMemory_¶
    

_property _stack_uses¶
    

_property _heap _: MultiValuedMemory_¶
    

_property _heap_uses¶
    

_property _memory _: MultiValuedMemory_¶
    

_property _memory_uses¶
    

_property _others _: [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[Atom, MultiValues]_¶
    

_property _uses_by_codeloc¶
    

get_sp()¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

get_stack_address(_offset_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**offset** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

_property _environment¶
    

_property _dep_graph¶
    

copy(_discard_tmpdefs =False_)¶
    

Return type:
    

`Self`

merge(_* others_)¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`Self`, [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")]

Parameters:
    

**others** (_Self_)

compare(_other_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**other** (_ReachingDefinitionsState_)

move_codelocs(_new_codeloc_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**new_codeloc** (_CodeLocation_)

kill_definitions(_atom_)¶
    

Overwrite existing definitions w.r.t ‘atom’ with a dummy definition instance. A dummy definition will not be removed during simplification.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**atom** (_Atom_)

kill_and_add_definition(_atom_ , _data_ , _dummy =False_, _tags =None_, _endness =None_, _annotated =False_, _uses =None_, _override_codeloc =None_)¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`MultiValues` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)"), [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`A`, bound= `Atom`)]]]

Parameters:
    

  * **atom** (_Atom_)

  * **data** (_MultiValues_)

  * **tags** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Tag_ _]__|__None_)

  * **annotated** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **uses** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__Definition_ _[__A_ _]__]__|__None_)

  * **override_codeloc** (_CodeLocation_ _|__None_)

add_use(_atom_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **atom** (_Atom_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_use_by_def(_definition_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **definition** (_Definition_ _[__A_ _]_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_tmp_use(_tmp_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **tmp** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_tmp_use_by_defs(_defs_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **defs** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _[__A_ _]__]_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_register_use(_reg_offset_ , _size_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **reg_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_register_use_by_defs(_defs_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **defs** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _[__A_ _]__]_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_stack_use(_stack_offset_ , _size_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **stack_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_stack_use_by_defs(_defs_ , _expr =None_)¶
    

Parameters:
    

  * **defs** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _[__A_ _]__]_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_heap_use(_heap_offset_ , _size_ , _expr =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **heap_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_heap_use_by_defs(_defs_ , _expr =None_)¶
    

Parameters:
    

  * **defs** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _[__A_ _]__]_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_memory_use_by_def(_definition_ , _expr =None_)¶
    

Parameters:
    

  * **definition** (_Definition_ _[__A_ _]_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

add_memory_use_by_defs(_defs_ , _expr =None_)¶
    

Parameters:
    

  * **defs** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _[__A_ _]__]_)

  * **expr** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _|__None_)

get_definitions(_atom_)¶
    

Return type:
    

[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`Definition`[`Atom`]]

Parameters:
    

**atom** (_Atom_ _|__Definition_ _[__Atom_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Atom_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _[__Atom_ _]__]__|__MultiValues_)

get_values(_spec_)¶
    

Return type:
    

`MultiValues` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**spec** (_A_ _|__Definition_ _[__A_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__A_ _]_)

get_one_value(_spec_ , _strip_annotations =False_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **spec** (_A_ _|__Definition_ _[__A_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__A_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _[__A_ _]__]_)

  * **strip_annotations** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

get_concrete_value(_spec_ , _cast_to= <class 'int'>_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **spec** (_Atom_ _|__Definition_ _[__Atom_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Atom_ _]_)

  * **cast_to** ([_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|_[_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)") _[_[_bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") _]_)

mark_guard(_target_)¶
    

mark_const(_value_ , _size_)¶
    

Parameters:
    

  * **value** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

downsize()¶
    

deref(_pointer_ , _size_ , _endness =Endness.BE_)¶
    

Parameters:
    

  * **pointer** (_MultiValues_ _[_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _]__|__Atom_ _|__Definition_ _[__Atom_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Atom_ _]__|_[_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__Definition_ _[__Atom_ _]__]__|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_BV_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") _|__HeapAddress_ _|__SpOffset_)

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__DerefSize_)

  * **endness** ([_Endness_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.types.Endness "\(in archinfo\)"))

_class _angr.analyses.reaching_definitions.subject.SubjectType(_value_)¶
    

Bases: [`Enum`](https://docs.python.org/3/library/enum.html#enum.Enum "\(in Python v3.13\)")

An enumeration.

Function _ = 1_¶
    

Block _ = 2_¶
    

CallTrace _ = 3_¶
    

_class _angr.analyses.reaching_definitions.subject.Subject(_content_ , _func_graph =None_, _cc =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_content_ , _func_graph =None_, _cc =None_)¶
    

The thing being analysed, and the way (visitor) to analyse it.

Parameters:
    

  * **content** (_Union_ _[__ailment.Block_ _,__angr.Block_ _,__Function_ _]_) – Thing to be analysed.

  * **func_graph** (_networkx.DiGraph_) – Alternative graph for function.graph.

  * **cc** (_SimCC_) – Calling convention of the function.

_property _cc¶
    

_property _content¶
    

_property _func_graph¶
    

_property _type¶
    

_property _visitor _: FunctionGraphVisitor | SingleNodeGraphVisitor_¶
    

_class _angr.analyses.reaching_definitions.engine_ail.SimEngineRDAIL(_project_ , _function_handler_ , _stack_pointer_tracker =None_, _use_callee_saved_regs_at_return =True_, _bp_as_gpr =False_)¶
    

Bases: `SimEngineNostmtAIL`[`ReachingDefinitionsState`, `MultiValues`[[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`FP`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)")], [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)"), `ReachingDefinitionsState`]

Parameters:
    

  * **function_handler** (_FunctionHandler_)

  * **bp_as_gpr** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_project_ , _function_handler_ , _stack_pointer_tracker =None_, _use_callee_saved_regs_at_return =True_, _bp_as_gpr =False_)¶
    

Parameters:
    

  * **function_handler** (_FunctionHandler_)

  * **bp_as_gpr** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

process(_state_ , _*_ , _dep_graph =None_, _visited_blocks =None_, _block =None_, _fail_fast =False_, _whitelist =None_, _** kwargs_)¶
    

_class _angr.analyses.cfg_slice_to_sink.CFGSliceToSink(_target_ , _transitions =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

The representation of a slice of a CFG.

__init__(_target_ , _transitions =None_)¶
    

Parameters:
    

  * **target** (_angr.knowledge_plugins.functions.function.Function_) – The targeted sink, to which every path in the slice leads.

  * **transitions** (_Dict_ _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__List_ _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__]_) – A mapping representing transitions in the graph. Indexes are source addresses and values a list of destination addresses, for which there exists a transition in the slice from source to destination.

_property _transitions¶
    

The transitions in the slice.

Type:
    

return Dict[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"),List[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]]

_property _transitions_as_tuples¶
    

The list of transitions as pairs of (source, destination).

Type:
    

return List[Tuple[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"),[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]]

_property _target¶
    

return angr.knowledge_plugins.functions.function.Function: The targeted sink function, from which the slice is constructed.

_property _nodes _: [list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]_¶
    

The complete list of addresses present in the slice.

Type:
    

return

_property _entrypoints¶
    

Entrypoints are all source addresses that are not the destination address of any transition.

Return List[int]:
    

The list of entrypoints addresses.

add_transitions(_transitions_)¶
    

Add the given transitions to the current slice.

Parameters:
    

**transitions** (_Dict_ _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__List_ _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__]_) – The list of transitions to be added to self.transitions.

Return Dict[int,List[int]]:
    

Return the updated list of transitions.

is_empty()¶
    

Test if a given slice does not contain any transition.

Return bool:
    

True if the <CFGSliceToSink> instance does not contain any transitions. False otherwise.

path_between(_source_ , _destination_ , _visited =None_)¶
    

Check the existence of a path in the slice between two given node addresses.

Parameters:
    

  * **source** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The source address.

  * **destination** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The destination address.

  * **visited** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – Used to avoid infinite recursion if loops are present in the slice.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

True if there is a path between the source and the destination in the CFG, False if not, or if we have been unable to decide (because of loops).

angr.analyses.cfg_slice_to_sink.slice_callgraph(_callgraph_ , _cfg_slice_to_sink_)¶
    

Slice a callgraph, keeping only the nodes present in the <CFGSliceToSink> representation, and th transitions for which a path exists.

_Note_ that this function mutates the graph passed as an argument.

Parameters:
    

  * **callgraph** (_networkx.MultiDiGraph_) – The callgraph to update.

  * **cfg_slice_to_sink** (_CFGSliceToSink_) – The representation of the slice, containing the data to update the callgraph from.

angr.analyses.cfg_slice_to_sink.slice_cfg_graph(_graph_ , _cfg_slice_to_sink_)¶
    

Slice a CFG graph, keeping only the transitions and nodes present in the <CFGSliceToSink> representation.

_Note_ that this function mutates the graph passed as an argument.

Parameters:
    

  * **graph** (_networkx.DiGraph_) – The graph to slice.

  * **cfg_slice_to_sink** (_CFGSliceToSink_) – The representation of the slice, containing the data to update the CFG from.

Return networkx.DiGraph:
    

The sliced graph.

angr.analyses.cfg_slice_to_sink.slice_function_graph(_function_graph_ , _cfg_slice_to_sink_)¶
    

Slice a function graph, keeping only the nodes present in the <CFGSliceToSink> representation.

Because the <CFGSliceToSink> is build from the CFG, and the function graph is _NOT_ a subgraph of the CFG, edges of the function graph will no be present in the <CFGSliceToSink> transitions. However, we use the fact that if there is an edge between two nodes in the function graph, then there must exist a path between these two nodes in the slice; Proof idea: \- The <CFGSliceToSink> is backward and recursively constructed; \- If a node is in the slice, then all its predecessors will be (transitively); \- If there is an edge between two nodes in the function graph, there is a path between them in the CFG; \- So: The origin node is a transitive predecessor of the destination one, hence if destination is in the slice, then origin will be too.

In consequence, in the end, removing the only nodes not present in the slice, and their related transitions gives us the expected result: a function graph representing (a higher view of) the flow in the slice.

_Note_ that this function mutates the graph passed as an argument.

Parameters:
    

  * **graph** (_networkx.DiGraph_) – The graph to slice.

  * **cfg_slice_to_sink** (_CFGSliceToSink_) – The representation of the slice, containing the data to update the CFG from.

Return networkx.DiGraph:
    

The sliced graph.

_class _angr.analyses.cfg_slice_to_sink.cfg_slice_to_sink.CFGSliceToSink(_target_ , _transitions =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

The representation of a slice of a CFG.

__init__(_target_ , _transitions =None_)¶
    

Parameters:
    

  * **target** (_angr.knowledge_plugins.functions.function.Function_) – The targeted sink, to which every path in the slice leads.

  * **transitions** (_Dict_ _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__List_ _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__]_) – A mapping representing transitions in the graph. Indexes are source addresses and values a list of destination addresses, for which there exists a transition in the slice from source to destination.

_property _transitions¶
    

The transitions in the slice.

Type:
    

return Dict[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"),List[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]]

_property _transitions_as_tuples¶
    

The list of transitions as pairs of (source, destination).

Type:
    

return List[Tuple[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"),[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]]

_property _target¶
    

return angr.knowledge_plugins.functions.function.Function: The targeted sink function, from which the slice is constructed.

_property _nodes _: [list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]_¶
    

The complete list of addresses present in the slice.

Type:
    

return

_property _entrypoints¶
    

Entrypoints are all source addresses that are not the destination address of any transition.

Return List[int]:
    

The list of entrypoints addresses.

add_transitions(_transitions_)¶
    

Add the given transitions to the current slice.

Parameters:
    

**transitions** (_Dict_ _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__List_ _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__]_) – The list of transitions to be added to self.transitions.

Return Dict[int,List[int]]:
    

Return the updated list of transitions.

is_empty()¶
    

Test if a given slice does not contain any transition.

Return bool:
    

True if the <CFGSliceToSink> instance does not contain any transitions. False otherwise.

path_between(_source_ , _destination_ , _visited =None_)¶
    

Check the existence of a path in the slice between two given node addresses.

Parameters:
    

  * **source** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The source address.

  * **destination** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The destination address.

  * **visited** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – Used to avoid infinite recursion if loops are present in the slice.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

True if there is a path between the source and the destination in the CFG, False if not, or if we have been unable to decide (because of loops).

angr.analyses.cfg_slice_to_sink.graph.slice_callgraph(_callgraph_ , _cfg_slice_to_sink_)¶
    

Slice a callgraph, keeping only the nodes present in the <CFGSliceToSink> representation, and th transitions for which a path exists.

_Note_ that this function mutates the graph passed as an argument.

Parameters:
    

  * **callgraph** (_networkx.MultiDiGraph_) – The callgraph to update.

  * **cfg_slice_to_sink** (_CFGSliceToSink_) – The representation of the slice, containing the data to update the callgraph from.

angr.analyses.cfg_slice_to_sink.graph.slice_cfg_graph(_graph_ , _cfg_slice_to_sink_)¶
    

Slice a CFG graph, keeping only the transitions and nodes present in the <CFGSliceToSink> representation.

_Note_ that this function mutates the graph passed as an argument.

Parameters:
    

  * **graph** (_networkx.DiGraph_) – The graph to slice.

  * **cfg_slice_to_sink** (_CFGSliceToSink_) – The representation of the slice, containing the data to update the CFG from.

Return networkx.DiGraph:
    

The sliced graph.

angr.analyses.cfg_slice_to_sink.graph.slice_function_graph(_function_graph_ , _cfg_slice_to_sink_)¶
    

Slice a function graph, keeping only the nodes present in the <CFGSliceToSink> representation.

Because the <CFGSliceToSink> is build from the CFG, and the function graph is _NOT_ a subgraph of the CFG, edges of the function graph will no be present in the <CFGSliceToSink> transitions. However, we use the fact that if there is an edge between two nodes in the function graph, then there must exist a path between these two nodes in the slice; Proof idea: \- The <CFGSliceToSink> is backward and recursively constructed; \- If a node is in the slice, then all its predecessors will be (transitively); \- If there is an edge between two nodes in the function graph, there is a path between them in the CFG; \- So: The origin node is a transitive predecessor of the destination one, hence if destination is in the slice, then origin will be too.

In consequence, in the end, removing the only nodes not present in the slice, and their related transitions gives us the expected result: a function graph representing (a higher view of) the flow in the slice.

_Note_ that this function mutates the graph passed as an argument.

Parameters:
    

  * **graph** (_networkx.DiGraph_) – The graph to slice.

  * **cfg_slice_to_sink** (_CFGSliceToSink_) – The representation of the slice, containing the data to update the CFG from.

Return networkx.DiGraph:
    

The sliced graph.

Some utilitary functions to manage our representation of transitions:
    

A dictionary, indexed by int (source addresses), which values are list of ints (target addresses).

angr.analyses.cfg_slice_to_sink.transitions.merge_transitions(_transitions_ , _existing_transitions_)¶
    

Merge two dictionaries of transitions together.

Parameters:
    

  * **transitions** (_Dict_ _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__List_ _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__]_) – Some transitions.

  * **existing_transitions** (_Dict_ _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__List_ _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__]_) – Other transitions.

Return Dict[int,List[int]]:
    

The merge of the two parameters.

_class _angr.analyses.stack_pointer_tracker.BottomType¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

The bottom value for register values.

_class _angr.analyses.stack_pointer_tracker.Constant(_val_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Represents a constant value.

__init__(_val_)¶
    

val¶
    

_class _angr.analyses.stack_pointer_tracker.Register(_offset_ , _bitlen_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Represent a register.

__init__(_offset_ , _bitlen_)¶
    

offset¶
    

bitlen¶
    

_class _angr.analyses.stack_pointer_tracker.OffsetVal(_reg_ , _offset_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Represent a value with an offset added.

__init__(_reg_ , _offset_)¶
    

_property _reg¶
    

_property _offset¶
    

_class _angr.analyses.stack_pointer_tracker.Eq(_val0_ , _val1_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Represent an equivalence condition.

__init__(_val0_ , _val1_)¶
    

val0¶
    

val1¶
    

_class _angr.analyses.stack_pointer_tracker.FrozenStackPointerTrackerState(_regs_ , _memory_ , _is_tracking_memory_ , _resilient_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Abstract state for StackPointerTracker analysis with registers and memory values being in frozensets.

__init__(_regs_ , _memory_ , _is_tracking_memory_ , _resilient_)¶
    

regs¶
    

memory¶
    

is_tracking_memory¶
    

resilient¶
    

unfreeze()¶
    

merge(_other_ , _addr_ , _reg_merge_cache_ , _mem_merge_cache_)¶
    

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **reg_merge_cache** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]_)

  * **mem_merge_cache** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]_)

_class _angr.analyses.stack_pointer_tracker.StackPointerTrackerState(_regs_ , _memory_ , _is_tracking_memory_ , _resilient_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Abstract state for StackPointerTracker analysis.

Parameters:
    

**resilient** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_regs_ , _memory_ , _is_tracking_memory_ , _resilient_)¶
    

Parameters:
    

**resilient** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

regs¶
    

memory¶
    

is_tracking_memory¶
    

resilient¶
    

give_up_on_memory_tracking()¶
    

store(_addr_ , _val_)¶
    

load(_addr_)¶
    

get(_reg_)¶
    

put(_reg_ , _val_ , _force =False_)¶
    

Parameters:
    

**force** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

copy()¶
    

freeze()¶
    

merge(_other_ , _addr_ , _reg_merge_cache_ , _mem_merge_cache_)¶
    

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **reg_merge_cache** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]_)

  * **mem_merge_cache** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]_)

_exception _angr.analyses.stack_pointer_tracker.CouldNotResolveException¶
    

Bases: [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception "\(in Python v3.13\)")

An exception used in StackPointerTracker analysis to represent internal resolving failures.

_class _angr.analyses.stack_pointer_tracker.StackPointerTracker(_func_ , _reg_offsets_ , _block =None_, _track_memory =True_, _cross_insn_opt =True_, _initial_reg_values =None_, _resilient =True_)¶
    

Bases: `Analysis`, `ForwardAnalysis`

Track the offset of stack pointer at the end of each basic block of a function.

Parameters:
    

  * **func** (_Function_ _|__None_)

  * **reg_offsets** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]_)

  * **block** (_Block_ _|__None_)

  * **resilient** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_func_ , _reg_offsets_ , _block =None_, _track_memory =True_, _cross_insn_opt =True_, _initial_reg_values =None_, _resilient =True_)¶
    

Parameters:
    

  * **func** (_Function_ _|__None_)

  * **reg_offsets** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]_)

  * **block** (_Block_ _|__None_)

  * **resilient** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

offset_after(_addr_ , _reg_)¶
    

offset_before(_addr_ , _reg_)¶
    

offset_after_block(_block_addr_ , _reg_)¶
    

offset_before_block(_block_addr_ , _reg_)¶
    

constant_after(_addr_ , _reg_)¶
    

constant_before(_addr_ , _reg_)¶
    

constant_after_block(_block_addr_ , _reg_)¶
    

constant_before_block(_block_addr_ , _reg_)¶
    

_property _inconsistent¶
    

inconsistent_for(_reg_)¶
    

offsets_for(_reg_)¶
    

_class _angr.analyses.variable_recovery.annotations.StackLocationAnnotation(_offset_)¶
    

Bases: [`Annotation`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.annotation.Annotation "\(in claripy\)")

__init__(_offset_)¶
    

_property _eliminatable¶
    

Returns whether this annotation can be eliminated in a simplification.

Returns:
    

True if eliminatable, False otherwise

_property _relocatable¶
    

Returns whether this annotation can be relocated in a simplification.

Returns:
    

True if it can be relocated, false otherwise.

_class _angr.analyses.variable_recovery.annotations.VariableSourceAnnotation(_block_addr_ , _stmt_idx_ , _ins_addr_)¶
    

Bases: [`Annotation`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.annotation.Annotation "\(in claripy\)")

__init__(_block_addr_ , _stmt_idx_ , _ins_addr_)¶
    

_property _eliminatable¶
    

Returns whether this annotation can be eliminated in a simplification.

Returns:
    

True if eliminatable, False otherwise

_property _relocatable¶
    

Returns whether this annotation can be relocated in a simplification.

Returns:
    

True if it can be relocated, false otherwise.

_static _from_state(_state_)¶
    

angr.analyses.variable_recovery.variable_recovery_base.parse_stack_pointer(_sp_)¶
    

Convert multiple supported forms of stack pointer representations into stack offsets.

Parameters:
    

**sp** – A stack pointer representation.

Returns:
    

A stack pointer offset.

Return type:
    

[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

_class _angr.analyses.variable_recovery.variable_recovery_base.VariableAnnotation(_addr_and_variables_)¶
    

Bases: [`Annotation`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.annotation.Annotation "\(in claripy\)")

Parameters:
    

**addr_and_variables** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__SimVariable_ _]__]_)

__init__(_addr_and_variables_)¶
    

Parameters:
    

**addr_and_variables** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__SimVariable_ _]__]_)

addr_and_variables¶
    

_property _relocatable¶
    

Returns whether this annotation can be relocated in a simplification.

Returns:
    

True if it can be relocated, false otherwise.

_property _eliminatable¶
    

Returns whether this annotation can be eliminated in a simplification.

Returns:
    

True if eliminatable, False otherwise

_class _angr.analyses.variable_recovery.variable_recovery_base.VariableRecoveryBase(_func_ , _max_iterations_ , _store_live_variables_ , _vvar_to_vvar =None_, _func_graph =None_, _entry_node_addr =None_)¶
    

Bases: `Analysis`

The base class for VariableRecovery and VariableRecoveryFast.

Parameters:
    

  * **store_live_variables** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **vvar_to_vvar** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **func_graph** (_networkx.DiGraph_ _|__None_)

  * **entry_node_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_ _]__|__None_)

__init__(_func_ , _max_iterations_ , _store_live_variables_ , _vvar_to_vvar =None_, _func_graph =None_, _entry_node_addr =None_)¶
    

Parameters:
    

  * **store_live_variables** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **vvar_to_vvar** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **func_graph** (_DiGraph_ _|__None_)

  * **entry_node_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_ _]__|__None_)

get_variable_definitions(_block_addr_)¶
    

Get variables that are defined at the specified block.

Parameters:
    

**block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the block.

Returns:
    

A set of variables.

initialize_dominance_frontiers()¶
    

_class _angr.analyses.variable_recovery.variable_recovery_base.VariableRecoveryStateBase(_block_addr_ , _analysis_ , _arch_ , _func_ , _project_ , _stack_region =None_, _register_region =None_, _global_region =None_, _typevars =None_, _type_constraints =None_, _func_typevar =None_, _delayed_type_constraints =None_, _stack_offset_typevars =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

The base abstract state for variable recovery analysis.

Parameters:
    

  * **block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **analysis** (_VariableRecoveryBase_)

  * **arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

  * **func** (_Function_)

  * **project** (_Project_)

__init__(_block_addr_ , _analysis_ , _arch_ , _func_ , _project_ , _stack_region =None_, _register_region =None_, _global_region =None_, _typevars =None_, _type_constraints =None_, _func_typevar =None_, _delayed_type_constraints =None_, _stack_offset_typevars =None_)¶
    

Parameters:
    

  * **block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **analysis** (_VariableRecoveryBase_)

  * **arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)"))

  * **func** (_Function_)

  * **project** (_Project_)

_static _top(_bits_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

_static _is_top(_thing_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_static _extract_variables(_expr_)¶
    

Return type:
    

[`Generator`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Generator "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), `SimVariable`]]

Parameters:
    

**expr** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

_static _annotate_with_variables(_expr_ , _addr_and_variables_)¶
    

Return type:
    

[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`AnyClaripy`, bound= [`Base`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

Parameters:
    

  * **expr** (_AnyClaripy_)

  * **addr_and_variables** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__SimVariable_ _]__]_)

stack_address(_offset_)¶
    

Return type:
    

[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")

Parameters:
    

**offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_static _is_stack_address(_addr_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**addr** ([_Base_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)"))

is_global_variable_address(_addr_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Parameters:
    

**addr** ([_Bits_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bits.Bits "\(in claripy\)"))

get_stack_offset(_addr_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**addr** ([_Bits_](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bits.Bits "\(in claripy\)"))

stack_addr_from_offset(_offset_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

Parameters:
    

**offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_property _func_addr¶
    

_property _dominance_frontiers¶
    

_property _variable_manager¶
    

_property _variables¶
    

get_variable_definitions(_block_addr_)¶
    

Get variables that are defined at the specified block.

Parameters:
    

**block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the block.

Returns:
    

A set of variables.

add_type_constraint(_constraint_)¶
    

Add a new type constraint.

Parameters:
    

**constraint**

Returns:
    

add_type_constraint_for_function(_func_typevar_ , _constraint_)¶
    

Add a new type constraint for a specified function.

Parameters:
    

  * **func_typevar**

  * **constraint**

Returns:
    

downsize()¶
    

Remove unnecessary members.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

None

_static _downsize_region(_region_)¶
    

Get rid of unnecessary references in region so that it won’t avoid garbage collection on those referenced objects.

Parameters:
    

**region** (`MultiValuedMemory`) – A MultiValuedMemory region.

Return type:
    

`MultiValuedMemory`

Returns:
    

None

_class _angr.analyses.variable_recovery.variable_recovery_fast.VariableRecoveryFastState(_block_addr_ , _analysis_ , _arch_ , _func_ , _project_ , _stack_region =None_, _register_region =None_, _global_region =None_, _typevars =None_, _type_constraints =None_, _func_typevar =None_, _delayed_type_constraints =None_, _stack_offset_typevars =None_, _ret_val_size =None_)¶
    

Bases: `VariableRecoveryStateBase`

The abstract state of variable recovery analysis.

Variables:
    

  * **stack_region** (_KeyedRegion_) – The stack store.

  * **register_region** (_KeyedRegion_) – The register store.

__init__(_block_addr_ , _analysis_ , _arch_ , _func_ , _project_ , _stack_region =None_, _register_region =None_, _global_region =None_, _typevars =None_, _type_constraints =None_, _func_typevar =None_, _delayed_type_constraints =None_, _stack_offset_typevars =None_, _ret_val_size =None_)¶
    

copy()¶
    

merge(_others_ , _successor =None_)¶
    

Merge two abstract states.

For any node A whose dominance frontier that the current node (at the current program location) belongs to, we create a phi variable V’ for each variable V that is defined in A, and then replace all existence of V with V’ in the merged abstract state.

Parameters:
    

**others** ([`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`VariableRecoveryFastState`, [`...`](https://docs.python.org/3/library/constants.html#Ellipsis "\(in Python v3.13\)")]) – Other abstract states to merge.

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`VariableRecoveryFastState`, [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")]

Returns:
    

The merged abstract state.

downsize()¶
    

Remove unnecessary members.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

None

_class _angr.analyses.variable_recovery.variable_recovery_fast.VariableRecoveryFast(_func_ , _func_graph =None_, _entry_node_addr =None_, _max_iterations =2_, _low_priority =False_, _track_sp =True_, _func_args =None_, _store_live_variables =False_, _unify_variables =True_, _func_arg_vvars =None_, _vvar_to_vvar =None_, _type_hints =None_)¶
    

Bases: `ForwardAnalysis`, `VariableRecoveryBase`

Recover “variables” from a function by keeping track of stack pointer offsets and pattern matching VEX statements.

If calling conventions are recovered prior to running VariableRecoveryFast, variables can be recognized more accurately. However, it is not a requirement. In this case, the function graph you pass must contain information indicating the call-out sites inside the analyzed function. These graph edges must be annotated with either `"type": "call"` or `"outside": True`.

Parameters:
    

  * **func** (_Function_ _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **func_graph** (_networkx.DiGraph_ _|__None_)

  * **entry_node_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_ _]__|__None_)

  * **max_iterations** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **func_args** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__SimVariable_ _]__|__None_)

  * **func_arg_vvars** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__VirtualVariable_ _,__SimVariable_ _]__]__|__None_)

  * **vvar_to_vvar** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **type_hints** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__atoms.VirtualVariable_ _|__atoms.MemoryLocation_ _,_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__]__|__None_)

__init__(_func_ , _func_graph =None_, _entry_node_addr =None_, _max_iterations =2_, _low_priority =False_, _track_sp =True_, _func_args =None_, _store_live_variables =False_, _unify_variables =True_, _func_arg_vvars =None_, _vvar_to_vvar =None_, _type_hints =None_)¶
    

Constructor

Parameters:
    

  * **order_jobs** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If all jobs should be ordered or not.

  * **allow_merging** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If job merging is allowed.

  * **allow_widening** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If job widening is allowed.

  * **graph_visitor** (_GraphVisitor_ _or_ _None_) – A graph visitor to provide successors.

  * **func** (_Function_ _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **func_graph** (_DiGraph_ _|__None_)

  * **entry_node_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_ _]__|__None_)

  * **max_iterations** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **func_args** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__SimVariable_ _]__|__None_)

  * **func_arg_vvars** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__VirtualVariable_ _,__SimVariable_ _]__]__|__None_)

  * **vvar_to_vvar** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **type_hints** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__VirtualVariable_ _|__MemoryLocation_ _,_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__]__|__None_)

Returns:
    

None

_class _angr.analyses.variable_recovery.variable_recovery.VariableRecoveryState(_project_ , _block_addr_ , _analysis_ , _arch_ , _func_ , _concrete_states_ , _stack_region =None_, _register_region =None_)¶
    

Bases: `VariableRecoveryStateBase`

The abstract state of variable recovery analysis.

Variables:
    

**variable_manager** (_angr.knowledge.variable_manager.VariableManager_) – The variable manager.

Parameters:
    

  * **project** (_angr.Project_)

  * **block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **arch** ([_archinfo.Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.Arch "\(in archinfo\)"))

  * **func** (_Function_)

__init__(_project_ , _block_addr_ , _analysis_ , _arch_ , _func_ , _concrete_states_ , _stack_region =None_, _register_region =None_)¶
    

Parameters:
    

  * **project** (_Project_)

  * **block_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **arch** ([_Arch_](https://docs.angr.io/projects/archinfo/en/latest/api.html#archinfo.arch.Arch "\(in archinfo\)"))

  * **func** (_Function_)

_property _concrete_states¶
    

get_concrete_state(_addr_)¶
    

Parameters:
    

**addr**

Returns:
    

copy()¶
    

register_callbacks(_concrete_states_)¶
    

Parameters:
    

**concrete_states**

Returns:
    

merge(_others_ , _successor =None_)¶
    

Merge two abstract states.

Parameters:
    

**others** ([`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`VariableRecoveryState`, [`...`](https://docs.python.org/3/library/constants.html#Ellipsis "\(in Python v3.13\)")]) – Other abstract states to merge.

Returns:
    

The merged abstract state.

Return type:
    

VariableRecoveryState, and a boolean that indicates if any merge has happened.

_class _angr.analyses.variable_recovery.variable_recovery.VariableRecovery(_func_ , _max_iterations =20_, _store_live_variables =False_)¶
    

Bases: `ForwardAnalysis`, `VariableRecoveryBase`

Recover “variables” from a function using forced execution.

While variables play a very important role in programming, it does not really exist after compiling. However, we can still identify and recovery their counterparts in binaries. It is worth noting that not every variable in source code can be identified in binaries, and not every recognized variable in binaries have a corresponding variable in the original source code. In short, there is no guarantee that the variables we identified/recognized in a binary are the same variables in its source code.

This analysis uses heuristics to identify and recovers the following types of variables: \- Register variables. \- Stack variables. \- Heap variables. (not implemented yet) \- Global variables. (not implemented yet)

This analysis takes a function as input, and performs a data-flow analysis on nodes. It runs concrete execution on every statement and hooks all register/memory accesses to discover all places that are accessing variables. It is slow, but has a more accurate analysis result. For a fast but inaccurate variable recovery, you may consider using VariableRecoveryFast.

This analysis follows SSA, which means every write creates a new variable in registers or memory (statck, heap, etc.). Things may get tricky when overlapping variable (in memory, as you cannot really have overlapping accesses to registers) accesses exist, and in such cases, a new variable will be created, and this new variable will overlap with one or more existing variables. A decision procedure (which is pretty much TODO) is required at the end of this analysis to resolve the conflicts between overlapping variables.

__init__(_func_ , _max_iterations =20_, _store_live_variables =False_)¶
    

Parameters:
    

**func** (_knowledge.Function_) – The function to analyze.

_class _angr.analyses.variable_recovery.engine_ail.SimEngineVRAIL(_* args_, _call_info =None_, _vvar_to_vvar_ , _vvar_type_hints =None_, _** kwargs_)¶
    

Bases: `SimEngineNostmtAIL`[`VariableRecoveryFastState`, `RichR`[[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`FP`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)")], [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)"), [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")], `SimEngineVRBase`[`VariableRecoveryFastState`, `Block`]

The engine for variable recovery on AIL.

Parameters:
    

  * **vvar_to_vvar** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **vvar_type_hints** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__typeconsts.TypeConstant_ _]__|__None_)

__init__(_* args_, _call_info =None_, _vvar_to_vvar_ , _vvar_type_hints =None_, _** kwargs_)¶
    

Parameters:
    

  * **vvar_to_vvar** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **vvar_type_hints** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__TypeConstant_ _]__|__None_)

_class _angr.analyses.variable_recovery.engine_vex.SimEngineVRVEX(_* args_, _call_info =None_, _** kwargs_)¶
    

Bases: `SimEngineNostmtVEX`[`VariableRecoveryFastState`, `RichR`[[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`FP`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)")], [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")], `SimEngineVRBase`[`VariableRecoveryFastState`, `Block`]

Implements the VEX engine for variable recovery analysis.

reg_read_stmts_to_ignore _: set[int]_¶
    

stmts_to_lower _: set[int]_¶
    

__init__(_* args_, _call_info =None_, _** kwargs_)¶
    

_class _angr.analyses.variable_recovery.engine_base.RichR(_data_ , _variable =None_, _typevar =None_, _type_constraints =None_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`RichRT_co`]

A rich representation of calculation results. The variable recovery data domain.

Parameters:
    

  * **data** (_RichRT_co_)

  * **typevar** (_typeconsts.TypeConstant_ _|__typevars.TypeVariable_ _|__None_)

  * **type_constraints** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__typevars.TypeConstraint_ _]__|__None_)

__init__(_data_ , _variable =None_, _typevar =None_, _type_constraints =None_)¶
    

Parameters:
    

  * **data** (_RichRT_co_)

  * **typevar** (_TypeConstant_ _|__TypeVariable_ _|__None_)

  * **type_constraints** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__TypeConstraint_ _]__|__None_)

data¶
    

variable¶
    

typevar _: `TypeConstant` | `TypeVariable` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

type_constraints¶
    

_property _bits _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.analyses.variable_recovery.engine_base.SimEngineVRBase(_project_ , _kb_ , _vvar_type_hints =None_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`VRStateType`, `BlockType`], `SimEngineLight`[`VRStateType`, `RichR`[[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)") | [`FP`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.fp.FP "\(in claripy\)")], `BlockType`, [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")]

The base class for variable recovery analyses. Contains methods for basic interactions with the state, like loading and storing data.

Parameters:
    

**vvar_type_hints** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__typeconsts.TypeConstant_ _]__|__None_)

__init__(_project_ , _kb_ , _vvar_type_hints =None_)¶
    

Parameters:
    

**vvar_type_hints** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__TypeConstant_ _]__|__None_)

_property _func_addr¶
    

_class _angr.analyses.variable_recovery.irsb_scanner.VEXIRSBScanner(_* args_, _** kwargs_)¶
    

Bases: `SimEngineLightVEX`[[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)"), [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)"), [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)"), [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")]

Scan the VEX IRSB to determine if any argument-passing registers should be narrowed by detecting cases of loading the whole register and immediately narrowing the register before writing to the tmp.

__init__(_* args_, _** kwargs_)¶
    

process(_state_ , _*_ , _block =None_, _whitelist =None_, _** kwargs_)¶
    

_class _angr.analyses.variable_recovery.VariableRecovery(_func_ , _max_iterations =20_, _store_live_variables =False_)¶
    

Bases: `ForwardAnalysis`, `VariableRecoveryBase`

Recover “variables” from a function using forced execution.

While variables play a very important role in programming, it does not really exist after compiling. However, we can still identify and recovery their counterparts in binaries. It is worth noting that not every variable in source code can be identified in binaries, and not every recognized variable in binaries have a corresponding variable in the original source code. In short, there is no guarantee that the variables we identified/recognized in a binary are the same variables in its source code.

This analysis uses heuristics to identify and recovers the following types of variables: \- Register variables. \- Stack variables. \- Heap variables. (not implemented yet) \- Global variables. (not implemented yet)

This analysis takes a function as input, and performs a data-flow analysis on nodes. It runs concrete execution on every statement and hooks all register/memory accesses to discover all places that are accessing variables. It is slow, but has a more accurate analysis result. For a fast but inaccurate variable recovery, you may consider using VariableRecoveryFast.

This analysis follows SSA, which means every write creates a new variable in registers or memory (statck, heap, etc.). Things may get tricky when overlapping variable (in memory, as you cannot really have overlapping accesses to registers) accesses exist, and in such cases, a new variable will be created, and this new variable will overlap with one or more existing variables. A decision procedure (which is pretty much TODO) is required at the end of this analysis to resolve the conflicts between overlapping variables.

__init__(_func_ , _max_iterations =20_, _store_live_variables =False_)¶
    

Parameters:
    

**func** (_knowledge.Function_) – The function to analyze.

_class _angr.analyses.variable_recovery.VariableRecoveryFast(_func_ , _func_graph =None_, _entry_node_addr =None_, _max_iterations =2_, _low_priority =False_, _track_sp =True_, _func_args =None_, _store_live_variables =False_, _unify_variables =True_, _func_arg_vvars =None_, _vvar_to_vvar =None_, _type_hints =None_)¶
    

Bases: `ForwardAnalysis`, `VariableRecoveryBase`

Recover “variables” from a function by keeping track of stack pointer offsets and pattern matching VEX statements.

If calling conventions are recovered prior to running VariableRecoveryFast, variables can be recognized more accurately. However, it is not a requirement. In this case, the function graph you pass must contain information indicating the call-out sites inside the analyzed function. These graph edges must be annotated with either `"type": "call"` or `"outside": True`.

Parameters:
    

  * **func** (_Function_ _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **func_graph** (_networkx.DiGraph_ _|__None_)

  * **entry_node_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_ _]__|__None_)

  * **max_iterations** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **func_args** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__SimVariable_ _]__|__None_)

  * **func_arg_vvars** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__VirtualVariable_ _,__SimVariable_ _]__]__|__None_)

  * **vvar_to_vvar** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **type_hints** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__atoms.VirtualVariable_ _|__atoms.MemoryLocation_ _,_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__]__|__None_)

__init__(_func_ , _func_graph =None_, _entry_node_addr =None_, _max_iterations =2_, _low_priority =False_, _track_sp =True_, _func_args =None_, _store_live_variables =False_, _unify_variables =True_, _func_arg_vvars =None_, _vvar_to_vvar =None_, _type_hints =None_)¶
    

Constructor

Parameters:
    

  * **order_jobs** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If all jobs should be ordered or not.

  * **allow_merging** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If job merging is allowed.

  * **allow_widening** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If job widening is allowed.

  * **graph_visitor** (_GraphVisitor_ _or_ _None_) – A graph visitor to provide successors.

  * **func** (_Function_ _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **func_graph** (_DiGraph_ _|__None_)

  * **entry_node_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_ _]__|__None_)

  * **max_iterations** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **func_args** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__SimVariable_ _]__|__None_)

  * **func_arg_vvars** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__VirtualVariable_ _,__SimVariable_ _]__]__|__None_)

  * **vvar_to_vvar** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **type_hints** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__VirtualVariable_ _|__MemoryLocation_ _,_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__]__|__None_)

Returns:
    

None

_class _angr.analyses.typehoon.lifter.TypeLifter(_bits_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Lift SimTypes to type constants.

Parameters:
    

**bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_bits_)¶
    

Parameters:
    

**bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

bits¶
    

memo¶
    

lift(_ty_)¶
    

Parameters:
    

**ty** (_SimType_)

_class _angr.analyses.typehoon.simple_solver.SketchNodeBase¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

The base class for nodes in a sketch.

_class _angr.analyses.typehoon.simple_solver.SketchNode(_typevar_)¶
    

Bases: `SketchNodeBase`

Represents a node in a sketch graph.

Parameters:
    

**typevar** (_TypeVariable_ _|__DerivedTypeVariable_)

__init__(_typevar_)¶
    

Parameters:
    

**typevar** (_TypeVariable_ _|__DerivedTypeVariable_)

typevar _: `TypeVariable` | `DerivedTypeVariable`_¶
    

upper_bound _: `TypeConstant`_¶
    

lower_bound _: `TypeConstant`_¶
    

_property _size _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

Best-effort estimation of the size of the typevar (in bits). Returns None if we cannot determine.

_class _angr.analyses.typehoon.simple_solver.RecursiveRefNode(_target_)¶
    

Bases: `SketchNodeBase`

Represents a cycle in a sketch graph.

This is equivalent to sketches.LabelNode in the reference implementation of retypd.

Parameters:
    

**target** (_DerivedTypeVariable_)

__init__(_target_)¶
    

Parameters:
    

**target** (_DerivedTypeVariable_)

_class _angr.analyses.typehoon.simple_solver.Sketch(_solver_ , _root_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Describes the sketch of a type variable.

Parameters:
    

  * **solver** (_SimpleSolver_)

  * **root** (_TypeVariable_)

__init__(_solver_ , _root_)¶
    

Parameters:
    

  * **solver** (_SimpleSolver_)

  * **root** (_TypeVariable_)

root _: `SketchNode`_¶
    

graph¶
    

node_mapping _: [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[`TypeVariable` | `DerivedTypeVariable`, `SketchNodeBase`]_¶
    

solver¶
    

lookup(_typevar_)¶
    

Return type:
    

`SketchNodeBase` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**typevar** (_TypeVariable_ _|__DerivedTypeVariable_)

add_edge(_src_ , _dst_ , _label_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **src** (_SketchNodeBase_)

  * **dst** (_SketchNodeBase_)

add_constraint(_constraint_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**constraint** (_TypeConstraint_)

_static _flatten_typevar(_derived_typevar_)¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`DerivedTypeVariable` | `TypeVariable` | `TypeConstant`, [`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")]

Parameters:
    

**derived_typevar** (_TypeVariable_ _|__TypeConstant_ _|__DerivedTypeVariable_)

_class _angr.analyses.typehoon.simple_solver.ConstraintGraphTag(_value_)¶
    

Bases: [`Enum`](https://docs.python.org/3/library/enum.html#enum.Enum "\(in Python v3.13\)")

An enumeration.

LEFT _ = 0_¶
    

RIGHT _ = 1_¶
    

UNKNOWN _ = 2_¶
    

_class _angr.analyses.typehoon.simple_solver.FORGOTTEN(_value_)¶
    

Bases: [`Enum`](https://docs.python.org/3/library/enum.html#enum.Enum "\(in Python v3.13\)")

An enumeration.

PRE_FORGOTTEN _ = 0_¶
    

POST_FORGOTTEN _ = 1_¶
    

_class _angr.analyses.typehoon.simple_solver.ConstraintGraphNode(_typevar_ , _variance_ , _tag_ , _forgotten_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Parameters:
    

  * **typevar** (_TypeVariable_ _|__DerivedTypeVariable_)

  * **variance** (_Variance_)

  * **tag** (_ConstraintGraphTag_)

  * **forgotten** (_FORGOTTEN_)

__init__(_typevar_ , _variance_ , _tag_ , _forgotten_)¶
    

Parameters:
    

  * **typevar** (_TypeVariable_ _|__DerivedTypeVariable_)

  * **variance** (_Variance_)

  * **tag** (_ConstraintGraphTag_)

  * **forgotten** (_FORGOTTEN_)

typevar¶
    

variance¶
    

tag¶
    

forgotten¶
    

forget_last_label()¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`ConstraintGraphNode`, `BaseLabel`] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

recall(_label_)¶
    

Return type:
    

`ConstraintGraphNode`

Parameters:
    

**label** (_BaseLabel_)

inverse()¶
    

Return type:
    

`ConstraintGraphNode`

inverse_wo_tag()¶
    

Invert the variance only.

Return type:
    

`ConstraintGraphNode`

_class _angr.analyses.typehoon.simple_solver.SimpleSolver(_bits_ , _constraints_ , _typevars_ , _constraint_set_degradation_threshold =150_, _stackvar_max_sizes =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

SimpleSolver is, by its name, a simple solver. Most of this solver is based on the (complex) simplification logic that the retypd paper describes and the retypd re-implementation (<https://github.com/GrammaTech/retypd>) implements. Additionally, we add some improvements to allow type propagation of known struct names, among a few other improvements.

Parameters:
    

  * **bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **constraint_set_degradation_threshold** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **stackvar_max_sizes** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__TypeVariable_ _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

__init__(_bits_ , _constraints_ , _typevars_ , _constraint_set_degradation_threshold =150_, _stackvar_max_sizes =None_)¶
    

Parameters:
    

  * **bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **constraint_set_degradation_threshold** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **stackvar_max_sizes** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__TypeVariable_ _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

solve()¶
    

Steps:

For each type variable, \- Infer the shape in its sketch \- Build the constraint graph \- Collect all constraints \- Apply constraints to derive the lower and upper bounds \- Determine a solution for type variables with constraints \- Rewrite the constraint graph by replacing determined type variables with their solutions \- Solve repeatedly until all interesting type variables have solutions

By repeatedly solving until exhausting interesting type variables, we ensure the S-Trans rule is applied.

infer_shapes(_typevars_ , _constraints_)¶
    

Computing sketches from constraint sets. Implements Algorithm E.1 in the retypd paper.

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)"), [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[`TypeVariable`, `Sketch`]]

Parameters:
    

  * **typevars** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__TypeVariable_ _]_)

  * **constraints** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__TypeConstraint_ _]_)

compute_quotient_graph(_constraints_)¶
    

Compute the quotient graph (the constraint graph modulo ~ in Algorithm E.1 in the retypd paper) with respect to a given set of type constraints.

Parameters:
    

**constraints** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__TypeConstraint_ _]_)

join(_t1_ , _t2_)¶
    

Return type:
    

`TypeConstant`

Parameters:
    

  * **t1** (_TypeConstant_ _|__TypeVariable_)

  * **t2** (_TypeConstant_ _|__TypeVariable_)

meet(_t1_ , _t2_)¶
    

Return type:
    

`TypeConstant`

Parameters:
    

  * **t1** (_TypeConstant_ _|__TypeVariable_)

  * **t2** (_TypeConstant_ _|__TypeVariable_)

_static _abstract(_t_)¶
    

Return type:
    

`TypeConstant` | `TypeVariable`

Parameters:
    

**t** (_TypeConstant_ _|__TypeVariable_)

determine(_sketches_ , _tvs_ , _solution_ , _nodes =None_)¶
    

Determine C-like types from sketches.

Parameters:
    

  * **sketches** – A dictionary storing sketches for each type variable.

  * **solution** ([`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")) – The dictionary storing C-like types for each type variable. Output.

  * **nodes** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`SketchNode`]]) – Optional. Nodes that should be considered in the sketch.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

None

_static _dump_constraint_graph(_graph_ , _filename_)¶
    

Dump the constraint graph to a file.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **graph** (_DiGraph_)

  * **filename** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.analyses.typehoon.translator.SimTypeTempRef(_typevar_)¶
    

Bases: `SimType`

Represents a temporary reference to another type. TypeVariableReference is translated to SimTypeTempRef.

__init__(_typevar_)¶
    

Parameters:
    

**label** – the type label.

c_repr(_** kwargs_)¶
    

_class _angr.analyses.typehoon.translator.TypeTranslator(_arch =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Translate type variables to SimType equivalence.

__init__(_arch =None_)¶
    

struct_name()¶
    

tc2simtype(_tc_)¶
    

simtype2tc(_simtype_)¶
    

Return type:
    

`TypeConstant`

Parameters:
    

**simtype** (_SimType_)

backpatch(_st_ , _translated_)¶
    

Parameters:
    

  * **st** (_sim_type.SimType_)

  * **translated** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)"))

Returns:
    

_class _angr.analyses.typehoon.typevars.TypeConstraint¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

pp_str(_mapping_)¶
    

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

Parameters:
    

**mapping** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__TypeVariable_ _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]_)

_class _angr.analyses.typehoon.typevars.Equivalence(_type_a_ , _type_b_)¶
    

Bases: `TypeConstraint`

__init__(_type_a_ , _type_b_)¶
    

type_a¶
    

type_b¶
    

pp_str(_mapping_)¶
    

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

Parameters:
    

**mapping** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__TypeVariable_ _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]_)

_class _angr.analyses.typehoon.typevars.Existence(_type__)¶
    

Bases: `TypeConstraint`

__init__(_type__)¶
    

type_¶
    

pp_str(_mapping_)¶
    

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

Parameters:
    

**mapping** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__TypeVariable_ _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]_)

replace(_replacements_)¶
    

_class _angr.analyses.typehoon.typevars.Subtype(_sub_type_ , _super_type_)¶
    

Bases: `TypeConstraint`

Parameters:
    

  * **sub_type** (_TypeType_)

  * **super_type** (_TypeType_)

__init__(_sub_type_ , _super_type_)¶
    

Parameters:
    

  * **sub_type** (_TypeConstant_ _|__TypeVariable_ _|__DerivedTypeVariable_)

  * **super_type** (_TypeConstant_ _|__TypeVariable_ _|__DerivedTypeVariable_)

super_type¶
    

sub_type¶
    

pp_str(_mapping_)¶
    

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

Parameters:
    

**mapping** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__TypeVariable_ _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]_)

replace(_replacements_)¶
    

_class _angr.analyses.typehoon.typevars.Add(_type_0_ , _type_1_ , _type_r_)¶
    

Bases: `TypeConstraint`

Describes the constraint that type_r == type0 + type1

__init__(_type_0_ , _type_1_ , _type_r_)¶
    

type_0¶
    

type_1¶
    

type_r¶
    

pp_str(_mapping_)¶
    

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

Parameters:
    

**mapping** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__TypeVariable_ _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]_)

replace(_replacements_)¶
    

_class _angr.analyses.typehoon.typevars.Sub(_type_0_ , _type_1_ , _type_r_)¶
    

Bases: `TypeConstraint`

Describes the constraint that type_r == type0 - type1

__init__(_type_0_ , _type_1_ , _type_r_)¶
    

type_0¶
    

type_1¶
    

type_r¶
    

pp_str(_mapping_)¶
    

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

Parameters:
    

**mapping** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__TypeVariable_ _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]_)

replace(_replacements_)¶
    

_class _angr.analyses.typehoon.typevars.TypeVariable(_idx =None_, _name =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

__init__(_idx =None_, _name =None_)¶
    

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

idx _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

name¶
    

pp_str(_mapping_)¶
    

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

Parameters:
    

**mapping** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__TypeVariable_ _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]_)

_class _angr.analyses.typehoon.typevars.DerivedTypeVariable(_type_var_ , _label_ , _labels =None_, _idx =None_)¶
    

Bases: `TypeVariable`

Parameters:
    

  * **type_var** (_TypeVariable_)

  * **label** (_BaseLabel_ _|__None_)

  * **labels** ([_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__BaseLabel_ _,__...__]_)

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_type_var_ , _label_ , _labels =None_, _idx =None_)¶
    

Parameters:
    

  * **type_var** (_TypeVariable_ _|__DerivedTypeVariable_)

  * **label** (_BaseLabel_ _|__None_)

  * **labels** ([_Iterable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable "\(in Python v3.13\)") _[__BaseLabel_ _]__|__None_)

type_var _: `TypeVariable`_¶
    

labels _: [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`BaseLabel`, [`...`](https://docs.python.org/3/library/constants.html#Ellipsis "\(in Python v3.13\)")]_¶
    

one_label()¶
    

Return type:
    

`BaseLabel` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

path()¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`BaseLabel`, [`...`](https://docs.python.org/3/library/constants.html#Ellipsis "\(in Python v3.13\)")]

longest_prefix()¶
    

Return type:
    

[`Union`](https://docs.python.org/3/library/typing.html#typing.Union "\(in Python v3.13\)")[`TypeConstant`, `TypeVariable`, `DerivedTypeVariable`, [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")]

pp_str(_mapping_)¶
    

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

Parameters:
    

**mapping** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__TypeVariable_ _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]_)

replace(_replacements_)¶
    

_class _angr.analyses.typehoon.typevars.TypeVariables¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__()¶
    

copy()¶
    

add_type_variable(_var_ , _typevar_ , _latest =True_)¶
    

Parameters:
    

  * **var** (_SimVariable_)

  * **typevar** (_TypeVariable_)

  * **latest** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

get_type_variable(_var_)¶
    

has_type_variable_for(_var_)¶
    

Parameters:
    

**var** (_SimVariable_)

typevar_to_variable(_typevar_)¶
    

Return type:
    

`SimVariable` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**typevar** (_TypeVariable_)

_class _angr.analyses.typehoon.typevars.BaseLabel¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__()¶
    

_property _variance _: Variance_¶
    

_class _angr.analyses.typehoon.typevars.FuncIn(_loc_)¶
    

Bases: `BaseLabel`

__init__(_loc_)¶
    

loc¶
    

_class _angr.analyses.typehoon.typevars.FuncOut(_loc_)¶
    

Bases: `BaseLabel`

__init__(_loc_)¶
    

loc¶
    

_class _angr.analyses.typehoon.typevars.Load¶
    

Bases: `BaseLabel`

_class _angr.analyses.typehoon.typevars.Store¶
    

Bases: `BaseLabel`

_property _variance _: Variance_¶
    

_class _angr.analyses.typehoon.typevars.AddN(_n_)¶
    

Bases: `BaseLabel`

__init__(_n_)¶
    

n¶
    

_class _angr.analyses.typehoon.typevars.SubN(_n_)¶
    

Bases: `BaseLabel`

__init__(_n_)¶
    

n¶
    

_class _angr.analyses.typehoon.typevars.ConvertTo(_to_bits_)¶
    

Bases: `BaseLabel`

__init__(_to_bits_)¶
    

to_bits¶
    

_class _angr.analyses.typehoon.typevars.ReinterpretAs(_to_type_ , _to_bits_)¶
    

Bases: `BaseLabel`

__init__(_to_type_ , _to_bits_)¶
    

to_type¶
    

to_bits¶
    

_class _angr.analyses.typehoon.typevars.HasField(_bits_ , _offset_)¶
    

Bases: `BaseLabel`

__init__(_bits_ , _offset_)¶
    

bits¶
    

offset¶
    

_class _angr.analyses.typehoon.typevars.IsArray¶
    

Bases: `BaseLabel`

angr.analyses.typehoon.typevars.new_dtv(_type_var_ , _*_ , _label =None_, _labels =None_)¶
    

Create a new DerivedTypeVariable with the given type variable (or DerivedTypeVariable) and labels.

Return type:
    

`TypeVariable` | `DerivedTypeVariable`

Parameters:
    

  * **type_var** (_TypeVariable_)

  * **label** (_BaseLabel_ _|__None_)

  * **labels** ([_Sequence_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence "\(in Python v3.13\)") _[__BaseLabel_ _]__|__None_)

_class _angr.analyses.typehoon.typehoon.Typehoon(_constraints_ , _func_var_ , _ground_truth =None_, _var_mapping =None_, _must_struct =None_, _stackvar_max_sizes =None_, _stack_offset_tvs =None_, _constraint_set_degradation_threshold =150_)¶
    

Bases: `Analysis`

A spiritual tribute to the long-standing typehoon project that @jmg (John Grosen) worked on during his days in the angr team. Now I feel really bad of asking the poor guy to work directly on VEX IR without any fancy static analysis support as we have right now…

Typehoon analysis implements a pushdown system that simplifies and solves type constraints. Our type constraints are largely an implementation of the paper Polymorphic Type Inference for Machine Code by Noonan, Loginov, and Cok from GrammaTech (with missing functionality support and bugs, of course). Type constraints are collected by running VariableRecoveryFast (maybe VariableRecovery later as well) on a function, and then solved using this analysis.

User may specify ground truth, which will override all types at certain program points during constraint solving.

Parameters:
    

  * **var_mapping** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__SimVariable_ _,_[_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__TypeVariable_ _]__]__|__None_)

  * **must_struct** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__TypeVariable_ _]__|__None_)

  * **stackvar_max_sizes** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__TypeVariable_ _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **stack_offset_tvs** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__TypeVariable_ _]__|__None_)

  * **constraint_set_degradation_threshold** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_constraints_ , _func_var_ , _ground_truth =None_, _var_mapping =None_, _must_struct =None_, _stackvar_max_sizes =None_, _stack_offset_tvs =None_, _constraint_set_degradation_threshold =150_)¶
    

Parameters:
    

  * **constraints**

  * **ground_truth** – A set of SimType-style solutions for some or all type variables. They will be respected during type solving.

  * **var_mapping** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[`SimVariable`, [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`TypeVariable`]]])

  * **must_struct** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`TypeVariable`]])

  * **stackvar_max_sizes** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__TypeVariable_ _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **stack_offset_tvs** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__TypeVariable_ _]__|__None_)

  * **constraint_set_degradation_threshold** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

update_variable_types(_func_addr_ , _var_to_typevars_ , _stack_offset_tvs =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **var_to_typevars** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__SimVariable_ _,_[_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__TypeVariable_ _]__]_)

  * **stack_offset_tvs** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__TypeVariable_ _]__|__None_)

pp_constraints()¶
    

Pretty-print constraints between _variables_ using the variable mapping.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

pp_solution()¶
    

Pretty-print solutions using the variable mapping.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

All type constants used in type inference. They can be mapped, translated, or rewritten to C-style types.

angr.analyses.typehoon.typeconsts.memoize(_f_)¶
    

_class _angr.analyses.typehoon.typeconsts.TypeConstant¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

SIZE _ = None_¶
    

pp_str(_mapping_)¶
    

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

_property _size _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.analyses.typehoon.typeconsts.TopType¶
    

Bases: `TypeConstant`

_class _angr.analyses.typehoon.typeconsts.BottomType¶
    

Bases: `TypeConstant`

_class _angr.analyses.typehoon.typeconsts.Int¶
    

Bases: `TypeConstant`

_class _angr.analyses.typehoon.typeconsts.Int1¶
    

Bases: `Int`

SIZE _ = 1_¶
    

_class _angr.analyses.typehoon.typeconsts.Int8¶
    

Bases: `Int`

SIZE _ = 1_¶
    

_class _angr.analyses.typehoon.typeconsts.Int16¶
    

Bases: `Int`

SIZE _ = 2_¶
    

_class _angr.analyses.typehoon.typeconsts.Int32¶
    

Bases: `Int`

SIZE _ = 4_¶
    

_class _angr.analyses.typehoon.typeconsts.Int64¶
    

Bases: `Int`

SIZE _ = 8_¶
    

_class _angr.analyses.typehoon.typeconsts.Int128¶
    

Bases: `Int`

SIZE _ = 16_¶
    

_class _angr.analyses.typehoon.typeconsts.Int256¶
    

Bases: `Int`

SIZE _ = 32_¶
    

_class _angr.analyses.typehoon.typeconsts.Int512¶
    

Bases: `Int`

SIZE _ = 32_¶
    

_class _angr.analyses.typehoon.typeconsts.IntVar(_size_)¶
    

Bases: `Int`

__init__(_size_)¶
    

_property _size _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.analyses.typehoon.typeconsts.Float¶
    

Bases: `TypeConstant`

_class _angr.analyses.typehoon.typeconsts.Float32¶
    

Bases: `Float`

SIZE _ = 4_¶
    

_class _angr.analyses.typehoon.typeconsts.Float64¶
    

Bases: `Float`

SIZE _ = 8_¶
    

_class _angr.analyses.typehoon.typeconsts.Pointer(_basetype_)¶
    

Bases: `TypeConstant`

Parameters:
    

**basetype** (_TypeConstant_ _|__None_)

__init__(_basetype_)¶
    

Parameters:
    

**basetype** (_TypeConstant_ _|__None_)

new(_basetype_)¶
    

_class _angr.analyses.typehoon.typeconsts.Pointer32(_basetype =None_)¶
    

Bases: `Pointer`, `Int32`

32-bit pointers.

__init__(_basetype =None_)¶
    

_class _angr.analyses.typehoon.typeconsts.Pointer64(_basetype =None_)¶
    

Bases: `Pointer`, `Int64`

64-bit pointers.

__init__(_basetype =None_)¶
    

_class _angr.analyses.typehoon.typeconsts.Array(_element =None_, _count =None_)¶
    

Bases: `TypeConstant`

__init__(_element =None_, _count =None_)¶
    

_property _size _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.analyses.typehoon.typeconsts.Struct(_fields =None_, _name =None_, _field_names =None_, _is_cppclass =False_)¶
    

Bases: `TypeConstant`

Parameters:
    

**is_cppclass** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_fields =None_, _name =None_, _field_names =None_, _is_cppclass =False_)¶
    

Parameters:
    

**is_cppclass** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

_property _size _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.analyses.typehoon.typeconsts.Function(_params_ , _outputs_)¶
    

Bases: `TypeConstant`

Parameters:
    

  * **params** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)"))

  * **outputs** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)"))

__init__(_params_ , _outputs_)¶
    

Parameters:
    

  * **params** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)"))

  * **outputs** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)"))

_class _angr.analyses.typehoon.typeconsts.TypeVariableReference(_typevar_)¶
    

Bases: `TypeConstant`

__init__(_typevar_)¶
    

angr.analyses.typehoon.typeconsts.int_type(_bits_)¶
    

Return type:
    

`Int`

Parameters:
    

**bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

angr.analyses.typehoon.typeconsts.float_type(_bits_)¶
    

Return type:
    

`Float` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_class _angr.analyses.typehoon.Typehoon(_constraints_ , _func_var_ , _ground_truth =None_, _var_mapping =None_, _must_struct =None_, _stackvar_max_sizes =None_, _stack_offset_tvs =None_, _constraint_set_degradation_threshold =150_)¶
    

Bases: `Analysis`

A spiritual tribute to the long-standing typehoon project that @jmg (John Grosen) worked on during his days in the angr team. Now I feel really bad of asking the poor guy to work directly on VEX IR without any fancy static analysis support as we have right now…

Typehoon analysis implements a pushdown system that simplifies and solves type constraints. Our type constraints are largely an implementation of the paper Polymorphic Type Inference for Machine Code by Noonan, Loginov, and Cok from GrammaTech (with missing functionality support and bugs, of course). Type constraints are collected by running VariableRecoveryFast (maybe VariableRecovery later as well) on a function, and then solved using this analysis.

User may specify ground truth, which will override all types at certain program points during constraint solving.

Parameters:
    

  * **var_mapping** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__SimVariable_ _,_[_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__TypeVariable_ _]__]__|__None_)

  * **must_struct** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__TypeVariable_ _]__|__None_)

  * **stackvar_max_sizes** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__TypeVariable_ _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **stack_offset_tvs** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__TypeVariable_ _]__|__None_)

  * **constraint_set_degradation_threshold** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_constraints_ , _func_var_ , _ground_truth =None_, _var_mapping =None_, _must_struct =None_, _stackvar_max_sizes =None_, _stack_offset_tvs =None_, _constraint_set_degradation_threshold =150_)¶
    

Parameters:
    

  * **constraints**

  * **ground_truth** – A set of SimType-style solutions for some or all type variables. They will be respected during type solving.

  * **var_mapping** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[`SimVariable`, [`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`TypeVariable`]]])

  * **must_struct** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[`TypeVariable`]])

  * **stackvar_max_sizes** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__TypeVariable_ _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **stack_offset_tvs** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__TypeVariable_ _]__|__None_)

  * **constraint_set_degradation_threshold** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

update_variable_types(_func_addr_ , _var_to_typevars_ , _stack_offset_tvs =None_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **func_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **var_to_typevars** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[__SimVariable_ _,_[_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[__TypeVariable_ _]__]_)

  * **stack_offset_tvs** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__TypeVariable_ _]__|__None_)

pp_constraints()¶
    

Pretty-print constraints between _variables_ using the variable mapping.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

pp_solution()¶
    

Pretty-print solutions using the variable mapping.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

_class _angr.analyses.identifier.identify.FuncInfo¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__()¶
    

_class _angr.analyses.identifier.identify.Identifier(_cfg =None_, _require_predecessors =True_, _only_find =None_)¶
    

Bases: `Analysis`

__init__(_cfg =None_, _require_predecessors =True_, _only_find =None_)¶
    

run(_only_find =None_)¶
    

can_call_same_name(_addr_ , _name_)¶
    

get_func_info(_func_)¶
    

_static _constrain_all_zero(_before_state_ , _state_ , _regs_)¶
    

identify_func(_function_)¶
    

check_tests(_cfg_func_ , _match_func_)¶
    

map_callsites()¶
    

do_trace(_addr_trace_ , _reverse_accesses_ , _func_info_)¶
    

get_call_args(_func_ , _callsite_)¶
    

_static _get_reg_name(_arch_ , _reg_offset_)¶
    

Parameters:
    

  * **arch** – the architecture

  * **reg_offset** – Tries to find the name of a register given the offset in the registers.

Returns:
    

The register name

find_stack_vars_x86(_func_)¶
    

_static _make_initial_state(_project_ , _stack_length_)¶
    

Returns:
    

an initial state with a symbolic stack and good options for rop

_static _make_symbolic_state(_project_ , _reg_list_ , _stack_length =80_)¶
    

converts an input state into a state with symbolic registers :return: the symbolic state

_class _angr.analyses.loopfinder.Loop(_entry_ , _entry_edges_ , _break_edges_ , _continue_edges_ , _body_nodes_ , _graph_ , _subloops_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_entry_ , _entry_edges_ , _break_edges_ , _continue_edges_ , _body_nodes_ , _graph_ , _subloops_)¶
    

_class _angr.analyses.loopfinder.LoopFinder(_functions =None_, _normalize =True_)¶
    

Bases: `Analysis`

Extracts all the loops from all the functions in a binary.

__init__(_functions =None_, _normalize =True_)¶
    

_class _angr.analyses.loop_analysis.VariableTypes¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Iterator _ = 'Iterator'_¶
    

HasNext _ = 'HasNext'_¶
    

Next _ = 'Next'_¶
    

_class _angr.analyses.loop_analysis.AnnotatedVariable(_variable_ , _type__)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_variable_ , _type__)¶
    

variable¶
    

type¶
    

_class _angr.analyses.loop_analysis.Condition(_op_ , _val0_ , _val1_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Equal _ = '=='_¶
    

NotEqual _ = '!='_¶
    

__init__(_op_ , _val0_ , _val1_)¶
    

_classmethod _from_opstr(_opstr_)¶
    

_class _angr.analyses.loop_analysis.SootBlockProcessor(_state_ , _block_ , _loop_ , _defuse_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_state_ , _block_ , _loop_ , _defuse_)¶
    

process()¶
    

_class _angr.analyses.loop_analysis.LoopAnalysisState(_block_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_block_)¶
    

copy()¶
    

merge(_state_)¶
    

add_loop_exit_stmt(_stmt_idx_ , _condition =None_)¶
    

_class _angr.analyses.loop_analysis.LoopAnalysis(_loop_ , _defuse_)¶
    

Bases: `ForwardAnalysis`, `Analysis`

Analyze a loop and recover important information about the loop (e.g., invariants, induction variables) in a static manner.

__init__(_loop_ , _defuse_)¶
    

Constructor

Parameters:
    

  * **order_jobs** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If all jobs should be ordered or not.

  * **allow_merging** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If job merging is allowed.

  * **allow_widening** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If job widening is allowed.

  * **graph_visitor** (_GraphVisitor_ _or_ _None_) – A graph visitor to provide successors.

Returns:
    

None

_exception _angr.analyses.veritesting.VeritestingError¶
    

Bases: [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception "\(in Python v3.13\)")

_class _angr.analyses.veritesting.CallTracingFilter(_project_ , _depth_ , _blacklist =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Filter to apply during CFG creation on a given state and jumpkind to determine if it should be skipped at a certain depth

whitelist _ = {<class 'angr.procedures.cgc.receive.receive'>, <class 'angr.procedures.cgc.transmit.transmit'>, <class 'angr.procedures.glibc.__ctype_b_loc.__ctype_b_loc'>, <class 'angr.procedures.libc.atoi.atoi'>, <class 'angr.procedures.libc.fgetc.fgetc'>, <class 'angr.procedures.libc.strcmp.strcmp'>, <class 'angr.procedures.libc.strlen.strlen'>, <class 'angr.procedures.posix.read.read'>}_¶
    

cfg_cache _ = {}_¶
    

__init__(_project_ , _depth_ , _blacklist =None_)¶
    

filter(_call_target_state_ , _jumpkind_)¶
    

The call will be skipped if it returns True.

Parameters:
    

  * **call_target_state** – The new state of the call target.

  * **jumpkind** – The Jumpkind of this call.

Returns:
    

True if we want to skip this call, False otherwise.

_class _angr.analyses.veritesting.Veritesting(_input_state_ , _boundaries =None_, _loop_unrolling_limit =10_, _enable_function_inlining =False_, _terminator =None_, _deviation_filter =None_)¶
    

Bases: `Analysis`

An exploration technique made for condensing chunks of code to single (nested) if-then-else constraints via CFG accurate to conduct Static Symbolic Execution SSE (conversion to single constraint)

cfg_cache _ = {}_¶
    

all_stashes _ = ('successful', 'errored', 'deadended', 'deviated', 'unconstrained')_¶
    

__init__(_input_state_ , _boundaries =None_, _loop_unrolling_limit =10_, _enable_function_inlining =False_, _terminator =None_, _deviation_filter =None_)¶
    

SSE stands for Static Symbolic Execution, and we also implemented an extended version of Veritesting (Avgerinos, Thanassis, et al, ICSE 2014).

Parameters:
    

  * **input_state** – The initial state to begin the execution with.

  * **boundaries** – Addresses where execution should stop.

  * **loop_unrolling_limit** – The maximum times that Veritesting should unroll a loop for.

  * **enable_function_inlining** – Whether we should enable function inlining and syscall inlining.

  * **terminator** – A callback function that takes a state as parameter. Veritesting will terminate if this function returns True.

  * **deviation_filter** – A callback function that takes a state as parameter. Veritesting will put the state into “deviated” stash if this function returns True.

is_not_in_cfg(_s_)¶
    

Returns if s.addr is not a proper node in our CFG.

Parameters:
    

**s** (_SimState_) – The SimState instance to test.

Returns bool:
    

False if our CFG contains p.addr, True otherwise.

is_overbound(_state_)¶
    

Filter out all states that run out of boundaries or loop too many times.

param SimState state: SimState instance to check returns bool: True if outside of mem/loop_ctr boundary

project _: Project_¶
    

kb _: KnowledgeBase_¶
    

_class _angr.analyses.vfg.VFGJob(_* args_, _** kwargs_)¶
    

Bases: `CFGJobBase`

A job descriptor that contains local variables used during VFG analysis.

__init__(_* args_, _** kwargs_)¶
    

Return type:
    

None

_property _block_id _: BlockID | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

callstack_repr(_kb_)¶
    

Parameters:
    

**kb** (_KnowledgeBase_)

_class _angr.analyses.vfg.PendingJob(_block_id_ , _state_ , _call_stack_ , _src_block_id_ , _src_stmt_idx_ , _src_ins_addr_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Describes a pending job during VFG analysis.

Parameters:
    

  * **block_id** (_BlockID_)

  * **state** (_SimState_)

  * **call_stack** (_CallStack_)

  * **src_block_id** (_BlockID_)

  * **src_stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **src_ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_block_id_ , _state_ , _call_stack_ , _src_block_id_ , _src_stmt_idx_ , _src_ins_addr_)¶
    

Parameters:
    

  * **block_id** (_BlockID_)

  * **state** (_SimState_)

  * **call_stack** (_CallStack_)

  * **src_block_id** (_BlockID_)

  * **src_stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **src_ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

Return type:
    

None

block_id¶
    

state¶
    

call_stack¶
    

src_block_id¶
    

src_stmt_idx¶
    

src_ins_addr¶
    

_class _angr.analyses.vfg.AnalysisTask¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

An analysis task describes a task that should be done before popping this task out of the task stack and discard it.

__init__()¶
    

Return type:
    

None

_property _done¶
    

_class _angr.analyses.vfg.FunctionAnalysis(_function_address_ , _return_address_)¶
    

Bases: `AnalysisTask`

Analyze a function, generate fix-point states from all endpoints of that function, and then merge them to one state.

Parameters:
    

  * **function_address** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **return_address** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_function_address_ , _return_address_)¶
    

Parameters:
    

  * **function_address** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **return_address** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

Return type:
    

None

_property _done _: [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

_class _angr.analyses.vfg.CallAnalysis(_address_ , _return_address_ , _function_analysis_tasks =None_, _mergeable_plugins =None_)¶
    

Bases: `AnalysisTask`

Analyze a call by analyze all functions this call might be calling, collect all final states generated by analyzing those functions, and merge them into one state.

Parameters:
    

  * **address** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **return_address** (_None_)

  * **function_analysis_tasks** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__Any_ _]__|__None_)

  * **mergeable_plugins** ([_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

__init__(_address_ , _return_address_ , _function_analysis_tasks =None_, _mergeable_plugins =None_)¶
    

Parameters:
    

  * **address** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **return_address** (_None_)

  * **function_analysis_tasks** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]__|__None_)

  * **mergeable_plugins** ([_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

Return type:
    

None

_property _done _: [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

register_function_analysis(_task_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**task** (_FunctionAnalysis_)

add_final_job(_job_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**job** (_VFGJob_)

merge_jobs()¶
    

Return type:
    

`VFGJob`

_class _angr.analyses.vfg.VFGNode(_addr_ , _key_ , _state =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A descriptor of nodes in a Value-Flow Graph

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **key** (_BlockID_)

  * **state** (_SimState_ _|__None_)

__init__(_addr_ , _key_ , _state =None_)¶
    

Constructor.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **key** (_BlockID_)

  * **state** (_SimState_)

Return type:
    

None

append_state(_s_ , _is_widened_state =False_)¶
    

Appended a new state to this VFGNode. :type s: :param s: The new state to append :type is_widened_state: :param is_widened_state: Whether it is a widened state or not.

_class _angr.analyses.vfg.VFG(_cfg =None_, _context_sensitivity_level =2_, _start =None_, _function_start =None_, _interfunction_level =0_, _initial_state =None_, _avoid_runs =None_, _remove_options =None_, _timeout =None_, _max_iterations_before_widening =8_, _max_iterations =40_, _widening_interval =3_, _final_state_callback =None_, _status_callback =None_, _record_function_final_states =False_)¶
    

Bases: `ForwardAnalysis`[`SimState`, `VFGNode`, `VFGJob`, `BlockID`], `Analysis`

This class represents a control-flow graph with static analysis result.

Perform abstract interpretation analysis starting from the given function address. The output is an invariant at the beginning (or the end) of each basic block.

Steps:

>   * Generate a CFG first if CFG is not provided.
> 
>   * Identify all merge points (denote the set of merge points as Pw) in the CFG.
> 
>   * Cut those loop back edges (can be derived from Pw) so that we gain an acyclic CFG.
> 
>   * Identify all variables that are 1) from memory loading 2) from initial values, or 3) phi functions. Denote
>     
> 
> the set of those variables as S_{var}.
> 
>   * Start real AI analysis and try to compute a fix point of each merge point. Perform widening/narrowing only on
>     
> 
> variables in S_{var}.
> 
> 

Parameters:
    

  * **cfg** (_CFGEmulated_ _|__None_)

  * **context_sensitivity_level** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **function_start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **interfunction_level** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **initial_state** (_SimState_ _|__None_)

  * **avoid_runs** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **remove_options** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__|__None_)

  * **timeout** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **max_iterations_before_widening** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **max_iterations** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **widening_interval** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **final_state_callback** (_Callable_ _[__[__SimState_ _,__CallStack_ _]__,__Any_ _]__|__None_)

  * **status_callback** (_Callable_ _[__[__VFG_ _]__,__Any_ _]__|__None_)

  * **record_function_final_states** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_cfg =None_, _context_sensitivity_level =2_, _start =None_, _function_start =None_, _interfunction_level =0_, _initial_state =None_, _avoid_runs =None_, _remove_options =None_, _timeout =None_, _max_iterations_before_widening =8_, _max_iterations =40_, _widening_interval =3_, _final_state_callback =None_, _status_callback =None_, _record_function_final_states =False_)¶
    

Parameters:
    

  * **cfg** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[`CFGEmulated`]) – The control-flow graph to base this analysis on. If none is provided, we will construct a CFGEmulated.

  * **context_sensitivity_level** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The level of context-sensitivity of this VFG. It ranges from 0 to infinity. Default 2.

  * **function_start** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – The address of the function to analyze.

  * **interfunction_level** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The level of interfunction-ness to be

  * **initial_state** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[`SimState`]) – A state to use as the initial one

  * **avoid_runs** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]]) – A list of runs to avoid

  * **remove_options** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`set`](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]]) – State options to remove from the initial state. It only works when initial_state is None

  * **timeout** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **final_state_callback** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`Callable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)")[[`SimState`, `CallStack`], [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – callback function when countering final state

  * **status_callback** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`Callable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)")[[`VFG`], [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]]) – callback function used in _analysis_core_baremetal

  * **start** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **max_iterations_before_widening** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **max_iterations** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **widening_interval** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **record_function_final_states** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Return type:
    

None

_property _function_initial_states¶
    

_property _function_final_states¶
    

get_any_node(_addr_)¶
    

Get any VFG node corresponding to the basic block at @addr. Note that depending on the context sensitivity level, there might be multiple nodes corresponding to different contexts. This function will return the first one it encounters, which might not be what you want.

Return type:
    

`VFGNode` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

get_all_nodes(_addr_)¶
    

Return type:
    

[`Generator`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Generator "\(in Python v3.13\)")[`VFGNode`]

irsb_from_node(_node_)¶
    

copy()¶
    

_class _angr.analyses.vsa_ddg.DefUseChain(_def_loc_ , _use_loc_ , _variable_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Stand for a def-use chain. it is generated by the DDG itself.

__init__(_def_loc_ , _use_loc_ , _variable_)¶
    

Constructor.

Parameters:
    

  * **def_loc**

  * **use_loc**

  * **variable**

Returns:
    

_class _angr.analyses.vsa_ddg.VSA_DDG(_vfg =None_, _start_addr =None_, _interfunction_level =0_, _context_sensitivity_level =2_, _keep_data =False_)¶
    

Bases: `Analysis`

A Data dependency graph based on VSA states. That means we don’t (and shouldn’t) expect any symbolic expressions.

__init__(_vfg =None_, _start_addr =None_, _interfunction_level =0_, _context_sensitivity_level =2_, _keep_data =False_)¶
    

Constructor.

Parameters:
    

  * **vfg** – An already constructed VFG. If not specified, a new VFG will be created with other specified parameters. vfg and start_addr cannot both be unspecified.

  * **start_addr** – The address where to start the analysis (typically, a function’s entry point).

  * **interfunction_level** – See VFG analysis.

  * **context_sensitivity_level** – See VFG analysis.

  * **keep_data** – Whether we keep set of addresses as edges in the graph, or just the cardinality of the sets, which can be used as a “weight”.

get_predecessors(_code_location_)¶
    

Returns all predecessors of code_location.

Parameters:
    

**code_location** – A CodeLocation instance.

Returns:
    

A list of all predecessors.

get_all_nodes(_simrun_addr_ , _stmt_idx_)¶
    

Get all DDG nodes matching the given basic block address and statement index.

_class _angr.analyses.vtable.Vtable(_vaddr_ , _size_ , _func_addrs =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

This contains the addr, size and function addresses of a Vtable

__init__(_vaddr_ , _size_ , _func_addrs =None_)¶
    

_class _angr.analyses.vtable.VtableFinder¶
    

Bases: `Analysis`

This analysis locates Vtables in a binary based on heuristics taken from - “Reconstruction of Class Hierarchies for Decompilation of C++ Programs”

__init__()¶
    

is_cross_referenced(_addr_)¶
    

is_function(_addr_)¶
    

analyze()¶
    

create_extract_vtable(_start_addr_ , _sec_size_)¶
    

_class _angr.analyses.find_objects_static.PossibleObject(_size_ , _addr_ , _class_name =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

This holds the address and class name of possible class instances. The address that it holds in mapped outside the binary so it is only valid in this analysis. TO DO: map the address to its uses in the registers/memory locations in the instructions

__init__(_size_ , _addr_ , _class_name =None_)¶
    

_class _angr.analyses.find_objects_static.NewFunctionHandler(_max_addr =None_, _new_func_addr =None_, _project =None_)¶
    

Bases: `FunctionHandler`

This handles calls to the function new(), by recording the size parameter passed to it and also assigns a new
    

address outside the mapped binary to the newly created space(possible object).

It also tracks if the function called right after new() is passed the same ‘this’ pointer and is a constructor, if so we mark it as an instance of the class the constructor belongs to.(only for non stripped binaries)

__init__(_max_addr =None_, _new_func_addr =None_, _project =None_)¶
    

Parameters:
    

  * **interfunction_level** – Maximum depth in to continue local function exploration

  * **extra_impls** – FunctionHandler classes to implement beyond what’s implemented in function_handler_library

hook(_analysis_)¶
    

Attach this instance of the function handler to an instance of RDA.

handle_local_function(_state_ , _data_)¶
    

Parameters:
    

  * **state** (_ReachingDefinitionsState_)

  * **data** (_FunctionCallData_)

_class _angr.analyses.find_objects_static.StaticObjectFinder¶
    

Bases: `Analysis`

This analysis tries to find objects on the heap based on calls to new(), and subsequent calls to constructors with
    

the ‘this’ pointer

__init__()¶
    

_class _angr.analyses.class_identifier.ClassIdentifier¶
    

Bases: `Analysis`

This is a class identifier for non stripped or partially stripped binaries, it identifies classes based on the demangled function names, and also assigns functions to their respective classes based on their names. It also uses the results from the VtableFinder analysis to assign the corresponding vtable to the classes.

> self.classes contains a mapping between class names and SimCppClass objects
> 
> e.g. A::tool() and A::qux() belong to the class A

__init__()¶
    

_class _angr.analyses.disassembly.DisassemblyPiece¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

addr _ = None_¶
    

ident _ = nan_¶
    

render(_formatting =None_)¶
    

getpiece(_formatting_ , _column_)¶
    

width(_formatting_)¶
    

height(_formatting_)¶
    

_static _color(_string_ , _coloring_ , _formatting_)¶
    

highlight(_string_ , _formatting =None_)¶
    

_class _angr.analyses.disassembly.FunctionStart(_func_)¶
    

Bases: `DisassemblyPiece`

__init__(_func_)¶
    

Constructor.

Parameters:
    

**func** (_angr.knowledge.Function_) – The function instance.

height(_formatting_)¶
    

_class _angr.analyses.disassembly.Label(_addr_ , _name_)¶
    

Bases: `DisassemblyPiece`

__init__(_addr_ , _name_)¶
    

_class _angr.analyses.disassembly.IROp(_addr_ , _seq_ , _obj_ , _irsb_)¶
    

Bases: `DisassemblyPiece`

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **seq** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **obj** ([_IRStmt_](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.stmt.IRStmt "\(in pyvex\)") _|_[_PcodeOp_](https://docs.angr.io/projects/pypcode/en/latest/api.html#pypcode.PcodeOp "\(in pypcode\)"))

  * **irsb** ([_IRSB_](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.block.IRSB "\(in pyvex\)") _|__IRSB_)

__init__(_addr_ , _seq_ , _obj_ , _irsb_)¶
    

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **seq** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **obj** ([_IRStmt_](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.stmt.IRStmt "\(in pyvex\)") _|_[_PcodeOp_](https://docs.angr.io/projects/pypcode/en/latest/api.html#pypcode.PcodeOp "\(in pypcode\)"))

  * **irsb** ([_IRSB_](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.block.IRSB "\(in pyvex\)") _|__IRSB_)

addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

seq _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

obj _: [`IRStmt`](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.stmt.IRStmt "\(in pyvex\)") | [`PcodeOp`](https://docs.angr.io/projects/pypcode/en/latest/api.html#pypcode.PcodeOp "\(in pypcode\)")_¶
    

irsb _: [`IRSB`](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.block.IRSB "\(in pyvex\)") | `IRSB`_¶
    

_class _angr.analyses.disassembly.BlockStart(_block_ , _parentfunc_ , _project_)¶
    

Bases: `DisassemblyPiece`

__init__(_block_ , _parentfunc_ , _project_)¶
    

_class _angr.analyses.disassembly.Hook(_block_)¶
    

Bases: `DisassemblyPiece`

__init__(_block_)¶
    

_class _angr.analyses.disassembly.Instruction(_insn_ , _parentblock_ , _project =None_)¶
    

Bases: `DisassemblyPiece`

__init__(_insn_ , _parentblock_ , _project =None_)¶
    

_property _mnemonic¶
    

reload_format()¶
    

dissect_instruction()¶
    

dissect_instruction_for_arm()¶
    

_static _split_arm_op_string(_op_str_)¶
    

Parameters:
    

**op_str** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

dissect_instruction_by_default()¶
    

_static _split_op_string(_insn_str_)¶
    

_class _angr.analyses.disassembly.SootExpression(_expr_)¶
    

Bases: `DisassemblyPiece`

__init__(_expr_)¶
    

_class _angr.analyses.disassembly.SootExpressionTarget(_target_stmt_idx_)¶
    

Bases: `SootExpression`

__init__(_target_stmt_idx_)¶
    

_class _angr.analyses.disassembly.SootExpressionStaticFieldRef(_field_)¶
    

Bases: `SootExpression`

__init__(_field_)¶
    

_class _angr.analyses.disassembly.SootExpressionInvoke(_invoke_type_ , _expr_)¶
    

Bases: `SootExpression`

Virtual _ = 'virtual'_¶
    

Static _ = 'static'_¶
    

Special _ = 'special'_¶
    

__init__(_invoke_type_ , _expr_)¶
    

_class _angr.analyses.disassembly.SootStatement(_block_addr_ , _raw_stmt_)¶
    

Bases: `DisassemblyPiece`

__init__(_block_addr_ , _raw_stmt_)¶
    

_property _stmt_idx¶
    

_class _angr.analyses.disassembly.Opcode(_parentinsn_)¶
    

Bases: `DisassemblyPiece`

__init__(_parentinsn_)¶
    

_class _angr.analyses.disassembly.Operand(_op_num_ , _children_ , _parentinsn_)¶
    

Bases: `DisassemblyPiece`

__init__(_op_num_ , _children_ , _parentinsn_)¶
    

_property _cs_operand¶
    

_static _build(_operand_type_ , _op_num_ , _children_ , _parentinsn_)¶
    

_class _angr.analyses.disassembly.ConstantOperand(_op_num_ , _children_ , _parentinsn_)¶
    

Bases: `Operand`

_class _angr.analyses.disassembly.RegisterOperand(_op_num_ , _children_ , _parentinsn_)¶
    

Bases: `Operand`

_property _register¶
    

_class _angr.analyses.disassembly.MemoryOperand(_op_num_ , _children_ , _parentinsn_)¶
    

Bases: `Operand`

__init__(_op_num_ , _children_ , _parentinsn_)¶
    

_class _angr.analyses.disassembly.OperandPiece¶
    

Bases: `DisassemblyPiece`

addr _ = None_¶
    

parentop _ = None_¶
    

ident _ = None_¶
    

_class _angr.analyses.disassembly.Register(_reg_ , _prefix =''_)¶
    

Bases: `OperandPiece`

__init__(_reg_ , _prefix =''_)¶
    

_class _angr.analyses.disassembly.Value(_val_ , _render_with_sign_)¶
    

Bases: `OperandPiece`

__init__(_val_ , _render_with_sign_)¶
    

_property _project¶
    

_class _angr.analyses.disassembly.Comment(_addr_ , _text_)¶
    

Bases: `DisassemblyPiece`

__init__(_addr_ , _text_)¶
    

height(_formatting_)¶
    

_class _angr.analyses.disassembly.FuncComment(_func_)¶
    

Bases: `DisassemblyPiece`

__init__(_func_)¶
    

_class _angr.analyses.disassembly.Disassembly(_function =None_, _ranges =None_, _thumb =False_, _include_ir =False_, _block_bytes =None_)¶
    

Bases: `Analysis`

Produce formatted machine code disassembly.

Parameters:
    

  * **function** (_Function_ _|__None_)

  * **ranges** (_Sequence_ _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__]__|__None_)

  * **thumb** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **include_ir** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **block_bytes** ([_bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") _|__None_)

__init__(_function =None_, _ranges =None_, _thumb =False_, _include_ir =False_, _block_bytes =None_)¶
    

Parameters:
    

  * **function** (_Function_ _|__None_)

  * **ranges** ([_Sequence_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__]__|__None_)

  * **thumb** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **include_ir** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **block_bytes** ([_bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") _|__None_)

func_lookup(_block_)¶
    

parse_block(_block_)¶
    

Parse instructions for a given block node

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**block** (_BlockNode_)

render(_formatting =None_, _show_edges =True_, _show_addresses =True_, _show_bytes =False_, _ascii_only =None_, _color =True_, _min_edge_depth =0_)¶
    

Render the disassembly to a string, with optional edges and addresses.

Color will be added by default, if enabled. To disable color pass an empty formatting dict.

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

Parameters:
    

  * **show_edges** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **show_addresses** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **show_bytes** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **ascii_only** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)") _|__None_)

  * **color** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **min_edge_depth** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

angr.analyses.disassembly_utils.decode_instruction(_arch_ , _instr_)¶
    

_exception _angr.analyses.reassembler.BinaryError¶
    

Bases: [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception "\(in Python v3.13\)")

_exception _angr.analyses.reassembler.InstructionError¶
    

Bases: `BinaryError`

_exception _angr.analyses.reassembler.ReassemblerFailureNotice¶
    

Bases: `BinaryError`

angr.analyses.reassembler.string_escape(_s_)¶
    

angr.analyses.reassembler.fill_reg_map()¶
    

angr.analyses.reassembler.split_operands(_s_)¶
    

angr.analyses.reassembler.is_hex(_s_)¶
    

_class _angr.analyses.reassembler.Label(_binary_ , _name_ , _original_addr =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

g_label_ctr _ = count(0)_¶
    

__init__(_binary_ , _name_ , _original_addr =None_)¶
    

_property _operand_str¶
    

_property _offset¶
    

_static _new_label(_binary_ , _name =None_, _function_name =None_, _original_addr =None_, _data_label =False_)¶
    

_class _angr.analyses.reassembler.DataLabel(_binary_ , _original_addr_ , _name =None_)¶
    

Bases: `Label`

__init__(_binary_ , _original_addr_ , _name =None_)¶
    

_property _operand_str¶
    

_class _angr.analyses.reassembler.FunctionLabel(_binary_ , _function_name_ , _original_addr_ , _plt =False_)¶
    

Bases: `Label`

__init__(_binary_ , _function_name_ , _original_addr_ , _plt =False_)¶
    

_property _function_name¶
    

_property _operand_str¶
    

_class _angr.analyses.reassembler.ObjectLabel(_binary_ , _symbol_name_ , _original_addr_ , _plt =False_)¶
    

Bases: `Label`

__init__(_binary_ , _symbol_name_ , _original_addr_ , _plt =False_)¶
    

_property _symbol_name¶
    

_property _operand_str¶
    

_class _angr.analyses.reassembler.NotypeLabel(_binary_ , _symbol_name_ , _original_addr_ , _plt =False_)¶
    

Bases: `Label`

__init__(_binary_ , _symbol_name_ , _original_addr_ , _plt =False_)¶
    

_property _symbol_name¶
    

_property _operand_str¶
    

_class _angr.analyses.reassembler.SymbolManager(_binary_ , _cfg_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

SymbolManager manages all symbols in the binary.

__init__(_binary_ , _cfg_)¶
    

Constructor.

Parameters:
    

  * **binary** (_Reassembler_) – The Binary analysis instance.

  * **cfg** (_angr.analyses.CFG_) – The CFG analysis instance.

Returns:
    

None

get_unique_symbol_name(_symbol_name_)¶
    

new_label(_addr_ , _name =None_, _is_function =None_, _force =False_)¶
    

label_got(_addr_ , _label_)¶
    

Mark a certain label as assigned (to an instruction or a block of data).

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address of the label.

  * **label** (_angr.analyses.reassembler.Label_) – The label that is just assigned.

Returns:
    

None

_class _angr.analyses.reassembler.Operand(_binary_ , _insn_addr_ , _insn_size_ , _capstone_operand_ , _operand_str_ , _mnemonic_ , _operand_offset_ , _syntax =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_binary_ , _insn_addr_ , _insn_size_ , _capstone_operand_ , _operand_str_ , _mnemonic_ , _operand_offset_ , _syntax =None_)¶
    

Constructor.

Parameters:
    

  * **binary** (_Reassembler_) – The Binary analysis.

  * **insn_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the instruction.

  * **capstone_operand**

  * **operand_str** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – the string representation of this operand

  * **mnemonic** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Mnemonic of the instruction that this operand belongs to.

  * **operand_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – offset of the operand into the instruction.

  * **syntax** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Provide a way to override the default syntax coming from binary.

Returns:
    

None

assembly()¶
    

_property _is_immediate¶
    

_property _symbolized¶
    

_class _angr.analyses.reassembler.Instruction(_binary_ , _addr_ , _size_ , _insn_bytes_ , _capstone_instr_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

High-level representation of an instruction in the binary

__init__(_binary_ , _addr_ , _size_ , _insn_bytes_ , _capstone_instr_)¶
    

Parameters:
    

  * **binary** (_Reassembler_) – The Binary analysis

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the instruction

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Size of the instruction

  * **insn_bytes** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Instruction bytes

  * **capstone_instr** – Capstone Instr object.

Returns:
    

None

assign_labels()¶
    

dbg_comments()¶
    

assembly(_comments =False_, _symbolized =True_)¶
    

Returns:
    

_class _angr.analyses.reassembler.BasicBlock(_binary_ , _addr_ , _size_ , _x86_getpc_retsite =False_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

BasicBlock represents a basic block in the binary.

Parameters:
    

**x86_getpc_retsite** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_binary_ , _addr_ , _size_ , _x86_getpc_retsite =False_)¶
    

Constructor.

Parameters:
    

  * **binary** (_Reassembler_) – The Binary analysis.

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the block

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Size of the block

  * **x86_getpc_retsite** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Returns:
    

None

assign_labels()¶
    

assembly(_comments =False_, _symbolized =True_)¶
    

instruction_addresses()¶
    

_class _angr.analyses.reassembler.Procedure(_binary_ , _function =None_, _addr =None_, _size =None_, _name =None_, _section ='.text'_, _asm_code =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Procedure in the binary.

__init__(_binary_ , _function =None_, _addr =None_, _size =None_, _name =None_, _section ='.text'_, _asm_code =None_)¶
    

Constructor.

Parameters:
    

  * **binary** (_Reassembler_) – The Binary analysis.

  * **function** (_angr.knowledge.Function_) – The function it represents

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function. Not required if function is provided.

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Size of the function. Not required if function is provided.

  * **section** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Which section this function comes from.

Returns:
    

None

_property _name¶
    

Get function name from the labels of the very first block. :return: Function name if there is any, None otherwise :rtype: string

_property _is_plt¶
    

If this function is a PLT entry or not. :return: True if this function is a PLT entry, False otherwise :rtype: bool

assign_labels()¶
    

assembly(_comments =False_, _symbolized =True_)¶
    

Get the assembly manifest of the procedure.

Parameters:
    

  * **comments**

  * **symbolized**

Returns:
    

A list of tuples (address, basic block assembly), ordered by basic block addresses

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

instruction_addresses()¶
    

Get all instruction addresses in the binary.

Returns:
    

A list of sorted instruction addresses.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

_class _angr.analyses.reassembler.ProcedureChunk(_project_ , _addr_ , _size_)¶
    

Bases: `Procedure`

Procedure chunk.

__init__(_project_ , _addr_ , _size_)¶
    

Constructor.

Parameters:
    

  * **project**

  * **addr**

  * **size**

Returns:
    

_class _angr.analyses.reassembler.Data(_binary_ , _memory_data =None_, _section =None_, _section_name =None_, _name =None_, _size =None_, _sort =None_, _addr =None_, _initial_content =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_binary_ , _memory_data =None_, _section =None_, _section_name =None_, _name =None_, _size =None_, _sort =None_, _addr =None_, _initial_content =None_)¶
    

_property _content¶
    

shrink(_new_size_)¶
    

Reduce the size of this block

Parameters:
    

**new_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The new size

Returns:
    

None

desymbolize()¶
    

We believe this was a pointer and symbolized it before. Now we want to desymbolize it.

The following actions are performed: \- Reload content from memory \- Mark the sort as ‘unknown’

Returns:
    

None

assign_labels()¶
    

assembly(_comments =False_, _symbolized =True_)¶
    

_class _angr.analyses.reassembler.Relocation(_addr_ , _ref_addr_ , _sort_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_addr_ , _ref_addr_ , _sort_)¶
    

_class _angr.analyses.reassembler.Reassembler(_syntax ='intel'_, _remove_cgc_attachments =True_, _log_relocations =True_)¶
    

Bases: `Analysis`

High-level representation of a binary with a linear representation of all instructions and data regions. After calling “symbolize”, it essentially acts as a binary reassembler.

Tested on CGC, x86 and x86-64 binaries.

Disclaimer: The reassembler is an empirical solution. Don’t be surprised if it does not work on some binaries.

__init__(_syntax ='intel'_, _remove_cgc_attachments =True_, _log_relocations =True_)¶
    

_property _instructions¶
    

Get a list of all instructions in the binary

Returns:
    

A list of (address, instruction)

Return type:
    

[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

_property _relocations¶
    

_property _inserted_asm_before_label¶
    

_property _inserted_asm_after_label¶
    

_property _main_executable_regions¶
    

return:

_property _main_nonexecutable_regions¶
    

return:

section_alignment(_section_name_)¶
    

Get the alignment for the specific section. If the section is not found, 16 is used as default.

Parameters:
    

**section_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The section.

Returns:
    

The alignment in bytes.

Return type:
    

[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

main_executable_regions_contain(_addr_)¶
    

Parameters:
    

**addr**

Returns:
    

main_executable_region_limbos_contain(_addr_)¶
    

Sometimes there exists a pointer that points to a few bytes before the beginning of a section, or a few bytes after the beginning of the section. We take care of that here.

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address to check.

Returns:
    

A 2-tuple of (bool, the closest base address)

Return type:
    

[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

main_nonexecutable_regions_contain(_addr_)¶
    

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address to check.

Returns:
    

True if the address is inside a non-executable region, False otherwise.

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

main_nonexecutable_region_limbos_contain(_addr_ , _tolerance_before =64_, _tolerance_after =64_)¶
    

Sometimes there exists a pointer that points to a few bytes before the beginning of a section, or a few bytes after the beginning of the section. We take care of that here.

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address to check.

Returns:
    

A 2-tuple of (bool, the closest base address)

Return type:
    

[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")

register_instruction_reference(_insn_addr_ , _ref_addr_ , _sort_ , _operand_offset_)¶
    

register_data_reference(_data_addr_ , _ref_addr_)¶
    

add_label(_name_ , _addr_)¶
    

Add a new label to the symbol manager.

Parameters:
    

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of the label.

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the label.

Returns:
    

None

insert_asm(_addr_ , _asm_code_ , _before_label =False_)¶
    

Insert some assembly code at the specific address. There must be an instruction starting at that address.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of insertion

  * **asm_code** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The assembly code to insert

Returns:
    

None

append_procedure(_name_ , _asm_code_)¶
    

Add a new procedure with specific name and assembly code.

Parameters:
    

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The name of the new procedure.

  * **asm_code** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The assembly code of the procedure

Returns:
    

None

append_data(_name_ , _initial_content_ , _size_ , _readonly =False_, _sort ='unknown'_)¶
    

Append a new data entry into the binary with specific name, content, and size.

Parameters:
    

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of the data entry. Will be used as the label.

  * **initial_content** ([_bytes_](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)")) – The initial content of the data entry.

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Size of the data entry.

  * **readonly** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If the data entry belongs to the readonly region.

  * **sort** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Type of the data.

Returns:
    

None

remove_instruction(_ins_addr_)¶
    

Parameters:
    

**ins_addr**

Returns:
    

randomize_procedures()¶
    

Returns:
    

symbolize()¶
    

assembly(_comments =False_, _symbolized =True_)¶
    

remove_cgc_attachments()¶
    

Remove CGC attachments.

Returns:
    

True if CGC attachments are found and removed, False otherwise

Return type:
    

[bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

remove_unnecessary_stuff()¶
    

Remove unnecessary functions and data

Returns:
    

None

remove_unnecessary_stuff_glibc()¶
    

fast_memory_load(_addr_ , _size_ , _data_type_ , _endness ='Iend_LE'_)¶
    

Load memory bytes from loader’s memory backend.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address to begin memory loading.

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Size in bytes.

  * **data_type** – Type of the data.

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Endianness of this memory load.

Returns:
    

Data read out of the memory.

Return type:
    

[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") or [bytes](https://docs.python.org/3/library/stdtypes.html#bytes "\(in Python v3.13\)") or [str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") or None

_class _angr.analyses.congruency_check.CongruencyCheck(_throw =False_)¶
    

Bases: `Analysis`

This is an analysis to ensure that angr executes things identically with different execution backends (i.e., unicorn vs vex).

__init__(_throw =False_)¶
    

Initializes a CongruencyCheck analysis.

Parameters:
    

**throw** – whether to raise an exception if an incongruency is found.

set_state_options(_left_add_options =None_, _left_remove_options =None_, _right_add_options =None_, _right_remove_options =None_)¶
    

Checks that the specified state options result in the same states over the next depth states.

set_states(_left_state_ , _right_state_)¶
    

Checks that the specified paths stay the same over the next depth states.

set_simgr(_simgr_)¶
    

run(_depth =None_)¶
    

Checks that the paths in the specified path group stay the same over the next depth bytes.

The path group should have a “left” and a “right” stash, each with a single path.

compare_path_group(_pg_)¶
    

compare_states(_sl_ , _sr_)¶
    

Compares two states for similarity.

compare_paths(_pl_ , _pr_)¶
    

_class _angr.analyses.static_hooker.StaticHooker(_library_ , _binary =None_)¶
    

Bases: `Analysis`

This analysis works on statically linked binaries - it finds the library functions statically linked into the binary and hooks them with the appropriate simprocedures.

Right now it only works on unstripped binaries, but hey! There’s room to grow!

__init__(_library_ , _binary =None_)¶
    

_class _angr.analyses.binary_optimizer.ConstantPropagation(_constant_ , _constant_assignment_loc_ , _constant_consuming_loc_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_constant_ , _constant_assignment_loc_ , _constant_consuming_loc_)¶
    

_class _angr.analyses.binary_optimizer.RedundantStackVariable(_argument_ , _stack_variable_ , _stack_variable_consuming_locs_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_argument_ , _stack_variable_ , _stack_variable_consuming_locs_)¶
    

_class _angr.analyses.binary_optimizer.RegisterReallocation(_stack_variable_ , _register_variable_ , _stack_variable_sources_ , _stack_variable_consumers_ , _prologue_addr_ , _prologue_size_ , _epilogue_addr_ , _epilogue_size_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_stack_variable_ , _register_variable_ , _stack_variable_sources_ , _stack_variable_consumers_ , _prologue_addr_ , _prologue_size_ , _epilogue_addr_ , _epilogue_size_)¶
    

Constructor.

Parameters:
    

  * **stack_variable** (_SimStackVariable_)

  * **register_variable** (_SimRegisterVariable_)

  * **stack_variable_sources** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)"))

  * **stack_variable_consumers** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)"))

  * **prologue_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **prologue_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **epilogue_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **epilogue_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_class _angr.analyses.binary_optimizer.DeadAssignment(_pv_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

__init__(_pv_)¶
    

Constructor.

Parameters:
    

**pv** (_angr.analyses.ddg.ProgramVariable_) – The assignment to remove.

_class _angr.analyses.binary_optimizer.BinaryOptimizer(_cfg_ , _techniques_)¶
    

Bases: `Analysis`

This is a collection of binary optimization techniques we used in Mechanical Phish during the finals of Cyber Grand Challenge. It focuses on dealing with some serious speed-impacting code constructs, and _sort of_ worked on _some_ CGC binaries compiled with O0. Use this analysis as a reference of how to use data dependency graph and such.

There is no guarantee that BinaryOptimizer will ever work on non-CGC binaries. Feel free to give us PR or MR, but please _do not_ ask for support of non-CGC binaries.

BLOCKS_THRESHOLD _ = 500_¶
    

__init__(_cfg_ , _techniques_)¶
    

optimize()¶
    

project _: Project_¶
    

kb _: KnowledgeBase_¶
    

_class _angr.analyses.callee_cleanup_finder.CalleeCleanupFinder(_starts =None_, _hook_all =False_)¶
    

Bases: `Analysis`

__init__(_starts =None_, _hook_all =False_)¶
    

analyze(_addr_)¶
    

_class _angr.analyses.dominance_frontier.DominanceFrontier(_func_ , _func_graph =None_, _entry =None_, _exception_edges =False_)¶
    

Bases: `Analysis`

Computes the dominance frontier of all nodes in a function graph, and provides an easy-to-use interface for querying the frontier information.

__init__(_func_ , _func_graph =None_, _entry =None_, _exception_edges =False_)¶
    

_class _angr.analyses.init_finder.SimEngineInitFinderVEX(_project_ , _replacements_ , _overlay_ , _pointers_only =False_)¶
    

Bases: `SimEngineNostmtVEX`[[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)"), [`Base`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.base.Base "\(in claripy\)") | [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)"), [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")]

The VEX engine class for InitFinder.

__init__(_project_ , _replacements_ , _overlay_ , _pointers_only =False_)¶
    

_static _is_concrete(_expr_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.analyses.init_finder.InitializationFinder(_func =None_, _func_graph =None_, _block =None_, _max_iterations =1_, _replacements =None_, _overlay =None_, _pointers_only =False_)¶
    

Bases: `ForwardAnalysis`, `Analysis`

Finds possible initializations for global data sections and generate an overlay to be used in other analyses later on.

__init__(_func =None_, _func_graph =None_, _block =None_, _max_iterations =1_, _replacements =None_, _overlay =None_, _pointers_only =False_)¶
    

Constructor

Parameters:
    

  * **order_jobs** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If all jobs should be ordered or not.

  * **allow_merging** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If job merging is allowed.

  * **allow_widening** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If job widening is allowed.

  * **graph_visitor** (_GraphVisitor_ _or_ _None_) – A graph visitor to provide successors.

Returns:
    

None

_class _angr.analyses.xrefs.SimEngineXRefsVEX(_xref_manager_ , _project_ , _replacements =None_)¶
    

Bases: `SimEngineNostmtVEX`[[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)"), [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)"), [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")]

The VEX engine class for XRefs analysis.

__init__(_xref_manager_ , _project_ , _replacements =None_)¶
    

add_xref(_xref_type_ , _from_loc_ , _to_loc_)¶
    

_static _extract_value_if_concrete(_expr_)¶
    

Extract the concrete value from expr if it is a concrete claripy AST.

Parameters:
    

**expr** – A claripy AST.

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

A concrete value or None if nothing concrete can be extracted.

_class _angr.analyses.xrefs.XRefsAnalysis(_func =None_, _func_graph =None_, _block =None_, _max_iterations =1_, _replacements =None_)¶
    

Bases: `ForwardAnalysis`, `Analysis`

XRefsAnalysis recovers in-depth x-refs (cross-references) in disassembly code.

Here is an example:
    
    
    .text:
    000023C8                 LDR     R2, =time_now
    000023CA                 LDR     R3, [R2]
    000023CC                 ADDS    R3, #1
    000023CE                 STR     R3, [R2]
    000023D0                 BX      LR
    
    .bss:
    1FFF36F4 time_now        % 4
    

You will have the following x-refs for time_now:
    
    
    23c8 - offset
    23ca - read access
    23ce - write access
    

__init__(_func =None_, _func_graph =None_, _block =None_, _max_iterations =1_, _replacements =None_)¶
    

Constructor

Parameters:
    

  * **order_jobs** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If all jobs should be ordered or not.

  * **allow_merging** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If job merging is allowed.

  * **allow_widening** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If job widening is allowed.

  * **graph_visitor** (_GraphVisitor_ _or_ _None_) – A graph visitor to provide successors.

Returns:
    

None

_class _angr.analyses.proximity_graph.ProxiNodeTypes¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Node Type Enums

Empty _ = 0_¶
    

String _ = 1_¶
    

Function _ = 2_¶
    

FunctionCall _ = 3_¶
    

Integer _ = 4_¶
    

Unknown _ = 5_¶
    

Variable _ = 6_¶
    

_class _angr.analyses.proximity_graph.BaseProxiNode(_type__ , _ref_at =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Base class for all nodes in a proximity graph.

Parameters:
    

  * **type_** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **ref_at** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

__init__(_type__ , _ref_at =None_)¶
    

Parameters:
    

  * **type_** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **ref_at** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

_class _angr.analyses.proximity_graph.FunctionProxiNode(_func_ , _ref_at =None_)¶
    

Bases: `BaseProxiNode`

Proximity node showing current and expanded function calls in graph.

Parameters:
    

**ref_at** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

__init__(_func_ , _ref_at =None_)¶
    

Parameters:
    

**ref_at** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

_class _angr.analyses.proximity_graph.VariableProxiNode(_addr_ , _name_ , _ref_at =None_)¶
    

Bases: `BaseProxiNode`

Variable arg node

Parameters:
    

**ref_at** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

__init__(_addr_ , _name_ , _ref_at =None_)¶
    

Parameters:
    

**ref_at** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

_class _angr.analyses.proximity_graph.StringProxiNode(_addr_ , _content_ , _ref_at =None_)¶
    

Bases: `BaseProxiNode`

String arg node

Parameters:
    

**ref_at** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

__init__(_addr_ , _content_ , _ref_at =None_)¶
    

Parameters:
    

**ref_at** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

_class _angr.analyses.proximity_graph.CallProxiNode(_callee_ , _ref_at =None_, _args =None_)¶
    

Bases: `BaseProxiNode`

Call node

Parameters:
    

  * **ref_at** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **args** ([_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__BaseProxiNode_ _]__|__None_)

__init__(_callee_ , _ref_at =None_, _args =None_)¶
    

Parameters:
    

  * **ref_at** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

  * **args** ([_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__BaseProxiNode_ _]__|__None_)

_class _angr.analyses.proximity_graph.IntegerProxiNode(_value_ , _ref_at =None_)¶
    

Bases: `BaseProxiNode`

Int arg node

Parameters:
    

  * **value** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **ref_at** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

__init__(_value_ , _ref_at =None_)¶
    

Parameters:
    

  * **value** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **ref_at** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

_class _angr.analyses.proximity_graph.UnknownProxiNode(_dummy_value_)¶
    

Bases: `BaseProxiNode`

Unknown arg node

Parameters:
    

**dummy_value** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

__init__(_dummy_value_)¶
    

Parameters:
    

**dummy_value** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.analyses.proximity_graph.ProximityGraphAnalysis(_func_ , _cfg_model_ , _xrefs_ , _decompilation =None_, _expand_funcs =None_)¶
    

Bases: `Analysis`

Generate a proximity graph.

Parameters:
    

  * **func** (_Function_)

  * **cfg_model** (_CFGModel_)

  * **xrefs** (_XRefManager_)

  * **decompilation** (_Decompiler_ _|__None_)

  * **expand_funcs** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

__init__(_func_ , _cfg_model_ , _xrefs_ , _decompilation =None_, _expand_funcs =None_)¶
    

Parameters:
    

  * **func** (_Function_)

  * **cfg_model** (_CFGModel_)

  * **xrefs** (_XRefManager_)

  * **decompilation** (_Decompiler_ _|__None_)

  * **expand_funcs** ([_set_](https://docs.python.org/3/library/stdtypes.html#set "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

Defines analysis that will generate a dynamic data-dependency graph

_class _angr.analyses.data_dep.data_dependency_analysis.NodalAnnotation(_node_)¶
    

Bases: [`Annotation`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.annotation.Annotation "\(in claripy\)")

Allows a node to be stored as an annotation to a BV in a DefaultMemory instance

Parameters:
    

**node** (_BaseDepNode_)

__init__(_node_)¶
    

Parameters:
    

**node** (_BaseDepNode_)

_property _relocatable _: [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

Can not be relocated in a simplification

_property _eliminatable¶
    

Can not be eliminated in a simplification

_class _angr.analyses.data_dep.data_dependency_analysis.DataDependencyGraphAnalysis(_end_state_ , _start_from =None_, _end_at =None_, _block_addrs =None_)¶
    

Bases: `Analysis`

This is a DYNAMIC data dependency graph that utilizes a given SimState to produce a DDG graph that is accurate to the path the program took during execution.

This analysis utilizes the SimActionData objects present in the provided SimState’s action history to generate the dependency graph.

Parameters:
    

  * **end_state** (_SimState_)

  * **start_from** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **end_at** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **block_addrs** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

__init__(_end_state_ , _start_from =None_, _end_at =None_, _block_addrs =None_)¶
    

Parameters:
    

  * **end_state** (`SimState`) – Simulation state used to extract all SimActionData

  * **start_from** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – An address or None, Specifies where to start generation of DDG

  * **end_at** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – An address or None, Specifies where to end generation of DDG

  * **block_addrs** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_) – List of block addresses that the DDG analysis should be run on

  * **block_addrs**

_property _graph _: DiGraph | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

_property _simplified_graph _: DiGraph | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

_property _sub_graph _: DiGraph | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

get_data_dep(_g_node_ , _include_tmp_nodes_ , _backwards_)¶
    

Return type:
    

`DiGraph` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **g_node** (_BaseDepNode_)

  * **include_tmp_nodes** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **backwards** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

_class _angr.analyses.data_dep.sim_act_location.SimActLocation(_bbl_addr_ , _ins_addr_ , _stmt_idx_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Structure-like class used to bundle the instruction address and statement index of a given SimAction in order to uniquely identify a given SimAction

Parameters:
    

  * **bbl_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_bbl_addr_ , _ins_addr_ , _stmt_idx_)¶
    

Parameters:
    

  * **bbl_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_class _angr.analyses.data_dep.sim_act_location.ParsedInstruction(_ins_addr_ , _min_stmt_idx_ , _max_stmt_idx_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Used by parser to facilitate linking with recent ancestors in an efficient manner

Parameters:
    

  * **ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **min_stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **max_stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_ins_addr_ , _min_stmt_idx_ , _max_stmt_idx_)¶
    

Parameters:
    

  * **ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **min_stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **max_stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_class _angr.analyses.data_dep.dep_nodes.DepNodeTypes¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Enumeration of types of BaseDepNode supported by this analysis

Memory _ = 1_¶
    

Register _ = 2_¶
    

Tmp _ = 3_¶
    

Constant _ = 4_¶
    

_class _angr.analyses.data_dep.dep_nodes.BaseDepNode(_type__ , _sim_act_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Base class for all nodes in a data-dependency graph

Parameters:
    

  * **type_** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **sim_act** (_SimActionData_)

__init__(_type__ , _sim_act_)¶
    

Parameters:
    

  * **type_** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **sim_act** (_SimActionData_)

value_tuple()¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"), [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]

Returns:
    

A tuple containing the node’s value as a BV and as an evaluated integer

_property _ast _: [BV](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")_¶
    

_property _type _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

Getter :return: An integer defined in DepNodeTypes, represents the subclass type of this DepNode.

_class _angr.analyses.data_dep.dep_nodes.ConstantDepNode(_sim_act_ , _value_)¶
    

Bases: `BaseDepNode`

Used to create a DepNode that will hold a constant, numeric value Uniquely identified by its value

Parameters:
    

  * **sim_act** (_SimActionData_)

  * **value** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_sim_act_ , _value_)¶
    

Parameters:
    

  * **sim_act** (_SimActionData_)

  * **value** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_class _angr.analyses.data_dep.dep_nodes.MemDepNode(_sim_act_ , _addr_)¶
    

Bases: `BaseDepNode`

Used to represent SimActions of type MEM

Parameters:
    

  * **sim_act** (_SimActionData_)

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_sim_act_ , _addr_)¶
    

Parameters:
    

  * **sim_act** (_SimActionData_)

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_property _width _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_classmethod _cast_to_mem(_base_dep_node_)¶
    

Casts a BaseDepNode into a MemDepNode

Parameters:
    

**base_dep_node** (_BaseDepNode_)

_class _angr.analyses.data_dep.dep_nodes.VarDepNode(_type__ , _sim_act_ , _reg_ , _arch_name =''_)¶
    

Bases: `BaseDepNode`

Abstract class for representing SimActions of TYPE reg or tmp

Parameters:
    

  * **type_** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **sim_act** (_SimActionData_)

  * **reg** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **arch_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

__init__(_type__ , _sim_act_ , _reg_ , _arch_name =''_)¶
    

Parameters:
    

  * **type_** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **sim_act** (_SimActionData_)

  * **reg** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **arch_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_property _display_name _: [str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")_¶
    

_class _angr.analyses.data_dep.dep_nodes.TmpDepNode(_sim_act_ , _reg_ , _arch_name =''_)¶
    

Bases: `VarDepNode`

Used to represent SimActions of type TMP

Parameters:
    

  * **sim_act** (_SimActionData_)

  * **reg** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **arch_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

__init__(_sim_act_ , _reg_ , _arch_name =''_)¶
    

Parameters:
    

  * **sim_act** (_SimActionData_)

  * **reg** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **arch_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.analyses.data_dep.dep_nodes.RegDepNode(_sim_act_ , _reg_ , _arch_name =''_)¶
    

Bases: `VarDepNode`

Base class for representing SimActions of TYPE reg

Parameters:
    

  * **sim_act** (_SimActionData_)

  * **reg** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **arch_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

__init__(_sim_act_ , _reg_ , _arch_name =''_)¶
    

Parameters:
    

  * **sim_act** (_SimActionData_)

  * **reg** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **arch_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_property _reg_size _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.analyses.data_dep.BaseDepNode(_type__ , _sim_act_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Base class for all nodes in a data-dependency graph

Parameters:
    

  * **type_** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **sim_act** (_SimActionData_)

__init__(_type__ , _sim_act_)¶
    

Parameters:
    

  * **type_** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **sim_act** (_SimActionData_)

value_tuple()¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`BV`](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)"), [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]

Returns:
    

A tuple containing the node’s value as a BV and as an evaluated integer

_property _ast _: [BV](https://docs.angr.io/projects/claripy/en/latest/api.html#claripy.ast.bv.BV "\(in claripy\)")_¶
    

_property _type _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

Getter :return: An integer defined in DepNodeTypes, represents the subclass type of this DepNode.

_class _angr.analyses.data_dep.ConstantDepNode(_sim_act_ , _value_)¶
    

Bases: `BaseDepNode`

Used to create a DepNode that will hold a constant, numeric value Uniquely identified by its value

Parameters:
    

  * **sim_act** (_SimActionData_)

  * **value** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_sim_act_ , _value_)¶
    

Parameters:
    

  * **sim_act** (_SimActionData_)

  * **value** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_class _angr.analyses.data_dep.DataDependencyGraphAnalysis(_end_state_ , _start_from =None_, _end_at =None_, _block_addrs =None_)¶
    

Bases: `Analysis`

This is a DYNAMIC data dependency graph that utilizes a given SimState to produce a DDG graph that is accurate to the path the program took during execution.

This analysis utilizes the SimActionData objects present in the provided SimState’s action history to generate the dependency graph.

Parameters:
    

  * **end_state** (_SimState_)

  * **start_from** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **end_at** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **block_addrs** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

__init__(_end_state_ , _start_from =None_, _end_at =None_, _block_addrs =None_)¶
    

Parameters:
    

  * **end_state** (`SimState`) – Simulation state used to extract all SimActionData

  * **start_from** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – An address or None, Specifies where to start generation of DDG

  * **end_at** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")]) – An address or None, Specifies where to end generation of DDG

  * **block_addrs** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_) – List of block addresses that the DDG analysis should be run on

  * **block_addrs**

_property _graph _: DiGraph | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

_property _simplified_graph _: DiGraph | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

_property _sub_graph _: DiGraph | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

get_data_dep(_g_node_ , _include_tmp_nodes_ , _backwards_)¶
    

Return type:
    

`DiGraph` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **g_node** (_BaseDepNode_)

  * **include_tmp_nodes** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **backwards** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

_class _angr.analyses.data_dep.DepNodeTypes¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Enumeration of types of BaseDepNode supported by this analysis

Memory _ = 1_¶
    

Register _ = 2_¶
    

Tmp _ = 3_¶
    

Constant _ = 4_¶
    

_class _angr.analyses.data_dep.MemDepNode(_sim_act_ , _addr_)¶
    

Bases: `BaseDepNode`

Used to represent SimActions of type MEM

Parameters:
    

  * **sim_act** (_SimActionData_)

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_sim_act_ , _addr_)¶
    

Parameters:
    

  * **sim_act** (_SimActionData_)

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

_property _width _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_classmethod _cast_to_mem(_base_dep_node_)¶
    

Casts a BaseDepNode into a MemDepNode

Parameters:
    

**base_dep_node** (_BaseDepNode_)

_class _angr.analyses.data_dep.RegDepNode(_sim_act_ , _reg_ , _arch_name =''_)¶
    

Bases: `VarDepNode`

Base class for representing SimActions of TYPE reg

Parameters:
    

  * **sim_act** (_SimActionData_)

  * **reg** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **arch_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

__init__(_sim_act_ , _reg_ , _arch_name =''_)¶
    

Parameters:
    

  * **sim_act** (_SimActionData_)

  * **reg** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **arch_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_property _reg_size _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.analyses.data_dep.TmpDepNode(_sim_act_ , _reg_ , _arch_name =''_)¶
    

Bases: `VarDepNode`

Used to represent SimActions of type TMP

Parameters:
    

  * **sim_act** (_SimActionData_)

  * **reg** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **arch_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

__init__(_sim_act_ , _reg_ , _arch_name =''_)¶
    

Parameters:
    

  * **sim_act** (_SimActionData_)

  * **reg** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **arch_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.analyses.data_dep.VarDepNode(_type__ , _sim_act_ , _reg_ , _arch_name =''_)¶
    

Bases: `BaseDepNode`

Abstract class for representing SimActions of TYPE reg or tmp

Parameters:
    

  * **type_** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **sim_act** (_SimActionData_)

  * **reg** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **arch_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

__init__(_type__ , _sim_act_ , _reg_ , _arch_name =''_)¶
    

Parameters:
    

  * **type_** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **sim_act** (_SimActionData_)

  * **reg** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **arch_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_property _display_name _: [str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")_¶
    

_exception _angr.blade.BadJumpkindNotification¶
    

Bases: [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception "\(in Python v3.13\)")

Notifies the caller that the jumpkind is bad (e.g., Ijk_NoDecode)

_class _angr.blade.Blade(_graph_ , _dst_run_ , _dst_stmt_idx_ , _direction ='backward'_, _project =None_, _cfg =None_, _ignore_sp =False_, _ignore_bp =False_, _ignored_regs =None_, _max_level =3_, _base_state =None_, _stop_at_calls =False_, _cross_insn_opt =False_, _max_predecessors =10_, _include_imarks =True_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Blade is a light-weight program slicer that works with networkx DiGraph containing CFGNodes. It is meant to be used in angr for small or on-the-fly analyses.

Parameters:
    

  * **graph** (_networkx.DiGraph_)

  * **dst_run** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **dst_stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **direction** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **ignore_sp** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **ignore_bp** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **max_level** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **stop_at_calls** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **max_predecessors** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **include_imarks** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_graph_ , _dst_run_ , _dst_stmt_idx_ , _direction ='backward'_, _project =None_, _cfg =None_, _ignore_sp =False_, _ignore_bp =False_, _ignored_regs =None_, _max_level =3_, _base_state =None_, _stop_at_calls =False_, _cross_insn_opt =False_, _max_predecessors =10_, _include_imarks =True_)¶
    

Parameters:
    

  * **graph** (`DiGraph`) – A graph representing the control flow graph. Note that it does not take angr.analyses.CFGEmulated or angr.analyses.CFGFast.

  * **dst_run** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – An address specifying the target SimRun.

  * **dst_stmt_idx** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The target statement index. -1 means executing until the last statement.

  * **direction** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – ‘backward’ or ‘forward’ slicing. Forward slicing is not yet supported.

  * **project** (_angr.Project_) – The project instance.

  * **cfg** (_angr.analyses.CFGBase_) – the CFG instance. It will be made mandatory later.

  * **ignore_sp** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether the stack pointer should be ignored in dependency tracking. Any dependency from/to stack pointers will be ignored if this options is True.

  * **ignore_bp** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether the base pointer should be ignored or not.

  * **max_level** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The maximum number of blocks that we trace back for.

  * **stop_at_calls** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Limit slicing within a single function. Do not proceed when encounters a call edge.

  * **include_imarks** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Should IMarks (instruction boundaries) be included in the slice.

  * **max_predecessors** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

Returns:
    

None

_property _slice¶
    

dbg_repr(_arch =None_)¶
    

_class _angr.slicer.SimLightState(_temps =None_, _regs =None_, _stack_offsets =None_, _options =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Represents a program state. Only used in SimSlicer.

__init__(_temps =None_, _regs =None_, _stack_offsets =None_, _options =None_)¶
    

temps¶
    

regs¶
    

stack_offsets¶
    

options¶
    

_class _angr.slicer.SimSlicer(_arch_ , _statements_ , _target_tmps =None_, _target_regs =None_, _target_stack_offsets =None_, _inslice_callback =None_, _inslice_callback_infodict =None_, _include_imarks =True_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A super lightweight intra-IRSB slicing class.

Parameters:
    

**include_imarks** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_arch_ , _statements_ , _target_tmps =None_, _target_regs =None_, _target_stack_offsets =None_, _inslice_callback =None_, _inslice_callback_infodict =None_, _include_imarks =True_)¶
    

Parameters:
    

**include_imarks** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

_class _angr.annocfg.AnnotatedCFG(_project_ , _cfg =None_, _detect_loops =False_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

AnnotatedCFG is a control flow graph with statement whitelists and exit whitelists to describe a slice of the program.

__init__(_project_ , _cfg =None_, _detect_loops =False_)¶
    

Constructor.

Parameters:
    

  * **project** – The angr Project instance

  * **cfg** – Control flow graph.

  * **detect_loops**

from_digraph(_digraph_)¶
    

Initialize this AnnotatedCFG object with a networkx.DiGraph consisting of the following form of nodes:

Tuples like (block address, statement ID)

Those nodes are connected by edges indicating the execution flow.

Parameters:
    

**digraph** (_networkx.DiGraph_) – A networkx.DiGraph object

get_addr(_run_)¶
    

add_block_to_whitelist(_block_)¶
    

add_statements_to_whitelist(_block_ , _stmt_ids_)¶
    

add_exit_to_whitelist(_run_from_ , _run_to_)¶
    

set_last_statement(_block_addr_ , _stmt_id_)¶
    

add_loop(_loop_tuple_)¶
    

A loop tuple contains a series of IRSB addresses that form a loop. Ideally it always starts with the first IRSB that we meet during the execution.

should_take_exit(_addr_from_ , _addr_to_)¶
    

should_execute_statement(_addr_ , _stmt_id_)¶
    

get_run(_addr_)¶
    

get_whitelisted_statements(_addr_)¶
    

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

True if all statements are whitelisted

get_last_statement_index(_addr_)¶
    

Get the statement index of the last statement to execute in the basic block specified by addr.

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the basic block.

Returns:
    

The statement index of the last statement to be executed in the block. Usually if the default exit is taken, it will be the last statement to execute. If the block is not in the slice or we should never take any exit going to this block, None is returned.

Return type:
    

[int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") or None

get_loops()¶
    

get_targets(_source_addr_)¶
    

dbg_repr()¶
    

dbg_print_irsb(_irsb_addr_ , _project =None_)¶
    

Pretty-print an IRSB with whitelist information

keep_path(_path_)¶
    

Given a path, returns True if the path should be kept, False if it should be cut.

merge_points(_path_)¶
    

successor_func(_path_)¶
    

Callback routine that takes in a path, and returns all feasible successors to path group. This callback routine should be passed to the keyword argument “successor_func” of PathGroup.step().

Parameters:
    

**path** – A Path instance.

Returns:
    

A list of all feasible Path successors.

angr.codenode.repr_addr(_addr_)¶
    

_class _angr.codenode.CodeNode(_addr_ , _size_ , _graph =None_, _thumb =False_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_addr_ , _size_ , _graph =None_, _thumb =False_)¶
    

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

addr _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

size _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

thumb¶
    

set_graph(_graph_)¶
    

successors()¶
    

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`CodeNode`]

predecessors()¶
    

is_hook _ = None_¶
    

_class _angr.codenode.BlockNode(_addr_ , _size_ , _bytestr =None_, _** kwargs_)¶
    

Bases: `CodeNode`

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

is_hook _ = False_¶
    

__init__(_addr_ , _size_ , _bytestr =None_, _** kwargs_)¶
    

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

bytestr¶
    

_class _angr.codenode.SootBlockNode(_addr_ , _size_ , _stmts_ , _** kwargs_)¶
    

Bases: `BlockNode`

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_addr_ , _size_ , _stmts_ , _** kwargs_)¶
    

stmts¶
    

_class _angr.codenode.HookNode(_addr_ , _size_ , _sim_procedure_ , _** kwargs_)¶
    

Bases: `CodeNode`

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

is_hook _ = True_¶
    

__init__(_addr_ , _size_ , _sim_procedure_ , _** kwargs_)¶
    

Parameters:
    

**sim_procedure** ([_type_](https://docs.python.org/3/library/functions.html#type "\(in Python v3.13\)")) – the the sim_procedure class

sim_procedure¶
    

_class _angr.codenode.SyscallNode(_addr_ , _size_ , _sim_procedure_ , _** kwargs_)¶
    

Bases: `HookNode`

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

is_hook _ = False_¶
    

sim_procedure¶
    

## SimOS¶

Manage OS-level configuration.

_class _angr.simos.SimCGC(_project_ , _** kwargs_)¶
    

Bases: `SimUserland`

Environment configuration for the CGC DECREE platform

__init__(_project_ , _** kwargs_)¶
    

state_blank(_flag_page =None_, _allocate_stack_page_count =256_, _** kwargs_)¶
    

Parameters:
    

  * **flag_page** – Flag page content, either a string or a list of BV8s

  * **allocate_stack_page_count** – Number of pages to pre-allocate for stack

state_entry(_add_options =None_, _** kwargs_)¶
    

_class _angr.simos.SimJavaVM(_* args_, _** kwargs_)¶
    

Bases: `SimOS`

__init__(_* args_, _** kwargs_)¶
    

state_blank(_addr =None_, _** kwargs_)¶
    

Initialize a blank state.

All parameters are optional.

Parameters:
    

  * **addr** – The execution start address.

  * **initial_prefix**

  * **stack_end** – The end of the stack (i.e., the byte after the last valid stack address).

  * **stack_size** – The number of bytes to allocate for stack space

  * **brk** – The address of the process’ break.

Returns:
    

The initialized SimState.

Any additional arguments will be passed to the SimState constructor

state_entry(_args =None_, _** kwargs_)¶
    

Create an entry state.

Parameters:
    

**args** – List of SootArgument values (optional).

_static _generate_symbolic_cmd_line_arg(_state_)¶
    

Generates a new symbolic cmd line argument string. :return: The string reference.

state_call(_addr_ , _* args_, _** kwargs_)¶
    

Create a native or a Java call state.

Parameters:
    

  * **addr** – Soot or native addr of the invoke target.

  * **args** – List of SootArgument values.

_static _get_default_value_by_type(_type__ , _state_)¶
    

Java specify defaults values for primitive and reference types. This method returns the default value for a given type.

Parameters:
    

  * **type** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of type.

  * **state** (_SimState_) – Current SimState.

Returns:
    

Default value for this type.

_static _cast_primitive(_state_ , _value_ , _to_type_)¶
    

Cast the value of primitive types.

Parameters:
    

  * **value** – Bitvector storing the primitive value.

  * **to_type** – Name of the targeted type.

Returns:
    

Resized value.

_static _init_static_field(_state_ , _field_class_name_ , _field_name_ , _field_type_)¶
    

Initialize the static field with an allocated, but not initialized, object of the given type.

Parameters:
    

  * **state** – State associated to the field.

  * **field_class_name** – Class containing the field.

  * **field_name** – Name of the field.

  * **field_type** – Type of the field and the new object.

_static _get_cmd_line_args(_state_)¶
    

get_addr_of_native_method(_soot_method_)¶
    

Get address of the implementation from a native declared Java function.

Parameters:
    

**soot_method** – Method descriptor of a native declared function.

Returns:
    

CLE address of the given method.

get_native_type(_java_type_)¶
    

Maps the Java type to a SimTypeReg representation of its native counterpart. This type can be used to indicate the (well-defined) size of native JNI types.

Returns:
    

A SymTypeReg with the JNI size of the given type.

_property _native_arch¶
    

Arch of the native simos.

Type:
    

return

get_native_cc()¶
    

Returns:
    

SimCC object for the native simos.

_class _angr.simos.SimLinux(_project_ , _** kwargs_)¶
    

Bases: `SimUserland`

OS-specific configuration for *nix-y OSes.

__init__(_project_ , _** kwargs_)¶
    

configure_project()¶
    

Configure the project to set up global settings (like SimProcedures).

syscall_abi(_state_)¶
    

Optionally, override this function to determine which abi is being used for the state’s current syscall.

state_blank(_fs =None_, _concrete_fs =False_, _chroot =None_, _cwd =None_, _pathsep =b'/'_, _thread_idx =None_, _init_libc =False_, _** kwargs_)¶
    

Initialize a blank state.

All parameters are optional.

Parameters:
    

  * **addr** – The execution start address.

  * **initial_prefix**

  * **stack_end** – The end of the stack (i.e., the byte after the last valid stack address).

  * **stack_size** – The number of bytes to allocate for stack space

  * **brk** – The address of the process’ break.

Returns:
    

The initialized SimState.

Any additional arguments will be passed to the SimState constructor

state_entry(_args =None_, _env =None_, _argc =None_, _** kwargs_)¶
    

set_entry_register_values(_state_)¶
    

state_full_init(_** kwargs_)¶
    

prepare_function_symbol(_symbol_name_ , _basic_addr =None_)¶
    

Prepare the address space with the data necessary to perform relocations pointing to the given symbol.

Returns a 2-tuple. The first item is the address of the function code, the second is the address of the relocation target.

initialize_segment_register_x64(_state_ , _concrete_target_)¶
    

Set the fs register in the angr to the value of the fs register in the concrete process

Parameters:
    

  * **state** – state which will be modified

  * **concrete_target** – concrete target that will be used to read the fs register

Returns:
    

None

initialize_gdt_x86(_state_ , _concrete_target_)¶
    

Create a GDT in the state memory and populate the segment registers. Rehook the vsyscall address using the real value in the concrete process memory

Parameters:
    

  * **state** – state which will be modified

  * **concrete_target** – concrete target that will be used to read the fs register

Returns:
    

get_segment_register_name()¶
    

_class _angr.simos.SimOS(_project_ , _name =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A class describing OS/arch-level configuration.

Parameters:
    

  * **project** (_angr.Project_)

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

__init__(_project_ , _name =None_)¶
    

Parameters:
    

  * **project** (_Project_)

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

name _: [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

configure_project()¶
    

Configure the project to set up global settings (like SimProcedures).

state_blank(_addr =None_, _initial_prefix =None_, _brk =None_, _stack_end =None_, _stack_size =8388608_, _stdin =None_, _thread_idx =None_, _permissions_backer =None_, _** kwargs_)¶
    

Initialize a blank state.

All parameters are optional.

Parameters:
    

  * **addr** – The execution start address.

  * **initial_prefix**

  * **stack_end** – The end of the stack (i.e., the byte after the last valid stack address).

  * **stack_size** – The number of bytes to allocate for stack space

  * **brk** – The address of the process’ break.

Returns:
    

The initialized SimState.

Any additional arguments will be passed to the SimState constructor

state_entry(_** kwargs_)¶
    

state_full_init(_** kwargs_)¶
    

state_call(_addr_ , _* args_, _** kwargs_)¶
    

prepare_call_state(_calling_state_ , _initial_state =None_, _preserve_registers =()_, _preserve_memory =()_)¶
    

This function prepares a state that is executing a call instruction. If given an initial_state, it copies over all of the critical registers to it from the calling_state. Otherwise, it prepares the calling_state for action.

This is mostly used to create minimalistic for CFG generation. Some ABIs, such as MIPS PIE and x86 PIE, require certain information to be maintained in certain registers. For example, for PIE MIPS, this function transfer t9, gp, and ra to the new state.

prepare_function_symbol(_symbol_name_ , _basic_addr =None_)¶
    

Prepare the address space with the data necessary to perform relocations pointing to the given symbol

Returns a 2-tuple. The first item is the address of the function code, the second is the address of the relocation target.

handle_exception(_successors_ , _engine_ , _exception_)¶
    

Perform exception handling. This method will be called when, during execution, a SimException is thrown. Currently, this can only indicate a segfault, but in the future it could indicate any unexpected exceptional behavior that can’t be handled by ordinary control flow.

The method may mutate the provided SimSuccessors object in any way it likes, or re-raise the exception.

Parameters:
    

  * **successors** – The SimSuccessors object currently being executed on

  * **engine** – The engine that was processing this step

  * **exception** – The actual exception object

syscall(_state_ , _allow_unsupported =True_)¶
    

Return type:
    

`SimProcedure` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **state** (_SimState_)

  * **allow_unsupported** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

syscall_abi(_state_)¶
    

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**state** (_SimState_)

syscall_cc(_state_)¶
    

Return type:
    

`SimCCSyscall` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**state** (_SimState_)

is_syscall_addr(_addr_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

syscall_from_addr(_addr_ , _allow_unsupported =True_)¶
    

Return type:
    

`SimProcedure` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

syscall_from_number(_number_ , _allow_unsupported =True_, _abi =None_)¶
    

Return type:
    

`SimProcedure` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

setup_gdt(_state_ , _gdt_)¶
    

Write the GlobalDescriptorTable object in the current state memory

Parameters:
    

  * **state** – state in which to write the GDT

  * **gdt** – GlobalDescriptorTable object

Returns:
    

generate_gdt(_fs_ , _gs_ , _fs_size =4294967295_, _gs_size =4294967295_)¶
    

Generate a GlobalDescriptorTable object and populate it using the value of the gs and fs register

Parameters:
    

  * **fs** – value of the fs segment register

  * **gs** – value of the gs segment register

  * **fs_size** – size of the fs segment register

  * **gs_size** – size of the gs segment register

Returns:
    

gdt a GlobalDescriptorTable object

_class _angr.simos.SimSnimmucNxp(_project_ , _name =None_, _** kwargs_)¶
    

Bases: `SimOS`

This class implements the “OS” for a bare-metal firmware used at an imaginary company.

Parameters:
    

  * **project** (_Project_)

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

__init__(_project_ , _name =None_, _** kwargs_)¶
    

Parameters:
    

**project** (_Project_)

configure_project()¶
    

Configure the project to set up global settings (like SimProcedures).

_class _angr.simos.SimUserland(_project_ , _syscall_library =None_, _syscall_addr_alignment =4_, _** kwargs_)¶
    

Bases: `SimOS`

This is a base class for any SimOS that wants to support syscalls.

It uses the CLE kernel object to provide addresses for syscalls. Syscalls will be emulated as a jump to one of these addresses, where a SimProcedure from the syscall library provided at construction time will be executed.

__init__(_project_ , _syscall_library =None_, _syscall_addr_alignment =4_, _** kwargs_)¶
    

configure_project(_abi_list =None_)¶
    

Configure the project to set up global settings (like SimProcedures).

syscall_cc(_state_)¶
    

Return type:
    

`SimCCSyscall`

syscall(_state_ , _allow_unsupported =True_)¶
    

Given a state, return the procedure corresponding to the current syscall. This procedure will have .syscall_number, .display_name, and .addr set.

Parameters:
    

  * **state** – The state to get the syscall number from

  * **allow_unsupported** – Whether to return a “dummy” sycall instead of raising an unsupported exception

syscall_abi(_state_)¶
    

Optionally, override this function to determine which abi is being used for the state’s current syscall.

is_syscall_addr(_addr_)¶
    

Return whether or not the given address corresponds to a syscall implementation.

syscall_from_addr(_addr_ , _allow_unsupported =True_)¶
    

Get a syscall SimProcedure from an address.

Parameters:
    

  * **addr** – The address to convert to a syscall SimProcedure

  * **allow_unsupported** – Whether to return a dummy procedure for an unsupported syscall instead of raising an exception.

Returns:
    

The SimProcedure for the syscall, or None if the address is not a syscall address.

syscall_from_number(_number_ , _allow_unsupported =True_, _abi =None_)¶
    

Get a syscall SimProcedure from its number.

Parameters:
    

  * **number** – The syscall number

  * **allow_unsupported** – Whether to return a “stub” syscall for unsupported numbers instead of throwing an error

  * **abi** – The name of the abi to use. If None, will assume that the abis have disjoint numbering schemes and pick the right one.

Returns:
    

The SimProcedure for the syscall

_class _angr.simos.SimWindows(_project_)¶
    

Bases: `SimOS`

Environment for the Windows Win32 subsystem. Does not support syscalls currently.

__init__(_project_)¶
    

configure_project()¶
    

Configure the project to set up global settings (like SimProcedures).

_property _is_dump _: [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

state_entry(_args =None_, _env =None_, _argc =None_, _** kwargs_)¶
    

state_blank(_thread_idx =None_, _** kwargs_)¶
    

Initialize a blank state.

All parameters are optional.

Parameters:
    

  * **addr** – The execution start address.

  * **initial_prefix**

  * **stack_end** – The end of the stack (i.e., the byte after the last valid stack address).

  * **stack_size** – The number of bytes to allocate for stack space

  * **brk** – The address of the process’ break.

Returns:
    

The initialized SimState.

Any additional arguments will be passed to the SimState constructor

handle_exception(_successors_ , _engine_ , _exception_)¶
    

Perform exception handling. This method will be called when, during execution, a SimException is thrown. Currently, this can only indicate a segfault, but in the future it could indicate any unexpected exceptional behavior that can’t be handled by ordinary control flow.

The method may mutate the provided SimSuccessors object in any way it likes, or re-raise the exception.

Parameters:
    

  * **successors** – The SimSuccessors object currently being executed on

  * **engine** – The engine that was processing this step

  * **exception** – The actual exception object

syscall(_state_ , _allow_unsupported =True_)¶
    

Given a state, return the procedure corresponding to the current syscall. This procedure will have .syscall_number, .display_name, and .addr set.

Parameters:
    

  * **state** – The state to get the syscall number from

  * **allow_unsupported** – Whether to return a “dummy” sycall instead of raising an unsupported exception

is_syscall_addr(_addr_)¶
    

Return whether or not the given address corresponds to a syscall implementation.

syscall_from_addr(_addr_ , _allow_unsupported =True_)¶
    

Get a syscall SimProcedure from an address.

Parameters:
    

  * **addr** – The address to convert to a syscall SimProcedure

  * **allow_unsupported** – Whether to return a dummy procedure for an unsupported syscall instead of raising an exception.

Returns:
    

The SimProcedure for the syscall, or None if the address is not a syscall address.

initialize_segment_register_x64(_state_ , _concrete_target_)¶
    

Set the gs register in the angr to the value of the fs register in the concrete process

Parameters:
    

  * **state** – state which will be modified

  * **concrete_target** – concrete target that will be used to read the fs register

Returns:
    

None

initialize_gdt_x86(_state_ , _concrete_target_)¶
    

Create a GDT in the state memory and populate the segment registers.

Parameters:
    

  * **state** – state which will be modified

  * **concrete_target** – concrete target that will be used to read the fs register

Returns:
    

the created GlobalDescriptorTable object

get_segment_register_name()¶
    

_class _angr.simos.simos.SimOS(_project_ , _name =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A class describing OS/arch-level configuration.

Parameters:
    

  * **project** (_angr.Project_)

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

__init__(_project_ , _name =None_)¶
    

Parameters:
    

  * **project** (_Project_)

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

name _: [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

configure_project()¶
    

Configure the project to set up global settings (like SimProcedures).

state_blank(_addr =None_, _initial_prefix =None_, _brk =None_, _stack_end =None_, _stack_size =8388608_, _stdin =None_, _thread_idx =None_, _permissions_backer =None_, _** kwargs_)¶
    

Initialize a blank state.

All parameters are optional.

Parameters:
    

  * **addr** – The execution start address.

  * **initial_prefix**

  * **stack_end** – The end of the stack (i.e., the byte after the last valid stack address).

  * **stack_size** – The number of bytes to allocate for stack space

  * **brk** – The address of the process’ break.

Returns:
    

The initialized SimState.

Any additional arguments will be passed to the SimState constructor

state_entry(_** kwargs_)¶
    

state_full_init(_** kwargs_)¶
    

state_call(_addr_ , _* args_, _** kwargs_)¶
    

prepare_call_state(_calling_state_ , _initial_state =None_, _preserve_registers =()_, _preserve_memory =()_)¶
    

This function prepares a state that is executing a call instruction. If given an initial_state, it copies over all of the critical registers to it from the calling_state. Otherwise, it prepares the calling_state for action.

This is mostly used to create minimalistic for CFG generation. Some ABIs, such as MIPS PIE and x86 PIE, require certain information to be maintained in certain registers. For example, for PIE MIPS, this function transfer t9, gp, and ra to the new state.

prepare_function_symbol(_symbol_name_ , _basic_addr =None_)¶
    

Prepare the address space with the data necessary to perform relocations pointing to the given symbol

Returns a 2-tuple. The first item is the address of the function code, the second is the address of the relocation target.

handle_exception(_successors_ , _engine_ , _exception_)¶
    

Perform exception handling. This method will be called when, during execution, a SimException is thrown. Currently, this can only indicate a segfault, but in the future it could indicate any unexpected exceptional behavior that can’t be handled by ordinary control flow.

The method may mutate the provided SimSuccessors object in any way it likes, or re-raise the exception.

Parameters:
    

  * **successors** – The SimSuccessors object currently being executed on

  * **engine** – The engine that was processing this step

  * **exception** – The actual exception object

syscall(_state_ , _allow_unsupported =True_)¶
    

Return type:
    

`SimProcedure` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **state** (_SimState_)

  * **allow_unsupported** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

syscall_abi(_state_)¶
    

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**state** (_SimState_)

syscall_cc(_state_)¶
    

Return type:
    

`SimCCSyscall` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**state** (_SimState_)

is_syscall_addr(_addr_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

syscall_from_addr(_addr_ , _allow_unsupported =True_)¶
    

Return type:
    

`SimProcedure` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

syscall_from_number(_number_ , _allow_unsupported =True_, _abi =None_)¶
    

Return type:
    

`SimProcedure` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

setup_gdt(_state_ , _gdt_)¶
    

Write the GlobalDescriptorTable object in the current state memory

Parameters:
    

  * **state** – state in which to write the GDT

  * **gdt** – GlobalDescriptorTable object

Returns:
    

generate_gdt(_fs_ , _gs_ , _fs_size =4294967295_, _gs_size =4294967295_)¶
    

Generate a GlobalDescriptorTable object and populate it using the value of the gs and fs register

Parameters:
    

  * **fs** – value of the fs segment register

  * **gs** – value of the gs segment register

  * **fs_size** – size of the fs segment register

  * **gs_size** – size of the gs segment register

Returns:
    

gdt a GlobalDescriptorTable object

_class _angr.simos.simos.GlobalDescriptorTable(_addr_ , _limit_ , _table_ , _gdt_sel_ , _cs_sel_ , _ds_sel_ , _es_sel_ , _ss_sel_ , _fs_sel_ , _gs_sel_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

GlobalDescriptorTable object to store the GDT table and the segment registers values

__init__(_addr_ , _limit_ , _table_ , _gdt_sel_ , _cs_sel_ , _ds_sel_ , _es_sel_ , _ss_sel_ , _fs_sel_ , _gs_sel_)¶
    

_class _angr.simos.linux.SimLinux(_project_ , _** kwargs_)¶
    

Bases: `SimUserland`

OS-specific configuration for *nix-y OSes.

__init__(_project_ , _** kwargs_)¶
    

configure_project()¶
    

Configure the project to set up global settings (like SimProcedures).

syscall_abi(_state_)¶
    

Optionally, override this function to determine which abi is being used for the state’s current syscall.

state_blank(_fs =None_, _concrete_fs =False_, _chroot =None_, _cwd =None_, _pathsep =b'/'_, _thread_idx =None_, _init_libc =False_, _** kwargs_)¶
    

Initialize a blank state.

All parameters are optional.

Parameters:
    

  * **addr** – The execution start address.

  * **initial_prefix**

  * **stack_end** – The end of the stack (i.e., the byte after the last valid stack address).

  * **stack_size** – The number of bytes to allocate for stack space

  * **brk** – The address of the process’ break.

Returns:
    

The initialized SimState.

Any additional arguments will be passed to the SimState constructor

state_entry(_args =None_, _env =None_, _argc =None_, _** kwargs_)¶
    

set_entry_register_values(_state_)¶
    

state_full_init(_** kwargs_)¶
    

prepare_function_symbol(_symbol_name_ , _basic_addr =None_)¶
    

Prepare the address space with the data necessary to perform relocations pointing to the given symbol.

Returns a 2-tuple. The first item is the address of the function code, the second is the address of the relocation target.

initialize_segment_register_x64(_state_ , _concrete_target_)¶
    

Set the fs register in the angr to the value of the fs register in the concrete process

Parameters:
    

  * **state** – state which will be modified

  * **concrete_target** – concrete target that will be used to read the fs register

Returns:
    

None

initialize_gdt_x86(_state_ , _concrete_target_)¶
    

Create a GDT in the state memory and populate the segment registers. Rehook the vsyscall address using the real value in the concrete process memory

Parameters:
    

  * **state** – state which will be modified

  * **concrete_target** – concrete target that will be used to read the fs register

Returns:
    

get_segment_register_name()¶
    

_class _angr.simos.cgc.SimCGC(_project_ , _** kwargs_)¶
    

Bases: `SimUserland`

Environment configuration for the CGC DECREE platform

__init__(_project_ , _** kwargs_)¶
    

state_blank(_flag_page =None_, _allocate_stack_page_count =256_, _** kwargs_)¶
    

Parameters:
    

  * **flag_page** – Flag page content, either a string or a list of BV8s

  * **allocate_stack_page_count** – Number of pages to pre-allocate for stack

state_entry(_add_options =None_, _** kwargs_)¶
    

_class _angr.simos.userland.SimUserland(_project_ , _syscall_library =None_, _syscall_addr_alignment =4_, _** kwargs_)¶
    

Bases: `SimOS`

This is a base class for any SimOS that wants to support syscalls.

It uses the CLE kernel object to provide addresses for syscalls. Syscalls will be emulated as a jump to one of these addresses, where a SimProcedure from the syscall library provided at construction time will be executed.

__init__(_project_ , _syscall_library =None_, _syscall_addr_alignment =4_, _** kwargs_)¶
    

configure_project(_abi_list =None_)¶
    

Configure the project to set up global settings (like SimProcedures).

syscall_cc(_state_)¶
    

Return type:
    

`SimCCSyscall`

syscall(_state_ , _allow_unsupported =True_)¶
    

Given a state, return the procedure corresponding to the current syscall. This procedure will have .syscall_number, .display_name, and .addr set.

Parameters:
    

  * **state** – The state to get the syscall number from

  * **allow_unsupported** – Whether to return a “dummy” sycall instead of raising an unsupported exception

syscall_abi(_state_)¶
    

Optionally, override this function to determine which abi is being used for the state’s current syscall.

is_syscall_addr(_addr_)¶
    

Return whether or not the given address corresponds to a syscall implementation.

syscall_from_addr(_addr_ , _allow_unsupported =True_)¶
    

Get a syscall SimProcedure from an address.

Parameters:
    

  * **addr** – The address to convert to a syscall SimProcedure

  * **allow_unsupported** – Whether to return a dummy procedure for an unsupported syscall instead of raising an exception.

Returns:
    

The SimProcedure for the syscall, or None if the address is not a syscall address.

syscall_from_number(_number_ , _allow_unsupported =True_, _abi =None_)¶
    

Get a syscall SimProcedure from its number.

Parameters:
    

  * **number** – The syscall number

  * **allow_unsupported** – Whether to return a “stub” syscall for unsupported numbers instead of throwing an error

  * **abi** – The name of the abi to use. If None, will assume that the abis have disjoint numbering schemes and pick the right one.

Returns:
    

The SimProcedure for the syscall

_class _angr.simos.windows.SecurityCookieInit(_value_)¶
    

Bases: [`Enum`](https://docs.python.org/3/library/enum.html#enum.Enum "\(in Python v3.13\)")

Security cooke initialization value initialization method.

NONE _ = 0_¶
    

RANDOM _ = 1_¶
    

STATIC _ = 2_¶
    

SYMBOLIC _ = 3_¶
    

_class _angr.simos.windows.SimWindows(_project_)¶
    

Bases: `SimOS`

Environment for the Windows Win32 subsystem. Does not support syscalls currently.

__init__(_project_)¶
    

configure_project()¶
    

Configure the project to set up global settings (like SimProcedures).

_property _is_dump _: [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

state_entry(_args =None_, _env =None_, _argc =None_, _** kwargs_)¶
    

state_blank(_thread_idx =None_, _** kwargs_)¶
    

Initialize a blank state.

All parameters are optional.

Parameters:
    

  * **addr** – The execution start address.

  * **initial_prefix**

  * **stack_end** – The end of the stack (i.e., the byte after the last valid stack address).

  * **stack_size** – The number of bytes to allocate for stack space

  * **brk** – The address of the process’ break.

Returns:
    

The initialized SimState.

Any additional arguments will be passed to the SimState constructor

handle_exception(_successors_ , _engine_ , _exception_)¶
    

Perform exception handling. This method will be called when, during execution, a SimException is thrown. Currently, this can only indicate a segfault, but in the future it could indicate any unexpected exceptional behavior that can’t be handled by ordinary control flow.

The method may mutate the provided SimSuccessors object in any way it likes, or re-raise the exception.

Parameters:
    

  * **successors** – The SimSuccessors object currently being executed on

  * **engine** – The engine that was processing this step

  * **exception** – The actual exception object

syscall(_state_ , _allow_unsupported =True_)¶
    

Given a state, return the procedure corresponding to the current syscall. This procedure will have .syscall_number, .display_name, and .addr set.

Parameters:
    

  * **state** – The state to get the syscall number from

  * **allow_unsupported** – Whether to return a “dummy” sycall instead of raising an unsupported exception

is_syscall_addr(_addr_)¶
    

Return whether or not the given address corresponds to a syscall implementation.

syscall_from_addr(_addr_ , _allow_unsupported =True_)¶
    

Get a syscall SimProcedure from an address.

Parameters:
    

  * **addr** – The address to convert to a syscall SimProcedure

  * **allow_unsupported** – Whether to return a dummy procedure for an unsupported syscall instead of raising an exception.

Returns:
    

The SimProcedure for the syscall, or None if the address is not a syscall address.

initialize_segment_register_x64(_state_ , _concrete_target_)¶
    

Set the gs register in the angr to the value of the fs register in the concrete process

Parameters:
    

  * **state** – state which will be modified

  * **concrete_target** – concrete target that will be used to read the fs register

Returns:
    

None

initialize_gdt_x86(_state_ , _concrete_target_)¶
    

Create a GDT in the state memory and populate the segment registers.

Parameters:
    

  * **state** – state which will be modified

  * **concrete_target** – concrete target that will be used to read the fs register

Returns:
    

the created GlobalDescriptorTable object

get_segment_register_name()¶
    

_class _angr.simos.javavm.SimJavaVM(_* args_, _** kwargs_)¶
    

Bases: `SimOS`

__init__(_* args_, _** kwargs_)¶
    

state_blank(_addr =None_, _** kwargs_)¶
    

Initialize a blank state.

All parameters are optional.

Parameters:
    

  * **addr** – The execution start address.

  * **initial_prefix**

  * **stack_end** – The end of the stack (i.e., the byte after the last valid stack address).

  * **stack_size** – The number of bytes to allocate for stack space

  * **brk** – The address of the process’ break.

Returns:
    

The initialized SimState.

Any additional arguments will be passed to the SimState constructor

state_entry(_args =None_, _** kwargs_)¶
    

Create an entry state.

Parameters:
    

**args** – List of SootArgument values (optional).

_static _generate_symbolic_cmd_line_arg(_state_)¶
    

Generates a new symbolic cmd line argument string. :return: The string reference.

state_call(_addr_ , _* args_, _** kwargs_)¶
    

Create a native or a Java call state.

Parameters:
    

  * **addr** – Soot or native addr of the invoke target.

  * **args** – List of SootArgument values.

_static _get_default_value_by_type(_type__ , _state_)¶
    

Java specify defaults values for primitive and reference types. This method returns the default value for a given type.

Parameters:
    

  * **type** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Name of type.

  * **state** (_SimState_) – Current SimState.

Returns:
    

Default value for this type.

_static _cast_primitive(_state_ , _value_ , _to_type_)¶
    

Cast the value of primitive types.

Parameters:
    

  * **value** – Bitvector storing the primitive value.

  * **to_type** – Name of the targeted type.

Returns:
    

Resized value.

_static _init_static_field(_state_ , _field_class_name_ , _field_name_ , _field_type_)¶
    

Initialize the static field with an allocated, but not initialized, object of the given type.

Parameters:
    

  * **state** – State associated to the field.

  * **field_class_name** – Class containing the field.

  * **field_name** – Name of the field.

  * **field_type** – Type of the field and the new object.

_static _get_cmd_line_args(_state_)¶
    

get_addr_of_native_method(_soot_method_)¶
    

Get address of the implementation from a native declared Java function.

Parameters:
    

**soot_method** – Method descriptor of a native declared function.

Returns:
    

CLE address of the given method.

get_native_type(_java_type_)¶
    

Maps the Java type to a SimTypeReg representation of its native counterpart. This type can be used to indicate the (well-defined) size of native JNI types.

Returns:
    

A SymTypeReg with the JNI size of the given type.

_property _native_arch¶
    

Arch of the native simos.

Type:
    

return

get_native_cc()¶
    

Returns:
    

SimCC object for the native simos.

angr.simos.javavm.prepare_native_return_state(_native_state_)¶
    

Hook target for native function call returns.

Recovers and stores the return value from native memory and toggles the state, s.t. execution continues in the Soot engine.

Note: Redirection needed for pickling.

## Function Signature Matching¶

angr.flirt.load_signatures(_path_)¶
    

Recursively load all FLIRT signatures under a specific path.

Parameters:
    

**path** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Location of FLIRT signatures.

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

angr.flirt.build_sig.get_basic_info(_ar_path_)¶
    

Get basic information of the archive file.

Return type:
    

[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"), [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]

Parameters:
    

**ar_path** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

angr.flirt.build_sig.get_unique_strings(_ar_path_)¶
    

For Linux libraries, this method requires ar (from binutils), nm (from binutils), and strings.

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]

Parameters:
    

**ar_path** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

angr.flirt.build_sig.run_pelf(_pelf_path_ , _ar_path_ , _output_path_)¶
    

Parameters:
    

  * **pelf_path** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **ar_path** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **output_path** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

angr.flirt.build_sig.run_sigmake(_sigmake_path_ , _sig_name_ , _pat_path_ , _sig_path_)¶
    

Parameters:
    

  * **sigmake_path** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **sig_name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **pat_path** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **sig_path** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

angr.flirt.build_sig.process_exc_file(_exc_path_)¶
    

We are doing the stupidest thing possible: For each batch of conflicts, we pick the most likely result based on a set of predefined rules.

TODO: Add caller-callee-based de-duplication.

Parameters:
    

**exc_path** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

angr.flirt.build_sig.main()¶
    

## Utils¶

angr.utils.is_pyinstaller()¶
    

Detect if we are currently running as a PyInstaller-packaged program.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

True if we are running as a PyInstaller-packaged program. False if we are running in Python directly (e.g., development mode).

angr.utils.looks_like_sql(_s_)¶
    

Determine if string s looks like an SQL query.

Parameters:
    

**s** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The string to detect.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

True if the string looks like an SQL, False otherwise.

angr.utils.timethis(_func_)¶
    

angr.utils.algo.binary_insert(_lst_ , _elem_ , _key_ , _lo =0_, _hi =None_)¶
    

Insert an element into a sorted list, and keep the list sorted.

The major difference from bisect.bisect_left is that this function supports a key method, so user doesn’t have to create the key array for each insertion.

Parameters:
    

  * **lst** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – The list. Must be pre-ordered.

  * **element** ([_object_](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")) – An element to insert into the list.

  * **key** (_func_) – A method to get the key for each element in the list.

  * **lo** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Lower bound of the search.

  * **hi** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Upper bound of the search.

  * **elem** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

None

angr.utils.constants.is_alignment_mask(_n_)¶
    

_class _angr.utils.cowdict.ChainMapCOW(_* args_, _collapse_threshold =None_)¶
    

Bases: [`ChainMap`](https://docs.python.org/3/library/collections.html#collections.ChainMap "\(in Python v3.13\)")

Implements a copy-on-write version of ChainMap that supports auto-collapsing.

__init__(_* args_, _collapse_threshold =None_)¶
    

Initialize a ChainMap by setting _maps_ to the given mappings. If no mappings are provided, a single empty dictionary is used.

copy()¶
    

New ChainMap or subclass with a new copy of maps[0] and refs to maps[1:]

clean()¶
    

_class _angr.utils.cowdict.DefaultChainMapCOW(_* args_, _default_factory =None_, _collapse_threshold =None_)¶
    

Bases: `ChainMapCOW`

Implements a copy-on-write version of ChainMap with default values that supports auto-collapsing.

__init__(_* args_, _default_factory =None_, _collapse_threshold =None_)¶
    

Initialize a ChainMap by setting _maps_ to the given mappings. If no mappings are provided, a single empty dictionary is used.

clean()¶
    

_class _angr.utils.dynamic_dictlist.DynamicDictList(_max_size =None_, _content =None_)¶
    

Bases: [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "\(in Python v3.13\)")[`VT`]

A list-like container class that internally uses dicts to store values when the number of values is less than the threshold LIST2DICT_THRESHOLD. Keys must be ints.

The default thresholds are determined according to experiments described at <https://github.com/angr/angr/pull/3471#issuecomment-1236515950>.

Parameters:
    

  * **max_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **content** (_DynamicDictList_ _|_[_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__VT_ _]__|_[_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__VT_ _]__|__None_)

__init__(_max_size =None_, _content =None_)¶
    

Parameters:
    

  * **max_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **content** (_DynamicDictList_ _|_[_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,__VT_ _]__|_[_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__VT_ _]__|__None_)

list_content _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`VT`)] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

max_size¶
    

dict_content _: [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"), [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "\(in Python v3.13\)")(`VT`)] | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

real_length()¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

angr.utils.enums_conv.cfg_jumpkind_to_pb(_jk_)¶
    

angr.utils.enums_conv.func_edge_type_to_pb(_jk_)¶
    

angr.utils.enums_conv.cfg_jumpkind_from_pb(_pb_)¶
    

angr.utils.enums_conv.func_edge_type_from_pb(_pb_)¶
    

angr.utils.env.is_pyinstaller()¶
    

Detect if we are currently running as a PyInstaller-packaged program.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

True if we are running as a PyInstaller-packaged program. False if we are running in Python directly (e.g., development mode).

angr.utils.graph.shallow_reverse(_g_)¶
    

Make a shallow copy of a directional graph and reverse the edges. This is a workaround to solve the issue that one cannot easily make a shallow reversed copy of a graph in NetworkX 2, since networkx.reverse(copy=False) now returns a GraphView, and GraphViews are always read-only.

Parameters:
    

**g** (_networkx.DiGraph_) – The graph to reverse.

Return type:
    

`DiGraph`

Returns:
    

A new networkx.DiGraph that has all nodes and all edges of the original graph, with edges reversed.

angr.utils.graph.inverted_idoms(_graph_)¶
    

Invert the given graph and generate the immediate dominator tree on the inverted graph. This is useful for computing post-dominators.

Parameters:
    

**graph** (`DiGraph`) – The graph to invert and generate immediate dominator tree for.

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[`DiGraph`, [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")]

Returns:
    

A tuple of the inverted graph and the immediate dominator tree.

angr.utils.graph.to_acyclic_graph(_graph_ , _node_order =None_, _loop_heads =None_)¶
    

Convert a given DiGraph into an acyclic graph.

Parameters:
    

  * **graph** (`DiGraph`) – The graph to convert.

  * **ordered_nodes** – A list of nodes sorted in a topological order.

  * **loop_heads** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")]) – A list of known loop head nodes.

  * **node_order** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _]__|__None_)

Return type:
    

`DiGraph`

Returns:
    

The converted acyclic graph.

angr.utils.graph.dfs_back_edges(_graph_ , _start_node_)¶
    

Perform an iterative DFS traversal of the graph, returning back edges.

Parameters:
    

  * **graph** – The graph to traverse.

  * **start_node** – The node where to start the traversal.

Returns:
    

An iterator of ‘backward’ edges.

angr.utils.graph.subgraph_between_nodes(_graph_ , _source_ , _frontier_ , _include_frontier =False_)¶
    

For a directed graph, return a subgraph that includes all nodes going from a source node to a target node.

Parameters:
    

  * **graph** (_networkx.DiGraph_) – The directed graph.

  * **source** – The source node.

  * **frontier** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – A collection of target nodes.

  * **include_frontier** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Should nodes in frontier be included in the subgraph.

Returns:
    

A subgraph.

Return type:
    

networkx.DiGraph

angr.utils.graph.dominates(_idom_ , _dominator_node_ , _node_)¶
    

angr.utils.graph.compute_dominance_frontier(_graph_ , _domtree_)¶
    

Compute a dominance frontier based on the given post-dominator tree.

This implementation is based on figure 2 of paper An Efficient Method of Computing Static Single Assignment Form by Ron Cytron, etc.

Parameters:
    

  * **graph** – The graph where we want to compute the dominance frontier.

  * **domtree** – The dominator tree

Returns:
    

A dict of dominance frontier

_class _angr.utils.graph.TemporaryNode(_label_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A temporary node.

Used as the start node and end node in post-dominator tree generation. Also used in some test cases.

__init__(_label_)¶
    

_class _angr.utils.graph.ContainerNode(_obj_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A container node.

Only used in dominator tree generation. We did this so we can set the index property without modifying the original object.

__init__(_obj_)¶
    

index _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

_property _obj¶
    

_class _angr.utils.graph.Dominators(_graph_ , _entry_node_ , _successors_func =None_, _reverse =False_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Describes dominators in a graph.

__init__(_graph_ , _entry_node_ , _successors_func =None_, _reverse =False_)¶
    

dom _: `DiGraph`_¶
    

_class _angr.utils.graph.PostDominators(_graph_ , _entry_node_ , _successors_func =None_)¶
    

Bases: `Dominators`

Describe post-dominators in a graph.

__init__(_graph_ , _entry_node_ , _successors_func =None_)¶
    

_property _post_dom _: DiGraph_¶
    

_class _angr.utils.graph.SCCPlaceholder(_scc_id_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Describes a placeholder for strongly-connected-components in a graph.

__init__(_scc_id_)¶
    

scc_id¶
    

_class _angr.utils.graph.GraphUtils¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A helper class with some static methods and algorithms implemented, that in fact, might take more than just normal CFGs.

_static _find_merge_points(_function_addr_ , _function_endpoints_ , _graph_)¶
    

Given a local transition graph of a function, find all merge points inside, and then perform a quasi-topological sort of those merge points.

A merge point might be one of the following cases: \- two or more paths come together, and ends at the same address. \- end of the current function

Parameters:
    

  * **function_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function.

  * **function_endpoints** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – Endpoints of the function. They typically come from Function.endpoints.

  * **graph** (_networkx.DiGraph_) – A local transition graph of a function. Normally it comes from Function.graph.

Returns:
    

A list of ordered addresses of merge points.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

_static _find_widening_points(_function_addr_ , _function_endpoints_ , _graph_)¶
    

Given a local transition graph of a function, find all widening points inside.

Correctly choosing widening points is very important in order to not lose too much information during static analysis. We mainly consider merge points that has at least one loop back edges coming in as widening points.

Parameters:
    

  * **function_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Address of the function.

  * **function_endpoints** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")) – Endpoints of the function, typically coming from Function.endpoints.

  * **graph** (_networkx.DiGraph_) – A local transition graph of a function, normally Function.graph.

Returns:
    

A list of addresses of widening points.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

_static _dfs_postorder_nodes_deterministic(_graph_ , _source_)¶
    

Parameters:
    

**graph** (_DiGraph_)

_static _reverse_post_order_sort_nodes(_graph_ , _nodes =None_)¶
    

Sort a given set of nodes in reverse post ordering.

Parameters:
    

  * **graph** (_networkx.DiGraph_) – A local transition graph of a function.

  * **nodes** (_iterable_) – A collection of nodes to sort.

Returns:
    

A list of sorted nodes.

Return type:
    

[list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

_static _quasi_topological_sort_nodes(_graph_ , _nodes =None_, _loop_heads =None_, _panic_mode_threshold =3000_)¶
    

Sort a given set of nodes from a graph based on the following rules:

# - if A -> B and not B -> A, then we have A < B # - if A -> B and B -> A, then the ordering is undefined

Following the above rules gives us a quasi-topological sorting of nodes in the graph. It also works for cyclic graphs.

Parameters:
    

  * **graph** (`DiGraph`) – A local transition graph of the function.

  * **nodes** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")]) – A list of nodes to sort. None if you want to sort all nodes inside the graph.

  * **loop_heads** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")]) – A list of nodes that should be treated loop heads.

  * **panic_mode_threshold** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Threshold of nodes in an SCC to begin aggressively removing edges.

Return type:
    

[`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")

Returns:
    

A list of ordered nodes.

_static _loop_nesting_forest(_graph_ , _start_node_)¶
    

Generates the loop-nesting forest for the provided directional graph. This is _not_ the algorithm proposed by Ramalingam.

Parameters:
    

  * **graph** (`DiGraph`) – the graph to generate the loop-nesting forest for.

  * **start_node** – the node to start traversing the graph from.

Return type:
    

[`OrderedDict`](https://docs.python.org/3/library/collections.html#collections.OrderedDict "\(in Python v3.13\)")[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"), `DiGraph`]

Returns:
    

An ordered dict of loop heads to their corresponding loop nodes.

angr.utils.lazy_import.lazy_import(_name_)¶
    

angr.utils.loader.is_pc(_project_ , _ins_addr_ , _addr_)¶
    

Check if the given address is program counter (PC) or not. This function is for handling the case on some bizarre architectures where PC is always the currently executed instruction address plus a constant value.

Parameters:
    

  * **project** (`Project`) – An angr Project instance.

  * **ins_addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address of an instruction. We calculate PC using this instruction address.

  * **addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address to check against.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

True if the given instruction address is the PC, False otherwise.

angr.utils.loader.is_in_readonly_section(_project_ , _addr_)¶
    

Check if the specified address is inside a read-only section.

Parameters:
    

  * **project** (`Project`) – An angr Project instance.

  * **addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address to check.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

True if the given address belongs to a read-only section, False otherwise.

angr.utils.loader.is_in_readonly_segment(_project_ , _addr_)¶
    

Check if the specified address is inside a read-only segment.

Parameters:
    

  * **project** (`Project`) – An angr Project instance.

  * **addr** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – The address to check.

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

Returns:
    

True if the given address belongs to a read-only segment, False otherwise.

angr.utils.library.get_function_name(_s_)¶
    

Get the function name from a C-style function declaration string.

Parameters:
    

**s** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – A C-style function declaration string.

Returns:
    

The function name.

Return type:
    

[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

angr.utils.library.register_kernel_types()¶
    

angr.utils.library.convert_cproto_to_py(_c_decl_)¶
    

Convert a C-style function declaration string to its corresponding SimTypes-based Python representation.

Parameters:
    

**c_decl** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The C-style function declaration string.

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"), `SimTypeFunction`, [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]

Returns:
    

A tuple of the function name, the prototype, and a string representing the SimType-based Python representation.

angr.utils.library.convert_cppproto_to_py(_cpp_decl_ , _with_param_names =False_)¶
    

Pre-process a C++-style function declaration string to its corresponding SimTypes-based Python representation.

Parameters:
    

  * **cpp_decl** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The C++-style function declaration string.

  * **with_param_names** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)"), `SimTypeCppFunction` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)"), [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")]

Returns:
    

A tuple of the function name, the prototype, and a string representing the SimType-based Python representation.

angr.utils.library.parsedcprotos2py(_parsed_cprotos_ , _fd_spots =frozenset({})_, _remove_sys_prefix =False_)¶
    

Parse a list of C function declarations and output to Python code that can be embedded into angr.procedures.definitions.
    
    
    >>> # parse the list of glibc C prototypes and output to a file
    >>> from angr.procedures.definitions import glibc
    >>> with open("glibc_protos", "w") as f: f.write(cprotos2py(glibc._libc_c_decls))
    

Parameters:
    

**parsed_cprotos** ([`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"), `SimTypeFunction`, [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]]) – A list of tuples where each tuple is (function name, parsed C function prototype, the original function declaration).

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

Returns:
    

A Python string.

angr.utils.library.cprotos2py(_cprotos_ , _fd_spots =frozenset({})_, _remove_sys_prefix =False_)¶
    

Parse a list of C function declarations and output to Python code that can be embedded into angr.procedures.definitions.
    
    
    >>> # parse the list of glibc C prototypes and output to a file
    >>> from angr.procedures.definitions import glibc
    >>> with open("glibc_protos", "w") as f: f.write(cprotos2py(glibc._libc_c_decls))
    

Parameters:
    

**cprotos** ([`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]) – A list of C prototype strings.

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

Returns:
    

A Python string.

angr.utils.library.get_cpp_function_name(_demangled_name_)¶
    

Parse a demangled C++ declaration into a function name.

Note that the extracted name may include template instantiation, for example:

> example_func<int>

Parameters:
    

**demangled_name** ([`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The demangled C++ function name.

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

Returns:
    

The qualified function name, excluding return type and parameters.

angr.utils.timing.print_timing_total()¶
    

angr.utils.timing.timethis(_func_)¶
    

angr.utils.formatting.setup_terminal()¶
    

Check if we are running in a TTY. If so, make sure the terminal supports ANSI escape sequences. If not, disable colorized output. Sets global ansi_color_enabled to True if colorized output should be enabled by default.

angr.utils.formatting.ansi_color(_s_ , _color_)¶
    

Colorize string s by wrapping in ANSI escape sequence for given color.

This function does not consider whether escape sequences are functional or not; it is up to the caller to determine if its appropriate. Check global ansi_color_enabled value in this module.

Return type:
    

[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")

Parameters:
    

  * **s** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **color** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

angr.utils.formatting.add_edge_to_buffer(_buf_ , _ref_ , _start_ , _end_ , _formatter =None_, _dashed =False_, _ascii_only =None_)¶
    

Draw an edge by adding Unicode box and arrow glyphs to beginning of each line in a list of lines.

Parameters:
    

  * **buf** ([`Sequence`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]) – Output buffer, used to render formatted edges.

  * **ref** ([`Sequence`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]) – Reference buffer, used to calculate edge depth.

  * **start** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Start line.

  * **end** ([`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – End line, where arrow points.

  * **formatter** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`Callable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)")[[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")], [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]]) – Optional callback function used to format the edge before writing it to output buffer.

  * **dashed** ([`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Render edge line dashed instead of solid.

  * **ascii_only** ([`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)")[[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")]) – Render edge using ASCII characters only. If unspecified, guess by stdout encoding.

Returns:
    

_class _angr.utils.mp.Closure(_f : Callable[..., [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")]_, _args : [list](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[Any]_, _kwargs : [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"), Any]_)¶
    

Bases: [`NamedTuple`](https://docs.python.org/3/library/typing.html#typing.NamedTuple "\(in Python v3.13\)")

A pickle-able lambda; note that f, args, and kwargs must be pickleable

Parameters:
    

  * **f** ([_Callable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)") _[__[__...__]__,__None_ _]_)

  * **args** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]_)

  * **kwargs** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]_)

f _: [`Callable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)")[[`...`](https://docs.python.org/3/library/constants.html#Ellipsis "\(in Python v3.13\)"), [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")]_¶
    

Alias for field number 0

args _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[[`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]_¶
    

Alias for field number 1

kwargs _: [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"), [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")]_¶
    

Alias for field number 2

_class _angr.utils.mp.Initializer(_*_ , __manual =True_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A singleton class with global state used to initialize a multiprocessing.Process

Parameters:
    

**_manual** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

_classmethod _get()¶
    

A wrapper around init since this class is a singleton

Return type:
    

`Initializer`

__init__(_*_ , __manual =True_)¶
    

Parameters:
    

**_manual** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

register(_f_ , _* args_, _** kwargs_)¶
    

A shortcut for adding Closures as initializers

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

  * **f** ([_Callable_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "\(in Python v3.13\)") _[__[__...__]__,__None_ _]_)

  * **args** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

  * **kwargs** ([_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)"))

initialize()¶
    

Initialize a multiprocessing.Process Set the current global initializer to the same state as this initializer, then calls each initializer

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

angr.utils.mp.mp_context()¶
    

## Errors¶

_exception _angr.errors.AngrError¶
    

Bases: [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception "\(in Python v3.13\)")

_exception _angr.errors.AngrRuntimeError¶
    

Bases: [`RuntimeError`](https://docs.python.org/3/library/exceptions.html#RuntimeError "\(in Python v3.13\)")

_exception _angr.errors.AngrValueError¶
    

Bases: `AngrError`, [`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError "\(in Python v3.13\)")

_exception _angr.errors.AngrLifterError¶
    

Bases: `AngrError`

_exception _angr.errors.AngrExitError¶
    

Bases: `AngrError`

_exception _angr.errors.AngrPathError¶
    

Bases: `AngrError`

_exception _angr.errors.AngrVaultError¶
    

Bases: `AngrError`

_exception _angr.errors.PathUnreachableError¶
    

Bases: `AngrPathError`

_exception _angr.errors.SimulationManagerError¶
    

Bases: `AngrError`

_exception _angr.errors.AngrInvalidArgumentError¶
    

Bases: `AngrError`

_exception _angr.errors.AngrSurveyorError¶
    

Bases: `AngrError`

_exception _angr.errors.AngrAnalysisError¶
    

Bases: `AngrError`

_exception _angr.errors.AngrBladeError¶
    

Bases: `AngrError`

_exception _angr.errors.AngrBladeSimProcError¶
    

Bases: `AngrBladeError`

_exception _angr.errors.AngrAnnotatedCFGError¶
    

Bases: `AngrError`

_exception _angr.errors.AngrBackwardSlicingError¶
    

Bases: `AngrError`

_exception _angr.errors.AngrCallableError¶
    

Bases: `AngrSurveyorError`

_exception _angr.errors.AngrCallableMultistateError¶
    

Bases: `AngrCallableError`

_exception _angr.errors.AngrSyscallError¶
    

Bases: `AngrError`

_exception _angr.errors.AngrSimOSError¶
    

Bases: `AngrError`

_exception _angr.errors.AngrAssemblyError¶
    

Bases: `AngrError`

_exception _angr.errors.AngrTypeError¶
    

Bases: `AngrError`, [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "\(in Python v3.13\)")

_exception _angr.errors.AngrMissingTypeError¶
    

Bases: `AngrTypeError`

_exception _angr.errors.AngrIncongruencyError¶
    

Bases: `AngrAnalysisError`

_exception _angr.errors.AngrForwardAnalysisError¶
    

Bases: `AngrError`

_exception _angr.errors.AngrSkipJobNotice¶
    

Bases: `AngrForwardAnalysisError`

_exception _angr.errors.AngrDelayJobNotice¶
    

Bases: `AngrForwardAnalysisError`

_exception _angr.errors.AngrJobMergingFailureNotice¶
    

Bases: `AngrForwardAnalysisError`

_exception _angr.errors.AngrJobWideningFailureNotice¶
    

Bases: `AngrForwardAnalysisError`

_exception _angr.errors.AngrCFGError¶
    

Bases: `AngrError`

_exception _angr.errors.AngrVFGError¶
    

Bases: `AngrError`

_exception _angr.errors.AngrVFGRestartAnalysisNotice¶
    

Bases: `AngrVFGError`

_exception _angr.errors.AngrDataGraphError¶
    

Bases: `AngrAnalysisError`

_exception _angr.errors.AngrDDGError¶
    

Bases: `AngrAnalysisError`

_exception _angr.errors.AngrLoopAnalysisError¶
    

Bases: `AngrAnalysisError`

_exception _angr.errors.AngrExplorationTechniqueError¶
    

Bases: `AngrError`

_exception _angr.errors.AngrExplorerError¶
    

Bases: `AngrExplorationTechniqueError`

_exception _angr.errors.AngrDirectorError¶
    

Bases: `AngrExplorationTechniqueError`

_exception _angr.errors.AngrTracerError¶
    

Bases: `AngrExplorationTechniqueError`

_exception _angr.errors.AngrVariableRecoveryError¶
    

Bases: `AngrAnalysisError`

_exception _angr.errors.AngrDBError¶
    

Bases: `AngrError`

_exception _angr.errors.AngrCorruptDBError¶
    

Bases: `AngrDBError`

_exception _angr.errors.AngrIncompatibleDBError¶
    

Bases: `AngrDBError`

_exception _angr.errors.TracerEnvironmentError¶
    

Bases: `AngrError`

_exception _angr.errors.SimError¶
    

Bases: [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception "\(in Python v3.13\)")

bbl_addr _ = None_¶
    

stmt_idx _ = None_¶
    

ins_addr _ = None_¶
    

executed_instruction_count _ = None_¶
    

guard _ = None_¶
    

record_state(_state_)¶
    

_exception _angr.errors.SimStateError¶
    

Bases: `SimError`

_exception _angr.errors.SimMergeError¶
    

Bases: `SimStateError`

_exception _angr.errors.SimMemoryError¶
    

Bases: `SimStateError`

_exception _angr.errors.SimMemoryMissingError(_missing_addr_ , _missing_size_ , _* args_)¶
    

Bases: `SimMemoryError`

__init__(_missing_addr_ , _missing_size_ , _* args_)¶
    

_exception _angr.errors.SimAbstractMemoryError¶
    

Bases: `SimMemoryError`

_exception _angr.errors.SimRegionMapError¶
    

Bases: `SimMemoryError`

_exception _angr.errors.SimMemoryLimitError¶
    

Bases: `SimMemoryError`

_exception _angr.errors.SimMemoryAddressError¶
    

Bases: `SimMemoryError`

_exception _angr.errors.SimFastMemoryError¶
    

Bases: `SimMemoryError`

_exception _angr.errors.SimEventError¶
    

Bases: `SimStateError`

_exception _angr.errors.SimPosixError¶
    

Bases: `SimStateError`

_exception _angr.errors.SimFilesystemError¶
    

Bases: `SimError`

_exception _angr.errors.SimSymbolicFilesystemError¶
    

Bases: `SimFilesystemError`

_exception _angr.errors.SimFileError¶
    

Bases: `SimMemoryError`, `SimFilesystemError`

_exception _angr.errors.SimHeapError¶
    

Bases: `SimStateError`

_exception _angr.errors.SimUnsupportedError¶
    

Bases: `SimError`

_exception _angr.errors.SimSolverError¶
    

Bases: `SimError`

_exception _angr.errors.SimSolverModeError¶
    

Bases: `SimSolverError`

_exception _angr.errors.SimSolverOptionError¶
    

Bases: `SimSolverError`

_exception _angr.errors.SimValueError¶
    

Bases: `SimSolverError`

_exception _angr.errors.SimUnsatError¶
    

Bases: `SimValueError`

_exception _angr.errors.SimOperationError¶
    

Bases: `SimError`

_exception _angr.errors.UnsupportedIROpError¶
    

Bases: `SimOperationError`, `SimUnsupportedError`

_exception _angr.errors.SimExpressionError¶
    

Bases: `SimError`

_exception _angr.errors.UnsupportedIRExprError¶
    

Bases: `SimExpressionError`, `SimUnsupportedError`

_exception _angr.errors.SimCCallError¶
    

Bases: `SimExpressionError`

_exception _angr.errors.UnsupportedCCallError¶
    

Bases: `SimCCallError`, `SimUnsupportedError`

_exception _angr.errors.SimUninitializedAccessError(_expr_type_ , _expr_)¶
    

Bases: `SimExpressionError`

__init__(_expr_type_ , _expr_)¶
    

_exception _angr.errors.SimStatementError¶
    

Bases: `SimError`

_exception _angr.errors.UnsupportedIRStmtError¶
    

Bases: `SimStatementError`, `SimUnsupportedError`

_exception _angr.errors.UnsupportedDirtyError¶
    

Bases: `UnsupportedIRStmtError`, `SimUnsupportedError`

_exception _angr.errors.SimMissingTempError¶
    

Bases: `SimValueError`, [`IndexError`](https://docs.python.org/3/library/exceptions.html#IndexError "\(in Python v3.13\)")

_exception _angr.errors.SimEngineError¶
    

Bases: `SimError`

_exception _angr.errors.SimIRSBError¶
    

Bases: `SimEngineError`

_exception _angr.errors.SimTranslationError¶
    

Bases: `SimEngineError`

_exception _angr.errors.SimProcedureError¶
    

Bases: `SimEngineError`

_exception _angr.errors.SimProcedureArgumentError¶
    

Bases: `SimProcedureError`

_exception _angr.errors.SimShadowStackError¶
    

Bases: `SimProcedureError`

_exception _angr.errors.SimFastPathError¶
    

Bases: `SimEngineError`

_exception _angr.errors.SimIRSBNoDecodeError¶
    

Bases: `SimIRSBError`

_exception _angr.errors.AngrUnsupportedSyscallError¶
    

Bases: `AngrSyscallError`, `SimProcedureError`, `SimUnsupportedError`

angr.errors.UnsupportedSyscallError¶
    

alias of `AngrUnsupportedSyscallError`

_exception _angr.errors.SimReliftException(_state_)¶
    

Bases: `SimEngineError`

__init__(_state_)¶
    

_exception _angr.errors.SimSlicerError¶
    

Bases: `SimError`

_exception _angr.errors.SimActionError¶
    

Bases: `SimError`

_exception _angr.errors.SimCCError¶
    

Bases: `SimError`

_exception _angr.errors.SimUCManagerError¶
    

Bases: `SimError`

_exception _angr.errors.SimUCManagerAllocationError¶
    

Bases: `SimUCManagerError`

_exception _angr.errors.SimUnicornUnsupport¶
    

Bases: `SimError`

_exception _angr.errors.SimUnicornError¶
    

Bases: `SimError`

_exception _angr.errors.SimUnicornSymbolic¶
    

Bases: `SimError`

_exception _angr.errors.SimEmptyCallStackError¶
    

Bases: `SimError`

_exception _angr.errors.SimStateOptionsError¶
    

Bases: `SimError`

_exception _angr.errors.SimException¶
    

Bases: `SimError`

_exception _angr.errors.SimSegfaultException(_addr_ , _reason_ , _original_addr =None_)¶
    

Bases: `SimException`, `SimMemoryError`

__init__(_addr_ , _reason_ , _original_addr =None_)¶
    

angr.errors.SimSegfaultError¶
    

alias of `SimSegfaultException`

_exception _angr.errors.SimZeroDivisionException¶
    

Bases: `SimException`, `SimOperationError`

_exception _angr.errors.AngrNoPluginError¶
    

Bases: `AngrError`

_exception _angr.errors.SimConcreteMemoryError¶
    

Bases: `AngrError`

_exception _angr.errors.SimConcreteRegisterError¶
    

Bases: `AngrError`

_exception _angr.errors.SimConcreteBreakpointError¶
    

Bases: `AngrError`

_exception _angr.errors.AngrDecompilationError¶
    

Bases: `AngrError`

_exception _angr.errors.UnsupportedNodeTypeError¶
    

Bases: `AngrError`, [`NotImplementedError`](https://docs.python.org/3/library/exceptions.html#NotImplementedError "\(in Python v3.13\)")

## Distributed analysis¶

angr.distributed provides a simple implementation for conducting long-running symbolic-execution-based tasks.

_class _angr.distributed.Server(_project_ , _spill_yard =None_, _db =None_, _max_workers =None_, _max_states =10_, _staging_max =10_, _bucketizer =True_, _recursion_limit =1000_, _worker_exit_callback =None_, _techniques =None_, _add_options =None_, _remove_options =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Server implements the analysis server with a series of control interfaces exposed.

Variables:
    

  * **project** – An instance of angr.Project.

  * **spill_yard** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – A directory to store spilled states.

  * **db** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Path of the database that stores information about spilled states.

  * **max_workers** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Maximum number of workers. Each worker starts a new process.

  * **max_states** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Maximum number of active states for each worker.

  * **staging_max** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Maximum number of inactive states that are kept into memory before spilled onto the disk and potentially be picked up by another worker.

  * **bucketizer** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Use the Bucketizer exploration strategy.

  * **_worker_exit_callback** – A method that will be called upon the exit of each worker.

__init__(_project_ , _spill_yard =None_, _db =None_, _max_workers =None_, _max_states =10_, _staging_max =10_, _bucketizer =True_, _recursion_limit =1000_, _worker_exit_callback =None_, _techniques =None_, _add_options =None_, _remove_options =None_)¶
    

inc_active_workers()¶
    

dec_active_workers()¶
    

stop()¶
    

_property _active_workers¶
    

_property _stopped¶
    

on_worker_exit(_worker_id_ , _stashes_)¶
    

run()¶
    

_class _angr.distributed.server.Server(_project_ , _spill_yard =None_, _db =None_, _max_workers =None_, _max_states =10_, _staging_max =10_, _bucketizer =True_, _recursion_limit =1000_, _worker_exit_callback =None_, _techniques =None_, _add_options =None_, _remove_options =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Server implements the analysis server with a series of control interfaces exposed.

Variables:
    

  * **project** – An instance of angr.Project.

  * **spill_yard** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – A directory to store spilled states.

  * **db** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Path of the database that stores information about spilled states.

  * **max_workers** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Maximum number of workers. Each worker starts a new process.

  * **max_states** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Maximum number of active states for each worker.

  * **staging_max** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")) – Maximum number of inactive states that are kept into memory before spilled onto the disk and potentially be picked up by another worker.

  * **bucketizer** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Use the Bucketizer exploration strategy.

  * **_worker_exit_callback** – A method that will be called upon the exit of each worker.

__init__(_project_ , _spill_yard =None_, _db =None_, _max_workers =None_, _max_states =10_, _staging_max =10_, _bucketizer =True_, _recursion_limit =1000_, _worker_exit_callback =None_, _techniques =None_, _add_options =None_, _remove_options =None_)¶
    

inc_active_workers()¶
    

dec_active_workers()¶
    

stop()¶
    

_property _active_workers¶
    

_property _stopped¶
    

on_worker_exit(_worker_id_ , _stashes_)¶
    

run()¶
    

_class _angr.distributed.worker.BadStatesDropper(_vault_ , _db_)¶
    

Bases: `ExplorationTechnique`

Dumps and drops states that are not “active”.

__init__(_vault_ , _db_)¶
    

step(_simgr_ , _stash ='active'_, _** kwargs_)¶
    

Hook the process of stepping a stash forward. Should call `simgr.step(stash, **kwargs)` in order to do the actual processing.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.distributed.worker.ExplorationStatusNotifier(_server_state_)¶
    

Bases: `ExplorationTechnique`

Force the exploration to stop if the server.stop is True.

Parameters:
    

**server_state** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)"))

__init__(_server_state_)¶
    

Parameters:
    

**server_state** ([_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)"))

step(_simgr_ , _stash ='active'_, _** kwargs_)¶
    

Hook the process of stepping a stash forward. Should call `simgr.step(stash, **kwargs)` in order to do the actual processing.

Parameters:
    

  * **simgr** (_angr.SimulationManager_)

  * **stash** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

_class _angr.distributed.worker.Worker(_worker_id_ , _server_ , _server_state_ , _recursion_limit =None_, _techniques =None_, _add_options =None_, _remove_options =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Worker implements a worker thread/process for conducting a task.

__init__(_worker_id_ , _server_ , _server_state_ , _recursion_limit =None_, _techniques =None_, _add_options =None_, _remove_options =None_)¶
    

start()¶
    

run(_initializer_)¶
    

Parameters:
    

**initializer** (_Initializer_)

## angr Intermediate Language¶

_class _angr.ailment.AILBlockWalker(_stmt_handlers =None_, _expr_handlers =None_, _update_block =True_, _replace_phi_stmt =False_)¶
    

Bases: `AILBlockWalkerBase`

Walks all statements and expressions of an AIL node, and rebuilds expressions, statements, or blocks if needed.

If you need a pure walker without rebuilding, use AILBlockWalkerBase instead.

Variables:
    

  * **update_block** – True if the block should be updated in place, False if a new block should be created and returned as the result of walk().

  * **replace_phi_stmt** – True if you want _handle_Phi be called and vvars potentially replaced; False otherwise. Default to False because in the most majority cases you do not want vvars in a Phi variable be replaced.

Parameters:
    

  * **update_block** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **replace_phi_stmt** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

__init__(_stmt_handlers =None_, _expr_handlers =None_, _update_block =True_, _replace_phi_stmt =False_)¶
    

Parameters:
    

  * **update_block** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **replace_phi_stmt** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

walk(_block_)¶
    

Walk the block and rebuild it if necessary. The block will be rebuilt in-place (by updating statements in the original block when self._update_block is set to True), or a new block will be created and returned.

Parameters:
    

**block** (`Block`) – The block to walk.

Return type:
    

`Block` | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Returns:
    

The new block that is rebuilt, or None if the block is not changed or when self._update_block is set to True.

_class _angr.ailment.AILBlockWalkerBase(_stmt_handlers =None_, _expr_handlers =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Walks all statements and expressions of an AIL node and do nothing.

__init__(_stmt_handlers =None_, _expr_handlers =None_)¶
    

walk(_block_)¶
    

Return type:
    

[`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")

Parameters:
    

**block** (_Block_)

walk_statement(_stmt_ , _block =None_)¶
    

Parameters:
    

  * **stmt** (_Statement_)

  * **block** (_Block_ _|__None_)

walk_expression(_expr_ , _stmt_idx =None_, _stmt =None_, _block =None_)¶
    

Parameters:
    

  * **expr** (_Expression_)

  * **stmt_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **stmt** (_Statement_ _|__None_)

  * **block** (_Block_ _|__None_)

_class _angr.ailment.Assignment(_idx_ , _dst_ , _src_ , _** kwargs_)¶
    

Bases: `Statement`

Assignment statement: expr_a = expr_b

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **dst** (_Atom_)

  * **src** (_Expression_)

__init__(_idx_ , _dst_ , _src_ , _** kwargs_)¶
    

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **dst** (_Atom_)

  * **src** (_Expression_)

dst¶
    

src¶
    

likes(_other_)¶
    

matches(_other_)¶
    

replace(_old_expr_ , _new_expr_)¶
    

Parameters:
    

  * **old_expr** (_Expression_)

  * **new_expr** (_Expression_)

copy()¶
    

Return type:
    

`Assignment`

_class _angr.ailment.BinaryOp(_idx_ , _op_ , _operands_ , _signed =False_, _*_ , _variable =None_, _variable_offset =None_, _bits =None_, _floating_point =False_, _rounding_mode =None_, _vector_count =None_, _vector_size =None_, _** kwargs_)¶
    

Bases: `Op`

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **op** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **operands** (_Sequence_ _[__Expression_ _]_)

  * **signed** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **vector_count** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **vector_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

OPSTR_MAP _ = {'Add': '+', 'AddF': '+', 'AddV': '+', 'And': '&', 'Carry': 'CARRY', 'CmpEQ': '==', 'CmpF': 'CmpF', 'CmpGE': '>=', 'CmpGE (signed)': '>=s', 'CmpGT': '>', 'CmpGT (signed)': '>s', 'CmpLE': '<=', 'CmpLE (signed)': '<=s', 'CmpLT': '<', 'CmpLT (signed)': '<s', 'CmpNE': '!=', 'Concat': 'CONCAT', 'Div': '/', 'DivF': '/', 'LogicalAnd': '&&', 'LogicalOr': '||', 'Mod': '%', 'Mul': '*', 'MulF': '*', 'MulV': '*', 'Or': '|', 'Rol': 'ROL', 'Ror': 'ROR', 'SBorrow': 'SBORROW', 'SCarry': 'SCARRY', 'Sar': '>>a', 'Shl': '<<', 'Shr': '>>', 'Sub': '-', 'SubF': '-', 'Xor': '^'}_¶
    

COMPARISON_NEGATION _ = {'CmpEQ': 'CmpNE', 'CmpGE': 'CmpLT', 'CmpGT': 'CmpLE', 'CmpLE': 'CmpGT', 'CmpLT': 'CmpGE', 'CmpNE': 'CmpEQ'}_¶
    

__init__(_idx_ , _op_ , _operands_ , _signed =False_, _*_ , _variable =None_, _variable_offset =None_, _bits =None_, _floating_point =False_, _rounding_mode =None_, _vector_count =None_, _vector_size =None_, _** kwargs_)¶
    

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **op** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **operands** ([_Sequence_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence "\(in Python v3.13\)") _[__Expression_ _]_)

  * **signed** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **vector_count** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **vector_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

operands¶
    

signed¶
    

variable¶
    

variable_offset¶
    

floating_point¶
    

rounding_mode _: [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

vector_count¶
    

vector_size¶
    

likes(_other_)¶
    

matches(_other_)¶
    

has_atom(_atom_ , _identity =True_)¶
    

replace(_old_expr_ , _new_expr_)¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"), `BinaryOp`]

Parameters:
    

  * **old_expr** (_Expression_)

  * **new_expr** (_Expression_)

_property _verbose_op¶
    

_property _size¶
    

copy()¶
    

Return type:
    

`BinaryOp`

_class _angr.ailment.Block(_addr_ , _original_size_ , _statements =None_, _idx =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Describes an AIL block.

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_addr_ , _original_size_ , _statements =None_, _idx =None_)¶
    

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

addr¶
    

original_size¶
    

statements _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`Statement`]_¶
    

idx¶
    

copy(_statements =None_)¶
    

dbg_repr(_indent =0_)¶
    

likes(_other_)¶
    

clear_hash()¶
    

_class _angr.ailment.Const(_idx_ , _variable_ , _value_ , _bits_ , _** kwargs_)¶
    

Bases: `Atom`

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **value** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_float_](https://docs.python.org/3/library/functions.html#float "\(in Python v3.13\)"))

  * **bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_idx_ , _variable_ , _value_ , _bits_ , _** kwargs_)¶
    

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **value** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_float_](https://docs.python.org/3/library/functions.html#float "\(in Python v3.13\)"))

  * **bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

value¶
    

_property _value_int _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_property _value_float _: [float](https://docs.python.org/3/library/functions.html#float "\(in Python v3.13\)")_¶
    

_property _size¶
    

likes(_other_)¶
    

matches(_other_)¶
    

_property _sign_bit¶
    

copy()¶
    

Return type:
    

`Const`

_property _is_int _: [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

_class _angr.ailment.Expression(_* args_, _** kwargs_)¶
    

Bases: `TaggedObject`

The base class of all AIL expressions.

bits _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

__init__(_idx_ , _depth_ , _** kwargs_)¶
    

depth¶
    

has_atom(_atom_ , _identity =True_)¶
    

_abstract _likes(_other_)¶
    

_abstract _matches(_other_)¶
    

replace(_old_expr_ , _new_expr_)¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"), `Self`]

Parameters:
    

  * **old_expr** (_Expression_)

  * **new_expr** (_Expression_)

_class _angr.ailment.IRSBConverter¶
    

Bases: `Converter`

_static _convert(_irsb_ , _manager_)¶
    

Convert the given IRSB to an AIL block

Parameters:
    

  * **irsb** – The IRSB to convert

  * **manager** – The manager to use

Returns:
    

Returns the converted block

_class _angr.ailment.Manager(_name =None_, _arch =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Parameters:
    

**name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

__init__(_name =None_, _arch =None_)¶
    

Parameters:
    

**name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

next_atom()¶
    

reset()¶
    

_property _ins_addr _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

_class _angr.ailment.PCodeIRSBConverter(_irsb_ , _manager_)¶
    

Bases: `Converter`

Converts a p-code IRSB to an AIL block

Parameters:
    

  * **irsb** (_IRSB_)

  * **manager** (_Manager_)

_static _convert(_irsb_ , _manager_)¶
    

Convert the given IRSB to an AIL block

Parameters:
    

  * **irsb** (`IRSB`) – IRSB to convert

  * **manager** (`Manager`) – Manager to use

Returns:
    

Converted block

__init__(_irsb_ , _manager_)¶
    

Parameters:
    

  * **irsb** (_IRSB_)

  * **manager** (_Manager_)

_class _angr.ailment.Register(_idx_ , _variable_ , _reg_offset_ , _bits_ , _** kwargs_)¶
    

Bases: `Atom`

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **reg_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_idx_ , _variable_ , _reg_offset_ , _bits_ , _** kwargs_)¶
    

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **reg_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

reg_offset¶
    

_property _size¶
    

likes(_other_)¶
    

matches(_other_)¶
    

copy()¶
    

Return type:
    

`Register`

_class _angr.ailment.Statement(_idx_ , _** kwargs_)¶
    

Bases: `TaggedObject`, [`ABC`](https://docs.python.org/3/library/abc.html#abc.ABC "\(in Python v3.13\)")

The base class of all AIL statements.

_abstract _replace(_old_expr_ , _new_expr_)¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"), `Self`]

Parameters:
    

  * **old_expr** (_Expression_)

  * **new_expr** (_Expression_)

eq(_expr0_ , _expr1_)¶
    

_abstract _likes(_other_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_abstract _matches(_other_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.ailment.Tmp(_idx_ , _variable_ , _tmp_idx_ , _bits_ , _** kwargs_)¶
    

Bases: `Atom`

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **tmp_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_idx_ , _variable_ , _tmp_idx_ , _bits_ , _** kwargs_)¶
    

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **tmp_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

tmp_idx¶
    

_property _size¶
    

likes(_other_)¶
    

matches(_other_)¶
    

copy()¶
    

Return type:
    

`Tmp`

_class _angr.ailment.UnaryOp(_idx_ , _op_ , _operand_ , _variable =None_, _variable_offset =None_, _bits =None_, _** kwargs_)¶
    

Bases: `Op`

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **op** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **operand** (_Expression_)

  * **variable_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_idx_ , _op_ , _operand_ , _variable =None_, _variable_offset =None_, _bits =None_, _** kwargs_)¶
    

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **op** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **operand** (_Expression_)

  * **variable_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

operand¶
    

variable¶
    

variable_offset¶
    

likes(_other_)¶
    

matches(_other_)¶
    

replace(_old_expr_ , _new_expr_)¶
    

_property _operands¶
    

_property _size¶
    

copy()¶
    

Return type:
    

`UnaryOp`

has_atom(_atom_ , _identity =True_)¶
    

_class _angr.ailment.VEXIRSBConverter¶
    

Bases: `Converter`

_static _convert(_irsb_ , _manager_)¶
    

Parameters:
    

  * **irsb**

  * **manager**

Returns:
    

_exception _angr.ailment.converter_common.SkipConversionNotice¶
    

Bases: [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception "\(in Python v3.13\)")

_class _angr.ailment.converter_common.Converter¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

_static _convert(_thing_)¶
    

_class _angr.ailment.converter_pcode.PCodeIRSBConverter(_irsb_ , _manager_)¶
    

Bases: `Converter`

Converts a p-code IRSB to an AIL block

Parameters:
    

  * **irsb** (_IRSB_)

  * **manager** (_Manager_)

_static _convert(_irsb_ , _manager_)¶
    

Convert the given IRSB to an AIL block

Parameters:
    

  * **irsb** (`IRSB`) – IRSB to convert

  * **manager** (`Manager`) – Manager to use

Returns:
    

Converted block

__init__(_irsb_ , _manager_)¶
    

Parameters:
    

  * **irsb** (_IRSB_)

  * **manager** (_Manager_)

_class _angr.ailment.converter_vex.VEXExprConverter¶
    

Bases: `Converter`

_static _simop_from_vexop(_vex_op_)¶
    

_static _generic_name_from_vex_op(_vex_op_)¶
    

_static _convert(_expr_ , _manager_)¶
    

Parameters:
    

**expr**

Returns:
    

_static _convert_list(_exprs_ , _manager_)¶
    

_static _register(_offset_ , _bits_ , _manager_)¶
    

_static _tmp(_tmp_idx_ , _bits_ , _manager_)¶
    

_static _RdTmp(_expr_ , _manager_)¶
    

_static _Get(_expr_ , _manager_)¶
    

_static _Load(_expr_ , _manager_)¶
    

_static _Unop(_expr_ , _manager_)¶
    

_static _Binop(_expr_ , _manager_)¶
    

_static _Triop(_expr_ , _manager_)¶
    

_static _Const(_expr_ , _manager_)¶
    

_static _const_n(_expr_ , _manager_)¶
    

_static _ITE(_expr_ , _manager_)¶
    

_static _CCall(_expr_ , _manager_)¶
    

Parameters:
    

**expr** ([_CCall_](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.expr.CCall "\(in pyvex\)"))

_class _angr.ailment.converter_vex.VEXStmtConverter¶
    

Bases: `Converter`

_static _convert(_idx_ , _stmt_ , _manager_)¶
    

Parameters:
    

  * **idx**

  * **stmt**

  * **manager**

Returns:
    

_static _WrTmp(_idx_ , _stmt_ , _manager_)¶
    

_static _Put(_idx_ , _stmt_ , _manager_)¶
    

_static _Store(_idx_ , _stmt_ , _manager_)¶
    

_static _Exit(_idx_ , _stmt_ , _manager_)¶
    

_static _LoadG(_idx_ , _stmt_ , _manager_)¶
    

Parameters:
    

**stmt** ([_LoadG_](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.stmt.LoadG "\(in pyvex\)"))

_static _StoreG(_idx_ , _stmt_ , _manager_)¶
    

Parameters:
    

**stmt** ([_StoreG_](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.stmt.StoreG "\(in pyvex\)"))

_static _CAS(_idx_ , _stmt_ , _manager_)¶
    

Parameters:
    

**stmt** ([_CAS_](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.stmt.CAS "\(in pyvex\)"))

_static _Dirty(_idx_ , _stmt_ , _manager_)¶
    

Parameters:
    

**stmt** ([_Dirty_](https://docs.angr.io/projects/pyvex/en/latest/api.html#pyvex.stmt.Dirty "\(in pyvex\)"))

_class _angr.ailment.converter_vex.VEXIRSBConverter¶
    

Bases: `Converter`

_static _convert(_irsb_ , _manager_)¶
    

Parameters:
    

  * **irsb**

  * **manager**

Returns:
    

_class _angr.ailment.expression.Expression(_* args_, _** kwargs_)¶
    

Bases: `TaggedObject`

The base class of all AIL expressions.

bits _: [`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

__init__(_idx_ , _depth_ , _** kwargs_)¶
    

depth¶
    

has_atom(_atom_ , _identity =True_)¶
    

_abstract _likes(_other_)¶
    

_abstract _matches(_other_)¶
    

replace(_old_expr_ , _new_expr_)¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"), `Self`]

Parameters:
    

  * **old_expr** (_Expression_)

  * **new_expr** (_Expression_)

_class _angr.ailment.expression.Atom(_idx_ , _variable =None_, _variable_offset =0_, _** kwargs_)¶
    

Bases: `Expression`

Parameters:
    

**idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_idx_ , _variable =None_, _variable_offset =0_, _** kwargs_)¶
    

Parameters:
    

**idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

variable¶
    

variable_offset¶
    

copy()¶
    

Return type:
    

`Self`

_class _angr.ailment.expression.Const(_idx_ , _variable_ , _value_ , _bits_ , _** kwargs_)¶
    

Bases: `Atom`

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **value** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_float_](https://docs.python.org/3/library/functions.html#float "\(in Python v3.13\)"))

  * **bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_idx_ , _variable_ , _value_ , _bits_ , _** kwargs_)¶
    

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **value** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_float_](https://docs.python.org/3/library/functions.html#float "\(in Python v3.13\)"))

  * **bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

value¶
    

_property _value_int _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_property _value_float _: [float](https://docs.python.org/3/library/functions.html#float "\(in Python v3.13\)")_¶
    

_property _size¶
    

likes(_other_)¶
    

matches(_other_)¶
    

_property _sign_bit¶
    

copy()¶
    

Return type:
    

`Const`

_property _is_int _: [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

_class _angr.ailment.expression.Tmp(_idx_ , _variable_ , _tmp_idx_ , _bits_ , _** kwargs_)¶
    

Bases: `Atom`

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **tmp_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_idx_ , _variable_ , _tmp_idx_ , _bits_ , _** kwargs_)¶
    

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **tmp_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

tmp_idx¶
    

_property _size¶
    

likes(_other_)¶
    

matches(_other_)¶
    

copy()¶
    

Return type:
    

`Tmp`

_class _angr.ailment.expression.Register(_idx_ , _variable_ , _reg_offset_ , _bits_ , _** kwargs_)¶
    

Bases: `Atom`

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **reg_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_idx_ , _variable_ , _reg_offset_ , _bits_ , _** kwargs_)¶
    

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **reg_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

reg_offset¶
    

_property _size¶
    

likes(_other_)¶
    

matches(_other_)¶
    

copy()¶
    

Return type:
    

`Register`

_class _angr.ailment.expression.VirtualVariableCategory(_value_)¶
    

Bases: [`IntEnum`](https://docs.python.org/3/library/enum.html#enum.IntEnum "\(in Python v3.13\)")

An enumeration.

REGISTER _ = 0_¶
    

STACK _ = 1_¶
    

MEMORY _ = 2_¶
    

PARAMETER _ = 3_¶
    

TMP _ = 4_¶
    

UNKNOWN _ = 5_¶
    

_class _angr.ailment.expression.VirtualVariable(_idx_ , _varid_ , _bits_ , _category_ , _oident =None_, _** kwargs_)¶
    

Bases: `Atom`

Parameters:
    

  * **varid** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **category** (_VirtualVariableCategory_)

  * **oident** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _|__None_)

__init__(_idx_ , _varid_ , _bits_ , _category_ , _oident =None_, _** kwargs_)¶
    

Parameters:
    

  * **varid** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **category** (_VirtualVariableCategory_)

  * **oident** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _|__None_)

varid¶
    

category¶
    

oident¶
    

_property _size¶
    

_property _was_reg _: [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

_property _was_stack _: [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

_property _was_parameter _: [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

_property _was_tmp _: [bool](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")_¶
    

_property _reg_offset _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_property _stack_offset _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_property _tmp_idx _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

_property _parameter_category _: VirtualVariableCategory | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

_property _parameter_reg_offset _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

_property _parameter_stack_offset _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

likes(_other_)¶
    

matches(_other_)¶
    

copy()¶
    

Return type:
    

`VirtualVariable`

_class _angr.ailment.expression.Phi(_idx_ , _bits_ , _src_and_vvars_ , _** kwargs_)¶
    

Bases: `Atom`

Parameters:
    

  * **bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **src_and_vvars** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_ _]__,__VirtualVariable_ _|__None_ _]__]_)

__init__(_idx_ , _bits_ , _src_and_vvars_ , _** kwargs_)¶
    

Parameters:
    

**src_and_vvars** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _,_[_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_ _]__,__VirtualVariable_ _|__None_ _]__]_)

src_and_vvars¶
    

_property _size _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_property _op _: [str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")_¶
    

_property _verbose_op _: [str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")_¶
    

likes(_other_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

matches(_other_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

copy()¶
    

Return type:
    

`Phi`

replace(_old_expr_ , _new_expr_)¶
    

_class _angr.ailment.expression.Op(_* args_, _** kwargs_)¶
    

Bases: `Expression`

__init__(_idx_ , _depth_ , _op_ , _** kwargs_)¶
    

op¶
    

_property _verbose_op¶
    

_class _angr.ailment.expression.UnaryOp(_idx_ , _op_ , _operand_ , _variable =None_, _variable_offset =None_, _bits =None_, _** kwargs_)¶
    

Bases: `Op`

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **op** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **operand** (_Expression_)

  * **variable_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_idx_ , _op_ , _operand_ , _variable =None_, _variable_offset =None_, _bits =None_, _** kwargs_)¶
    

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **op** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **operand** (_Expression_)

  * **variable_offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

operand¶
    

variable¶
    

variable_offset¶
    

likes(_other_)¶
    

matches(_other_)¶
    

replace(_old_expr_ , _new_expr_)¶
    

_property _operands¶
    

_property _size¶
    

copy()¶
    

Return type:
    

`UnaryOp`

has_atom(_atom_ , _identity =True_)¶
    

_class _angr.ailment.expression.ConvertType(_value_)¶
    

Bases: [`Enum`](https://docs.python.org/3/library/enum.html#enum.Enum "\(in Python v3.13\)")

An enumeration.

TYPE_INT _ = 0_¶
    

TYPE_FP _ = 1_¶
    

_class _angr.ailment.expression.Convert(_idx_ , _from_bits_ , _to_bits_ , _is_signed_ , _operand_ , _from_type =ConvertType.TYPE_INT_, _to_type =ConvertType.TYPE_INT_, _rounding_mode =None_, _** kwargs_)¶
    

Bases: `UnaryOp`

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **from_bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **to_bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **is_signed** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **operand** (_Expression_)

  * **from_type** (_ConvertType_)

  * **to_type** (_ConvertType_)

TYPE_INT _ = 0_¶
    

TYPE_FP _ = 1_¶
    

__init__(_idx_ , _from_bits_ , _to_bits_ , _is_signed_ , _operand_ , _from_type =ConvertType.TYPE_INT_, _to_type =ConvertType.TYPE_INT_, _rounding_mode =None_, _** kwargs_)¶
    

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **from_bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **to_bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **is_signed** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **operand** (_Expression_)

  * **from_type** (_ConvertType_)

  * **to_type** (_ConvertType_)

from_bits¶
    

to_bits¶
    

is_signed¶
    

from_type¶
    

to_type¶
    

rounding_mode¶
    

likes(_other_)¶
    

matches(_other_)¶
    

replace(_old_expr_ , _new_expr_)¶
    

copy()¶
    

Return type:
    

`Convert`

_class _angr.ailment.expression.Reinterpret(_idx_ , _from_bits_ , _from_type_ , _to_bits_ , _to_type_ , _operand_ , _** kwargs_)¶
    

Bases: `UnaryOp`

Parameters:
    

  * **from_bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **from_type** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **to_bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **to_type** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

__init__(_idx_ , _from_bits_ , _from_type_ , _to_bits_ , _to_type_ , _operand_ , _** kwargs_)¶
    

Parameters:
    

  * **from_bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **from_type** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **to_bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **to_type** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

from_bits¶
    

from_type¶
    

to_bits¶
    

to_type¶
    

likes(_other_)¶
    

matches(_other_)¶
    

replace(_old_expr_ , _new_expr_)¶
    

copy()¶
    

Return type:
    

`Reinterpret`

_class _angr.ailment.expression.BinaryOp(_idx_ , _op_ , _operands_ , _signed =False_, _*_ , _variable =None_, _variable_offset =None_, _bits =None_, _floating_point =False_, _rounding_mode =None_, _vector_count =None_, _vector_size =None_, _** kwargs_)¶
    

Bases: `Op`

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **op** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **operands** (_Sequence_ _[__Expression_ _]_)

  * **signed** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **rounding_mode** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **vector_count** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **vector_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

OPSTR_MAP _ = {'Add': '+', 'AddF': '+', 'AddV': '+', 'And': '&', 'Carry': 'CARRY', 'CmpEQ': '==', 'CmpF': 'CmpF', 'CmpGE': '>=', 'CmpGE (signed)': '>=s', 'CmpGT': '>', 'CmpGT (signed)': '>s', 'CmpLE': '<=', 'CmpLE (signed)': '<=s', 'CmpLT': '<', 'CmpLT (signed)': '<s', 'CmpNE': '!=', 'Concat': 'CONCAT', 'Div': '/', 'DivF': '/', 'LogicalAnd': '&&', 'LogicalOr': '||', 'Mod': '%', 'Mul': '*', 'MulF': '*', 'MulV': '*', 'Or': '|', 'Rol': 'ROL', 'Ror': 'ROR', 'SBorrow': 'SBORROW', 'SCarry': 'SCARRY', 'Sar': '>>a', 'Shl': '<<', 'Shr': '>>', 'Sub': '-', 'SubF': '-', 'Xor': '^'}_¶
    

COMPARISON_NEGATION _ = {'CmpEQ': 'CmpNE', 'CmpGE': 'CmpLT', 'CmpGT': 'CmpLE', 'CmpLE': 'CmpGT', 'CmpLT': 'CmpGE', 'CmpNE': 'CmpEQ'}_¶
    

__init__(_idx_ , _op_ , _operands_ , _signed =False_, _*_ , _variable =None_, _variable_offset =None_, _bits =None_, _floating_point =False_, _rounding_mode =None_, _vector_count =None_, _vector_size =None_, _** kwargs_)¶
    

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **op** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **operands** ([_Sequence_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence "\(in Python v3.13\)") _[__Expression_ _]_)

  * **signed** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"))

  * **vector_count** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **vector_size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

operands¶
    

signed¶
    

variable¶
    

variable_offset¶
    

floating_point¶
    

rounding_mode _: [`str`](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") | [`None`](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

vector_count¶
    

vector_size¶
    

likes(_other_)¶
    

matches(_other_)¶
    

has_atom(_atom_ , _identity =True_)¶
    

replace(_old_expr_ , _new_expr_)¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"), `BinaryOp`]

Parameters:
    

  * **old_expr** (_Expression_)

  * **new_expr** (_Expression_)

_property _verbose_op¶
    

_property _size¶
    

copy()¶
    

Return type:
    

`BinaryOp`

_class _angr.ailment.expression.Load(_idx_ , _addr_ , _size_ , _endness_ , _variable =None_, _variable_offset =None_, _guard =None_, _alt =None_, _** kwargs_)¶
    

Bases: `Expression`

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **addr** (_Expression_)

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

__init__(_idx_ , _addr_ , _size_ , _endness_ , _variable =None_, _variable_offset =None_, _guard =None_, _alt =None_, _** kwargs_)¶
    

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **addr** (_Expression_)

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

addr¶
    

size¶
    

endness¶
    

guard¶
    

alt¶
    

variable¶
    

variable_offset¶
    

has_atom(_atom_ , _identity =True_)¶
    

replace(_old_expr_ , _new_expr_)¶
    

likes(_other_)¶
    

matches(_other_)¶
    

copy()¶
    

Return type:
    

`Load`

_class _angr.ailment.expression.ITE(_idx_ , _cond_ , _iffalse_ , _iftrue_ , _variable =None_, _variable_offset =None_, _** kwargs_)¶
    

Bases: `Expression`

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **cond** (_Expression_)

  * **iffalse** (_Expression_)

  * **iftrue** (_Expression_)

__init__(_idx_ , _cond_ , _iffalse_ , _iftrue_ , _variable =None_, _variable_offset =None_, _** kwargs_)¶
    

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **cond** (_Expression_)

  * **iffalse** (_Expression_)

  * **iftrue** (_Expression_)

cond¶
    

iffalse¶
    

iftrue¶
    

variable¶
    

variable_offset¶
    

likes(_other_)¶
    

matches(_other_)¶
    

has_atom(_atom_ , _identity =True_)¶
    

replace(_old_expr_ , _new_expr_)¶
    

_property _size¶
    

copy()¶
    

Return type:
    

`ITE`

_class _angr.ailment.expression.DirtyExpression(_idx_ , _callee_ , _operands_ , _*_ , _guard =None_, _mfx =None_, _maddr =None_, _msize =None_, _bits_ , _** kwargs_)¶
    

Bases: `Expression`

Parameters:
    

  * **callee** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **operands** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__Expression_ _]_)

  * **guard** (_Expression_ _|__None_)

  * **mfx** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **maddr** (_Expression_ _|__None_)

  * **msize** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_idx_ , _callee_ , _operands_ , _*_ , _guard =None_, _mfx =None_, _maddr =None_, _msize =None_, _bits_ , _** kwargs_)¶
    

Parameters:
    

  * **callee** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **operands** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__Expression_ _]_)

  * **guard** (_Expression_ _|__None_)

  * **mfx** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

  * **maddr** (_Expression_ _|__None_)

  * **msize** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

callee¶
    

guard¶
    

operands¶
    

mfx¶
    

maddr¶
    

msize¶
    

_property _op _: [str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")_¶
    

_property _verbose_op _: [str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")_¶
    

likes(_other_)¶
    

matches(_other_)¶
    

copy()¶
    

Return type:
    

`DirtyExpression`

replace(_old_expr_ , _new_expr_)¶
    

Parameters:
    

  * **old_expr** (_Expression_)

  * **new_expr** (_Expression_)

_property _size¶
    

_class _angr.ailment.expression.VEXCCallExpression(_idx_ , _callee_ , _operands_ , _bits_ , _** kwargs_)¶
    

Bases: `Expression`

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **callee** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **operands** ([_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__Expression_ _,__...__]_)

  * **bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_idx_ , _callee_ , _operands_ , _bits_ , _** kwargs_)¶
    

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **callee** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **operands** ([_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[__Expression_ _,__...__]_)

  * **bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

callee¶
    

operands¶
    

_property _op _: [str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")_¶
    

_property _verbose_op _: [str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")_¶
    

likes(_other_)¶
    

matches(_other_)¶
    

copy()¶
    

Return type:
    

`VEXCCallExpression`

replace(_old_expr_ , _new_expr_)¶
    

_property _size¶
    

_class _angr.ailment.expression.MultiStatementExpression(_idx_ , _stmts_ , _expr_ , _** kwargs_)¶
    

Bases: `Expression`

For representing comma-separated statements and expression in C.

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **stmts** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__Statement_ _]_)

  * **expr** (_Expression_)

__init__(_idx_ , _stmts_ , _expr_ , _** kwargs_)¶
    

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **stmts** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__Statement_ _]_)

  * **expr** (_Expression_)

stmts¶
    

expr¶
    

likes(_other_)¶
    

matches(_other_)¶
    

_property _size¶
    

replace(_old_expr_ , _new_expr_)¶
    

copy()¶
    

Return type:
    

`MultiStatementExpression`

_class _angr.ailment.expression.BasePointerOffset(_idx_ , _bits_ , _base_ , _offset_ , _variable =None_, _variable_offset =None_, _** kwargs_)¶
    

Bases: `Expression`

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **base** (_Expression_ _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_idx_ , _bits_ , _base_ , _offset_ , _variable =None_, _variable_offset =None_, _** kwargs_)¶
    

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **base** (_Expression_ _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

base¶
    

offset¶
    

variable¶
    

variable_offset¶
    

_property _size¶
    

likes(_other_)¶
    

matches(_other_)¶
    

replace(_old_expr_ , _new_expr_)¶
    

copy()¶
    

Return type:
    

`BasePointerOffset`

_class _angr.ailment.expression.StackBaseOffset(_idx_ , _bits_ , _offset_ , _** kwargs_)¶
    

Bases: `BasePointerOffset`

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_idx_ , _bits_ , _offset_ , _** kwargs_)¶
    

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **offset** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

copy()¶
    

Return type:
    

`StackBaseOffset`

angr.ailment.expression.negate(_expr_)¶
    

Return type:
    

`Expression`

Parameters:
    

**expr** (_Expression_)

_class _angr.ailment.statement.Statement(_idx_ , _** kwargs_)¶
    

Bases: `TaggedObject`, [`ABC`](https://docs.python.org/3/library/abc.html#abc.ABC "\(in Python v3.13\)")

The base class of all AIL statements.

_abstract _replace(_old_expr_ , _new_expr_)¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"), `Self`]

Parameters:
    

  * **old_expr** (_Expression_)

  * **new_expr** (_Expression_)

eq(_expr0_ , _expr1_)¶
    

_abstract _likes(_other_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_abstract _matches(_other_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_class _angr.ailment.statement.Assignment(_idx_ , _dst_ , _src_ , _** kwargs_)¶
    

Bases: `Statement`

Assignment statement: expr_a = expr_b

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **dst** (_Atom_)

  * **src** (_Expression_)

__init__(_idx_ , _dst_ , _src_ , _** kwargs_)¶
    

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **dst** (_Atom_)

  * **src** (_Expression_)

dst¶
    

src¶
    

likes(_other_)¶
    

matches(_other_)¶
    

replace(_old_expr_ , _new_expr_)¶
    

Parameters:
    

  * **old_expr** (_Expression_)

  * **new_expr** (_Expression_)

copy()¶
    

Return type:
    

`Assignment`

_class _angr.ailment.statement.WeakAssignment(_idx_ , _dst_ , _src_ , _** kwargs_)¶
    

Bases: `Statement`

An assignment statement that does not create a new variable at its destination; It should be seen as operator=(&dst, &src) in C++-like syntax.

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **dst** (_Atom_)

  * **src** (_Expression_)

__init__(_idx_ , _dst_ , _src_ , _** kwargs_)¶
    

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **dst** (_Atom_)

  * **src** (_Expression_)

dst¶
    

src¶
    

likes(_other_)¶
    

matches(_other_)¶
    

replace(_old_expr_ , _new_expr_)¶
    

Parameters:
    

  * **old_expr** (_Expression_)

  * **new_expr** (_Expression_)

copy()¶
    

Return type:
    

`WeakAssignment`

_class _angr.ailment.statement.Store(_idx_ , _addr_ , _data_ , _size_ , _endness_ , _guard =None_, _variable =None_, _offset =None_, _** kwargs_)¶
    

Bases: `Statement`

Store statement: *addr = data

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **addr** (_Expression_)

  * **data** (_Expression_)

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **guard** (_Expression_ _|__None_)

__init__(_idx_ , _addr_ , _data_ , _size_ , _endness_ , _guard =None_, _variable =None_, _offset =None_, _** kwargs_)¶
    

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **addr** (_Expression_)

  * **data** (_Expression_)

  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **guard** (_Expression_ _|__None_)

addr¶
    

data¶
    

size¶
    

endness¶
    

variable¶
    

guard¶
    

offset¶
    

likes(_other_)¶
    

matches(_other_)¶
    

replace(_old_expr_ , _new_expr_)¶
    

copy()¶
    

Return type:
    

`Store`

_class _angr.ailment.statement.Jump(_idx_ , _target_ , _target_idx =None_, _** kwargs_)¶
    

Bases: `Statement`

Jump statement: goto target

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **target** (_Expression_)

  * **target_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_idx_ , _target_ , _target_idx =None_, _** kwargs_)¶
    

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **target** (_Expression_)

  * **target_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

target¶
    

target_idx¶
    

likes(_other_)¶
    

matches(_other_)¶
    

_property _depth¶
    

replace(_old_expr_ , _new_expr_)¶
    

copy()¶
    

_class _angr.ailment.statement.ConditionalJump(_idx_ , _condition_ , _true_target_ , _false_target_ , _true_target_idx =None_, _false_target_idx =None_, _** kwargs_)¶
    

Bases: `Statement`

if (cond) {true_target} else {false_target}

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **condition** (_Expression_)

  * **true_target** (_Expression_ _|__None_)

  * **false_target** (_Expression_ _|__None_)

  * **true_target_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **false_target_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_idx_ , _condition_ , _true_target_ , _false_target_ , _true_target_idx =None_, _false_target_idx =None_, _** kwargs_)¶
    

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **condition** (_Expression_)

  * **true_target** (_Expression_ _|__None_)

  * **false_target** (_Expression_ _|__None_)

  * **true_target_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **false_target_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

condition¶
    

true_target¶
    

false_target¶
    

true_target_idx¶
    

false_target_idx¶
    

likes(_other_)¶
    

matches(_other_)¶
    

replace(_old_expr_ , _new_expr_)¶
    

copy()¶
    

Return type:
    

`ConditionalJump`

_class _angr.ailment.statement.Call(_idx_ , _target_ , _calling_convention =None_, _prototype =None_, _args =None_, _ret_expr =None_, _fp_ret_expr =None_, _bits =None_, _** kwargs_)¶
    

Bases: `Expression`, `Statement`

Call is both an expression and a statement.

When used as a statement, it will set ret_expr, fp_ret_expr, or both if both of them should hold return values. When used as an expression, both ret_expr and fp_ret_expr should be None (and should be ignored). The size of the call expression is stored in the bits attribute.

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **target** (_Expression_ _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **calling_convention** (_SimCC_ _|__None_)

  * **args** (_Sequence_ _[__Expression_ _]__|__None_)

  * **ret_expr** (_Expression_ _|__None_)

  * **fp_ret_expr** (_Expression_ _|__None_)

  * **bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

__init__(_idx_ , _target_ , _calling_convention =None_, _prototype =None_, _args =None_, _ret_expr =None_, _fp_ret_expr =None_, _bits =None_, _** kwargs_)¶
    

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **target** (_Expression_ _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **calling_convention** (_SimCC_ _|__None_)

  * **args** ([_Sequence_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence "\(in Python v3.13\)") _[__Expression_ _]__|__None_)

  * **ret_expr** (_Expression_ _|__None_)

  * **fp_ret_expr** (_Expression_ _|__None_)

  * **bits** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

target¶
    

calling_convention¶
    

prototype¶
    

args¶
    

ret_expr¶
    

fp_ret_expr¶
    

likes(_other_)¶
    

matches(_other_)¶
    

_property _size¶
    

_property _verbose_op¶
    

_property _op¶
    

replace(_old_expr_ , _new_expr_)¶
    

Parameters:
    

  * **old_expr** (_Expression_)

  * **new_expr** (_Expression_)

copy()¶
    

_class _angr.ailment.statement.Return(_idx_ , _ret_exprs_ , _** kwargs_)¶
    

Bases: `Statement`

Return statement: (return expr_a), (return)

Parameters:
    

**idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_idx_ , _ret_exprs_ , _** kwargs_)¶
    

Parameters:
    

**idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

ret_exprs¶
    

likes(_other_)¶
    

matches(_other_)¶
    

replace(_old_expr_ , _new_expr_)¶
    

copy()¶
    

_class _angr.ailment.statement.CAS(_idx_ , _addr_ , _data_lo_ , _data_hi_ , _expd_lo_ , _expd_hi_ , _old_lo_ , _old_hi_ , _endness_ , _** kwargs_)¶
    

Bases: `Statement`

Atomic compare-and-swap.

*_lo and *_hi are used to represent the low and high parts of a 128-bit CAS operation; *_hi is None if the CAS operation works on values that are less than or equal to 64 bits.

addr: The address to be compared and swapped. data: The value to be written if the comparison is successful. expd: The expected value to be compared against. old: The value that is currently stored at addr before compare-and-swap; it will be returned after compare-and-swap.

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **addr** (_Expression_)

  * **data_lo** (_Expression_)

  * **data_hi** (_Expression_ _|__None_)

  * **expd_lo** (_Expression_)

  * **expd_hi** (_Expression_ _|__None_)

  * **old_lo** (_Atom_)

  * **old_hi** (_Atom_ _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

__init__(_idx_ , _addr_ , _data_lo_ , _data_hi_ , _expd_lo_ , _expd_hi_ , _old_lo_ , _old_hi_ , _endness_ , _** kwargs_)¶
    

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **addr** (_Expression_)

  * **data_lo** (_Expression_)

  * **data_hi** (_Expression_ _|__None_)

  * **expd_lo** (_Expression_)

  * **expd_hi** (_Expression_ _|__None_)

  * **old_lo** (_Atom_)

  * **old_hi** (_Atom_ _|__None_)

  * **endness** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

addr¶
    

data_lo¶
    

data_hi¶
    

expd_lo¶
    

expd_hi¶
    

old_lo¶
    

old_hi¶
    

endness¶
    

replace(_old_expr_ , _new_expr_)¶
    

Return type:
    

[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)")[[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)"), `CAS`]

Parameters:
    

  * **old_expr** (_Expression_)

  * **new_expr** (_Expression_)

copy()¶
    

Return type:
    

`CAS`

likes(_other_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

matches(_other_)¶
    

Return type:
    

[`bool`](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")

_property _bits _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_property _size _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")_¶
    

_class _angr.ailment.statement.DirtyStatement(_idx_ , _dirty_ , _** kwargs_)¶
    

Bases: `Statement`

Wrapper around the original statement, which is usually not convertible (temporarily).

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **dirty** (_DirtyExpression_)

__init__(_idx_ , _dirty_ , _** kwargs_)¶
    

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **dirty** (_DirtyExpression_)

dirty¶
    

replace(_old_expr_ , _new_expr_)¶
    

copy()¶
    

Return type:
    

`DirtyStatement`

likes(_other_)¶
    

matches(_other_)¶
    

_class _angr.ailment.statement.Label(_idx_ , _name_ , _ins_addr_ , _block_idx =None_, _** kwargs_)¶
    

Bases: `Statement`

A dummy statement that indicates a label with a name.

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **block_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

__init__(_idx_ , _name_ , _ins_addr_ , _block_idx =None_, _** kwargs_)¶
    

Parameters:
    

  * **idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"))

  * **ins_addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **block_idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

name¶
    

ins_addr¶
    

block_idx¶
    

likes(_other_)¶
    

Parameters:
    

**other** (_Label_)

replace(_old_expr_ , _new_expr_)¶
    

matches(_other_)¶
    

Parameters:
    

**other** (_Label_)

copy()¶
    

Return type:
    

`Label`

_class _angr.ailment.block.Block(_addr_ , _original_size_ , _statements =None_, _idx =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Describes an AIL block.

Parameters:
    

  * **addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

  * **statements** ([_list_](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)") _[__Statement_ _]_)

__init__(_addr_ , _original_size_ , _statements =None_, _idx =None_)¶
    

Parameters:
    

**addr** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)"))

addr¶
    

original_size¶
    

statements _: [`list`](https://docs.python.org/3/library/stdtypes.html#list "\(in Python v3.13\)")[`Statement`]_¶
    

idx¶
    

copy(_statements =None_)¶
    

dbg_repr(_indent =0_)¶
    

likes(_other_)¶
    

clear_hash()¶
    

_class _angr.ailment.manager.Manager(_name =None_, _arch =None_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

Parameters:
    

**name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

__init__(_name =None_, _arch =None_)¶
    

Parameters:
    

**name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__None_)

next_atom()¶
    

reset()¶
    

_property _ins_addr _: [int](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") | [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")_¶
    

_class _angr.ailment.tagged_object.TaggedObject(_idx_ , _** kwargs_)¶
    

Bases: [`object`](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")

A class that takes arbitrary tags.

__init__(_idx_ , _** kwargs_)¶
    

Parameters:
    

**idx** ([_int_](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)") _|__None_)

idx¶
    

initialize_tags(_tags_)¶
    

_property _tags _: [dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")_¶
    

angr.ailment.utils.get_bits(_expr_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

Parameters:
    

**expr** (_Expression_)

angr.ailment.utils.stable_hash(_t_)¶
    

Return type:
    

[`int`](https://docs.python.org/3/library/functions.html#int "\(in Python v3.13\)")

Parameters:
    

**t** ([_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)"))

angr.ailment.utils.is_none_or_likeable(_arg1_ , _arg2_ , _is_list =False_)¶
    

Returns whether two things are both None or can like each other

angr.ailment.utils.is_none_or_matchable(_arg1_ , _arg2_ , _is_list =False_)¶
    

Returns whether two things are both None or can match each other